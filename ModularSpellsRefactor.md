~Manastorm Spell System Refactor: Game Plan
1. The Vision: "Keyword Totality Doctrine"

Problem: Currently, spell behaviors (rules), visual effects (VFX), sound 
effects (SFX), and potentially UI descriptions are likely defined 
separately or hardcoded within each spell's logic in spells.lua and 
vfx.lua. This makes adding new spells complex, leads to inconsistencies, 
and doesn't enforce a unified visual language based on the game's rules 
(like Projectile vs. Remote, Fire vs. Ice).
Goal: We want a system where defining a spell is as simple as listing its 
core keywords (like "Fire", "Projectile", "Damage", "Knockdown"). These 
keywords become the single source of truth, dictating everything about 
that aspect of the spell:
How it behaves in the simulation (combat.lua).
How it looks (vfx.lua).
How it sounds.
How it's described in the UI (like a spellbook).
Why?:
Consistency: Spells with the "Projectile" keyword will always share core 
visual motion characteristics. Fire spells will always have a certain 
color palette and feel.
Maintainability: Change the "Fire" keyword's VFX once, and all fire spells 
update instantly.
Scalability: Adding new spells becomes much faster â€“ just combine existing 
keywords or define a new keyword with its associated data. Designers can 
mix and match keywords easily.
Readability: Players learn the visual language tied to keywords, allowing 
them to understand spells diegetically, without needing explicit text 
popups during intense duels.
2. The Technical Approach: Refactor & Compilation

We will refactor the existing codebase by introducing two key new 
components and modifying existing ones:

keywords.lua (New File): This file will become a dictionary or library of 
all possible spell keywords. Each keyword entry will be pure data, 
defining the deltas or pieces it contributes:
behavior: How it modifies game state (e.g., { damageAmount = 10, 
damageType = "fire" }).
vfx: Visual parameters (e.g., { form = "orb", trail = "flare", color = {1, 
0.4, 0.2} }).
sfx: Sound cues (e.g., { cast = "fire_launch", impact = "explosion_soft" 
}).
description: A text fragment for UI tooltips (e.g., "Travels in a straight 
line...").
flags: Tags for categorization or synergies (e.g., { "ranged", "offensive" 
}).
spellCompiler.lua (New File): This file will contain a function, let's 
call it compileSpell(spellDefinition, keywordData).
It takes a basic spell definition (like { name = "Fireball", keywords = 
{"Fire", "Projectile", "Damage"}, cost = 1 } from the refactored 
spells.lua).
It looks up each keyword in keywords.lua.
It merges all the behavior, vfx, sfx, description, and flags data from 
those keywords into a single, complete "compiled spell" object. This 
object contains all the information needed to execute, render, and 
describe the spell.
spells.lua (Refactored): This file will be simplified dramatically. It 
will only contain the basic definitions: spell name, cost, cooldown, and 
the list of keywords it uses. All specific logic and VFX/SFX details will 
be removed.
combat.lua / Simulation Logic (Updated): Instead of reading logic directly 
from spells.lua, the simulation will now use the compiledSpell.behavior 
object generated by the compiler.
vfx.lua / Rendering Logic (Updated): Instead of having hardcoded effects 
per spell name, the VFX engine will read parameters from the 
compiledSpell.vfx object to dynamically create the correct visuals based 
on form, affinity, function, etc.
Sound Engine (Updated): Similarly, sound cues will be triggered based on 
the compiledSpell.sfx data.
UI (Future): Any spellbook or tooltip UI will read from 
compiledSpell.description and compiledSpell.flags.
3. The Process:

We'll tackle this iteratively:

Setup: Create the new files and basic structures.
Migrate Keywords: Define keywords in keywords.lua based on existing spell 
logic, starting with behavior.
Build Compiler: Implement the compileSpell function to merge keyword data.
Refactor spells.lua: Strip out old logic, use only keyword lists.
Integrate: Make the simulation use the compiled spells.
VFX/SFX Data: Add visual and audio data to keywords.
Render Integration: Update VFX/SFX systems to use compiled data.
UI Data: Add description/flags and prepare for UI integration.
This approach allows us to gradually shift functionality to the new system 
while ensuring the game remains functional (or close to it) throughout the 
process.~
