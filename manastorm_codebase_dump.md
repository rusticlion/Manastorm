# Manastorm Codebase Dump
Generated: Thu Jun 26 14:09:07 CDT 2025

# Source Code

## ./ai/OpponentAI.lua
```lua
-- ai/OpponentAI.lua
-- Basic AI opponent for Manastorm
-- Phase 2: Modular AI Architecture with Personality System

local Constants = require("core.Constants")
local ManaHelpers = require("systems.ManaHelpers")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the OpponentAI module
local OpponentAI = {}

-- AI States - Define as constants for clarity
OpponentAI.STATE = {
    IDLE = "IDLE",             -- Default state, focus on building mana resources
    ATTACK = "ATTACK",         -- Aggressive offense, prioritize damage spells
    DEFEND = "DEFEND",         -- Defensive posture, prioritize shields and healing
    COUNTER = "COUNTER",       -- Counter opponent's active spells
    ESCAPE = "ESCAPE",         -- Desperate state when very low health, try to survive
    POSITION = "POSITION"      -- Adjust position (elevation/range) for advantage
}

-- Constructor for OpponentAI
-- @param wizard - The wizard object this AI will control (typically game.wizards[2])
-- @param gameState - Reference to the game state (the global 'game' object)
-- @param personalityModule - The personality module to use for decision making
function OpponentAI.new(wizard, gameState, personalityModule)
    -- Create default personality if none provided
    personalityModule = personalityModule or PersonalityBase.new("Default")
    
    -- Create a new instance
    local ai = {
        -- Store references to game objects
        wizard = wizard,
        gameState = gameState,
        
        -- Store personality
        personality = personalityModule,
        
        -- Track the opposing wizard (player's wizard)
        playerWizard = nil,
        
        -- Track last perception time for throttling
        lastPerceptionTime = 0,
        perceptionInterval = 2, -- Update perception every 2 seconds
        
        -- Track last action time for throttling
        lastActionTime = 0,
        actionInterval = 1.0, -- Consider actions every 1.0 seconds
        
        -- Simple finite state machine
        currentState = OpponentAI.STATE.IDLE, -- Initial state
        lastState = nil,           -- Previous state for transition detection
        stateChangeTime = 0,       -- When the last state change occurred
        
        -- Current decision and action
        currentDecision = nil,
        
        -- Perceived game state (updated periodically)
        perception = {
            selfHealth = 0,
            opponentHealth = 0,
            rangeState = Constants.RangeState.FAR,
            ownElevation = Constants.ElevationState.GROUNDED,
            opponentElevation = Constants.ElevationState.GROUNDED,
            availableTokens = {}, -- Count of each token type
            activeSlots = 0, -- Number of spell slots currently in use
            spellSlots = {}, -- Detailed information about own spell slots
            opponentSpellSlots = {}, -- Information about opponent spell slots
        },
        
        -- Debug output options
        debug = {
            printPerception = true, -- Set to false to disable perception debug output
            perceptionPrintInterval = 2.0, -- How often to print perception details (seconds)
            lastPerceptionPrintTime = 0,
        }
    }
    
    -- Set the metatable to use the OpponentAI methods
    setmetatable(ai, {__index = OpponentAI})
    
    -- Find the opposing wizard (player's wizard)
    for i, w in ipairs(gameState.wizards) do
        if w ~= wizard then
            ai.playerWizard = w
            break
        end
    end
    
    return ai
end

-- Main update method - called from main.lua's love.update
-- @param dt - Delta time from the game loop
function OpponentAI:update(dt)
    -- Update perception (throttled)
    if love.timer.getTime() - self.lastPerceptionTime > self.perceptionInterval then
        self:perceive()
        self.lastPerceptionTime = love.timer.getTime()
        
        -- Debug output (throttled separately)
        if self.debug.printPerception and love.timer.getTime() - self.debug.lastPerceptionPrintTime > self.debug.perceptionPrintInterval then
            self:printPerceptionDebug()
            self.debug.lastPerceptionPrintTime = love.timer.getTime()
        end
    end
    
    -- Make decisions and act (throttled)
    if love.timer.getTime() - self.lastActionTime > self.actionInterval then
        -- Store previous state for transition detection
        self.lastState = self.currentState
        
        -- Make a decision based on current perception
        local decision = self:decide()
        self.currentDecision = decision
        
        -- If state changed, log it and record the time
        if self.currentState ~= self.lastState then
            print(string.format("[AI] State transition: %s -> %s", 
                self.lastState, self.currentState))
            self.stateChangeTime = love.timer.getTime()
            
            -- Print the decision that led to the state change
            if decision and decision.type then
                print(string.format("[AI] New Action: %s (reason: %s)", 
                    decision.type, decision.reason or "unknown"))
            end
        end
        
        -- Execute the decided action
        self:act(decision)
        
        self.lastActionTime = love.timer.getTime()
    end
end

-- Observe the current game state and update perception
function OpponentAI:perceive()
    local p = self.perception -- shorthand for readability
    
    -- Check if game state and wizards still exist (safety check)
    if not self.gameState or not self.wizard or not self.playerWizard then
        print("ERROR: AI missing critical game references")
        return
    end
    
    -- Basic game state perception
    p.rangeState = self.gameState.rangeState
    
    -- Self wizard perception
    p.selfHealth = self.wizard.health
    p.ownElevation = self.wizard.elevation
    
    -- Opponent wizard perception
    p.opponentHealth = self.playerWizard.health
    p.opponentElevation = self.playerWizard.elevation
    
    -- Mana pool token counts
    p.availableTokens = {}
    
    -- Track counts for all token types
    for _, tokenType in ipairs(Constants.getAllTokenTypes()) do
        p.availableTokens[tokenType] = ManaHelpers.count(tokenType, self.gameState.manaPool)
    end
    
    -- Count total free tokens
    p.totalFreeTokens = 0
    for _, count in pairs(p.availableTokens) do
        p.totalFreeTokens = p.totalFreeTokens + count
    end
    
    -- Spell slot perception (own)
    p.spellSlots = {}
    p.activeSlots = 0
    
    for i, slot in ipairs(self.wizard.spellSlots) do
        p.spellSlots[i] = {
            active = slot.active,
            progress = slot.progress,
            castTime = slot.castTime,
            isShield = slot.isShield or false,
            willBecomeShield = slot.willBecomeShield or false,
            spellType = slot.spellType,
            frozen = slot.frozen or false,
            attackType = slot.attackType,
            tokenCount = slot.tokens and #slot.tokens or 0
        }
        
        if slot.active then
            p.activeSlots = p.activeSlots + 1
        end
    end
    
    -- Spell slot perception (opponent)
    p.opponentSpellSlots = {}
    p.opponentActiveSlots = 0
    
    for i, slot in ipairs(self.playerWizard.spellSlots) do
        p.opponentSpellSlots[i] = {
            active = slot.active,
            progress = slot.progress,
            castTime = slot.castTime,
            isShield = slot.isShield or false,
            spellType = slot.spellType,
            tokenCount = slot.tokens and #slot.tokens or 0
        }
        
        if slot.active then
            p.opponentActiveSlots = p.opponentActiveSlots + 1
        end
    end
    
    -- Can pay for basic token costs? (for decision making)
    p.canPayForSingleToken = {}
    for _, tokenType in ipairs(Constants.getAllTokenTypes()) do
        local canPay = self.wizard:canPayManaCost({tokenType}) ~= nil
        p.canPayForSingleToken[tokenType] = canPay
    end
    
    -- Calculate key derived states for decision making
    p.opponentLowHealth = p.opponentHealth < 30
    p.selfLowHealth = p.selfHealth < 30
    p.selfCriticalHealth = p.selfHealth < 15
    
    -- Calculate health advantage (positive = AI has more health)
    p.healthAdvantage = p.selfHealth - p.opponentHealth
    
    -- Check if opponent has dangerous spell in progress
    p.opponentHasDangerousSpell = false
    for _, slot in ipairs(p.opponentSpellSlots) do
        if slot.active and not slot.isShield and slot.progress > 0 then
            -- Simple heuristic: consider any active spell with progress "dangerous"
            p.opponentHasDangerousSpell = true
            break
        end
    end
    
    -- Check if we have any shield active
    p.hasActiveShield = false
    for _, slot in ipairs(p.spellSlots) do
        if slot.active and slot.isShield then
            p.hasActiveShield = true
            break
        end
    end
    
    return p
end

-- Print debug information about current perception
function OpponentAI:printPerceptionDebug()
    local p = self.perception
    print("=== AI PERCEPTION ===")
    print(string.format("PERSONALITY: %s", self.personality.name))
    print(string.format("HEALTH: Self=%d, Opponent=%d", p.selfHealth, p.opponentHealth))
    print(string.format("RANGE: %s, ELEVATION: Self=%s, Opp=%s", 
        p.rangeState, p.ownElevation, p.opponentElevation))
    
    -- Token counts
    local tokenInfo = "TOKENS: "
    for tokenType, count in pairs(p.availableTokens) do
        if count > 0 then
            tokenInfo = tokenInfo .. tokenType .. "=" .. count .. " "
        end
    end
    print(tokenInfo)
    
    -- Spell slot info (self)
    print("SPELL SLOTS:")
    for i, slot in ipairs(p.spellSlots) do
        if slot.active then
            print(string.format("  [%d] %s - Progress: %.1f/%.1f %s%s", 
                i, slot.spellType or "Unknown", 
                slot.progress, slot.castTime,
                slot.isShield and "[SHIELD]" or "",
                slot.frozen and "[FROZEN]" or ""))
        end
    end
    
    -- Opponent spell slots
    print("OPPONENT SLOTS:")
    for i, slot in ipairs(p.opponentSpellSlots) do
        if slot.active then
            print(string.format("  [%d] %s - Progress: %.1f/%.1f %s", 
                i, slot.spellType or "Unknown", 
                slot.progress, slot.castTime,
                slot.isShield and "[SHIELD]" or ""))
        end
    end
    
    -- Current AI state
    print("AI STATE: " .. self.currentState)
    if self.currentDecision then
        print("CURRENT ACTION: " .. (self.currentDecision.type or "None"))
    end
    print("===================")
end

-- Decide what to do based on current perception
function OpponentAI:decide()
    local p = self.perception
    local spellbook = self.wizard.spellbook
    
    -- Check if personality wants to override state selection
    local suggestedState = self.personality:suggestState(self, p)
    if suggestedState then
        self.currentState = suggestedState
    else
        -- Basic state transition logic based on health and threat
        
        -- Critical health - go into escape mode
        if p.selfCriticalHealth then
            self.currentState = OpponentAI.STATE.ESCAPE
        
        -- Low health - prioritize defense
        elseif p.selfLowHealth and not p.hasActiveShield then
            self.currentState = OpponentAI.STATE.DEFEND
        
        -- Opponent has very low health - press the advantage
        elseif p.opponentLowHealth then
            self.currentState = OpponentAI.STATE.ATTACK
        
        -- Opponent is casting something - consider countering
        elseif p.opponentHasDangerousSpell and p.totalFreeTokens >= 2 then
            self.currentState = OpponentAI.STATE.COUNTER
        
        -- If health advantage is significant and we're not in low health, attack
        elseif p.healthAdvantage > 15 and not p.selfLowHealth then
            self.currentState = OpponentAI.STATE.ATTACK
        
        -- If we're at a health disadvantage, consider defense
        elseif p.healthAdvantage < -15 and not p.hasActiveShield then
            self.currentState = OpponentAI.STATE.DEFEND
        
        -- If no tokens or very few tokens are available, focus on gaining resources
        elseif p.totalFreeTokens <= 1 then
            self.currentState = OpponentAI.STATE.IDLE
        
        -- Default state when no specific criteria are met - slight aggression bias
        else
            -- Slightly biased toward attacking when nothing else is going on
            local randomChoice = math.random(1, 10)
            
            if randomChoice <= 6 then -- 60% chance of attack
                self.currentState = OpponentAI.STATE.ATTACK
            elseif randomChoice <= 9 then -- 30% chance of defense
                self.currentState = OpponentAI.STATE.DEFEND
            else -- 10% chance of resource gathering
                self.currentState = OpponentAI.STATE.IDLE
            end
        end
    end
    
    -- State->Action mapping
    local spell = nil
    local actionType = nil
    local reason = nil
    
    -- Based on the current state, decide what specific spell to cast
    if self.currentState == OpponentAI.STATE.ATTACK then
        -- Ask personality module for attack spell
        spell = self.personality:getAttackSpell(self, p, spellbook)
        reason = "Attack"
        actionType = "ATTACK_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.DEFEND then
        -- Ask personality module for defense spell
        spell = self.personality:getDefenseSpell(self, p, spellbook)
        reason = "Defense"
        actionType = "DEFEND_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.COUNTER then
        -- Ask personality module for counter spell
        spell = self.personality:getCounterSpell(self, p, spellbook)
        reason = "Counter"
        actionType = "COUNTER_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.ESCAPE then
        -- Emergency defense: shield, escape, or free all (last resort)
        if p.activeSlots > 0 and p.totalFreeTokens < 1 then
            -- No resources, free all spell slots
            return {
                type = "FREE_ALL",
                reason = "Critical health - free resources"
            }
        end
        
        -- Ask personality module for escape spell
        spell = self.personality:getEscapeSpell(self, p, spellbook)
        reason = "Escape"
        actionType = "ESCAPE_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.POSITION then
        -- Ask personality module for positioning spell
        spell = self.personality:getPositioningSpell(self, p, spellbook)
        reason = "Positioning"
        actionType = "POSITION_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.IDLE then
        -- Ask personality module for conjure/resource spell
        spell = self.personality:getConjureSpell(self, p, spellbook)
        reason = "Generate resources"
        actionType = "CONJURE_ACTION"
    end
    
    -- If we found a specific spell and have a slot for it, cast it
    if spell and self:hasAvailableSpellSlot() then
        -- Evaluate dynamic cost if provided
        local costToEvaluate
        if spell.getCost then
            costToEvaluate = spell.getCost(self.wizard, self.playerWizard)
        else
            costToEvaluate = spell.cost
        end

        local canAfford = self.wizard:canPayManaCost(costToEvaluate)
        if canAfford then
            return {
                type = "CAST_SPELL",
                spell = spell,
                reason = reason
            }
        end
    end
    
    -- Return the general action if no specific spell was found or affordable
    return {
        type = actionType,
        reason = reason .. " (no specific spell found or affordable)"
    }
end

-- Execute the decided action
function OpponentAI:act(decision)
    -- Safety check
    if not decision or not decision.type then
        print("[AI] No valid decision to act on")
        return
    end
    
    -- Log the action
    print("[AI Action] " .. decision.type)
    
    -- For conciseness
    local wizard = self.wizard
    
    -- Execute based on action type
    if decision.type == "WAIT_ACTION" then
        -- Do nothing (idle)
        print("[AI] Waiting...")
        
    elseif decision.type == "FREE_ALL" then
        -- Cancel all active spells
        print("[AI] Freeing all spells")
        wizard:freeAllSpells()
        
    elseif decision.type == "CAST_SPELL" and decision.spell then
        -- Direct spell casting (specified by higher-level logic)
        print("[AI] Casting specific spell: " .. decision.spell.name)
        local success = wizard:queueSpell(decision.spell)
        if not success then
            print("[AI] Failed to cast " .. decision.spell.name)
        end
    
    -- Generic action types - try to get a spell from personality as fallback
    elseif decision.type == "ATTACK_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.ATTACK, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting attack spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable attack spell found")
        end
        
    elseif decision.type == "DEFEND_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.DEFEND, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting defense spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable defense spell found")
        end
        
    elseif decision.type == "COUNTER_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.COUNTER, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting counter spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable counter spell found")
        end
        
    elseif decision.type == "ESCAPE_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.ESCAPE, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting escape spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable escape spell found")
        end
        
    elseif decision.type == "POSITION_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.POSITION, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting positioning spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable positioning spell found")
        end
        
    elseif decision.type == "CONJURE_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.IDLE, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting conjure spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable conjure spell found")
        end
    
    else
        print("[AI] Unknown action type: " .. decision.type)
    end
end

-- Helper function to check if a spell slot is available
function OpponentAI:hasAvailableSpellSlot()
    for _, slot in ipairs(self.wizard.spellSlots) do
        if not slot.active then
            return true
        end
    end
    return false
end

return OpponentAI```

## ./ai/PersonalityBase.lua
```lua
-- ai/PersonalityBase.lua
-- Interface for wizard AI personalities in Manastorm
-- Defines the contract for how personality modules interact with the OpponentAI system

local PersonalityBase = {}

-- Constructor for personality modules
-- @param name - A string identifier for the personality
function PersonalityBase.new(name)
    local personality = {
        name = name or "Generic",
        description = "Base personality module - meant to be extended"
    }
    
    -- Set metatable to use PersonalityBase methods
    setmetatable(personality, {__index = PersonalityBase})
    
    return personality
end

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getAttackSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best defensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getDefenseSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best counter spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getCounterSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best escape spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getEscapeSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best conjuration spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getConjureSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best positioning spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getPositioningSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get best spell for a given intent/state when no specific spell was found
-- @param state - The AI state (from OpponentAI.STATE)
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getBestSpellForIntent(state, ai, perception, spellbook)
    -- This is a fallback method for when more specific methods don't find a suitable spell
    -- Each personality can implement custom fallback logic
    
    -- Base implementation tries to match the state to a specific spell getter
    if state == "ATTACK" then
        return self:getAttackSpell(ai, perception, spellbook)
    elseif state == "DEFEND" then
        return self:getDefenseSpell(ai, perception, spellbook)
    elseif state == "COUNTER" then
        return self:getCounterSpell(ai, perception, spellbook)
    elseif state == "ESCAPE" then
        return self:getEscapeSpell(ai, perception, spellbook)
    elseif state == "IDLE" then
        return self:getConjureSpell(ai, perception, spellbook)
    elseif state == "POSITION" then
        return self:getPositioningSpell(ai, perception, spellbook)
    end
    
    return nil
end

-- Can be used to provide character-specific customizations to FSM state selection
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @return - A string state name or nil to use default state selection logic
function PersonalityBase:suggestState(ai, perception)
    -- Base implementation returns nil, letting the core AI decide
    -- Derived personalities can override this to customize state selection
    return nil
end

return PersonalityBase```

## ./ai/personalities/AshgarPersonality.lua
```lua
-- ai/personalities/AshgarPersonality.lua
-- AI personality module for Ashgar the Emberfist

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the AshgarPersonality module
local AshgarPersonality = PersonalityBase.new("Ashgar the Emberfist")

-- Ashgar's Spellbook:
-- "1": Conjure Fire (Conjure)
-- "2": Nova Conjuring (Resource Management/Setup)
-- "3": Firebolt (Attack)
-- "12": Battle Shield (Defense)
-- "13": Blast Wave (Attack - Zone, good vs NEAR)
-- "23": Emberlift (Positioning/Utility, Conjure Fire)
-- "123": Meteor (Attack - Aerial Finisher, requires AERIAL setup)

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Meteor (powerful aerial finisher) - if both conditions are met:
    -- 1. AI is in AERIAL state
    -- 2. Opponent is in GROUNDED state
    if p.ownElevation == Constants.ElevationState.AERIAL and 
       p.opponentElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["123"]) -- Meteor
    end
    
    -- Blast Wave (good at NEAR range)
    if p.rangeState == Constants.RangeState.NEAR and 
       p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["13"]) -- Blast Wave
    end
    
    -- Firebolt (basic attack, better at FAR range)
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["3"]) -- Firebolt 
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best defensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Battle Shield is Ashgar's primary defense
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() and not p.hasActiveShield then
        table.insert(spellsToTry, spellbook["12"]) -- Battle Shield
    end
    
    -- Emberlift can be used to escape by changing elevation
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() and 
       p.ownElevation == Constants.ElevationState.GROUNDED then
        table.insert(spellsToTry, spellbook["23"]) -- Emberlift
    end
    
    -- If we don't have enough tokens for a shield
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        -- Try to gain tokens
        table.insert(spellsToTry, spellbook["1"]) -- Conjure Fire
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best counter spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getCounterSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Ashgar doesn't have direct counter spells like Selene's Eclipse,
    -- but he can use Blast Wave to disrupt opponents at NEAR range
    -- or Emberlift to change position
    
    if p.opponentHasDangerousSpell then
        -- If near, use Blast Wave as a counter
        if p.rangeState == Constants.RangeState.NEAR and p.totalFreeTokens >= 2 then
            table.insert(spellsToTry, spellbook["13"]) -- Blast Wave
        end
        
        -- Use Emberlift to change position and potentially disrupt
        if p.totalFreeTokens >= 2 and p.ownElevation == Constants.ElevationState.GROUNDED then
            table.insert(spellsToTry, spellbook["23"]) -- Emberlift
        end
        
        -- Simple attack may also work as disruption
        if p.totalFreeTokens >= 1 then
            table.insert(spellsToTry, spellbook["3"]) -- Firebolt
        end
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    -- If no counter spell is available, fall back to a defensive option
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Get the best escape spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getEscapeSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- When in critical health
    
    -- First priority: Battle Shield if not already shielded
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["12"]) -- Battle Shield
    end
    
    -- Second priority: Emberlift to change elevation (if grounded)
    if p.ownElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["23"]) -- Emberlift
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best conjuration spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getConjureSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Try to use Nova Conjuring for more advanced resource generation
    -- when we already have some tokens
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["2"]) -- Nova Conjuring
    end
    
    -- Basic conjuration spell - always useful
    if ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["1"]) -- Conjure Fire
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best positioning spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getPositioningSpell(ai, perception, spellbook)
    local p = perception
    
    -- Emberlift is Ashgar's primary positioning spell
    -- Use it when grounded to gain aerial advantage
    if p.ownElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local posSpell = spellbook["23"] -- Emberlift
        
        if posSpell and ai.wizard:canPayManaCost(posSpell.cost) then
            return posSpell
        end
    end
    
    return nil
end

-- Suggest custom state based on Ashgar's special capabilities
function AshgarPersonality:suggestState(ai, perception)
    local p = perception
    
    -- Consider positioning to setup an aerial meteor attack
    if not p.selfCriticalHealth and -- not in emergency
       p.ownElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 2 and 
       ai:hasAvailableSpellSlot() then
        
        -- 20% chance to try positioning for a meteor setup when conditions are good
        if math.random(1, 5) == 1 then
            return ai.STATE.POSITION
        end
    end
    
    -- Let the core AI decide in other cases
    return nil
end

return AshgarPersonality```

## ./ai/personalities/BorrakPersonality.lua
```lua
-- ai/personalities/BorrakPersonality.lua
-- AI personality module for Borrak, the water warlock

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")
local ManaHelpers = require("systems.ManaHelpers")

-- Define the BorrakPersonality module
local BorrakPersonality = PersonalityBase.new("Borrak")

-- Utility to randomly choose a spell from a list that the wizard can afford
local function chooseRandomAffordable(ai, spells)
    -- shuffle order for randomness
    for i = #spells, 2, -1 do
        local j = math.random(i)
        spells[i], spells[j] = spells[j], spells[i]
    end

    for _, spell in ipairs(spells) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    return nil
end

-- Get the best offensive spell for the current situation
function BorrakPersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local options = {}

    if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(options, spellbook["123"]) -- Wave Crash
    end
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(options, spellbook["23"]) -- Maelstrom
        table.insert(options, spellbook["13"]) -- Brine Chain
        table.insert(options, spellbook["12"]) -- Tidal Force
    end
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(options, spellbook["2"]) -- Water Gun
    end

    return chooseRandomAffordable(ai, options)
end

-- Get the best defensive spell for the current situation
function BorrakPersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local shield = spellbook["3"] -- Riptide Guard
        if shield and ai.wizard:canPayManaCost(shield.cost) then
            return shield
        end
    end
    return nil
end

-- Counters simply fall back to defensive options
function BorrakPersonality:getCounterSpell(ai, perception, spellbook)
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Escape behavior is also to put up a shield
function BorrakPersonality:getEscapeSpell(ai, perception, spellbook)
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Conjure Water whenever possible
function BorrakPersonality:getConjureSpell(ai, perception, spellbook)
    if ai:hasAvailableSpellSlot() then
        local spell = spellbook["1"] -- Conjure Water
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    return nil
end

-- Borrak generally has no special positioning logic
function BorrakPersonality:getPositioningSpell(ai, perception, spellbook)
    return nil
end

-- Suggest AI state based on Borrak's strategy
function BorrakPersonality:suggestState(ai, perception)
    local p = perception
    local waterCount = p.availableTokens[Constants.TokenType.WATER] or 0

    -- Focus on conjuring until we have at least 3 Water tokens
    if waterCount < 3 then
        return ai.STATE.IDLE
    end

    -- Maintain a shield if we don't have one
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        return ai.STATE.DEFEND
    end

    -- Alternate between attacking and conjuring
    if math.random() < 0.5 then
        return ai.STATE.ATTACK
    else
        return ai.STATE.IDLE
    end
end

return BorrakPersonality
```

## ./ai/personalities/SelenePersonality.lua
```lua
-- ai/personalities/SelenePersonality.lua
-- AI personality module for Selene of the Veil

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the SelenePersonality module
local SelenePersonality = PersonalityBase.new("Selene of the Veil")

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- CORE STRATEGY: 
    -- 1. Save up for Full Moon Beam
    -- 2. Try to queue Full Moon Beam in the middle slot
    -- 3. Use Eclipse to boost its damage
    
    -- Track what spells we already have active
    local fullMoonBeamActive = false
    local eclipseActive = false
    local moonDanceActive = false
    local gravityTrapActive = false
    local fullMoonBeamSlot = nil
    
    for i, slot in ipairs(p.spellSlots) do
        if slot.active then
            if slot.spellType == "fullmoonbeam" then
                fullMoonBeamActive = true
                fullMoonBeamSlot = i
            elseif slot.spellType == "eclipse" then
                eclipseActive = true
            elseif slot.spellType == "moondance" then
                moonDanceActive = true
            elseif slot.spellType == "gravityTrap" then
                gravityTrapActive = true
            end
        end
    end
    
    -- Check if we have enough resources for Full Moon Beam
    if p.totalFreeTokens >= 4 and not fullMoonBeamActive and ai:hasAvailableSpellSlot() then
        -- We have enough tokens for Full Moon Beam, prioritize it
        local fullMoonBeam = spellbook["123"] -- Full Moon Beam
        if fullMoonBeam and ai.wizard:canPayManaCost(fullMoonBeam.cost) then
            -- We're specifically looking for this, so prioritize it highly
            return fullMoonBeam
        end
    end
    
    -- If we have Full Moon Beam active, follow up with Eclipse to enhance it
    if fullMoonBeamActive and not eclipseActive and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local eclipse = spellbook["13"] -- Eclipse
        if eclipse and ai.wizard:canPayManaCost(eclipse.cost) then
            return eclipse
        end
    end
    
    -- If opponent is aerial, consider Gravity Trap
    if p.opponentElevation == Constants.ElevationState.AERIAL and p.totalFreeTokens >= 2 and 
       not gravityTrapActive and ai:hasAvailableSpellSlot() then
        local gravityTrap = spellbook["23"] -- gravityTrap
        if gravityTrap and ai.wizard:canPayManaCost(gravityTrap.cost) then
            table.insert(spellsToTry, gravityTrap)
        end
    end
    
    -- If we have a shield up and < 3 tokens, consider Moon Dance for chip damage
    if p.hasActiveShield and p.totalFreeTokens >= 1 and p.totalFreeTokens < 3 and 
       not moonDanceActive and ai:hasAvailableSpellSlot() then
        local moonDance = spellbook["3"] -- moondance
        if moonDance and ai.wizard:canPayManaCost(moonDance.cost) then
            table.insert(spellsToTry, moonDance)
        end
    end
    
    -- If we have 3+ tokens but can't do Full Moon Beam for some reason, try Eclipse
    if not eclipseActive and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local eclipse = spellbook["13"] -- eclipse
        if eclipse and ai.wizard:canPayManaCost(eclipse.cost) then
            table.insert(spellsToTry, eclipse)
        end
    end
    
    -- Return the first affordable spell from our priority list
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best defensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    -- ENHANCED STRATEGY: Prioritize defense more - try to keep a shield up at all times
    -- Put up a shield whenever we don't have one and can afford it, not just when low health
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() and not p.hasActiveShield then
        -- Try shield spell (wrapinmoonlight) - Selene's primary advantage
        table.insert(spellsToTry, spellbook["2"]) -- wrapinmoonlight
    end

    -- Secondary options if shield isn't possible
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        -- If health is starting to get low, consider evasive maneuvers
        if p.selfHealth < 75 and not p.hasActiveShield then
            table.insert(spellsToTry, spellbook["3"]) -- moondance (position change for evasion)
        end

        -- Building resources is also defensive when we need tokens for shield
        if p.totalFreeTokens < 2 then
            table.insert(spellsToTry, spellbook["1"]) -- conjuremoonlight
        end
    end

    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best counter spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getCounterSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Check if there's something to counter and we have enough resources
    if p.opponentHasDangerousSpell and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        -- For Selene, try using eclipse or moondance
        table.insert(spellsToTry, spellbook["13"]) -- eclipse (freezes crown slot)
        table.insert(spellsToTry, spellbook["3"])  -- moondance (can disrupt by changing range)
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    -- If no counter spell is available, fall back to a defensive option
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Get the best escape spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getEscapeSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- When in critical health, try shield, range change, or free all slots
    
    -- First priority: shields if not already shielded
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["2"]) -- wrapinmoonlight
    end
    
    -- Second priority: change range/position
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["3"]) -- moondance
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best conjuration spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getConjureSpell(ai, perception, spellbook)
    local p = perception
    
    -- Try conjuration spell if a slot is available
    if ai:hasAvailableSpellSlot() then
        local conjureSpell = spellbook["1"] -- conjuremoonlight
        
        if conjureSpell and ai.wizard:canPayManaCost(conjureSpell.cost) then
            return conjureSpell
        end
    end
    
    return nil
end

-- Get the best positioning spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getPositioningSpell(ai, perception, spellbook)
    local p = perception
    
    -- If at NEAR range, prioritize Moon Dance to get back to FAR
    if p.rangeState == Constants.RangeState.NEAR then
        local moonDance = spellbook["3"] -- moondance
        if moonDance and ai.wizard:canPayManaCost(moonDance.cost) and ai:hasAvailableSpellSlot() then
            return moonDance
        end
    end
    
    -- Default behavior - try to use moondance to change range if needed
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        local posSpell = spellbook["3"] -- moondance
        
        if posSpell and ai.wizard:canPayManaCost(posSpell.cost) then
            return posSpell
        end
    end
    
    return nil
end

-- Override suggestState to provide Selene-specific state suggestions
function SelenePersonality:suggestState(ai, perception)
    local p = perception
    
    -- If at NEAR range, prioritize positioning to get back to FAR
    if p.rangeState == Constants.RangeState.NEAR and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        -- 80% chance to prioritize positioning when at NEAR range
        if math.random() < 0.5 then
            return ai.STATE.POSITION
        end
    end
    
    -- NEW CORE STRATEGY: Focus on resource accumulation for Full Moon Beam + Eclipse combo
    -- If we have a shield up and 3+ tokens, focus on attacking to try our combo
    if p.hasActiveShield and p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        -- With a shield up and enough tokens, we should try our combo
        return ai.STATE.ATTACK
    end
    
    -- If we have a lot of tokens, prioritize attacking to use them
    if p.totalFreeTokens >= 4 and ai:hasAvailableSpellSlot() then
        -- We have enough tokens for our most powerful spells
        return ai.STATE.ATTACK
    end
    
    -- ENHANCED STRATEGY: More proactive shield usage
    -- Prioritize defense if we don't have a shield and have enough resources
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        -- 70% chance to prioritize defense when we don't have a shield (increased from 60%)
        if math.random() < 0.7 then
            return ai.STATE.DEFEND
        end
    end
    
    -- ENHANCED STRATEGY: Resource accumulation when we have a shield but not enough tokens
    -- If we have a shield but less than 3 tokens, focus on resource gathering
    if p.hasActiveShield and p.totalFreeTokens < 3 then
        -- 70% chance to focus on resource gathering when we have a shield but few tokens
        if math.random() < 0.7 then
            return ai.STATE.IDLE
        end
    end
    
    -- ENHANCED STRATEGY: Prioritize Counter when opponent is casting
    -- If opponent is casting and we have enough tokens, counter them
    if p.opponentHasDangerousSpell and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        -- 80% chance to try countering dangerous spells
        if math.random() < 0.8 then
            return ai.STATE.COUNTER
        end
    end
    
    -- Let the default AI logic handle other cases
    return nil
end

return SelenePersonality```

## ./ai/personalities/SilexPersonality.lua
```lua
-- ai/personalities/SilexPersonality.lua
-- AI personality module for Silex, the salt mage

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the SilexPersonality module
local SilexPersonality = PersonalityBase.new("Silex")

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SilexPersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    -- Big area damage when we have plenty of tokens
    if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["123"]) -- Salt Storm
    end

    -- Use Shield Breaker to punish opponents hiding behind shields
    if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["23"]) -- Shield Breaker
    end

    -- Trap the opponent to maintain advantage
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["3"]) -- Imprison
    end

    -- Quick poke
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["2"]) -- Glitter Fang
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best defensive spell for the current situation
function SilexPersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    -- Always try to keep a Salt Circle up
    if not p.hasActiveShield and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["12"]) -- Salt Circle
    end

    -- Add Stone Shield as backup protection
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["13"]) -- Stone Shield
    end

    -- Build resources if we can't shield
    if p.totalFreeTokens == 0 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["1"]) -- Conjure Salt
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best counter spell for the current situation
function SilexPersonality:getCounterSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    if p.opponentHasDangerousSpell then
        -- Put up Salt Circle to ward off incoming spells
        if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
            table.insert(spellsToTry, spellbook["12"]) -- Salt Circle
        end
        -- Try to break the spell with Shield Breaker
        if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
            table.insert(spellsToTry, spellbook["23"]) -- Shield Breaker
        end
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Get the best escape spell for the current situation
function SilexPersonality:getEscapeSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["13"]) -- Stone Shield
    end

    if not p.hasActiveShield and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["12"]) -- Salt Circle
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best conjuration spell for the current situation
function SilexPersonality:getConjureSpell(ai, perception, spellbook)
    print("Silex:getConjureSpell")
    if ai:hasAvailableSpellSlot() then
        local spell = spellbook["1"] -- Conjure Salt
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Positioning is not a focus for Silex
function SilexPersonality:getPositioningSpell(ai, perception, spellbook)
    return nil
end

-- Suggest AI state based on Silex's strategy
function SilexPersonality:suggestState(ai, perception)
    local p = perception

    -- Prioritize keeping a shield up
    if not p.hasActiveShield and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        return ai.STATE.DEFEND
    end

    -- If shielded and have resources, press the attack
    if p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        return ai.STATE.ATTACK
    end

    -- Build resources when low
    if p.totalFreeTokens == 0 and ai:hasAvailableSpellSlot() then
        return ai.STATE.IDLE
    end

    return nil
end

return SilexPersonality
```

## ./characterData.lua
```lua
-- characterData.lua
-- Defines color and spellbook data for each playable character

local SpellsModule = require("spells")
local Spells = SpellsModule.spells

local characterData = {}

characterData.Ashgar = {
    color = {255,100,100},
    spellbook = {
        ["1"]  = Spells.conjurefire,
        ["2"]  = Spells.firebolt,
        ["3"]  = Spells.fireball,
        ["12"] = Spells.burnToAsh,
        ["13"] = Spells.blastwave,
        ["23"] = Spells.saltcircle,
        ["123"] = Spells.eruption,
    },
    spells = {
        Spells.conjurefire,
        Spells.firebolt,
        Spells.fireball,
        Spells.burnToAsh,
        Spells.blastwave,
        Spells.saltcircle,
        Spells.eruption,
        Spells.combustMana,
        Spells.blazingAscent,
        Spells.desperationFire,
    },
    campaignOpponents = {"Selene", "Silex", "Borrak"}
}

characterData.Selene = {
    color = {100,100,255},
    spellbook = {
        ["1"]  = Spells.conjuremoonlight,
        ["2"]  = Spells.wrapinmoonlight,
        ["3"]  = Spells.moondance,
        ["12"] = Spells.infiniteprocession,
        ["13"] = Spells.eclipse,
        ["23"] = Spells.gravityTrap,
        ["123"] = Spells.fullmoonbeam,
    },
    spells = {
        Spells.conjuremoonlight,
        Spells.wrapinmoonlight,
        Spells.moondance,
        Spells.infiniteprocession,
        Spells.eclipse,
        Spells.gravityTrap,
        Spells.fullmoonbeam,
        Spells.lunardisjunction,
        Spells.lunarTides,
        Spells.moonDrain,
    },
    campaignOpponents = {"Ashgar", "Borrak", "Silex"}
}

characterData.Silex = {
    color = {200,200,200},
    spellbook = {
        ["1"]  = Spells.conjuresalt,
        ["2"]  = Spells.glitterfang,
        ["3"]  = Spells.imprison,
        ["12"] = Spells.saltcircle,
        ["13"] = Spells.stoneshield,
        ["23"] = Spells.shieldbreaker,
        ["123"] = Spells.saltstorm,
    },
    spells = {
        Spells.conjuresalt,
        Spells.glitterfang,
        Spells.imprison,
        Spells.saltcircle,
        Spells.stoneshield,
        Spells.shieldbreaker,
        Spells.saltstorm,
        Spells.jaggedearth,
    }
}

characterData.Borrak = {
    color = {100,180,255},
    spellbook = {
        ["1"]  = Spells.conjurewater,
        ["2"]  = Spells.watergun,
        ["3"]  = Spells.riptideguard,
        ["12"] = Spells.tidalforce,
        ["13"] = Spells.brinechain,
        ["23"] = Spells.maelstrom,
        ["123"] = Spells.wavecrash,
    },
    spells = {
        Spells.conjurewater,
        Spells.watergun,
        Spells.riptideguard,
        Spells.tidalforce,
        Spells.brinechain,
        Spells.maelstrom,
        Spells.wavecrash,
        Spells.forceBlast,
    }
}

characterData.Brightwulf = {
    color = {255,100,100},
    spellbook = {
        ["1"]  = Spells.burnTheSoul,
        ["2"]  = Spells.SpaceRipper,
        ["3"]  = Spells.StingingEyes,
        ["12"] = Spells.emberlift,
        ["13"] = Spells.meteor,
        ["23"] = Spells.fusionRay,
        ["123"] = Spells.CoreBolt,
    },
    spells = {
        Spells.burnTheSoul,
        Spells.SpaceRipper,
        Spells.StingingEyes,
        Spells.emberlift,
        Spells.meteor,
        Spells.fusionRay,
        Spells.CoreBolt,
    }
}

-- Placeholder spellbooks for other characters, defaulting to Ashgar's spells
local defaultSpellbook = characterData.Ashgar.spellbook
local defaultColor = {255,255,255}

local roster = {"Klaus","Ohm","Archive","End"}
for _, name in ipairs(roster) do
    characterData[name] = {
        color = defaultColor,
        spellbook = defaultSpellbook,
    }
end

return characterData
```

## ./conf.lua
```lua
-- Configuration
function love.conf(t)
    t.title = "Manastorm - The Ninefold Circle"  -- The title of the window
    t.version = "11.4"                    -- The LÖVE version this game was made for
    
    -- Base design resolution
    t.window.width = 800
    t.window.height = 600
    
    -- Allow high DPI mode on supported displays (macOS, etc)
    t.window.highdpi = true
    
    -- Make window resizable
    t.window.resizable = true
    
    -- Graphics settings
    t.window.vsync = 1                    -- Vertical sync (1 = enabled)
    t.window.msaa = 0                     -- Disable anti-aliasing to keep pixel art crisp
    
    -- For debugging
    t.console = true
    
    -- Disable unused modules
    -- Enable joystick module for gamepad input
    t.modules.joystick = true
    t.modules.physics = false
end```

## ./core/AssetCache.lua
```lua
-- AssetCache.lua
-- Centralized cache for game assets to prevent duplicate loads
-- All image and sound loading should go through this module

local AssetCache = {}

-- Create weak tables for storing loaded assets
-- Using weak keys allows unused assets to be garbage collected
local imageCache = setmetatable({}, {__mode = "v"})
local soundCache = setmetatable({}, {__mode = "v"})

-- Cache hit counters for metrics
local stats = {
    imageHits = 0,
    imageMisses = 0,
    soundHits = 0,
    soundMisses = 0
}

-- Get an image, loading it only once
function AssetCache.getImage(path)
    if not path then
        print("ERROR: AssetCache.getImage called with nil path")
        return nil
    end
    
    if imageCache[path] then
        stats.imageHits = stats.imageHits + 1
        return imageCache[path]
    end
    
    stats.imageMisses = stats.imageMisses + 1
    
    local success, result = pcall(function()
        return love.graphics.newImage(path)
    end)
    
    if not success then
        print("ERROR: Failed to load image: " .. path .. " - " .. tostring(result))
        return nil
    end
    
    imageCache[path] = result
    return result
end

-- Get a sound, loading it only once
function AssetCache.getSound(path, soundType)
    if not path then
        print("ERROR: AssetCache.getSound called with nil path")
        return nil
    end
    
    soundType = soundType or "static" -- Default to static for effects
    
    if soundCache[path] then
        stats.soundHits = stats.soundHits + 1
        return soundCache[path]
    end
    
    stats.soundMisses = stats.soundMisses + 1
    
    local success, result = pcall(function()
        return love.audio.newSource(path, soundType)
    end)
    
    if not success then
        print("ERROR: Failed to load sound: " .. path .. " - " .. tostring(result))
        return nil
    end
    
    soundCache[path] = result
    return result
end

-- Check if a file exists
local function fileExists(path)
    local success = pcall(function()
        return love.filesystem.getInfo(path) ~= nil
    end)
    return success and love.filesystem.getInfo(path) ~= nil
end

-- Preload a collection of assets (useful at startup)
function AssetCache.preload(assets)
    local loaded = {images = 0, sounds = 0}
    local failed = {images = 0, sounds = 0}
    
    for type, paths in pairs(assets) do
        if type == "images" then
            for _, path in ipairs(paths) do
                if fileExists(path) then
                    local success, _ = pcall(function()
                        AssetCache.getImage(path)
                    end)
                    if success then
                        loaded.images = loaded.images + 1
                    else
                        failed.images = failed.images + 1
                        print("Failed to load image: " .. path)
                    end
                else
                    failed.images = failed.images + 1
                    print("Image file not found: " .. path)
                end
            end
        elseif type == "sounds" then
            for _, data in ipairs(paths) do
                local path, soundType = data[1], data[2]
                if fileExists(path) then
                    local success, _ = pcall(function()
                        AssetCache.getSound(path, soundType)
                    end)
                    if success then
                        loaded.sounds = loaded.sounds + 1
                    else
                        failed.sounds = failed.sounds + 1
                        print("Failed to load sound: " .. path)
                    end
                else
                    failed.sounds = failed.sounds + 1
                    print("Sound file not found: " .. path)
                end
            end
        end
    end
    
    if failed.images > 0 or failed.sounds > 0 then
        print(string.format("AssetCache: Loaded %d images, %d sounds. Failed: %d images, %d sounds", 
                           loaded.images, loaded.sounds, failed.images, failed.sounds))
    end
    
    return loaded
end

-- Flush the cache (useful for dev hot-reload)
function AssetCache.flush()
    for k in pairs(imageCache) do
        imageCache[k] = nil
    end
    for k in pairs(soundCache) do
        soundCache[k] = nil
    end
    
    -- Reset stats
    stats.imageHits = 0
    stats.imageMisses = 0
    stats.soundHits = 0
    stats.soundMisses = 0
end

-- Helper function to count table items (for weak tables)
local function countTableItems(t)
    local count = 0
    for _ in pairs(t) do 
        count = count + 1 
    end
    return count
end

-- Get cache statistics for debug overlay
function AssetCache.dumpStats()
    return {
        images = {
            loaded = countTableItems(imageCache),
            hits = stats.imageHits,
            misses = stats.imageMisses
        },
        sounds = {
            loaded = countTableItems(soundCache),
            hits = stats.soundHits,
            misses = stats.soundMisses
        }
    }
end

return AssetCache```

## ./core/Constants.lua
```lua
-- core/Constants.lua
-- Centralized constants for Manastorm
-- Replaces string literals with structured tables for better typesafety and autocomplete

local Constants = {}

-- Token types (mana/resource types)
Constants.TokenType = {
    FIRE = "fire",
    WATER = "water",
    SALT = "salt",
    SUN = "sun",
    MOON = "moon",
    STAR = "star",
    LIFE = "life",
    MIND = "mind",
    VOID = "void",
    RANDOM = "random",   -- Special: used in spell costs to indicate any token
    ANY = "any"          -- Special: used in keywords for wildcard matching
}

-- Token states in the mana pool
Constants.TokenState = {
    FREE = "FREE",             -- Available in the pool
    CHANNELED = "CHANNELED",   -- Being used in a spell slot
    SHIELDING = "SHIELDING",   -- Being used for a shield spell
    LOCKED = "LOCKED",         -- Temporarily unavailable
    DESTROYED = "DESTROYED"    -- Removed from play (legacy state for backwards compatibility)
}

-- Token status in the lifecycle state machine
Constants.TokenStatus = {
    FREE = "FREE",             -- Available in the pool
    CHANNELED = "CHANNELED",   -- Being used in a spell slot
    SHIELDING = "SHIELDING",   -- Being used for a shield spell
    LOCKED = "LOCKED",         -- Temporarily unavailable
    APPEARING = "APPEARING",   -- Animating into existence from wizard to pool (transition state)
    RETURNING = "RETURNING",   -- Animating back to pool center (transition state)
    ORBITING = "ORBITING",     -- Animating from pool center to orbit (transition state)
    DISSOLVING = "DISSOLVING", -- Animating destruction (transition state)
    POOLED = "POOLED"          -- Released to the object pool
}

-- Visual constants for tokens
Constants.TokenVisuals = {
    -- Scale applied when a token is placed in a spell slot
    CHANNELED_SCALE = 1.0
}

-- Range positioning between wizards
Constants.RangeState = {
    NEAR = "NEAR",
    FAR = "FAR"
}

-- Elevation positioning of wizards
Constants.ElevationState = {
    GROUNDED = "GROUNDED",
    AERIAL = "AERIAL"
}

-- Color Palette (RGBA, 0-1 range)
-- Constants.Color = {
--     BLACK = {0, 0, 0, 1},                    -- #000000
--     MAROON = {0.592, 0.184, 0.278, 1},       -- #972f47
--     FOREST = {0.482, 0.620, 0.145, 1},       -- #7b9e25
--     OCEAN = {0.282, 0.184, 0.745, 1},        -- #482fbe
--     SMOKE = {0.557, 0.475, 0.420, 1},        -- #8e796b
--     CRIMSON = {0.906, 0.122, 0.231, 1},      -- #e71f3b
--     LIME = {0.651, 0.871, 0, 1},             -- #a6de00
--     SKY = {0.365, 0.459, 0.745, 1},          -- #5d75be
--     SAND = {0.906, 0.722, 0.427, 1},         -- #e7b86d
--     OCHRE = {0.847, 0.349, 0.024, 1},        -- #d85906
--     ORANGE = {0.984, 0.675, 0.043, 1},       -- #fbac0b
--     PUCE = {0.851, 0.502, 0.494, 1},         -- #d9807e
--     BONE = {0.906, 0.890, 0.745, 1},         -- #e7e3be
--     YELLOW = {0.984, 0.941, 0.024, 1},       -- #fbf006
--     MINT = {0.502, 0.953, 0.561, 1},         -- #80f38f
--     PINK = {1, 0.820, 1, 1}                  -- #ffd1ff
-- }

Constants.Color = {
    BLACK          = {0.000, 0.000, 0.000, 1}, -- #000000
    VOID           = {0.102, 0.043, 0.118, 1}, -- #1a0b1e
    GRAY           = {0.620, 0.620, 0.620, 1}, -- #9e9e9e
    WHITE          = {1.000, 1.000, 1.000, 1}, -- #ffffff
    RED_HERO       = {1.000, 0.290, 0.141, 1}, -- #ff4a24
    RED_SHADE      = {0.765, 0.212, 0.094, 1}, -- #c33618
    GREEN_HERO     = {0.651, 0.871, 0.000, 1}, -- #a6de00
    GREEN_SHADE    = {0.275, 0.400, 0.000, 1}, -- #466600
    BLUE_HERO      = {0.000, 0.573, 0.875, 1}, -- #0092df
    BLUE_SHADE     = {0.000, 0.322, 0.600, 1}, -- #005299
    YELLOW_HERO    = {1.000, 0.843, 0.000, 1}, -- #ffd700
    YELLOW_SHADE   = {0.784, 0.651, 0.000, 1}, -- #c8a600
    LAVENDER_HERO  = {0.788, 0.722, 1.000, 1}, -- #c9b8ff
    LAVENDER_SHADE = {0.478, 0.424, 0.769, 1}, -- #7a6cc4
    PURPLE_HERO    = {0.353, 0.204, 0.769, 1}, -- #5a34c4
    MAGENTA_HERO   = {0.820, 0.145, 0.659, 1}, -- #d125a8
}

-- Default color for unknown types
Constants.Color.DEFAULT = Constants.Color.SMOKE

-- Helper function to get color based on token type
-- Added mappings for types found in manapool.lua (Nature, Force)
function Constants.getColorForTokenType(tokenType)
    if tokenType == Constants.TokenType.FIRE then return Constants.Color.RED_HERO
    elseif tokenType == Constants.TokenType.WATER then return Constants.Color.BLUE_HERO
    elseif tokenType == Constants.TokenType.SALT then return Constants.Color.GRAY
    elseif tokenType == Constants.TokenType.SUN then return Constants.Color.YELLOW_HERO
    elseif tokenType == Constants.TokenType.MOON then return Constants.Color.LAVENDER_HERO
    elseif tokenType == Constants.TokenType.STAR then return Constants.Color.YELLOW_HERO
    elseif tokenType == Constants.TokenType.LIFE then return Constants.Color.GREEN_HERO
    elseif tokenType == Constants.TokenType.MIND then return Constants.Color.MAGENTA_HERO
    elseif tokenType == Constants.TokenType.VOID then return Constants.Color.WHITE
    else
        print("Warning: Unknown token type for color lookup: " .. tostring(tokenType))
        return Constants.Color.DEFAULT
    end
end

-- Shield types for blocking spells
Constants.ShieldType = {
    BARRIER = "barrier",    -- Physical barrier (blocks projectiles)
    WARD = "ward",          -- Magical ward (blocks remote spells)
    FIELD = "field"         -- Magical field (flexible defense)
}

-- Attack types for spells
-- This makes the overall palette: Projectiles, Beams, and Blasts beat nothing, Remotes beat Barriers, Zones beat Wards.
Constants.AttackType = {
    PROJECTILE = "projectile",  -- Magic flies toward a target, blocked by all shield types but efficient
    REMOTE = "remote",          -- Magic directly affects target, beats Barriers, expensive or slow
    ZONE = "zone",              -- Magic affects a physical area, beats Wards, position-dependent
    UTILITY = "utility"         -- Non-damaging effect, can't be blocked
}

Constants.VisualShape = {
    BOLT = "bolt",
    BEAM = "beam",
    BLAST = "blast",
    ZAP = "zap",
    CONE = "cone",
    REMOTE = "remote",
    METEOR = "meteor",
    CONJURE_BASE = "conjure",
    SURGE = "surge",
    AURA = "aura",
    VORTEX = "vortex",
    TORNADO = "tornado",
    WAVE = "wave",
}

local function buildCastSpeedSet(oneTier)
    return {
        ONE_TIER = oneTier,
        VERY_SLOW = oneTier * 5,
        SLOW = oneTier * 4,
        NORMAL = oneTier * 3,
        FAST = oneTier * 2,
        VERY_FAST = oneTier
    }
end

Constants.CastSpeedSets = {
    FAST = buildCastSpeedSet(3),
    SLOW = buildCastSpeedSet(5)
}

Constants.CastSpeed = Constants.CastSpeedSets.FAST

function Constants.setCastSpeedSet(name)
    if Constants.CastSpeedSets[name] then
        Constants.CastSpeed = Constants.CastSpeedSets[name]
    end
end

-- Target types for keywords
Constants.TargetType = {
    -- Simple targeting - used in spell definitions
    SELF = "SELF",             -- Target the caster
    ENEMY = "ENEMY",           -- Target the opponent
    ALL = "ALL",               -- Target all wizards
    
    -- Complex targeting - used in keyword behaviors
    SLOT_SELF = "SLOT_SELF",     -- Target caster's spell slots
    SLOT_ENEMY = "SLOT_ENEMY",   -- Target opponent's spell slots
    POOL_SELF = "POOL_SELF",     -- Affect mana pool from caster's perspective
    POOL_ENEMY = "POOL_ENEMY",   -- Affect mana pool from opponent's perspective
    
    -- Legacy targeting (lowercase) - should be migrated to uppercase
    CASTER = "caster",         -- The casting wizard
    TARGET = "target"          -- The targeted wizard
}

-- Damage types for spells
Constants.DamageType = {
    FIRE = "fire",
    WATER = "water",
    SALT = "salt",
    SUN = "sun",
    MOON = "moon",
    STAR = "star",
    LIFE = "life",
    MIND = "mind",
    VOID = "void",
    GENERIC = "generic",
    MIXED = "mixed"
}

-- Player sides in battle
Constants.PlayerSide = {
    PLAYER = "PLAYER",
    OPPONENT = "OPPONENT",
    NEUTRAL = "NEUTRAL"
}

-- Status effect types applied to wizards
Constants.StatusType = {
    BURN = "burn",       -- Damage over time
    SLOW = "slow",       -- Increases next cast time
    STUN = "stun",       -- Prevents actions
    REFLECT = "reflect"  -- Reflects incoming spells
}

-- Helper functions for dynamic string generation
-- E.g., replaces patterns like "POOL_" .. side with Constants.poolSide(side)

-- Generate pool target based on side
function Constants.poolSide(side)
    if side == Constants.TargetType.SELF then
        return Constants.TargetType.POOL_SELF
    elseif side == Constants.TargetType.ENEMY then
        return Constants.TargetType.POOL_ENEMY
    else
        return nil
    end
end

-- Generate slot target based on side
function Constants.slotSide(side)
    if side == Constants.TargetType.SELF then
        return Constants.TargetType.SLOT_SELF
    elseif side == Constants.TargetType.ENEMY then
        return Constants.TargetType.SLOT_ENEMY
    else
        return nil
    end
end

-- Utility function to get all token types (excluding special types)
function Constants.getAllTokenTypes()
    return {
        Constants.TokenType.FIRE,
        Constants.TokenType.WATER,
        Constants.TokenType.SALT,
        Constants.TokenType.SUN,
        Constants.TokenType.MOON,
        Constants.TokenType.STAR,
        Constants.TokenType.LIFE,
        Constants.TokenType.MIND,
        Constants.TokenType.VOID
    }
end

-- Utility function to get all shield types
function Constants.getAllShieldTypes()
    return {
        Constants.ShieldType.BARRIER,
        Constants.ShieldType.WARD,
        Constants.ShieldType.FIELD
    }
end

-- Utility function to get all attack types
function Constants.getAllAttackTypes()
    return {
        Constants.AttackType.PROJECTILE,
        Constants.AttackType.REMOTE,
        Constants.AttackType.ZONE,
        Constants.AttackType.UTILITY
    }
end
-- Spell metadata field names for consistent reference
Constants.SpellMetadata = {
    ID = "id",
    NAME = "name",
    AFFINITY = "affinity",
    DESCRIPTION = "description",
    ATTACK_TYPE = "attackType",
    CAST_TIME = "castTime",
    COST = "cost",
    KEYWORDS = "keywords",
    VISUAL_SHAPE = "visualShape",
    VFX = "vfx",
    SFX = "sfx",
    ZONE = "zone"
}

-- Utility function to get all spell metadata field names
function Constants.getAllSpellMetadataFields()
    local fields = {}
    for _, value in pairs(Constants.SpellMetadata) do
        table.insert(fields, value)
    end
    return fields
end

-- Keyword metadata field names for consistent reference
Constants.KeywordMetadata = {
    BEHAVIOR = "behavior",
    EXECUTE = "execute",
    TARGET_TYPE = "targetType",
    CATEGORY = "category",
    PARAMS = "params",
    ENABLED = "enabled",
    VALUE = "value"
}

-- Utility function to get all keyword metadata field names
function Constants.getAllKeywordMetadataFields()
    local fields = {}
    for _, value in pairs(Constants.KeywordMetadata) do
        table.insert(fields, value)
    end
    return fields
end

-- Event metadata field names for consistent reference
Constants.EventMetadata = {
    TYPE = "type",
    SOURCE = "source",
    TARGET = "target",
    AMOUNT = "amount",
    DAMAGE_TYPE = "damageType",
    TOKEN_TYPE = "tokenType",
    DURATION = "duration",
    POSITION = "position",
    ELEVATION = "elevation",
    SLOT_INDEX = "slotIndex",
    VFX = "vfx",
    SFX = "sfx",
    AFFINITY = "affinity",
    ATTACK_TYPE = "attackType",
    TAGS = "tags"
}

-- Utility function to get all event metadata field names
function Constants.getAllEventMetadataFields()
    local fields = {}
    for _, value in pairs(Constants.EventMetadata) do
        table.insert(fields, value)
    end
    return fields
end

-- Visual effect types for consistent usage across the codebase
Constants.VFXType = {
    -- General effects
    IMPACT = "impact",
    
    -- Base template effects (used by VisualResolver)
    PROJ_BASE = "proj_base",       -- Base projectile effect
    BOLT_BASE = "bolt_base",       -- Base bolt effect
    ZAP_BASE = "zap_base",        -- Base zap lightning effect
    ORB_BASE = "orb_base",         -- Base orb effect (lobbed arc projectile)
    BEAM_BASE = "beam_base",       -- Base beam effect
    REMOTE_BASE = "remote_base",   -- Base remote effect (explosion/flash)
    WARP_BASE = "warp_base",       -- Base warp effect (reality distortion)
    ZONE_BASE = "zone_base",       -- Base zone/area effect
    BLAST_BASE = "blast_base",     -- Base conical blast effect
    UTIL_BASE = "util_base",       -- Base utility effect
    SURGE_BASE = "surge_base",      -- Base surge fountain effect
    WAVE_BASE = "wave_base",       -- Base flowing wave effect
    CONJURE_BASE = "conjure_base", -- Base token conjuration effect
    IMPACT_BASE = "impact_base",   -- Base impact effect
    
    -- Overlay addon effects (used by VisualResolver)
    DAMAGE_OVERLAY = "damage_overlay",
    EMBER_OVERLAY = "ember_overlay",
    DOT_OVERLAY = "dot_overlay",
    SPARKLE_OVERLAY = "sparkle_overlay",
    RESOURCE_OVERLAY = "resource_overlay",
    MOVEMENT_OVERLAY = "movement_overlay",
    RISE_OVERLAY = "rise_overlay",
    FALL_OVERLAY = "fall_overlay",
    SHIELD_OVERLAY = "shield_overlay",
    BARRIER_OVERLAY = "barrier_overlay",
    
    -- Movement and positioning effects
    TIDAL_FORCE_GROUND = "tidal_force_ground",
    GRAVITY_PIN_GROUND = "gravity_pin_ground",
    GRAVITY_TRAP_SET = "gravity_trap_set",
    FORCE_BLAST = "force_blast",
    
    -- Special fire effects
    FORCE_BLAST_UP = "force_blast_up",
    ELEVATION_UP = "elevation_up",
    ELEVATION_DOWN = "elevation_down",
    RANGE_CHANGE = "range_change",
    FORCE_POSITION = "force_position",
    
    -- Resource effects
    FREE_MANA = "free_mana",
    TOKEN_LOCK = "token_lock",
    TOKEN_SHIFT = "token_shift",
    TOKEN_CONSUME = "token_consume",
    
    -- Projectile spells
    FIREBOLT = "firebolt",
    METEOR = "meteor",
    TIDAL_FORCE = "tidal_force",
    LUNARDISJUNCTION = "lunardisjunction",
    
    -- Area/zone effects
    MISTVEIL = "mistveil",
    EMBERLIFT = "emberlift",
    FULLMOONBEAM = "fullmoonbeam",
    DISJOINT_CANCEL = "disjoint_cancel",
    
    -- Conjuration effects
    CONJUREFIRE = "conjurefire",
    CONJUREMOONLIGHT = "conjuremoonlight",
    FORCE_CONJURE = "force_conjure",
    STAR_CONJURE = "star_conjure",
    VOLATILECONJURING = "volatileconjuring",
    NOVA_CONJURE = "nova_conjure",
    WITCH_CONJURE = "witch_conjure",
    
    -- Defense effects
    SHIELD = "shield",
    REFLECT = "reflect",
    
    -- Spell timing effects
    SPELL_ACCELERATE = "spell_accelerate",
    SPELL_CANCEL = "spell_cancel",
    SPELL_FREEZE = "spell_freeze",
    SPELL_ECHO = "spell_echo"
}

-- Utility function to get all VFX types
function Constants.getAllVFXTypes()
    local types = {}
    for _, value in pairs(Constants.VFXType) do
        table.insert(types, value)
    end
    return types
end

-- Utility function to check if a value exists in VFXType
function Constants.isValidVFXType(value)
    for _, v in pairs(Constants.VFXType) do
        if v == value then
            return true
        end
    end
    return false
end

-- Abstract game actions for input mapping
Constants.ControlAction = {
    -- Player 1 actions
    P1_SLOT1 = "p1_slot1",
    P1_SLOT2 = "p1_slot2",
    P1_SLOT3 = "p1_slot3",
    P1_CAST  = "p1_cast",
    P1_FREE  = "p1_free",
    P1_BOOK  = "p1_book",
    P1_SLOT1_RELEASE = "p1_slot1_release",
    P1_SLOT2_RELEASE = "p1_slot2_release",
    P1_SLOT3_RELEASE = "p1_slot3_release",

    -- Player 2 actions
    P2_SLOT1 = "p2_slot1",
    P2_SLOT2 = "p2_slot2",
    P2_SLOT3 = "p2_slot3",
    P2_CAST  = "p2_cast",
    P2_FREE  = "p2_free",
    P2_BOOK  = "p2_book",
    P2_SLOT1_RELEASE = "p2_slot1_release",
    P2_SLOT2_RELEASE = "p2_slot2_release",
    P2_SLOT3_RELEASE = "p2_slot3_release",

    -- Menu navigation
    MENU_UP    = "menu_up",
    MENU_DOWN  = "menu_down",
    MENU_LEFT  = "menu_left",
    MENU_RIGHT = "menu_right",

    -- Menu actions
    MENU_CONFIRM      = "menu_confirm",
    MENU_CANCEL_BACK  = "menu_cancel_back",

    -- System actions
    SYS_TOGGLE_DEBUG   = "sys_toggle_debug",
    SYS_QUIT_MENU_BACK = "sys_quit_menu_back"
}

-- Motion styles for VFX particles
Constants.MotionStyle = {
    RADIAL = "radial",     -- Particles expand outward in all directions (default)
    DIRECTIONAL = "directional", -- Particles move in a specific direction
    SWIRL = "swirl",       -- Particles move in a circular/spiral pattern
    RISE = "rise",         -- Particles float upward
    FALL = "fall",         -- Particles fall downward
    PULSE = "pulse",       -- Particles expand and contract rhythmically
    RIPPLE = "ripple",     -- Particles move in wave-like patterns
    STATIC = "static"      -- Particles stay in place with minimal motion
}

-- Utility function to get all motion styles
function Constants.getAllMotionStyles()
    local styles = {}
    for _, value in pairs(Constants.MotionStyle) do
        table.insert(styles, value)
    end
    return styles
end

return Constants
```

## ./core/Input.lua
```lua
-- Input.lua
-- Unified input routing system for Manastorm

local Input = {}
local Constants = require("core.Constants")

-- Store a reference to the game state for routing
local gameState = nil
Input.controls = nil

-- States considered to have a menu active
local MENU_STATES = {
    MENU = true,
    SETTINGS = true,
    CHARACTER_SELECT = true,
    COMPENDIUM = true,
    CAMPAIGN_MENU = true,
    CAMPAIGN_VICTORY = true,
    CAMPAIGN_DEFEAT = true
}

-- Set up input routes by category
Input.Routes = {
    -- System-level controls (scaling, fullscreen, quit)
    system = {},

    -- Player 1 keyboard controls
    p1_kb = {},

    -- Player 2 keyboard controls
    p2_kb = {},

    -- Gamepad routes will be added later
    gp1 = {},
    gp2 = {},

    -- Debug controls (only available outside gameOver state)
    debug = {},

    -- Test controls (only available outside gameOver state)
    test = {},

    -- UI controls (available in any state)
    ui = {},

    -- Game over state controls
    gameOver = {}
}

-- Initialize with game state reference
function Input.init(game)
    gameState = game
    Input.controls = gameState.settings.get("controls")
    Input.setupRoutes()
end

-- Central dispatch for abstract control actions
function Input.triggerAction(action, playerIndex, params)
    local gs = gameState
    if not gs then return false end

    -- Player 1 actions
    if action == Constants.ControlAction.P1_SLOT1 and playerIndex == 1 then
        gs.wizards[1]:keySpell(1, true)
    elseif action == Constants.ControlAction.P1_SLOT2 and playerIndex == 1 then
        gs.wizards[1]:keySpell(2, true)
    elseif action == Constants.ControlAction.P1_SLOT3 and playerIndex == 1 then
        gs.wizards[1]:keySpell(3, true)
    elseif action == Constants.ControlAction.P1_CAST and playerIndex == 1 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM, params)
        end
        gs.wizards[1]:castKeyedSpell()
    elseif action == Constants.ControlAction.P1_FREE and playerIndex == 1 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK, params)
        end
        gs.wizards[1]:freeAllSpells()
    elseif action == Constants.ControlAction.P1_BOOK and playerIndex == 1 then
        require("ui").toggleSpellbook(1)
    elseif action == Constants.ControlAction.P1_SLOT1_RELEASE and playerIndex == 1 then
        gs.wizards[1]:keySpell(1, false)
    elseif action == Constants.ControlAction.P1_SLOT2_RELEASE and playerIndex == 1 then
        gs.wizards[1]:keySpell(2, false)
    elseif action == Constants.ControlAction.P1_SLOT3_RELEASE and playerIndex == 1 then
        gs.wizards[1]:keySpell(3, false)

    -- Player 2 actions
    elseif action == Constants.ControlAction.P2_SLOT1 and playerIndex == 2 then
        gs.wizards[2]:keySpell(1, true)
    elseif action == Constants.ControlAction.P2_SLOT2 and playerIndex == 2 then
        gs.wizards[2]:keySpell(2, true)
    elseif action == Constants.ControlAction.P2_SLOT3 and playerIndex == 2 then
        gs.wizards[2]:keySpell(3, true)
    elseif action == Constants.ControlAction.P2_CAST and playerIndex == 2 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM, params)
        end
        gs.wizards[2]:castKeyedSpell()
    elseif action == Constants.ControlAction.P2_FREE and playerIndex == 2 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK, params)
        end
        gs.wizards[2]:freeAllSpells()
    elseif action == Constants.ControlAction.P2_BOOK and playerIndex == 2 then
        require("ui").toggleSpellbook(2)
    elseif action == Constants.ControlAction.P2_SLOT1_RELEASE and playerIndex == 2 then
        gs.wizards[2]:keySpell(1, false)
    elseif action == Constants.ControlAction.P2_SLOT2_RELEASE and playerIndex == 2 then
        gs.wizards[2]:keySpell(2, false)
    elseif action == Constants.ControlAction.P2_SLOT3_RELEASE and playerIndex == 2 then
        gs.wizards[2]:keySpell(3, false)

    -- Menu/UI actions
    elseif action == Constants.ControlAction.MENU_UP
        or action == Constants.ControlAction.MENU_DOWN
        or action == Constants.ControlAction.MENU_LEFT
        or action == Constants.ControlAction.MENU_RIGHT
        or action == Constants.ControlAction.MENU_CONFIRM
        or action == Constants.ControlAction.MENU_CANCEL_BACK then
        return Input.triggerUIAction(action, params)
    else
        return false
    end
    return true
end

-- Handle UI related actions based on current state
function Input.triggerUIAction(action, params)
    local gs = gameState
    if not gs then return false end

    if action == Constants.ControlAction.MENU_CANCEL_BACK then
        if gs.currentState == "MENU" then
            love.event.quit()
        elseif gs.currentState == "BATTLE" then
            gs.currentState = "MENU"
        elseif gs.currentState == "GAME_OVER" then
            gs.currentState = "MENU"
            gs.resetGame()
        elseif gs.currentState == "CHARACTER_SELECT" then
            gs.characterSelectBack(true)
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.currentState = "MENU"
            gs.campaignMenu = nil
        elseif gs.currentState == "CAMPAIGN_VICTORY" then
            gs.currentState = "MENU"
            gs.campaignProgress = nil
        elseif gs.currentState == "CAMPAIGN_DEFEAT" then
            gs.currentState = "MENU"
            gs.campaignProgress = nil
        elseif gs.currentState == "SETTINGS" then
            if gs.settingsBack then
                gs.settingsBack()
            else
                gs.currentState = "MENU"
            end
        elseif gs.currentState == "COMPENDIUM" then
            gs.currentState = "MENU"
        end
        return true
    elseif action == Constants.ControlAction.MENU_CONFIRM then
        if gs.currentState == "MENU" then
            gs.startCharacterSelect()
            return true
        elseif gs.currentState == "SETTINGS" then
            gs.settingsSelect()
            return true
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.campaignMenuConfirm()
            return true
        elseif gs.currentState == "CHARACTER_SELECT" then
            gs.characterSelectConfirm()
            return true
        elseif gs.currentState == "CAMPAIGN_DEFEAT" then
            gs.retryCampaignBattle()
            return true
        elseif gs.currentState == "CAMPAIGN_VICTORY" then
            gs.currentState = "MENU"
            gs.campaignProgress = nil
            return true
        end
        return false
    elseif action == Constants.ControlAction.MENU_UP then
        if gs.currentState == "SETTINGS" then
            gs.settingsMove(-1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumMove(-1)
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.campaignMenuMove(-1)
        end
        return true
    elseif action == Constants.ControlAction.MENU_DOWN then
        if gs.currentState == "SETTINGS" then
            gs.settingsMove(1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumMove(1)
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.campaignMenuMove(1)
        end
        return true
    elseif action == Constants.ControlAction.MENU_LEFT then
        if gs.currentState == "SETTINGS" then
            gs.settingsAdjust(-1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumChangePage(-1)
        end
        return true
    elseif action == Constants.ControlAction.MENU_RIGHT then
        if gs.currentState == "SETTINGS" then
            gs.settingsAdjust(1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumChangePage(1)
        end
        return true
    end

    return false
end

-- Main entry point for key handling
function Input.handleKey(key, scancode, isrepeat)
    -- Log key presses for debugging
    print("DEBUG: Key pressed: '" .. key .. "'")

    -- Handle settings key capture
    if gameState and gameState.currentState == "SETTINGS" and gameState.settingsMenu and gameState.settingsMenu.waitingForKey then
        local capture = gameState.settingsMenu.waitingForKey
        local controls = gameState.settings.get("controls")
        if controls[capture.playerType] then
            controls[capture.playerType][capture.action] = key
            gameState.settings.set("controls", controls)
            if gameState.settings.save then gameState.settings.save() end
            -- update list for UI
            if gameState.settingsMenu.rebindActionList then
                for _, entry in ipairs(gameState.settingsMenu.rebindActionList) do
                    if entry.action == capture.action then
                        entry.binding = key
                    end
                end
            end
        end
        gameState.settingsMenu.waitingForKey = nil
        Input.setupRoutes()
        return true
    end
    
    -- First check gameOver state - these have highest priority
    if gameState and gameState.gameOver then
        local handler = Input.Routes.gameOver[key]
        if handler then
            return handler(key, scancode, isrepeat)
        end
        return false -- Don't process other keys in gameOver state
    end
    
    -- Check system shortcuts (with modifiers) next
    if love.keyboard.isDown("lalt") or love.keyboard.isDown("ralt") then
        local handler = Input.Routes.system[key]
        if handler then
            return handler(key, scancode, isrepeat)
        end
    end
    
    -- Check developer shortcuts
    if love.keyboard.isDown("lctrl") or love.keyboard.isDown("rctrl") then
        local handler = Input.Routes.system["ctrl_" .. key]
        if handler then
            return handler(key, scancode, isrepeat)
        end
    end
    
    -- Check UI controls (always active). Only stop processing if handled
    local uiHandler = Input.Routes.ui[key]
    if uiHandler then
        local handled = uiHandler(key, scancode, isrepeat)
        if handled then
            return true
        end
        -- fall through to player controls when not handled
    end

    -- Check player 1 keyboard controls
    local p1Handler = Input.Routes.p1_kb[key]
    if p1Handler then
        return p1Handler(key, scancode, isrepeat)
    end

    -- Check player 2 keyboard controls if allowed
    local p2Handler = Input.Routes.p2_kb[key]
    if p2Handler and not gameState.useAI and not gameState.p2UsingGamepad then
        return p2Handler(key, scancode, isrepeat)
    end
    
    -- Check debug controls
    local debugHandler = Input.Routes.debug[key]
    if debugHandler then
        return debugHandler(key, scancode, isrepeat)
    end
    
    -- Check test controls (lowest priority)
    local testHandler = Input.Routes.test[key]
    if testHandler then
        return testHandler(key, scancode, isrepeat)
    end
    
    -- No handler found
    return false
end

-- Handle key release events
function Input.handleKeyReleased(key, scancode)
    local controls = gameState.settings.get("controls")
    local kp1 = controls.keyboardP1 or (controls.p1 or {})
    local kp2 = controls.keyboardP2 or (controls.p2 or {})

    local p1s1 = kp1[Constants.ControlAction.P1_SLOT1] or kp1.slot1
    local p1s2 = kp1[Constants.ControlAction.P1_SLOT2] or kp1.slot2
    local p1s3 = kp1[Constants.ControlAction.P1_SLOT3] or kp1.slot3
    if key == p1s1 or key == p1s2 or key == p1s3 then
        local slotIndex = (key == p1s1) and 1 or (key == p1s2 and 2 or 3)
        if slotIndex == 1 then
            return Input.triggerAction(Constants.ControlAction.P1_SLOT1_RELEASE, 1)
        elseif slotIndex == 2 then
            return Input.triggerAction(Constants.ControlAction.P1_SLOT2_RELEASE, 1)
        else
            return Input.triggerAction(Constants.ControlAction.P1_SLOT3_RELEASE, 1)
        end
    end

    if not gameState.useAI and not gameState.p2UsingGamepad then
        local p2s1 = kp2[Constants.ControlAction.P2_SLOT1] or kp2.slot1
        local p2s2 = kp2[Constants.ControlAction.P2_SLOT2] or kp2.slot2
        local p2s3 = kp2[Constants.ControlAction.P2_SLOT3] or kp2.slot3
        if key == p2s1 or key == p2s2 or key == p2s3 then
            local slotIndex = (key == p2s1) and 1 or (key == p2s2 and 2 or 3)
            if slotIndex == 1 then
                return Input.triggerAction(Constants.ControlAction.P2_SLOT1_RELEASE, 2)
            elseif slotIndex == 2 then
                return Input.triggerAction(Constants.ControlAction.P2_SLOT2_RELEASE, 2)
            else
                return Input.triggerAction(Constants.ControlAction.P2_SLOT3_RELEASE, 2)
            end
        end
    end

    return false
end

-- Process gamepad button events
function Input.handleGamepadButton(joystickID, buttonName, isPressed)
    local playerIndex
    if joystickID == gameState.p1GamepadID then
        playerIndex = 1
    elseif joystickID == gameState.p2GamepadID then
        playerIndex = 2
    end
    if not playerIndex then return false end

    if playerIndex == 2 then
        if gameState.useAI then return false end
        gameState.p2UsingGamepad = true
    end

    if gameState and gameState.currentState == "SETTINGS" and gameState.settingsMenu and gameState.settingsMenu.waitingForKey then
        local capture = gameState.settingsMenu.waitingForKey
        if capture.playerType == "gamepadP1" and playerIndex == 1 or capture.playerType == "gamepadP2" and playerIndex == 2 then
            if isPressed then
                local controls = gameState.settings.get("controls")
                controls[capture.playerType][capture.action] = buttonName
                gameState.settings.set("controls", controls)
                if gameState.settings.save then gameState.settings.save() end
                if gameState.settingsMenu.rebindActionList then
                    for _, entry in ipairs(gameState.settingsMenu.rebindActionList) do
                        if entry.action == capture.action then
                            entry.binding = buttonName
                        end
                    end
                end
                gameState.settingsMenu.waitingForKey = nil
                Input.setupRoutes()
            end
            return true
        end
    end

    local controls = Input.controls or gameState.settings.get("controls")
    local map = (playerIndex == 1) and (controls.gamepadP1 or {}) or (controls.gamepadP2 or {})

    for action, button in pairs(map) do
        if button == buttonName then
            if not isPressed then
                -- Trigger release variants for spell slot buttons
                if action == Constants.ControlAction.P1_SLOT1 then
                    return Input.triggerAction(Constants.ControlAction.P1_SLOT1_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P1_SLOT2 then
                    return Input.triggerAction(Constants.ControlAction.P1_SLOT2_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P1_SLOT3 then
                    return Input.triggerAction(Constants.ControlAction.P1_SLOT3_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P2_SLOT1 then
                    return Input.triggerAction(Constants.ControlAction.P2_SLOT1_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P2_SLOT2 then
                    return Input.triggerAction(Constants.ControlAction.P2_SLOT2_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P2_SLOT3 then
                    return Input.triggerAction(Constants.ControlAction.P2_SLOT3_RELEASE, playerIndex)
                end
            end
            return Input.triggerAction(action, playerIndex, {pressed = isPressed})
        end
    end

    return false
end

-- Store previous axis values to implement deadzone and edge detection
Input._axisState = { [1] = {}, [2] = {} }
Input._axisRepeat = { [1] = {}, [2] = {} }
Input.AXIS_DEADZONE = 0.3
Input.AXIS_REPEAT_DELAY = 0.4
Input.AXIS_REPEAT_INTERVAL = 0.2

-- Process gamepad axis movements for menu navigation
function Input.handleGamepadAxis(joystickID, axisName, value)
    local playerIndex
    if joystickID == gameState.p1GamepadID then
        playerIndex = 1
    elseif joystickID == gameState.p2GamepadID then
        playerIndex = 2
    end
    if not playerIndex then return false end

    if playerIndex == 2 then
        if gameState.useAI then return false end
        if math.abs(value) > Input.AXIS_DEADZONE then
            gameState.p2UsingGamepad = true
        end
    end

    if gameState and gameState.currentState == "SETTINGS" and gameState.settingsMenu and gameState.settingsMenu.waitingForKey then
        local capture = gameState.settingsMenu.waitingForKey
        if (capture.playerType == "gamepadP1" and playerIndex == 1) or (capture.playerType == "gamepadP2" and playerIndex == 2) then
            if math.abs(value) > Input.AXIS_DEADZONE then
                local controls = gameState.settings.get("controls")
                controls[capture.playerType][capture.action] = axisName
                gameState.settings.set("controls", controls)
                if gameState.settings.save then gameState.settings.save() end
                if gameState.settingsMenu.rebindActionList then
                    for _, entry in ipairs(gameState.settingsMenu.rebindActionList) do
                        if entry.action == capture.action then
                            entry.binding = axisName
                        end
                    end
                end
                gameState.settingsMenu.waitingForKey = nil
                Input.setupRoutes()
            end
            return true
        end
    end

    local prev = Input._axisState[playerIndex][axisName] or 0
    Input._axisState[playerIndex][axisName] = value

    local action
    if axisName == "lefty" or axisName == "righty" then
        if value < -Input.AXIS_DEADZONE and prev >= -Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_UP
        elseif value > Input.AXIS_DEADZONE and prev <= Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_DOWN
        end
    elseif axisName == "leftx" or axisName == "rightx" then
        if value < -Input.AXIS_DEADZONE and prev >= -Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_LEFT
        elseif value > Input.AXIS_DEADZONE and prev <= Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_RIGHT
        end
    end

    if action then
        Input._axisRepeat[playerIndex][axisName] = {action = action, timer = Input.AXIS_REPEAT_DELAY}
        return Input.triggerUIAction(action, {value = value})
    elseif math.abs(value) < Input.AXIS_DEADZONE then
        Input._axisRepeat[playerIndex][axisName] = nil
    end

    return false
end

-- Define all keyboard shortcuts and routes
function Input.setupRoutes()
    -- Reset route tables
    Input.Routes.system = {}
    Input.Routes.p1_kb = {}
    Input.Routes.p2_kb = {}
    Input.Routes.gp1 = {}
    Input.Routes.gp2 = {}
    Input.Routes.debug = {}
    Input.Routes.test = {}
    Input.Routes.ui = {}
    Input.Routes.gameOver = {}

    local c = gameState.settings.get("controls")
    Input.controls = c

    local function addRoute(tbl, key, actionDesc, fn)
        if not key or key == "" then
            print("[Input] Warning: action " .. actionDesc .. " has no binding")
            return
        end
        if tbl[key] then
            print("[Input] Warning: conflicting binding for key/button '" .. key .. "'")
        end
        tbl[key] = fn
    end

    -- Build player 1 keyboard routes
    local kp1 = c.keyboardP1 or {}
    for action, key in pairs(kp1) do
        addRoute(Input.Routes.p1_kb, key, action, function()
            return Input.triggerAction(action, 1)
        end)
    end

    -- Build player 2 keyboard routes
    local kp2 = c.keyboardP2 or {}
    for action, key in pairs(kp2) do
        addRoute(Input.Routes.p2_kb, key, action, function()
            return Input.triggerAction(action, 2)
        end)
    end

    -- Build player 1 gamepad routes (button to action lookup)
    local gp1 = c.gamepadP1 or {}
    for action, button in pairs(gp1) do
        addRoute(Input.Routes.gp1, button, action, function(pressed)
            return Input.handleGamepadButton(gameState.p1GamepadID, button, pressed)
        end)
    end

    -- Build player 2 gamepad routes
    local gp2 = c.gamepadP2 or {}
    for action, button in pairs(gp2) do
        addRoute(Input.Routes.gp2, button, action, function(pressed)
            return Input.handleGamepadButton(gameState.p2GamepadID, button, pressed)
        end)
    end

    -- SYSTEM CONTROLS (with ALT modifier)
    Input.Routes.system["1"] = function()
        love.window.setMode(gameState.baseWidth, gameState.baseHeight)
        Input.recalculateScaling()
        return true
    end

    Input.Routes.system["2"] = function()
        love.window.setMode(gameState.baseWidth * 2, gameState.baseHeight * 2)
        Input.recalculateScaling()
        return true
    end

    Input.Routes.system["3"] = function()
        love.window.setMode(gameState.baseWidth * 3, gameState.baseHeight * 3)
        Input.recalculateScaling()
        return true
    end

    Input.Routes.system["f"] = function()
        love.window.setFullscreen(not love.window.getFullscreen())
        Input.recalculateScaling()
        return true
    end

    -- Developer hot-reload with Ctrl+R
    Input.Routes.system["ctrl_r"] = function()
        print("Hot-reloading assets...")
        local AssetPreloader = require("core.assetPreloader")
        local reloadStats = AssetPreloader.reloadAllAssets()
        print(string.format("Asset reload complete: %d images, %d sounds in %.2f seconds",
                          reloadStats.imageCount,
                          reloadStats.soundCount,
                          reloadStats.loadTime))
        return true
    end

    -- GAME OVER STATE CONTROLS
    Input.Routes.gameOver["space"] = function()
        if gameState.currentState == "GAME_OVER" then
            gameState.winScreenTimer = gameState.winScreenDuration
            return true
        end
        return false
    end
    
    -- SYSTEM CONTROLS (with ALT modifier)
    -- Set window to 1x scale
    Input.Routes.system["1"] = function()
        love.window.setMode(gameState.baseWidth, gameState.baseHeight)
        Input.recalculateScaling()
        return true
    end
    
    -- Set window to 2x scale
    Input.Routes.system["2"] = function()
        love.window.setMode(gameState.baseWidth * 2, gameState.baseHeight * 2)
        Input.recalculateScaling()
        return true
    end
    
    -- Set window to 3x scale
    Input.Routes.system["3"] = function()
        love.window.setMode(gameState.baseWidth * 3, gameState.baseHeight * 3)
        Input.recalculateScaling()
        return true
    end
    
    -- Toggle fullscreen
    Input.Routes.system["f"] = function()
        love.window.setFullscreen(not love.window.getFullscreen())
        Input.recalculateScaling()
        return true
    end
    
    -- Developer hot-reload with Ctrl+R
    Input.Routes.system["ctrl_r"] = function()
        print("Hot-reloading assets...")
        local AssetPreloader = require("core.assetPreloader")
        local reloadStats = AssetPreloader.reloadAllAssets()
        print(string.format("Asset reload complete: %d images, %d sounds in %.2f seconds",
                          reloadStats.imageCount,
                          reloadStats.soundCount,
                          reloadStats.loadTime))
        return true
    end
    
    -- MENU CONTROLS
    Input.Routes.ui["1"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCampaignMenu()
            return true
        end
        return false
    end

    -- Character Duel - goes to character select screen
    Input.Routes.ui["2"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCharacterSelect()
            return true
        end
        return false
    end

    -- Research Duel stub
    Input.Routes.ui["3"] = function()
        if gameState.currentState == "MENU" then
            print("Research Duel not implemented yet")
            return true
        end
        return false
    end

    -- Open Compendium screen (with number key 4)
    Input.Routes.ui["4"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCompendium()
            return true
        end
        return false
    end
    
    -- Open Compendium screen (with letter C for easier access)
    Input.Routes.ui["c"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCompendium()
            return true
        end
        return false
    end

    -- Open settings menu
    Input.Routes.ui["5"] = function()
        if gameState.currentState == "MENU" then
            gameState.startSettings()
            return true
        end
        return false
    end

    -- Exit the game
    Input.Routes.ui["6"] = function()
        if gameState.currentState == "MENU" then
            love.event.quit()
            return true
        end
        return false
    end

    -- Generic menu navigation keys
    Input.Routes.ui["return"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)
    end
    Input.Routes.ui["space"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)
    end
    Input.Routes.ui["escape"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK)
    end

    Input.Routes.ui["up"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_UP)
    end
    Input.Routes.ui["down"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_DOWN)
    end
    Input.Routes.ui["left"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_LEFT)
    end
    Input.Routes.ui["right"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_RIGHT)
    end

    -- Assign spells to slots when in Compendium
    for i=1,7 do
        local existing = Input.Routes.ui[tostring(i)]
        Input.Routes.ui[tostring(i)] = function()
            if gameState.currentState == "COMPENDIUM" then
                gameState.compendiumAssign(i)
                return true
            elseif existing then
                return existing()
            end
            return false
        end
    end

    -- CHARACTER SELECT CONTROLS
    -- Move cursor left
    Input.Routes.ui["q"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(-1)
            return true
        end
        return false
    end

    -- Move cursor right
    Input.Routes.ui["e"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(1)
            return true
        end
        return false
    end

    -- CHARACTER SELECT CONTROLS
    -- Move cursor left
    Input.Routes.ui["q"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(-1)
            return true
        end
        return false
    end

    -- Move cursor right
    Input.Routes.ui["e"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(1)
            return true
        end
        return false
    end

    -- Confirm selection / Fight (legacy key)
    Input.Routes.ui["f"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)
    end

    -- Toggle Player 2 mode between Human and AI
    Input.Routes.ui["tab"] = function()
        if gameState.currentState == "CHARACTER_SELECT" and gameState.characterSelect.stage >= 2 then
            gameState.useAI = not gameState.useAI
            return true
        end
        return false
    end

    Input.Routes.ui["r"] = function()
        if gameState.currentState == "CAMPAIGN_DEFEAT" or gameState.currentState == "CAMPAIGN_VICTORY" then
            gameState.restartCampaign()
            return true
        end
        return false
    end

    
    -- DEBUG CONTROLS
    -- Add 30 random tokens with T key
    Input.Routes.debug["t"] = function()
        local addedTokens = {}
        for i = 1, 30 do
            local tokenType = gameState.addRandomToken()
            addedTokens[tokenType] = (addedTokens[tokenType] or 0) + 1
        end
        
        -- Print summary of added tokens
        for tokenType, count in pairs(addedTokens) do
            print("Added " .. count .. " " .. tokenType .. " tokens to the mana pool")
        end
        return true
    end
    
    -- Add specific tokens for testing
    Input.Routes.debug["z"] = function()
        local tokenType = "moon"
        gameState.manaPool:addToken(tokenType, gameState.tokenImages[tokenType])
        print("Added a " .. tokenType .. " token to the mana pool")
        return true
    end
    
    Input.Routes.debug["x"] = function()
        local tokenType = "star"
        gameState.manaPool:addToken(tokenType, gameState.tokenImages[tokenType])
        print("Added a " .. tokenType .. " token to the mana pool")
        return true
    end
    
    Input.Routes.debug["c"] = function()
        local tokenType = "force"
        gameState.manaPool:addToken(tokenType, gameState.tokenImages[tokenType])
        print("Added a " .. tokenType .. " token to the mana pool")
        return true
    end
    
    -- Position/elevation test controls
    -- Toggle range state with R key
    Input.Routes.debug["r"] = function()
        if gameState.rangeState == "NEAR" then
            gameState.rangeState = "FAR"
        else
            gameState.rangeState = "NEAR"
        end
        print("Range state toggled to: " .. gameState.rangeState)
        return true
    end
    
    -- Toggle Ashgar's elevation with A key
    Input.Routes.debug["a"] = function()
        if gameState.wizards[1].elevation == "GROUNDED" then
            gameState.wizards[1].elevation = "AERIAL"
        else
            gameState.wizards[1].elevation = "GROUNDED"
        end
        print("Ashgar elevation toggled to: " .. gameState.wizards[1].elevation)
        return true
    end
    
    -- Toggle Selene's elevation with S key
    Input.Routes.debug["s"] = function()
        if gameState.wizards[2].elevation == "GROUNDED" then
            gameState.wizards[2].elevation = "AERIAL"
        else
            gameState.wizards[2].elevation = "GROUNDED"
        end
        print("Selene elevation toggled to: " .. gameState.wizards[2].elevation)
        return true
    end
    
    -- TESTING / VFX CONTROLS
    -- Namespace these differently to avoid conflict with custom spell hotkeys
    -- Using a safeguard to check the context
    
    -- Test firebolt effect
    Input.Routes.test["1"] = function()
        if not hasActiveSpellInput() then
            gameState.vfx.createEffect("firebolt", gameState.wizards[1].x, gameState.wizards[1].y, gameState.wizards[2].x, gameState.wizards[2].y)
            print("Testing firebolt VFX")
            return true
        end
        return false
    end
    
    -- Test meteor effect
    Input.Routes.test["2"] = function()
        if not hasActiveSpellInput() then
            gameState.vfx.createEffect("meteor", gameState.wizards[2].x, gameState.wizards[2].y - 100, gameState.wizards[2].x, gameState.wizards[2].y)
            print("Testing meteor VFX")
            return true
        end
        return false
    end
    
    -- Test mist veil effect
    Input.Routes.test["3"] = function()
        gameState.vfx.createEffect("mistveil", gameState.wizards[1].x, gameState.wizards[1].y)
        print("Testing mist veil VFX")
        return true
    end
    
    -- Test emberlift effect
    Input.Routes.test["4"] = function()
        gameState.vfx.createEffect("emberlift", gameState.wizards[2].x, gameState.wizards[2].y)
        print("Testing emberlift VFX") 
        return true
    end
    
    -- Test full moon beam effect
    Input.Routes.test["5"] = function()
        gameState.vfx.createEffect("fullmoonbeam", gameState.wizards[2].x, gameState.wizards[2].y, gameState.wizards[1].x, gameState.wizards[1].y)
        print("Testing full moon beam VFX")
        return true
    end
    
    -- Test conjure fire effect
    Input.Routes.test["6"] = function()
        gameState.vfx.createEffect("conjurefire", gameState.wizards[1].x, gameState.wizards[1].y, nil, nil, {
            manaPoolX = gameState.manaPool.x,
            manaPoolY = gameState.manaPool.y
        })
        print("Testing conjure fire VFX")
        return true
    end
    
    -- Test conjure moonlight effect
    Input.Routes.test["7"] = function()
        gameState.vfx.createEffect("conjuremoonlight", gameState.wizards[2].x, gameState.wizards[2].y, nil, nil, {
            manaPoolX = gameState.manaPool.x,
            manaPoolY = gameState.manaPool.y
        })
        print("Testing conjure moonlight VFX")
        return true
    end
    
    -- Test volatile conjuring effect
    Input.Routes.test["8"] = function()
        gameState.vfx.createEffect("volatileconjuring", gameState.wizards[1].x, gameState.wizards[1].y, nil, nil, {
            manaPoolX = gameState.manaPool.x,
            manaPoolY = gameState.manaPool.y
        })
        print("Testing volatile conjuring VFX")
        return true
    end
    
    -- Add direct keys for casting shield spells
    -- This is a special case for spell debugging
    Input.Routes.debug["kp1"] = function() -- Using KeyPad 1 instead of regular 1
        -- Force cast Moon Ward for Selene
        print("DEBUG: Directly casting Moon Ward for Selene")
        local result = gameState.wizards[2]:queueSpell(gameState.customSpells.moonWard)
        print("DEBUG: Moon Ward cast result: " .. tostring(result))
        return true
    end
    
    Input.Routes.debug["kp2"] = function() -- Using KeyPad 2 instead of regular 2
        -- Force cast Mirror Shield for Selene
        print("DEBUG: Directly casting Mirror Shield for Selene")
        local result = gameState.wizards[2]:queueSpell(gameState.customSpells.mirrorShield)
        print("DEBUG: Mirror Shield cast result: " .. tostring(result))
        return true
    end
end

-- Helper to check if there's active spell input happening
-- Prevents VFX test keys from conflicting with spell casting
function hasActiveSpellInput()
    if not gameState or not gameState.wizards then
        return false
    end
    
    -- Check if any wizard has active key combinations
    for _, wizard in ipairs(gameState.wizards) do
        if wizard.activeKeys and (wizard.activeKeys[1] or wizard.activeKeys[2] or wizard.activeKeys[3]) then
            return true
        end
    end
    
    return false
end

-- Helper function to recalculate scaling
function Input.recalculateScaling()
    if gameState and gameState.calculateScaling then
        gameState.calculateScaling()
    end
end

-- Update repeat timers for held gamepad axes
function Input.update(dt)
    for playerIndex, axes in pairs(Input._axisRepeat) do
        for axis, state in pairs(axes) do
            state.timer = state.timer - dt
            if state.timer <= 0 then
                Input.triggerUIAction(state.action, {value = Input._axisState[playerIndex][axis]})
                state.timer = Input.AXIS_REPEAT_INTERVAL
            end
        end
    end
end

-- Document all currently used keys and default bindings
-- `actions` mirrors the defaults defined in core/Settings.lua so that
-- documentation and debug overlays can display current mappings.
Input.reservedKeys = {
    actions = {
        [Constants.ControlAction.P1_SLOT1] = {keyboardP1 = "q", gamepadP1 = "dpdown"},
        [Constants.ControlAction.P1_SLOT2] = {keyboardP1 = "w", gamepadP1 = "dpleft"},
        [Constants.ControlAction.P1_SLOT3] = {keyboardP1 = "e", gamepadP1 = "dpright"},
        [Constants.ControlAction.P1_CAST]  = {keyboardP1 = "f", gamepadP1 = "a"},
        [Constants.ControlAction.P1_FREE]  = {keyboardP1 = "g", gamepadP1 = "y"},
        [Constants.ControlAction.P1_BOOK]  = {keyboardP1 = "b", gamepadP1 = "b"},

        [Constants.ControlAction.P2_SLOT1] = {keyboardP2 = "i", gamepadP2 = "dpdown"},
        [Constants.ControlAction.P2_SLOT2] = {keyboardP2 = "o", gamepadP2 = "dpleft"},
        [Constants.ControlAction.P2_SLOT3] = {keyboardP2 = "p", gamepadP2 = "dpright"},
        [Constants.ControlAction.P2_CAST]  = {keyboardP2 = "j", gamepadP2 = "a"},
        [Constants.ControlAction.P2_FREE]  = {keyboardP2 = "h", gamepadP2 = "y"},
        [Constants.ControlAction.P2_BOOK]  = {keyboardP2 = "m", gamepadP2 = "b"},

        [Constants.ControlAction.MENU_UP]    = {keyboardP1 = "up",    keyboardP2 = "up",    gamepadP1 = "dpup",    gamepadP2 = "dpup"},
        [Constants.ControlAction.MENU_DOWN]  = {keyboardP1 = "down",  keyboardP2 = "down",  gamepadP1 = "dpdown",  gamepadP2 = "dpdown"},
        [Constants.ControlAction.MENU_LEFT]  = {keyboardP1 = "left",  keyboardP2 = "left",  gamepadP1 = "dpleft",  gamepadP2 = "dpleft"},
        [Constants.ControlAction.MENU_RIGHT] = {keyboardP1 = "right", keyboardP2 = "right", gamepadP1 = "dpright", gamepadP2 = "dpright"},
        [Constants.ControlAction.MENU_CONFIRM]     = {keyboardP1 = "return", keyboardP2 = "return", gamepadP1 = "a", gamepadP2 = "a"},
        [Constants.ControlAction.MENU_CANCEL_BACK] = {keyboardP1 = "escape", keyboardP2 = "escape", gamepadP1 = "b", gamepadP2 = "b"}
    },

    system = {
        "Alt+1", "Alt+2", "Alt+3", "Alt+f", -- Window scaling
        "Ctrl+R", -- Asset reload
    },
    
    menu = {
        "1", "2", "3", "4", "5", "6", -- Main menu options
        "Up", "Down", "Left", "Right", -- Navigation
        "Enter", "Space", -- Confirm
        "Escape", -- Quit/Back
    },
    
    battle = {
        "Escape", -- Return to menu from battle
    },

    campaignMenu = {
        "Up", "Down", "Left", "Right", "F", "Enter", "Space", "Escape"
    },

    characterSelect = {
        "Q", "E", -- Move cursor
        "F", "Enter", "Space", -- Confirm
        "Escape" -- Back
    },
    
    gameOver = {
        "Space", "Enter", -- Return to menu after game over
        "Escape", -- Return to menu immediately
    },
    
    player1 = {
        "Q", "W", "E", -- Spell slots
        "F", -- Cast keyed spell
        "G", -- Free all spells
        "B", -- Toggle spellbook
    },
    
    player2 = {
        "I", "O", "P", -- Spell slots
        "J", -- Cast keyed spell
        "H", -- Free all spells
        "M", -- Toggle spellbook
    },
    
    debug = {
        "T", -- Add random token
        "Z", "X", "C", -- Add specific tokens
        "R", -- Toggle range state
        "A", "S", -- Toggle elevations
        "P", -- Show object pool stats
        "Keypad 1", "Keypad 2", -- Direct shield spell casts
    },
    
    testing = {
        "1-8", -- VFX tests
    }
}

return Input
```

## ./core/Log.lua
```lua
local Log = {}

-- Flag to enable verbose debug logging
Log.verbose = false

--- Set verbose logging flag
-- @param enabled boolean
function Log.setVerbose(enabled)
    Log.verbose = not not enabled
end

--- Print a debug message if verbose logging is enabled
function Log.debug(...)
    if Log.verbose then
        print(...)
    end
end

return Log
```

## ./core/Pool.lua
```lua
-- Pool.lua
-- Object pooling system to reduce garbage generation and frame spikes
-- by reusing tables for frequently created and destroyed objects

local Pool = {}
Pool.__index = Pool

-- Store different pools for different object types
Pool.pools = {}

-- Debug statistics
Pool.stats = {
    acquires = {},
    releases = {},
    creates = {},
    poolSizes = {}
}

-- Create a new pool of objects with a given id
function Pool.create(id, initialSize, factoryFn, resetFn)
    if Pool.pools[id] then
        print("[POOL] WARNING: Pool with id '" .. id .. "' already exists! Using existing pool.")
        return Pool.pools[id]
    end
    
    local pool = {
        id = id,
        objects = {}, -- Available objects
        active = {}, -- Currently in use
        factory = factoryFn or function() return {} end, -- Creates new objects
        reset = resetFn or function(obj) 
            -- Basic reset function (clear all fields)
            for k, _ in pairs(obj) do
                obj[k] = nil
            end
            return obj
        end
    }
    
    -- Initialize stats for this pool
    Pool.stats.acquires[id] = 0
    Pool.stats.releases[id] = 0
    Pool.stats.creates[id] = 0
    Pool.stats.poolSizes[id] = 0
    
    -- Pre-populate the pool with specified number of objects
    for i = 1, initialSize or 0 do
        local obj = pool.factory()
        table.insert(pool.objects, obj)
        Pool.stats.creates[id] = Pool.stats.creates[id] + 1
        Pool.stats.poolSizes[id] = Pool.stats.poolSizes[id] + 1
    end
    
    Pool.pools[id] = pool
    print("[POOL] Created new pool '" .. id .. "' with " .. (initialSize or 0) .. " objects")
    
    return pool
end

-- Get an object from the pool, creating a new one if none are available
function Pool.acquire(id, ...)
    local pool = Pool.pools[id]
    if not pool then
        print("[POOL] WARNING: Acquiring from non-existent pool '" .. id .. "'. Creating new pool.")
        local varArgs = {...}
        -- Using the varargs to determine initialization functions
        local factoryFn = varArgs[1]
        local resetFn = varArgs[2]
        pool = Pool.create(id, 0, factoryFn, resetFn)
    end
    
    local obj
    if #pool.objects > 0 then
        -- Use an existing object from the pool
        obj = table.remove(pool.objects)
    else
        -- Create a new object
        obj = pool.factory()
        Pool.stats.creates[id] = Pool.stats.creates[id] + 1
        Pool.stats.poolSizes[id] = Pool.stats.poolSizes[id] + 1
        -- Debug message when creating a new object (uncomment for debugging)
        -- print("[POOL] Created new object for pool '" .. id .. "'")
    end
    
    -- Mark as active and track statistics
    pool.active[obj] = true
    Pool.stats.acquires[id] = Pool.stats.acquires[id] + 1
    
    return obj
end

-- Return an object to the pool
function Pool.release(id, obj)
    local pool = Pool.pools[id]
    if not pool then
        print("[POOL] ERROR: Trying to release to non-existent pool '" .. id .. "'. Object discarded.")
        return false
    end
    
    -- Check if object is actually from this pool
    if not pool.active[obj] then
        print("[POOL] WARNING: Object being released was not acquired from pool '" .. id .. "'. Object discarded.")
        return false
    end
    
    -- Remove from active set
    pool.active[obj] = nil
    
    -- Reset the object to clean state using pool's reset function
    obj = pool.reset(obj)
    
    -- Add back to available pool
    table.insert(pool.objects, obj)
    Pool.stats.releases[id] = Pool.stats.releases[id] + 1
    
    return true
end

-- Get the current size of a pool (available + active)
function Pool.size(id)
    local pool = Pool.pools[id]
    if not pool then return 0 end
    
    local activeCount = 0
    for _ in pairs(pool.active) do
        activeCount = activeCount + 1
    end
    
    return #pool.objects + activeCount
end

-- Get the number of available objects in the pool
function Pool.available(id)
    local pool = Pool.pools[id]
    if not pool then return 0 end
    
    return #pool.objects
end

-- Get number of active objects from the pool
function Pool.activeCount(id)
    local pool = Pool.pools[id]
    if not pool then return 0 end
    
    local count = 0
    for _ in pairs(pool.active) do
        count = count + 1
    end
    
    return count
end

-- Clear a pool (useful during level transitions or game resets)
function Pool.clear(id)
    local pool = Pool.pools[id]
    if not pool then return end
    
    -- Clear both active and inactive objects
    pool.objects = {}
    pool.active = {}
    
    -- Reset stats
    Pool.stats.poolSizes[id] = 0
    
    print("[POOL] Cleared pool '" .. id .. "'")
end

-- Get debug stats about pool usage
function Pool.getStats()
    local stats = {
        pools = {},
        totalObjects = 0,
        totalActive = 0,
        totalAvailable = 0
    }
    
    for id, pool in pairs(Pool.pools) do
        local activeCount = 0
        for _ in pairs(pool.active) do
            activeCount = activeCount + 1
        end
        
        local poolStats = {
            id = id,
            size = Pool.size(id),
            active = activeCount,
            available = #pool.objects,
            acquires = Pool.stats.acquires[id] or 0,
            releases = Pool.stats.releases[id] or 0,
            creates = Pool.stats.creates[id] or 0
        }
        
        table.insert(stats.pools, poolStats)
        stats.totalObjects = stats.totalObjects + poolStats.size
        stats.totalActive = stats.totalActive + poolStats.active
        stats.totalAvailable = stats.totalAvailable + poolStats.available
    end
    
    return stats
end

-- Print debug stats for all pools
function Pool.printStats()
    local stats = Pool.getStats()
    
    print("\n=== OBJECT POOL STATISTICS ===")
    print(string.format("Total Objects: %d (Active: %d, Available: %d)", 
        stats.totalObjects, stats.totalActive, stats.totalAvailable))
    
    for _, poolStats in ipairs(stats.pools) do
        print(string.format("Pool '%s': %d objects (%d active, %d available)", 
            poolStats.id, poolStats.size, poolStats.active, poolStats.available))
        print(string.format("  - Created: %d, Acquired: %d, Released: %d, Reuse: %.1f%%", 
            poolStats.creates, poolStats.acquires, poolStats.releases,
            poolStats.acquires > 0 and ((poolStats.acquires - poolStats.creates) / poolStats.acquires * 100) or 0))
    end
    print("==============================\n")
end

-- Debug overlay showing pool stats
function Pool.drawDebugOverlay()
    local stats = Pool.getStats()
    
    -- Check if love.graphics is available
    if not love or not love.graphics then return end
    
    -- Save current graphics state
    love.graphics.push("all")
    
    -- Set up colors and font
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 10, 10, 300, 20 + #stats.pools * 40)
    
    love.graphics.setColor(1, 1, 1, 1)
    love.graphics.print("OBJECT POOLS: " .. stats.totalObjects .. " objects (" .. 
        stats.totalActive .. " active, " .. stats.totalAvailable .. " available)", 15, 15)
    
    for i, poolStats in ipairs(stats.pools) do
        love.graphics.print(string.format("'%s': %d obj (%d active, %d avail)", 
            poolStats.id, poolStats.size, poolStats.active, poolStats.available), 20, 15 + i * 20)
        
        -- Calculate reuse percentage
        local reusePercent = poolStats.acquires > 0 and 
            ((poolStats.acquires - poolStats.creates) / poolStats.acquires * 100) or 0
        
        love.graphics.print(string.format("Created: %d, Acq: %d, Reuse: %.1f%%", 
            poolStats.creates, poolStats.acquires, reusePercent), 30, 15 + i * 20 + 12)
        
        -- Draw a small bar showing active vs available
        if poolStats.size > 0 then
            -- Background bar
            love.graphics.setColor(0.3, 0.3, 0.3, 1)
            love.graphics.rectangle("fill", 180, 19 + i * 20, 100, 8)
            
            -- Active portion
            love.graphics.setColor(0.8, 0.3, 0.3, 1)
            love.graphics.rectangle("fill", 180, 19 + i * 20, 
                100 * (poolStats.active / poolStats.size), 8)
        end
    end
    
    -- Restore graphics state
    love.graphics.pop()
end

return Pool```

## ./core/Settings.lua
```lua
local Settings = {}
local Constants = require("core.Constants")

-- Default configuration
local defaults = {
    dummyFlag = false,
    gameSpeed = "FAST",
    controls = {
        keyboardP1 = {
            [Constants.ControlAction.P1_SLOT1] = "q",
            [Constants.ControlAction.P1_SLOT2] = "w",
            [Constants.ControlAction.P1_SLOT3] = "e",
            [Constants.ControlAction.P1_CAST]  = "f",
            [Constants.ControlAction.P1_FREE]  = "g",
            [Constants.ControlAction.P1_BOOK]  = "b",
            [Constants.ControlAction.MENU_UP]    = "up",
            [Constants.ControlAction.MENU_DOWN]  = "down",
            [Constants.ControlAction.MENU_LEFT]  = "left",
            [Constants.ControlAction.MENU_RIGHT] = "right",
            [Constants.ControlAction.MENU_CONFIRM]     = "return",
            [Constants.ControlAction.MENU_CANCEL_BACK] = "escape"
        },
        keyboardP2 = {
            [Constants.ControlAction.P2_SLOT1] = "i",
            [Constants.ControlAction.P2_SLOT2] = "o",
            [Constants.ControlAction.P2_SLOT3] = "p",
            [Constants.ControlAction.P2_CAST]  = "j",
            [Constants.ControlAction.P2_FREE]  = "h",
            [Constants.ControlAction.P2_BOOK]  = "m"
        },
        gamepadP1 = {
            [Constants.ControlAction.P1_SLOT1] = "dpdown",
            [Constants.ControlAction.P1_SLOT2] = "dpleft",
            [Constants.ControlAction.P1_SLOT3] = "dpright",
            [Constants.ControlAction.P1_CAST]  = "a",
            [Constants.ControlAction.P1_FREE]  = "y",
            [Constants.ControlAction.P1_BOOK]  = "b",
            [Constants.ControlAction.MENU_UP]    = "dpup",
            [Constants.ControlAction.MENU_DOWN]  = "dpdown",
            [Constants.ControlAction.MENU_LEFT]  = "dpleft",
            [Constants.ControlAction.MENU_RIGHT] = "dpright",
            [Constants.ControlAction.MENU_CONFIRM]     = "a",
            [Constants.ControlAction.MENU_CANCEL_BACK] = "b"
        },
        gamepadP2 = {
            [Constants.ControlAction.P2_SLOT1] = "dpdown",
            -- Placeholder for P2 controller mappings
        }
    }
}

local function deepcopy(tbl)
    if type(tbl) ~= "table" then return tbl end
    local result = {}
    for k, v in pairs(tbl) do
        result[k] = deepcopy(v)
    end
    return result
end

local function serialize(tbl, indent)
    indent = indent or 0
    local parts = {"{\n"}
    local pad = string.rep(" ", indent + 2)
    for k, v in pairs(tbl) do
        local key
        if type(k) == "string" then
            key = k .. " = "
        else
            key = "[" .. k .. "] = "
        end
        if type(v) == "table" then
            table.insert(parts, pad .. key .. serialize(v, indent + 2) .. ",\n")
        elseif type(v) == "string" then
            table.insert(parts, pad .. key .. string.format("%q", v) .. ",\n")
        else
            table.insert(parts, pad .. key .. tostring(v) .. ",\n")
        end
    end
    table.insert(parts, string.rep(" ", indent) .. "}")
    return table.concat(parts)
end

local function mergeDefaults(target, default)
    for k, v in pairs(default) do
        if type(v) == "table" then
            if type(target[k]) ~= "table" then
                target[k] = deepcopy(v)
            else
                mergeDefaults(target[k], v)
            end
        elseif target[k] == nil then
            target[k] = v
        end
    end
end

Settings.data = nil

function Settings.load()
    if love.filesystem.getInfo("settings.lua") then
        local chunk = love.filesystem.load("settings.lua")
        local ok, result = pcall(chunk)
        if ok and type(result) == "table" then
            Settings.data = result
            -- Backwards compatibility: convert numeric gameSpeed
            if type(Settings.data.gameSpeed) ~= "string" then
                Settings.data.gameSpeed = "FAST"
            end
            -- Merge new defaults for missing values
            mergeDefaults(Settings.data, defaults)
            return
        end
    end
    Settings.data = deepcopy(defaults)
    Settings.save()
end

function Settings.save()
    if not Settings.data then return end
    local serialized = "return " .. serialize(Settings.data) .. "\n"
    love.filesystem.write("settings.lua", serialized)
end

function Settings.get(key)
    if not Settings.data then Settings.load() end
    return Settings.data[key]
end

function Settings.set(key, value)
    if not Settings.data then Settings.load() end
    Settings.data[key] = value
    Settings.save()
end

function Settings.getDefaults()
    return deepcopy(defaults)
end

return Settings
```

## ./core/Tips.lua
```lua
local Tips = {}

local loadedTips = nil

local function parseTips(json)
    local tips = {}
    if not json then return tips end
    for tipBlock in json:gmatch("%{[^{}]*%}") do
        local title = tipBlock:match('"title"%s*:%s*"(.-)"')
        local content = tipBlock:match('"content"%s*:%s*"(.-)"')
        local source = tipBlock:match('"source"%s*:%s*"(.-)"')
        if title and content and source then
            table.insert(tips, {
                title = title,
                content = content,
                source = source
            })
        end
    end
    return tips
end

function Tips.load(path)
    if loadedTips then
        return loadedTips
    end
    local data = love.filesystem.read(path)
    if not data then
        print("ERROR: Could not load tips file: " .. tostring(path))
        loadedTips = {}
        return loadedTips
    end
    loadedTips = parseTips(data)
    return loadedTips
end

function Tips.getRandomTip()
    if not loadedTips then
        return nil
    end
    if #loadedTips == 0 then
        return nil
    end
    return loadedTips[love.math.random(#loadedTips)]
end

return Tips
```

## ./core/assetPreloader.lua
```lua
-- assetPreloader.lua
-- Centralized preloader for game assets

local AssetCache = require("core.AssetCache")

local AssetPreloader = {}

-- Preload all game assets to avoid hitches during gameplay
function AssetPreloader.preloadAllAssets()
    local startTime = love.timer.getTime()
    
    -- Manifest of all assets to preload
    local assetManifest = {
        images = {
            -- Token & UI assets
            "assets/sprites/token-lock.png",
            
            -- Elemental tokens
            "assets/sprites/v2Tokens/fire-token.png", 
            "assets/sprites/v2Tokens/water-token.png",
            "assets/sprites/v2Tokens/salt-token.png",
            "assets/sprites/v2Tokens/sun-token.png",
            "assets/sprites/v2Tokens/moon-token.png",
            "assets/sprites/v2Tokens/star-token.png",
            "assets/sprites/v2Tokens/life-token.png",
            "assets/sprites/v2Tokens/mind-token.png",
            "assets/sprites/v2Tokens/void-token.png",
            
            -- VFX assets
            "assets/sprites/fire-particle.png",
            "assets/sprites/fire-glow.png",
            "assets/sprites/force-wave.png", 
            "assets/sprites/moon-glow.png",
            "assets/sprites/sparkle.png",
            "assets/sprites/impact-ring.png",
            "assets/sprites/1px.png",
            "assets/sprites/3px-twinkle1.png",
            "assets/sprites/3px-twinkle2.png",
            
            
            -- Game entity assets
            "assets/sprites/wizard.png",
            "assets/sprites/ashgar.png",
            "assets/sprites/ashgar-cast.png",
            "assets/sprites/ashgar-idle-1.png",
            "assets/sprites/ashgar-idle-2.png",
            "assets/sprites/ashgar-idle-3.png",
            "assets/sprites/ashgar-idle-4.png",
            "assets/sprites/ashgar-idle-5.png",
            "assets/sprites/ashgar-idle-6.png",
            "assets/sprites/ashgar-idle-7.png",
            "assets/sprites/selene.png",
            "assets/sprites/selene-cast.png",

            "assets/sprites/grounded-circle.png"
        },
        
        sounds = {
            -- These are placeholders until actual sound assets are created
            -- Format: {path, type} where type is "static" or "stream"
            -- {"assets/sounds/firebolt.wav", "static"},
            -- {"assets/sounds/meteor.wav", "static"},
            -- {"assets/sounds/mist.wav", "static"}
        }
    }
    
    -- Check assets directory structure
    local assetsExist = love.filesystem.getInfo("assets/sprites")
    if not assetsExist then
        print("WARNING: assets/sprites directory not found. Asset loading may fail.")
    end
    
    -- Filter manifest to only include existing paths
    local filteredManifest = {
        images = {},
        sounds = {}
    }
    
    for _, path in ipairs(assetManifest.images) do
        if love.filesystem.getInfo(path) then
            table.insert(filteredManifest.images, path)
        else
            print("Asset not found, will skip: " .. path)
        end
    end
    
    for _, soundData in ipairs(assetManifest.sounds) do
        if love.filesystem.getInfo(soundData[1]) then
            table.insert(filteredManifest.sounds, soundData)
        else
            print("Sound asset not found, will skip: " .. soundData[1])
        end
    end
    
    -- Preload all assets in the filtered manifest
    local loaded = AssetCache.preload(filteredManifest)
    
    -- Report preload time
    local loadTime = love.timer.getTime() - startTime
    print(string.format("AssetPreloader: Loaded %d images and %d sounds in %.2f seconds", 
                        loaded.images, loaded.sounds, loadTime))
                        
    -- Return statistics for verification
    return {
        imageCount = loaded.images,
        soundCount = loaded.sounds,
        loadTime = loadTime
    }
end

-- Helper to reload all assets (useful for development hot-reload)
function AssetPreloader.reloadAllAssets()
    AssetCache.flush()
    return AssetPreloader.preloadAllAssets()
end

-- Get asset cache statistics
function AssetPreloader.getStats()
    return AssetCache.dumpStats()
end

return AssetPreloader```

## ./docs/keywords.lua
```lua
-- Keywords Documentation Generator
-- This file helps maintain up-to-date documentation for the keyword system

local Spells = require("spells")

local DocGenerator = {}

-- Function to get the default target type description for a keyword
local function getTargetTypeDescription(keyword)
    local targetType = Spells.keywordSystem.keywordTargets[keyword]
    local descriptions = {
        self = "Affects the caster",
        enemy = "Affects the opponent",
        pool_self = "Affects the caster's mana pool",
        pool_enemy = "Affects the opponent's mana pool",
        slot_self = "Affects the caster's spell slots",
        slot_enemy = "Affects the opponent's spell slots",
        global = "Affects the game state",
        none = "No specific target"
    }
    
    return descriptions[targetType] or "Unknown target type"
end

-- Generate markdown documentation for all available keywords
function DocGenerator.generateMarkdown()
    local output = "# Manastorm Spell Keyword Reference\n\n"
    output = output .. "This document provides a reference for all available keywords in the Manastorm spell system.\n\n"
    
    -- Get keyword info organized by category
    local keywordsByCategory = Spells.keywordSystem.getKeywordHelp("byCategory")
    
    -- Table of contents
    output = output .. "## Contents\n\n"
    for categoryKey, category in pairs(keywordsByCategory) do
        output = output .. "- [" .. category.name .. "](#" .. string.lower(category.name:gsub("%s+", "-")) .. ")\n"
    end
    output = output .. "\n\n"
    
    -- Generate sections for each category
    for categoryKey, category in pairs(keywordsByCategory) do
        output = output .. "## " .. category.name .. "\n\n"
        
        for _, keyword in ipairs(category.keywords) do
            output = output .. "### " .. keyword.name .. "\n\n"
            output = output .. keyword.description .. "\n\n"
            output = output .. "**Default targeting:** " .. getTargetTypeDescription(keyword.name) .. "\n\n"
            output = output .. "**Example usage:**\n\n"
            output = output .. "```lua\n" .. keyword.example .. "\n```\n\n"
            
            -- Add targeting example if appropriate
            if Spells.keywordSystem.keywordTargets[keyword.name] then
                output = output .. "**Custom targeting example:**\n\n"
                output = output .. "```lua\n" .. keyword.name .. " = {\n"
                output = output .. "    -- Parameters as above\n"
                output = output .. "    target = \"" .. Spells.keywordSystem.keywordTargets[keyword.name] .. "\"  -- Default target\n"
                output = output .. "    -- You can override with any of: \"self\", \"enemy\", \"pool_self\", \"pool_enemy\", \"slot_self\", \"slot_enemy\", \"global\", \"none\"\n"
                output = output .. "}\n```\n\n"
            end
        end
    end
    
    -- Add a section with sample spells
    output = output .. "## Sample Spells\n\n"
    output = output .. "These examples show how to combine multiple keywords to create complex spell effects.\n\n"
    
    -- Targeting section
    output = output .. "### About Targeting\n\n"
    output = output .. "Each keyword has a default target (shown in the keyword documentation). You can override this by specifying a `target` parameter in the keyword configuration.\n\n"
    output = output .. "Available target types:\n\n"
    output = output .. "| Target Type | Description |\n"
    output = output .. "|------------|-------------|\n"
    output = output .. "| `self` | Affects the caster |\n"
    output = output .. "| `enemy` | Affects the opponent |\n"
    output = output .. "| `pool_self` | Affects the caster's mana pool |\n"
    output = output .. "| `pool_enemy` | Affects the opponent's mana pool |\n"
    output = output .. "| `slot_self` | Affects the caster's spell slots |\n"
    output = output .. "| `slot_enemy` | Affects the opponent's spell slots |\n"
    output = output .. "| `global` | Affects the game state |\n"
    output = output .. "| `none` | No specific target |\n\n"
    
    -- Multi-target spell example
    output = output .. "### Arcane Reversal (Multi-Target Example)\n\n"
    output = output .. "```lua\nSpells.arcaneReversal = {\n"
    output = output .. "    id = \"arcanereversal\",\n"
    output = output .. "    name = \"Arcane Reversal\",\n"
    output = output .. "    description = \"A complex spell that manipulates mana, movement, and timing simultaneously\",\n"
    output = output .. "    attackType = \"remote\",\n"
    output = output .. "    castTime = 6.0,\n"
    output = output .. "    cost = {\"moon\", \"star\", \"force\", \"force\"},\n"
    output = output .. "    keywords = {\n"
    output = output .. "        -- Apply damage to enemy\n"
    output = output .. "        damage = {\n"
    output = output .. "            amount = function(caster, target)\n"
    output = output .. "                -- More damage if enemy has active shields\n"
    output = output .. "                local shieldCount = 0\n"
    output = output .. "                for _, slot in ipairs(target.spellSlots) do\n"
    output = output .. "                    if slot.active and slot.isShield then\n"
    output = output .. "                        shieldCount = shieldCount + 1\n"
    output = output .. "                    end\n"
    output = output .. "                end\n"
    output = output .. "                return 8 + (shieldCount * 4)  -- 8 base + 4 per shield\n"
    output = output .. "            end,\n"
    output = output .. "            type = \"star\",\n"
    output = output .. "            target = \"ENEMY\"  -- Explicit targeting\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Move self to opposite range\n"
    output = output .. "        rangeShift = {\n"
    output = output .. "            position = function(caster, target)\n"
    output = output .. "                return caster.gameState.rangeState == \"NEAR\" and \"FAR\" or \"NEAR\"\n"
    output = output .. "            end,\n"
    output = output .. "            target = \"SELF\"  -- Different target from damage\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Lock opponent's mana tokens\n"
    output = output .. "        lock = {\n"
    output = output .. "            duration = 4.0,\n"
    output = output .. "            target = \"POOL_ENEMY\"  -- Target opponent's pool\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Add tokens to own pool\n"
    output = output .. "        conjure = {\n"
    output = output .. "            token = \"force\",\n"
    output = output .. "            amount = 1,\n"
    output = output .. "            target = \"POOL_SELF\"  -- Target own pool\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Accelerate own next spell\n"
    output = output .. "        accelerate = {\n"
    output = output .. "            amount = 2.0,\n"
    output = output .. "            slot = 1,  -- First slot\n"
    output = output .. "            target = \"SLOT_SELF\"  -- Target own slot\n"
    output = output .. "        }\n"
    output = output .. "    },\n"
    output = output .. "    vfx = \"arcane_reversal\",\n"
    output = output .. "}\n```\n\n"
    
    -- Fireball example
    output = output .. "### Fireball\n\n"
    output = output .. "```lua\nSpells.fireball = {\n"
    output = output .. "    id = \"fireball\",\n"
    output = output .. "    name = \"Fireball\",\n"
    output = output .. "    description = \"Launches a ball of fire that deals heavy damage\",\n"
    output = output .. "    attackType = \"projectile\",\n"
    output = output .. "    castTime = 4.0,\n"
    output = output .. "    cost = {\"fire\", \"fire\", \"force\"},\n"
    output = output .. "    keywords = {\n"
    output = output .. "        damage = {\n"
    output = output .. "            amount = function(caster, target)\n"
    output = output .. "                -- More damage at FAR range\n"
    output = output .. "                return caster.gameState.rangeState == \"FAR\" and 18 or 12\n"
    output = output .. "            end,\n"
    output = output .. "            type = \"fire\"\n"
    output = output .. "            -- No target specified, uses default: ENEMY\n"
    output = output .. "        },\n"
    output = output .. "        -- Add AOE effect if cast from AERIAL\n"
    output = output .. "        zoneMulti = function(caster, target)\n"
    output = output .. "            return caster.elevation == \"AERIAL\"\n"
    output = output .. "        end\n"
    output = output .. "    },\n"
    output = output .. "    vfx = \"fireball\",\n"
    output = output .. "    sfx = \"explosion\",\n"
    output = output .. "}\n```\n\n"
    
    return output
end

-- Generate a documentation file
function DocGenerator.writeDocumentation(outputPath)
    outputPath = outputPath or "/Users/russell/Manastorm/docs/KEYWORDS.md"
    
    local markdown = DocGenerator.generateMarkdown()
    
    local file = io.open(outputPath, "w")
    if file then
        file:write(markdown)
        file:close()
        print("Keyword documentation written to: " .. outputPath)
        return true
    else
        print("Error: Could not open file for writing: " .. outputPath)
        return false
    end
end

-- Execute documentation generation if this file is run directly
if not ... then
    DocGenerator.writeDocumentation()
end

return DocGenerator```

## ./expr.lua
```lua
-- expr.lua
-- Expression helper functions for spell parameter evaluation

local Constants = require("core.Constants")
local ManaHelpers = require("systems.ManaHelpers")

local expr = {}

-- Choose whichever token is more abundant in the shared pool
function expr.more(a, b)
    return function(caster)
        local manaPool = caster and caster.manaPool
        return ManaHelpers.count(a, manaPool) > ManaHelpers.count(b, manaPool) and b or a
    end
end

-- Choose the scarcer token
function expr.less(a, b)
    return function(caster)
        local manaPool = caster and caster.manaPool
        return ManaHelpers.count(a, manaPool) < ManaHelpers.count(b, manaPool) and a or b
    end
end

-- Choose a token type based on a condition
function expr.ifCond(condition, trueValue, falseValue)
    return function(caster, target, slot)
        if condition(caster, target, slot) then
            return trueValue
        else
            return falseValue
        end
    end
end

-- Choose a value based on elevation state
function expr.byElevation(elevationValues)
    return function(caster, target, slot)
        local entityToCheck = target or caster
        local elevation = entityToCheck and entityToCheck.elevation or "GROUNDED"
        return elevationValues[elevation] or elevationValues.default
    end
end

-- Choose a value based on range state
function expr.byRange(rangeValues)
    return function(caster, target, slot)
        local rangeState = caster and caster.gameState and caster.gameState.rangeState or "NEAR"
        return rangeValues[rangeState] or rangeValues.default
    end
end

-- Choose a value based on which wizard has more tokens
function expr.whoHasMore(tokenType, casterValue, targetValue)
    return function(caster, target, slot)
        if not caster or not target or not caster.manaPool or not target.manaPool then
            return casterValue -- Default to caster value if we can't determine
        end
        
        local casterCount = ManaHelpers.count(tokenType, caster.manaPool)
        local targetCount = ManaHelpers.count(tokenType, target.manaPool)
        
        return casterCount >= targetCount and casterValue or targetValue
    end
end

-- Calculate a value based on the number of tokens
function expr.countScale(tokenType, baseValue, multiplier)
    return function(caster, target, slot)
        if not caster or not caster.manaPool then 
            return baseValue
        end
        
        local count = ManaHelpers.count(tokenType, caster.manaPool)
        return baseValue + (count * multiplier)
    end
end

return expr```

## ./keywords.lua
```lua
-- keywords.lua
-- Defines all keywords and their behaviors for the spell system
--
-- IMPORTANT: Keyword execute functions should create and return events rather than directly modifying game state.
-- The events are collected and processed by the EventRunner module.
--
-- When creating a new keyword, follow this pattern:
--
-- Keywords.newKeyword = {
--     behavior = {
--         -- Define behavior metadata here to document the effect
--         descriptiveProperty = true,
--         targetType = Constants.TargetType.ENEMY,
--         category = "CATEGORY"
--     },
--     
--     -- Implementation function should return events
--     execute = function(params, caster, target, results)
--         -- Create your event(s) here 
--         results.myEvent = {
--             type = "EVENT_TYPE", 
--             source = "caster",
--             target = "enemy",
--             property = params.property
--         }
--         
--         -- Return the results table containing events
--         return results
--     end
-- }
--
-- Parameter resolution:
-- Keyword parameters can now be static values or functions. If a function is provided, 
-- it will be called with (caster, target, slot) and the result used as the parameter value.
--
-- Example static parameter:
--   damage = { amount = 10 }
--
-- Example function parameter:
--   damage = { 
--     amount = function(caster, target, slot)
--       return target.elevation == "AERIAL" and 15 or 10
--     end
--   }
--
-- Example using expression helpers:
--   tokenShift = {
--     type = expr.more(Constants.TokenType.SUN, Constants.TokenType.MOON),
--     amount = 1
--   }
--
-- See docs/combat_events.md for the event schema and types.

local Constants = require("core.Constants")

-- Utility: resolve a param that may be a callable
local function resolve(value, caster, target, slot, default)
    if type(value) == "function" then
        local ok, result = pcall(value, caster, target, slot)
        return ok and result or default
    end
    return value ~= nil and value or default
end

local Keywords = {}

-- Export utility functions
Keywords.util = { resolve = resolve }

-- Keyword categories for organization
Keywords.categories = {
    DAMAGE = "Damage Effects",
    DOT = "Damage Over Time",
    TIMING = "Spell Timing",
    MOVEMENT = "Movement & Position",
    RESOURCE = "Resource Manipulation",
    TOKEN = "Token Manipulation",
    DEFENSE = "Defense Mechanisms",
    SPECIAL = "Special Effects",
    ZONE = "Zone Mechanics",
    TRAP = "Trap Mechanics"
}

-- Target types for keywords (legacy support - new code should use Constants.TargetType directly)

-- Sustained spell system keywords
-- These are keywords related to the sustained spell system, which allows spells
-- to continue occupying a slot after being cast (shields, traps, etc)

-- sustain: Marks a spell to remain active in its slot after casting
Keywords.sustain = {
    -- Behavior definition
    behavior = {
        marksSpellAsSustained = true,
        category = "TIMING"
    },
    
    -- Implementation function - Sets results.isSustained flag
    execute = function(params, caster, target, results, events)
        results.isSustained = true
        return results
    end
}

-- trap_trigger: Defines the condition that triggers a trap spell
Keywords.trap_trigger = {
    -- Behavior definition
    behavior = {
        storesTriggerCondition = true,
        category = "TRAP"
    },
    
    -- Implementation function - Stores trigger condition
    execute = function(params, caster, target, results, events)
        results.trapTrigger = params
        print(string.format("[TRAP] Stored trigger condition: %s", 
            params.condition or "unknown"))
        return results
    end
}


-- trap_effect: Defines the effect that occurs when a trap is triggered
Keywords.trap_effect = {
    -- Behavior definition
    behavior = {
        storesEffectPayload = true,
        category = "TRAP"
    },
    
    -- Implementation function - Stores effect payload
    execute = function(params, caster, target, results, events)
        results.trapEffect = params
        
        -- Get a list of the effects included
        local effectNames = {}
        for effectName, _ in pairs(params) do
            table.insert(effectNames, effectName)
        end
        
        -- Log the effects included
        if #effectNames > 0 then
            print(string.format("[TRAP] Stored effect payload with effects: %s", 
                table.concat(effectNames, ", ")))
        else
            print("[TRAP] Warning: Effect payload with no effects defined")
        end
        
        return results
    end
}

-- field_status: Defines a persistent status applied while the field is active
Keywords.field_status = {
    behavior = {
        marksSpellAsSustained = true,
        category = "FIELD"
    },

    execute = function(params, caster, target, results, events)
        results.fieldStatus = params
        results.isField = true
        results.isSustained = true
        return results
    end
}
Keywords.targetTypes = Constants.TargetType

-- ===== Core Combat Keywords =====

-- damage: Deals direct damage to a target
Keywords.damage = {
    -- Behavior definition
    behavior = {
        dealsDamage = true,
        targetType = Constants.TargetType.ENEMY,
        category = "DAMAGE",
        
        -- Default parameters
        defaultAmount = 0,
        defaultType = Constants.DamageType.GENERIC
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events, spell)
        -- Use resolve to handle conditional parameter
        local applyDamage = resolve(params.condition, caster, target, results.currentSlot, true)
        
        -- Only generate event if condition passed (or no condition)
        if applyDamage then
            -- Use resolve for damage amount and type
            local calculatedDamage = resolve(params.amount, caster, target, results.currentSlot, 0)
            local damageType = resolve(params.type, caster, target, results.currentSlot, Constants.DamageType.GENERIC)

            -- Get relevant token count from slot for manaCost approximation
            local manaCost = 0
            if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
                manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
            end

            -- Determine if we should delay damage display for visual sync
            local delayDamage = false
            
            -- For projectile and meteor spells, we want to delay damage until visual completes
            if spell and (spell.attackType == "projectile" or spell.attackType == "meteor" or
                          spell.visualShape == "meteor") then
                delayDamage = true
            end
            
            -- Generate event with enriched visual metadata
            table.insert(events or {}, {
                type = "DAMAGE", 
                source = "caster", 
                target = "enemy",
                amount = calculatedDamage, 
                damageType = damageType,
                scaledDamage = (type(params.amount) == "function"), -- Keep scaledDamage flag based on original param type
                -- Add delay flag for visual synchronization
                delayDamage = delayDamage,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { DAMAGE = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil,
                -- Add debug flag to track this event's flow
                _debug_enriched = true
            })
        end

        return results
    end
}

-- burn: Applies damage over time effect
Keywords.burn = {
    -- refactor to more consistent behavior: each second, apply damage equal to Burn X and --X.
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true,
        statusType = Constants.StatusType.BURN,
        dealsDamageOverTime = true,
        targetType = Constants.TargetType.ENEMY,
        category = "DOT",
        
        -- Default parameters
        defaultDuration = 3.0,
        defaultTickDamage = 2,
        defaultTickInterval = 1.0
    },
    
    -- Implementation function - Generates APPLY_STATUS event
    execute = function(params, caster, target, results, events, spell)
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end

        if params.target == Constants.TargetType.ALL then
            table.insert(events or {}, {
                type = "APPLY_STATUS",
                source = "caster",
                target = "self",
                statusType = Constants.StatusType.BURN,
                duration = params.duration or 3.0,
                tickDamage = params.tickDamage or 2,
                tickInterval = params.tickInterval or 1.0,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { BURN = true, DOT = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil
            })
            table.insert(events or {}, {
                type = "APPLY_STATUS",
                source = "caster",
                target = "enemy",
                statusType = Constants.StatusType.BURN,
                duration = params.duration or 3.0,
                tickDamage = params.tickDamage or 2,
                tickInterval = params.tickInterval or 1.0,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { BURN = true, DOT = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil
            })
        else
            table.insert(events or {}, {
                type = "APPLY_STATUS",
                source = "caster",
                target = params.target or "enemy",
                statusType = Constants.StatusType.BURN,
                duration = params.duration or 3.0,
                tickDamage = params.tickDamage or 2,
                tickInterval = params.tickInterval or 1.0,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { BURN = true, DOT = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil
            })
        end
        return results
    end
}

-- stagger: Interrupts a spell and prevents recasting for a duration
Keywords.stagger = {
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true, -- Assuming stagger applies a stun/daze status
        statusType = Constants.StatusType.STUN,      -- Using "stun" status for simplicity
        interruptsSpell = true,    -- Stagger implies interruption
        targetType = "ENEMY",     -- Typically targets enemy
        category = "TIMING",
        
        -- Default parameters
        defaultDuration = 3.0
    },
    
    -- Implementation function - Generates APPLY_STATUS event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "APPLY_STATUS",
            source = "caster",
            target = params.target or "enemy",
            statusType = "stun", -- Using "stun" as the status effect
            duration = params.duration or 3.0
        })
        
        -- Optionally, could also add a CANCEL_SPELL event if stagger should interrupt
        -- table.insert(events or {}, { type = "CANCEL_SPELL", target = "enemy_slot", ... })
        
        return results
    end
}

-- ===== Movement & Positioning Keywords =====

-- elevate: Sets a wizard to AERIAL state
Keywords.elevate = {
    -- Behavior definition
    behavior = {
        setsElevationState = Constants.ElevationState.AERIAL,
        hasDefaultDuration = true,
        targetType = Constants.TargetType.SELF,
        category = "MOVEMENT",
        
        -- Default parameters
        defaultDuration = 5.0,
        defaultVfx = "emberlift"
    },
    
    -- Implementation function - Generates SET_ELEVATION event
    execute = function(params, caster, target, results, events, spell)
        -- Create elevation event
        local vfxValue = params.vfx or "emberlift"
        -- Check if we have a vfx parameter that's a table and should be a string
        if type(vfxValue) == "table" and vfxValue.effect then
            vfxValue = vfxValue.effect
        end
        
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end
        
        table.insert(events or {}, {
            type = "SET_ELEVATION",
            source = "caster",
            target = params.target or "self", -- Use specified target or default to self
            elevation = Constants.ElevationState.AERIAL,
            duration = params.duration or 5.0,
            vfx = vfxValue,
            
            -- Visual metadata for VisualResolver
            affinity = spell and spell.affinity or nil,
            attackType = spell and spell.attackType or nil,
            manaCost = manaCost,
            tags = { MOVEMENT = true, ELEVATE = true },
            rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
            elevation = Constants.ElevationState.AERIAL  -- The new elevation state
        })
        return results
    end
}

-- ground: Forces a wizard to GROUNDED state
Keywords.ground = {
    -- Behavior definition
    behavior = {
        setsElevationState = Constants.ElevationState.GROUNDED,
        canBeConditional = true,
        targetType = Constants.TargetType.ENEMY,
        category = "MOVEMENT",
        defaultVfx = "tidal_force_ground" -- Add default VFX for ground
    },
    
    -- Implementation function - Generates SET_ELEVATION event
    execute = function(params, caster, target, results, events, spell)
        -- Use resolver for conditional parameter
        local applyGrounding = resolve(params.conditional, caster, target, results.currentSlot, true)
        
        if applyGrounding then
            -- Resolve other parameters
            local targetEntity = resolve(params.target, caster, target, results.currentSlot, "enemy")
            local vfxEffect = resolve(params.vfx, caster, target, results.currentSlot, "tidal_force_ground")
            
            -- Handle vfx parameter conversion if needed
            local vfxString = vfxEffect
            -- If vfxEffect is a table with an effect property, extract that string
            if type(vfxEffect) == "table" and vfxEffect.effect then
                vfxString = vfxEffect.effect
            end
            
            -- Get relevant token count from slot for manaCost approximation
            local manaCost = 0
            if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
                manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
            end
            
            table.insert(events or {}, {
                type = "SET_ELEVATION",
                source = "caster",
                target = targetEntity,
                elevation = Constants.ElevationState.GROUNDED,
                vfx = vfxString,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                manaCost = manaCost,
                tags = { MOVEMENT = true, GROUND = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = Constants.ElevationState.GROUNDED  -- The new elevation state
            })
        end
        return results
    end
}

-- rangeShift: Changes the range state (NEAR/FAR)
Keywords.rangeShift = {
    -- Behavior definition
    behavior = {
        setsRangeState = true,
        targetType = Constants.TargetType.SELF,
        category = "MOVEMENT",
        
        -- Default parameters
        defaultPosition = Constants.RangeState.NEAR 
    },
    
    -- Implementation function - Generates SET_RANGE event
    execute = function(params, caster, target, results, events)
        -- Use resolver for all parameters
        local targetPosition = resolve(params.position, caster, target, results.currentSlot, Constants.RangeState.NEAR)
        local targetEntity = resolve(params.target, caster, target, results.currentSlot, "self")
        
        table.insert(events or {}, {
            type = "SET_RANGE",
            source = "caster",
            target = targetEntity, -- Usually affects both, but can be targeted
            position = targetPosition
        })
        return results
    end
}

-- forcePull: Forces opponent to move to caster's range
Keywords.forcePull = {
    -- Behavior definition
    behavior = {
        forcesOpponentPosition = true,
        targetType = Constants.TargetType.ENEMY,
        category = "MOVEMENT"
    },
    
    -- Implementation function - Generates FORCE_POSITION event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "FORCE_POSITION",
            source = "caster",
            target = "enemy" -- Force position applies to the enemy relative to caster
        })
        return results
    end
}

-- ===== Resource & Token Keywords =====

-- conjure: Creates new tokens in the shared mana pool
Keywords.conjure = {
    -- Behavior definition
    behavior = {
        addsTokensToSharedPool = true,
        targetType = "POOL_SELF", -- Indicates who gets credit for the conjuring, not a separate pool
        category = "RESOURCE",
        
        -- Default parameters
        defaultTokenType = "fire",
        defaultAmount = 1
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events, spell)
        local tokenTypeParam = params.token or Constants.TokenType.FIRE -- Default if nil
        local amount = params.amount or 1
        local targetPool = params.target or "POOL_SELF" -- Default target pool

        events = events or {} -- Ensure events table exists

        -- Set the justConjuredMana flag on the wizard
        if caster and caster.justConjuredMana ~= nil then
            caster.justConjuredMana = true
        end
        
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end

        if type(tokenTypeParam) == "table" then
            -- Handle array of token types
            for _, specificTokenType in ipairs(tokenTypeParam) do
                for i = 1, amount do -- Assuming amount applies per token type
                    table.insert(events, {
                        type = "CONJURE_TOKEN",
                        source = "caster",
                        target = targetPool,
                        tokenType = specificTokenType,
                        amount = 1, -- Conjure one of this specific type
                        
                        -- Visual metadata for VisualResolver
                        affinity = spell and spell.affinity or nil,
                        attackType = spell and spell.attackType or nil,
                        manaCost = manaCost,
                        tags = { CONJURE = true, RESOURCE = true },
                        rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                        elevation = caster and caster.elevation or nil
                    })
                end
            end
        elseif type(tokenTypeParam) == "string" then
             -- Handle single token type string (original behavior)
             for i = 1, amount do
                 table.insert(events, {
                     type = "CONJURE_TOKEN",
                     source = "caster",
                     target = targetPool,
                     tokenType = tokenTypeParam,
                     amount = 1, -- Conjure one of this specific type
                     
                     -- Visual metadata for VisualResolver
                     affinity = spell and spell.affinity or nil,
                     attackType = spell and spell.attackType or nil,
                     manaCost = manaCost,
                     tags = { CONJURE = true, RESOURCE = true },
                     rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                     elevation = caster and caster.elevation or nil
                 })
             end
        else
            print("WARN: Conjure keyword received unexpected token type: " .. type(tokenTypeParam))
        end
        
        -- Event-based system, no direct modification needed
        return results
    end
}

-- dissipate: Removes tokens from the shared mana pool
Keywords.dissipate = {
    -- Behavior definition
    behavior = {
        removesTokensFromSharedPool = true,
        targetType = "POOL_ENEMY", -- Indicates which player is causing the removal, not separate pools
        category = "RESOURCE",
        
        -- Default parameters
        defaultTokenType = "any",
        defaultAmount = 1
    },
    
    -- Implementation function - Generates DISSIPATE_TOKEN event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "DISSIPATE_TOKEN",
            source = "caster",
            target = "pool", -- Target the shared pool
            tokenType = params.token or "any",
            amount = params.amount or 1,
            dissipateTarget = params.target or "enemy" -- Specify whose tokens to target within the pool
        })
        return results
    end
}

-- tokenShift: Changes token types in the shared mana pool
Keywords.tokenShift = {
    -- Behavior definition
    behavior = {
        transformsTokensInSharedPool = true,
        targetType = "POOL_SELF", -- Indicates who initiates the transformation, not separate pools
        category = "RESOURCE",
        
        -- Default parameters
        defaultTokenType = "fire",
        defaultAmount = 1,
        supportedTypes = {"fire", "water", "salt", "sun", "moon", "star", "life", "mind", "void", "random"}
    },
    
    -- Implementation function - Generates SHIFT_TOKEN event
    execute = function(params, caster, target, results, events)
        local tokenType = resolve(params.type, caster, target, results.currentSlot, "fire")
        local amount = resolve(params.amount, caster, target, results.currentSlot, 1)
        
        table.insert(events or {}, {
            type = "SHIFT_TOKEN",
            source = "caster",
            target = "pool",
            tokenType = tokenType,
            amount = amount,
            shiftTarget = params.target or "self" -- Whose tokens to target within the pool
        })
        return results
    end
}

-- NEW KEYWORD: disruptAndShift
-- Removes a token from an opponent's channeling slot and changes its type
Keywords.disruptAndShift = {
    behavior = {
        disruptsChanneling = true,
        transformsTokens = true, -- Indicates it changes token type
        targetType = "SLOT_ENEMY", -- Targets an enemy spell slot
        category = "TOKEN",
        
        -- Default parameters
        defaultTargetType = "fire" -- Default type to shift to
    },
    
    -- Implementation function - Generates DISRUPT_AND_SHIFT event
    execute = function(params, caster, target, results, events)
        -- Determine target slot (using same logic as disjoint/cancel)
        local targetSlotIndex = 0
        if params.slot and type(params.slot) == "function" then
            targetSlotIndex = params.slot(caster, target, results.currentSlot)
        elseif params.slot then
            targetSlotIndex = params.slot
        end
        targetSlotIndex = tonumber(targetSlotIndex) or 0 -- 0 means random active

        -- Generate DISRUPT_AND_SHIFT event
        table.insert(events or {}, {
            type = "DISRUPT_AND_SHIFT",
            source = "caster",
            target = "enemy_slot", -- Target opponent's slot
            slotIndex = targetSlotIndex, -- 0 means random active slot handled by EventRunner
            newType = params.targetType or "fire" -- Type to shift the removed token to
        })
        
        return results
    end
}

-- ===== Cast Time Keywords =====

-- slow: Applies a status effect that increases the cast time of the opponent's next spell
Keywords.slow = {
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true,
        statusType = Constants.StatusType.SLOW,
        targetType = Constants.TargetType.ENEMY, -- Applies status to enemy wizard
        category = "TIMING",
        
        -- Default parameters
        defaultMagnitude = Constants.CastSpeed.ONE_TIER, -- How much to increase cast time by
        defaultDuration = 10.0, -- How long the slow effect waits for a cast
        defaultSlot = nil -- nil or 0 means next cast in any slot, 1/2/3 targets specific slot
    },
    
    -- Implementation function - Generates an APPLY_STATUS event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "APPLY_STATUS",
            source = "caster",
            target = params.target or "enemy", -- Target the enemy wizard entity
            statusType = Constants.StatusType.SLOW,
            magnitude = params.magnitude or Constants.CastSpeed.ONE_TIER, -- How much time to add
            duration = params.duration or 10.0, -- How long effect persists waiting for cast
            targetSlot = params.slot or nil -- Which slot to affect (nil for any)
        })
        return results
    end
}

-- accelerate: Reduces cast time of a spell
Keywords.accelerate = {
    -- Behavior definition
    behavior = {
        reducesSpellCastTime = true,
        targetType = "SLOT_SELF",
        category = "TIMING",
        
        -- Default parameters
        defaultAmount = 1.0
    },
    
    -- Implementation function - Generates ACCELERATE_SPELL event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "ACCELERATE_SPELL",
            source = "caster",
            target = "self_slot", -- Target own spell slot
            slotIndex = params.slot or 0, -- 0 means current/last cast slot
            amount = params.amount or 1.0
        })
        return results
    end
}

-- dispel: Cancels a spell and returns mana to the pool
Keywords.dispel = {
    -- Behavior definition
    behavior = {
        cancelsSpell = true,
        returnsManaToPool = true,
        targetType = "SLOT_ENEMY",
        category = "TIMING"
    },
    
    -- Implementation function - Generates CANCEL_SPELL event
    execute = function(params, caster, target, results, events)
        local targetSlotIndex = 0
        if params.slot and type(params.slot) == "function" then
            targetSlotIndex = params.slot(caster, target, results.currentSlot)
        elseif params.slot then
            targetSlotIndex = params.slot
        end
        targetSlotIndex = tonumber(targetSlotIndex) or 0

        table.insert(events or {}, {
            type = "CANCEL_SPELL",
            source = "caster",
            target = "enemy_slot",
            slotIndex = targetSlotIndex,
            returnMana = true -- Key difference for dispel
        })
        return results
    end
}

-- disjoint: Cancels a spell and destroys its mana
Keywords.disjoint = {
    -- Behavior definition
    behavior = {
        cancelsSpell = true,
        destroysMana = true,
        targetType = "SLOT_ENEMY",
        category = "TIMING"
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events)
        -- Use resolver to handle the slot parameter
        local targetSlotIndex = resolve(params.slot, caster, target, results.currentSlot, 0)
        targetSlotIndex = tonumber(targetSlotIndex) or 0 -- Ensure it's a number, default to 0
        
        -- Create a CANCEL_SPELL event with returnMana = false
        table.insert(events or {}, {
            type = "CANCEL_SPELL",
            source = "caster",
            target = "enemy_slot", -- Use string that EventRunner.resolveTarget understands
            slotIndex = targetSlotIndex, -- 0 means random active slot handled by EventRunner
            returnMana = false -- Key difference for disjoint
        })
        return results
    end
}

-- freeze: Pauses a spell's progress for a duration
Keywords.freeze = {
    -- Behavior definition
    behavior = {
        pausesSpellProgress = true,
        targetType = "SLOT_ENEMY", -- Can be overridden by spell
        category = "TIMING",
        
        -- Default parameters
        defaultSlot = 2,  -- Default to middle slot
        defaultDuration = 2.0
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events)
        -- Get the slot to target (default to middle slot)
        local targetSlot = params.slot or 2  
        
        -- Determine the target entity (caster or enemy)
        local targetEntity = params.target or "enemy_slot" -- Default to enemy if not specified
        
        -- Make sure we have an events table
        events = events or {}
        
        -- Create a FREEZE_SPELL event directly, using the targetEntity
        table.insert(events, {
            type = "FREEZE_SPELL",
            source = "caster",
            target = targetEntity, -- Use the resolved target (e.g., "self" or "enemy_slot")
            slotIndex = targetSlot, -- Use specified slot or default 2
            duration = params.duration or 2.0
        })
        return results
    end
}

-- ===== Defense Keywords =====

-- block: Creates a shield to block specific attack types
Keywords.block = {
    -- Behavior definition
    behavior = {
        createsShield = true,
        targetType = "SELF",
        category = "DEFENSE",
        marksSpellAsSustained = true,
        
        -- Shield properties
        shieldTypes = {"barrier", "ward"},
        attackTypes = {"projectile", "remote", "zone"}
    },
    
    -- Implementation function - Generates CREATE_SHIELD event
    execute = function(params, caster, target, results, events, spell)
        -- Mark the spell as sustained
        results.isSustained = true
        print("[DEBUG] Block keyword setting results.isSustained = true")
        
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end
        
        table.insert(events or {}, {
            type = "CREATE_SHIELD",
            source = "caster",
            target = "self_slot", -- Shields are created in the caster's slot
            slotIndex = results.currentSlot, -- Use the slot the spell was cast from
            defenseType = params.type or "barrier",
            blocksAttackTypes = params.blocks or {"projectile"},
            reflect = params.reflect or false,
            onBlock = params.onBlock, -- Add support for the onBlock callback
            
            -- Visual metadata for VisualResolver
            affinity = spell and spell.affinity or nil,
            attackType = spell and spell.attackType or nil,
            manaCost = manaCost,
            tags = { SHIELD = true, DEFENSE = true },
            rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
            elevation = caster and caster.elevation or nil
        })
        return results
    end
}

-- reflect: Reflects incoming spells
Keywords.reflect = {
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true, -- Reflect handled as a status effect
        statusType = Constants.StatusType.REFLECT,
        targetType = "SELF",
        category = "DEFENSE",
        
        -- Default parameters
        defaultDuration = 3.0
    },
    
    -- Implementation function - Generates APPLY_STATUS event
    execute = function(params, caster, target, results, events)
         table.insert(events or {}, {
            type = "APPLY_STATUS",
            source = "caster",
            target = "self",
            statusType = Constants.StatusType.REFLECT,
            duration = params.duration or 3.0
        })
        return results
    end
}

-- ===== Special Effect Keywords =====

-- echo: Recasts the spell after a delay
Keywords.echo = {
    -- Behavior definition
    behavior = {
        recastsSpell = true,
        targetType = "SLOT_SELF",
        category = "SPECIAL",
        
        -- Default parameters
        defaultDelay = 2.0
    },
    
    -- Implementation function - New event-based pattern
    execute = function(params, caster, target, results, events)
        -- Create an ECHO event directly
        table.insert(events or {}, {
            type = "ECHO",
            source = "caster",
            target = "self_slot",
            slotIndex = results.currentSlot, -- Use the current slot or specified one
            delay = params.delay or 2.0
        })
        return results
    end
}

-- ===== Zone Keywords =====

-- zoneAnchor: Locks spell to cast-time range; fails if range changes
Keywords.zoneAnchor = {
    -- Behavior definition
    behavior = {
        anchorsSpellToConditions = true,
        targetType = "SELF",
        category = "ZONE",
        
        -- Parameters
        conditionTypes = {"range", "elevation"}
    },
    
    -- Implementation function - Generates ZONE_ANCHOR event
    execute = function(params, caster, target, results, events)
        local anchorRange = "ANY"
        local anchorElevation = "ANY"
        
        if params.range then
            anchorRange = params.range
        elseif caster and caster.gameState then
            anchorRange = caster.gameState.rangeState
        end
        
        if params.elevation then
            anchorElevation = params.elevation
        elseif target then
            anchorElevation = target.elevation
        end
        
        local requireAll = params.requireAll
        if requireAll == nil then requireAll = true end
        
        table.insert(events or {}, {
            type = "ZONE_ANCHOR",
            source = "caster",
            target = "self_slot",
            slotIndex = results.currentSlot,
            anchorRange = anchorRange,
            anchorElevation = anchorElevation,
            requireAll = requireAll
        })
        return results
    end
}

-- zoneMulti: Makes zone affect both NEAR and FAR ranges
Keywords.zoneMulti = {
    -- Behavior definition
    behavior = {
        affectsBothRanges = true,
        targetType = "SELF",
        category = "ZONE"
    },
    
    -- Implementation function - Generates ZONE_MULTI event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "ZONE_MULTI",
            source = "caster",
            target = "self_slot",
            slotIndex = results.currentSlot
        })
        return results
    end
}

-- consume: Permanently removes the tokens channeled to cast this spell
Keywords.consume = {
    -- Behavior definition
    behavior = {
        destroysChanneledTokens = true,
        targetType = "SLOT_SELF",
        category = "RESOURCE",
        
        -- Default parameters
        defaultAmount = "all" -- By default, consume all channeled tokens
    },
    
    -- Implementation function - Generates CONSUME_TOKENS event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "CONSUME_TOKENS",
            source = "caster",
            target = "self_slot", -- Target own spell slot
            slotIndex = results.currentSlot, -- Use the slot the spell was cast from
            amount = params.amount or "all" -- "all" means consume all tokens used for the spell
        })
        return results
    end
}

-- vfx: Handles explicit visual effect overrides for spells
Keywords.vfx = {
    behavior = {
        overridesVisualEffect = true,
        category = "SPECIAL"
    },
    execute = function(params, caster, target, results, events, spell)
        -- Instead of creating an event, just set effectOverride in results
        if params.effect then
            -- Get the effect type, whether it's a string or constant
            local effectType
            if type(params.effect) == "string" then
                effectType = params.effect
            else
                effectType = params.effect
            end
            
            -- Store the override in the results object
            results.effectOverride = effectType
            
            -- Debug output
            print(string.format("[VFX KEYWORD] Setting effectOverride: %s for %s", 
                tostring(effectType),
                caster and caster.name or "unknown"))
        end
        
        -- Also store any other relevant parameters
        if params.duration then
            results.effectDuration = params.duration
        end
        
        if params.target then
            results.effectTarget = params.target
        end
        
        -- Store other vfx parameters that might be useful
        results.vfxParams = params
        
        return results
    end
}

return Keywords

```

## ./main.lua
```lua
-- Manastorm - Wizard Duel Game
-- Main game file

-- Load dependencies
local AssetCache = require("core.AssetCache")
local AssetPreloader = require("core.assetPreloader")
local Constants = require("core.Constants")
local Input = require("core.Input")
local Pool = require("core.Pool")
local Wizard = require("wizard")
local ManaPool = require("manapool")
local UI = require("ui")
local VFX = require("vfx")
local Keywords = require("keywords")
local SpellCompiler = require("spellCompiler")
local SpellsModule = require("spells") -- Now using the modular spells structure
local SustainedSpellManager = require("systems.SustainedSpellManager")
local Settings = require("core.Settings")
local Tips = require("core.Tips")
local OpponentAI = require("ai.OpponentAI")
local SelenePersonality = require("ai.personalities.SelenePersonality")
local AshgarPersonality = require("ai.personalities.AshgarPersonality")
local SilexPersonality = require("ai.personalities.SilexPersonality")
local BorrakPersonality = require("ai.personalities.BorrakPersonality")
local CharacterData = require("characterData")

-- Resolution settings
local baseWidth = 800    -- Base design resolution width
local baseHeight = 600   -- Base design resolution height
local scale = 1          -- Current scaling factor
local offsetX = 0        -- Horizontal offset for pillarboxing
local offsetY = 0        -- Vertical offset for letterboxing

-- Screen shake variables
local shakeTimer = 0
local shakeIntensity = 0

-- Hitstop variables
local hitstopTimer = 0

-- Game state (globally accessible)
game = {
    wizards = {},
    manaPool = nil,
    font = nil,
    characterData = CharacterData,
    rangeState = Constants.RangeState.FAR,  -- Initial range state (NEAR or FAR)
    gameOver = false,
    winner = nil,
    winScreenTimer = 0,
    winScreenDuration = 5,  -- How long to show the win screen before auto-reset
    keywords = Keywords,
    spellCompiler = SpellCompiler,
    -- State management
    currentState = "MENU", -- Start in the menu state (MENU, CHARACTER_SELECT, BATTLE, GAME_OVER, BATTLE_ATTRACT, GAME_OVER_ATTRACT, CAMPAIGN_MENU, CAMPAIGN_VICTORY, CAMPAIGN_DEFEAT)
    campaignProgress = nil, -- Holds campaign run info when active
    -- Game mode
    useAI = false,         -- Whether to use AI for the second player
    -- Gamepad identifiers (assigned when controllers connect)
    p1GamepadID = nil,
    p2GamepadID = nil,
    p2UsingGamepad = false,
    -- Attract mode properties
    attractModeActive = false,
    menuIdleTimer = 0,
    ATTRACT_MODE_DELAY = 15, -- Start attract mode after 15 seconds of inactivity
    settings = Settings,
    settingsMenu = {
        selected = 1,
        mode = nil,
        waitingForKey = nil,
        bindOrder = {
            {"p1","slot1","P1 Slot 1"},
            {"p1","slot2","P1 Slot 2"},
            {"p1","slot3","P1 Slot 3"},
            {"p1","cast","P1 Cast"},
            {"p2","slot1","P2 Slot 1"},
            {"p2","slot2","P2 Slot 2"},
            {"p2","slot3","P2 Slot 3"},
            {"p2","cast","P2 Cast"}
        },
        rebindIndex = 1,
        rebindSelection = 1,
        rebindPlayerType = nil,
        rebindActionList = nil,
        rebindOptions = nil
    },
    -- Resolution properties
    baseWidth = baseWidth,
    baseHeight = baseHeight,
    scale = scale,
    offsetX = offsetX,
    offsetY = offsetY,
    currentTip = nil
}

-- Helper function to trigger screen shake
function triggerShake(duration, intensity)
    shakeTimer = duration or 0.5
    shakeIntensity = intensity or 5
    print("Screen shake triggered: " .. duration .. "s, intensity " .. intensity)
end

-- Helper function to trigger hitstop (game pause)
function triggerHitstop(duration)
    hitstopTimer = duration or 0.1
    print("Hitstop triggered: " .. duration .. "s")
end

-- Make these functions available to other modules through the game table
game.triggerShake = triggerShake
game.triggerHitstop = triggerHitstop

-- Define token types and images (globally available for consistency)
game.tokenTypes = {
    Constants.TokenType.FIRE, 
    Constants.TokenType.WATER, 
    Constants.TokenType.SALT, 
    Constants.TokenType.SUN, 
    Constants.TokenType.MOON, 
    Constants.TokenType.STAR,
    Constants.TokenType.LIFE,
    Constants.TokenType.MIND,
    Constants.TokenType.VOID
}
game.tokenImages = {
    [Constants.TokenType.FIRE] = "assets/sprites/v2Tokens/fire-token.png",
    [Constants.TokenType.WATER] = "assets/sprites/v2Tokens/water-token.png",
    [Constants.TokenType.SALT] = "assets/sprites/v2Tokens/salt-token.png",
    [Constants.TokenType.SUN] = "assets/sprites/v2Tokens/sun-token.png",
    [Constants.TokenType.MOON] = "assets/sprites/v2Tokens/moon-token.png",
    [Constants.TokenType.STAR] = "assets/sprites/v2Tokens/star-token.png",
    [Constants.TokenType.LIFE] = "assets/sprites/v2Tokens/life-token.png",
    [Constants.TokenType.MIND] = "assets/sprites/v2Tokens/mind-token.png",
    [Constants.TokenType.VOID] = "assets/sprites/v2Tokens/void-token.png"
}

-- Character roster and unlocks
game.characterRoster = {
    "Ashgar", "Borrak", "Silex",
    "Brightwulf", "Selene", "Klaus",
    "Ohm", "Archive", "End"
}

game.unlockedCharacters = {
    Ashgar = true,
    Borrak = true,
    Silex = false,
    Selene = true,
    Brightwulf = true,
    Klaus = false,
    Ohm = false,
    Archive = false,
    End = false
}

-- Spells unlocked for customization
game.unlockedSpells = {
    conjurefire = true,
    firebolt = true,
    fireball = true,
    burnToAsh = true,
    blastwave = true,
    saltcircle = true,
    eruption = true,

    conjuremoonlight = true,
    wrapinmoonlight = true,
    moondance = true,
    infiniteprocession = true,
    eclipse = true,
    gravityTrap = true,
    fullmoonbeam = true,

    conjuresalt = true,
    glitterfang = true,
    imprison = true,
    stoneshield = true,
    shieldbreaker = true,
    saltstorm = true,

    conjurewater = true,
    watergun = true,
    riptideguard = true,
    tidalforce = true,
    brinechain = true,
    maelstrom = true,
    wavecrash = true,
    desperationfire = true,
    moondrain = true,
}

-- Custom spellbooks configured by the player
game.customSpellbooks = {}

game.compendium = {
    page = 1,
    cursor = 1,
    scrollOffset = 0,
    assignFeedback = {
        active = false,
        slot = 0,
        timer = 0
    }
}

-- Temporary state for the campaign character selection menu
game.campaignMenu = {
    selectedCharacterIndex = 1
}

-- Get a list of all unlocked characters in the roster
local function getUnlockedCharacterList()
    local list = {}
    for _, name in ipairs(game.characterRoster) do
        if game.unlockedCharacters[name] then
            table.insert(list, name)
        end
    end
    return list
end

-- Helper to grab an AI personality for a given character name
local function getPersonalityFor(name)
    if name == "Selene" then
        return SelenePersonality
    elseif name == "Ashgar" then
        return AshgarPersonality
    elseif name == "Borrak" then
        return BorrakPersonality
    elseif name == "Silex" then
        return SilexPersonality
    else
        return nil
    end
end

game.characterSelect = {
    stage = 1, -- 1: choose player, 2: choose opponent, 3: confirm
    cursor = 1,
    selected = {nil, nil}
}

-- Helper function to add a random token to the mana pool
function game.addRandomToken()
    local randomType = game.tokenTypes[math.random(#game.tokenTypes)]
    game.manaPool:addToken(randomType, game.tokenImages[randomType])
    return randomType
end

-- Calculate the appropriate scaling for the current window size
function calculateScaling()
    local windowWidth, windowHeight = love.graphics.getDimensions()
    
    -- Calculate potential scales based on window dimensions
    local scaleX = windowWidth / baseWidth
    local scaleY = windowHeight / baseHeight
    
    -- Use the smaller scale factor to maintain aspect ratio and fit within the window
    scale = math.min(scaleX, scaleY)
    
    -- Calculate offsets needed to center the scaled content
    offsetX = (windowWidth - baseWidth * scale) / 2
    offsetY = (windowHeight - baseHeight * scale) / 2
    
    -- Update global references
    game.scale = scale
    game.offsetX = offsetX
    game.offsetY = offsetY
    
    print("Window resized: " .. windowWidth .. "x" .. windowHeight .. " -> Simple scale: " .. scale .. ", Offset: (" .. offsetX .. ", " .. offsetY .. ")")
end

-- Set a scissor rectangle taking current scale and offsets into account
local function setScaledScissor(x, y, w, h)
    love.graphics.setScissor(
        offsetX + x * scale,
        offsetY + y * scale,
        w * scale,
        h * scale
    )
end

-- Handle window resize events
function love.resize(width, height)
    calculateScaling()
end

-- Set up pixel art-friendly scaling
-- function configurePixelArtRendering()
--     -- Disable texture filtering for crisp pixel art
--     love.graphics.setDefaultFilter("nearest", "nearest", 1)
--     
--     -- Use integer scaling when possible
--     love.graphics.setLineStyle("rough")
-- end

function love.load()
    -- Set up window
    love.window.setTitle("Manastorm - Realtime Strategic Wizard Duels")
    
    -- Configure pixel art rendering -- REMOVE THIS CALL
    -- configurePixelArtRendering()

    -- Set default texture filtering for sharper (potentially pixelated) look
    love.graphics.setDefaultFilter("nearest", "nearest")
    
    -- Calculate initial scaling
    calculateScaling()
    
    -- Load background image
    game.backgroundImage = AssetCache.getImage("assets/sprites/background.png")
    
    -- Preload all assets to prevent in-game loading hitches
    print("Preloading game assets...")
    local preloadStats = AssetPreloader.preloadAllAssets()
    print(string.format("Asset preloading complete: %d images, %d sounds in %.2f seconds",
                        preloadStats.imageCount,
                        preloadStats.soundCount,
                        preloadStats.loadTime))

    -- Load persisted settings
    Settings.load()
    Constants.setCastSpeedSet(Settings.get("gameSpeed") or "FAST")
    
    -- Set up game object to have calculateScaling function that can be called by Input
    game.calculateScaling = calculateScaling
    
    -- Load game font
    -- For now, fall back to system font if custom font isn't available
    local fontPath = "assets/fonts/LionscriptNew-Regular.ttf"
    local fontExists = love.filesystem.getInfo(fontPath)
    
    if fontExists then
        game.font = love.graphics.newFont(fontPath, 16)
        print("Using custom game font: " .. fontPath)
    else
        game.font = love.graphics.newFont(16)  -- Default system font
        print("Custom font not found, using system font")
    end
    
    -- Set default font for normal rendering
    love.graphics.setFont(game.font)

    -- Load gameplay tips
    Tips.load("assets/text/tips.json")
    
    -- Create mana pool positioned above the battlefield, but below health bars
    game.manaPool = ManaPool.new(baseWidth/2, 120)  -- Positioned between health bars and wizards
    
    -- Create wizards - moved lower on screen to allow more room for aerial movement
    local d1 = CharacterData.Ashgar
    local d2 = CharacterData.Selene
    game.wizards[1] = Wizard.new("Ashgar", 200, 370, d1.color, d1.spellbook)
    game.wizards[2] = Wizard.new("Selene", 600, 370, d2.color, d2.spellbook)
    
    -- Set up references
    for _, wizard in ipairs(game.wizards) do
        wizard.manaPool = game.manaPool
        wizard.gameState = game
    end
    
    -- Initialize VFX system
    game.vfx = VFX.init()
    
    -- Make screen shake and hitstop functions directly available to VFX module
    VFX.triggerShake = triggerShake
    VFX.triggerHitstop = triggerHitstop
    
    -- Precompile all spells for better performance
    print("Precompiling all spells...")
    
    -- Create a compiledSpells table and do the compilation ourselves
    game.compiledSpells = {}
    
    -- Get all spells from the SpellsModule
    local allSpells = SpellsModule.spells
    
    -- Compile each spell
    for id, spell in pairs(allSpells) do
        game.compiledSpells[id] = game.spellCompiler.compileSpell(spell, game.keywords)
        print("Compiled spell: " .. spell.name)
    end
    
    -- Count compiled spells
    local count = 0
    for _ in pairs(game.compiledSpells) do
        count = count + 1
    end
    
    print("Precompiled " .. count .. " spells")
    
    -- Create custom shield spells just for hotkeys
    -- These are complete, independent spell definitions
    game.customSpells = {}
    
    -- Define Moon Ward with minimal dependencies
    game.customSpells.moonWard = {
        id = "customMoonWard",
        name = "Moon Ward",
        description = "A mystical ward that blocks projectiles and remotes",
        attackType = Constants.AttackType.UTILITY,
        castTime = 4.5,
        cost = {Constants.TokenType.MOON, Constants.TokenType.MOON},
        keywords = {
            block = {
                type = Constants.ShieldType.WARD,
                blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.REMOTE},
                manaLinked = true
            }
        },
        vfx = "moon_ward",
        sfx = "shield_up",
    }
    
    -- Define Mirror Shield with minimal dependencies
    game.customSpells.mirrorShield = {
        id = "customMirrorShield",
        name = "Mirror Shield",
        description = "A reflective barrier that returns damage to attackers",
        attackType = Constants.AttackType.UTILITY,
        castTime = 5.0,
        cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.STAR},
        keywords = {
            block = {
                type = Constants.ShieldType.BARRIER,
                blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
                manaLinked = false,
                reflect = true,
                hitPoints = 3
            }
        },
        vfx = "mirror_shield",
        sfx = "crystal_ring",
    }
    
    -- Compile custom spells too
    for id, spell in pairs(game.customSpells) do
        game.compiledSpells[id] = game.spellCompiler.compileSpell(spell, game.keywords)
        print("Compiled custom spell: " .. spell.name)
    end
    
    -- Initialize mana pool with a single random token to start
    local tokenType = game.addRandomToken()
    
    -- Log which token was added
    print("Starting the game with a single " .. tokenType .. " token")
    
    -- Initialize input system with game state reference
    Input.init(game)
    print("Input system initialized")
    
    -- Initialize SustainedSpellManager
    game.sustainedSpellManager = SustainedSpellManager
    print("SustainedSpellManager initialized")
    
    -- We'll initialize the AI opponent when starting a game with AI
    -- instead of here, so it's not always active
end

-- Display hotkey help overlay
function drawHotkeyHelp()
    local x = baseWidth - 300
    local y = 50
    local lineHeight = 20
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", x - 10, y - 10, 290, 500)
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print("HOTKEY REFERENCE", x, y)
    y = y + lineHeight * 2
    
    -- System keys
    love.graphics.setColor(0.8, 0.8, 1, 1)
    love.graphics.print("SYSTEM:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.system) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    y = y + lineHeight/2
    
    -- Player 1 keys
    love.graphics.setColor(1, 0.5, 0.5, 1)
    love.graphics.print("PLAYER 1:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.player1) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    y = y + lineHeight/2
    
    -- Player 2 keys
    love.graphics.setColor(0.5, 0.5, 1, 1)
    love.graphics.print("PLAYER 2:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.player2) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    y = y + lineHeight/2
    
    -- Debug keys
    love.graphics.setColor(0.8, 1, 0.8, 1)
    love.graphics.print("DEBUG:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.debug) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    
    -- Testing keys
    y = y + lineHeight/2
    love.graphics.setColor(1, 0.8, 0.5, 1)
    love.graphics.print("TESTING:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.testing) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
end

-- Reset the game
function resetGame()
    -- Reset game state
    game.gameOver = false
    game.winner = nil
    game.winScreenTimer = 0
    game.currentTip = nil
    
    -- Reset wizards
    for _, wizard in ipairs(game.wizards) do
        wizard.health = 100
        wizard.elevation = Constants.ElevationState.GROUNDED
        wizard.elevationTimer = 0
        if wizard.statusEffects and wizard.statusEffects[Constants.StatusType.STUN] then
            wizard.statusEffects[Constants.StatusType.STUN].active = false
            wizard.statusEffects[Constants.StatusType.STUN].duration = 0
            wizard.statusEffects[Constants.StatusType.STUN].elapsed = 0
            wizard.statusEffects[Constants.StatusType.STUN].totalTime = 0
        end
        
        -- Reset spell slots
        for i = 1, 3 do
            wizard.spellSlots[i] = {
                active = false,
                progress = 0,
                spellType = nil,
                castTime = 0,
                tokens = {},
                isShield = false,
                defenseType = nil,
                shieldStrength = 0,
                blocksAttackTypes = nil,
                wasAlreadyCast = false -- Add this flag to prevent repeated spell casts
            }
        end
        
        -- Reset status effects
        wizard.statusEffects[Constants.StatusType.BURN].active = false
        wizard.statusEffects[Constants.StatusType.BURN].duration = 0
        wizard.statusEffects[Constants.StatusType.BURN].tickDamage = 0
        wizard.statusEffects[Constants.StatusType.BURN].tickInterval = 1.0
        wizard.statusEffects[Constants.StatusType.BURN].elapsed = 0
        wizard.statusEffects[Constants.StatusType.BURN].totalTime = 0
        
        -- Reset blockers
        if wizard.blockers then
            for blockType in pairs(wizard.blockers) do
                wizard.blockers[blockType] = 0
            end
        end
        
        -- Reset spell keying
        wizard.activeKeys = {[1] = false, [2] = false, [3] = false}
        wizard.currentKeyedSpell = nil
    end
    
    -- Reset range state
    game.rangeState = Constants.RangeState.FAR
    
    -- Clear sustained spells
    if game.sustainedSpellManager then
        game.sustainedSpellManager.activeSpells = {}
    end
    
    -- Clear mana pool and add a single token to start
    if game.manaPool then
        game.manaPool:clear()
        local tokenType = game.addRandomToken()
        print("Game reset! Starting with a single " .. tokenType .. " token")
    end
    
    -- Reinitialize AI opponent if AI mode is enabled and not being set up by campaign
    if game.useAI then
        if not game.isSettingUpCampaignBattle then
            local aiWizard = game.wizards[2]
            local personality = getPersonalityFor(aiWizard.name)
            if personality then
                print("Initializing " .. aiWizard.name .. " AI personality")
            else
                print("Unknown wizard type: " .. aiWizard.name .. ". Using default personality.")
            end
            game.opponentAI = OpponentAI.new(aiWizard, game, personality)
            print("AI opponent reinitialized with personality: " .. (personality and personality.name or "Default"))
        end
    else
        -- Disable AI if we're switching to PvP mode
        game.opponentAI = nil
    end
    
    -- Reset health display animation state
    if UI and UI.healthDisplay then
        for i = 1, 2 do
            local display = UI.healthDisplay["player" .. i]
            if display then
                display.currentHealth = 100
                display.targetHealth = 100
                display.pendingDamage = 0
                display.lastDamageTime = 0
            end
        end
    end
    
    -- The current state is handled by the caller
    print("Game reset complete")
end

-- Add resetGame function to game state so Input system can call it
function game.resetGame()
    resetGame()
end

-- Function to start an AI vs AI attract mode game
function startGameAttractMode()
    print("Starting attract mode...")

    -- Mark attract mode as active
    game.attractModeActive = true

    -- Reset the game to clear any existing state
    resetGame()

    -- Choose two random unlocked characters
    local unlocked = getUnlockedCharacterList()
    if #unlocked < 2 then
        print("Not enough unlocked characters for attract mode")
        return
    end

    local name1 = unlocked[math.random(#unlocked)]
    local name2 = unlocked[math.random(#unlocked)]
    while name2 == name1 do
        name2 = unlocked[math.random(#unlocked)]
    end

    setupWizards(name1, name2)

    -- Temporarily store input routes so we can restore them later
    game.savedInputRoutes = {
        p1 = Input.Routes.p1,
        p2 = Input.Routes.p2
    }

    -- Disable player input during attract mode
    Input.Routes.p1 = {}
    Input.Routes.p2 = {}

    -- Make sure AI mode is enabled but not tracked by the normal flag
    -- This way we can have two AI players without affecting the normal mode
    game.useAI = false

    -- Create AIs for both players
    game.player1AI = OpponentAI.new(game.wizards[1], game, getPersonalityFor(name1))
    game.player2AI = OpponentAI.new(game.wizards[2], game, getPersonalityFor(name2))

    -- Reset idle timer
    game.menuIdleTimer = 0

    -- Transition to the attract mode battle state
    game.currentState = "BATTLE_ATTRACT"

    print("Attract mode started: " .. game.wizards[1].name .. " vs " .. game.wizards[2].name)
end

-- Function to exit attract mode and return to the menu
function exitAttractMode()
    print("Exiting attract mode...")

    -- Disable attract mode
    game.attractModeActive = false

    -- Clean up AI instances
    game.player1AI = nil
    game.player2AI = nil

    -- Reset the game
    resetGame()

    -- Restore input routes if we saved them
    if game.savedInputRoutes then
        Input.Routes.p1 = game.savedInputRoutes.p1
        Input.Routes.p2 = game.savedInputRoutes.p2
        game.savedInputRoutes = nil
    end

    -- Reset idle timer
    game.menuIdleTimer = 0

    -- Return to menu
    game.currentState = "MENU"

    print("Attract mode ended, returned to menu")
end

-- Handle successful completion of a campaign
function handleCampaignVictory()
    if not game.campaignProgress then return end
    print(game.campaignProgress.characterName .. " campaign complete! Wins: " .. game.campaignProgress.wins)
    game.currentState = "CAMPAIGN_VICTORY"
end

-- Handle failure of a campaign run
function handleCampaignDefeat()
    if not game.campaignProgress then return end
    print(game.campaignProgress.characterName .. " campaign failed at opponent " .. game.campaignProgress.currentOpponentIndex)
    resetGame()
    game.currentState = "CAMPAIGN_DEFEAT"
end

-- Restart the entire campaign from the first opponent
function restartCampaign()
    if not game.campaignProgress then return end
    game.campaignProgress.currentOpponentIndex = 1
    game.campaignProgress.wins = 0
    startCampaignBattle()
end

-- Retry the current campaign battle
function retryCampaignBattle()
    if not game.campaignProgress then return end
    startCampaignBattle()
end

-- Expose campaign helpers
game.restartCampaign = restartCampaign
game.retryCampaignBattle = retryCampaignBattle

-- Placeholder implementation for starting a campaign battle
function startCampaignBattle()
    if not game.campaignProgress then
        print("ERROR: startCampaignBattle called without campaignProgress")
        return
    end

    local playerCharacterName = game.campaignProgress.characterName
    local opponentIndex = game.campaignProgress.currentOpponentIndex or 1
    local playerData = game.characterData[playerCharacterName] or {}
    local opponentName
    if playerData.campaignOpponents then
        opponentName = playerData.campaignOpponents[opponentIndex]
    end

    if not opponentName then
        if handleCampaignVictory then
            handleCampaignVictory()
        else
            print("Campaign complete for " .. tostring(playerCharacterName))
        end
        return
    end

    setupWizards(playerCharacterName, opponentName)

    game.useAI = true

    local personality = getPersonalityFor(opponentName)
    game.opponentAI = OpponentAI.new(game.wizards[2], game, personality)

    game.isSettingUpCampaignBattle = true
    resetGame()
    game.isSettingUpCampaignBattle = nil

    game.currentState = "BATTLE"
end

-- Initialize wizards for battle based on selected names
function setupWizards(name1, name2)
    local data1 = game.characterData[name1] or {}
    local data2 = game.characterData[name2] or {}
    local book1 = game.customSpellbooks[name1] or data1.spellbook
    local book2 = game.customSpellbooks[name2] or data2.spellbook
    game.wizards[1] = Wizard.new(name1, 200, 370, data1.color or {255,255,255}, book1)
    game.wizards[2] = Wizard.new(name2, 600, 370, data2.color or {255,255,255}, book2)
    for _, wizard in ipairs(game.wizards) do
        wizard.manaPool = game.manaPool
        wizard.gameState = game
    end
end

-- Start character selection
function game.startCharacterSelect()
    game.characterSelect.stage = 1
    game.characterSelect.cursor = 1
    game.characterSelect.selected = {nil,nil}
    game.useAI = true -- default to AI opponent
    game.p2UsingGamepad = false
    game.currentState = "CHARACTER_SELECT"
end

-- Move selection cursor
function game.characterSelectMove(dir)
    local count = #game.characterRoster
    local idx = game.characterSelect.cursor
    repeat
        idx = ((idx -1 + dir -1) % count) + 1
    until game.unlockedCharacters[game.characterRoster[idx]]
    game.characterSelect.cursor = idx
end

-- Confirm selection or start fight
function game.characterSelectConfirm()
    local idx = game.characterSelect.cursor
    local name = game.characterRoster[idx]
    if not game.unlockedCharacters[name] then return end

    if game.characterSelect.stage == 1 then
        game.characterSelect.selected[1] = name
        game.characterSelect.stage = 2
    elseif game.characterSelect.stage == 2 then
        game.characterSelect.selected[2] = name
        game.characterSelect.stage = 3
    else
        setupWizards(game.characterSelect.selected[1], game.characterSelect.selected[2])
        resetGame()
        game.currentState = "BATTLE"
    end
end

-- Back out of selection
function game.characterSelectBack(toMenu)
    if toMenu then
        game.currentState = "MENU"
        return
    end
    if game.characterSelect.stage == 2 then
        game.characterSelect.stage = 1
        game.characterSelect.selected[1] = nil
    elseif game.characterSelect.stage == 3 then
        game.characterSelect.stage = 2
        game.characterSelect.selected[2] = nil
    else
        game.currentState = "MENU"
    end
end

-- Start settings menu
function game.startSettings()
    game.settingsMenu.selected = 1
    game.settingsMenu.mode = nil
    game.settingsMenu.waitingForKey = nil
    game.settingsMenu.rebindIndex = 1
    game.settingsMenu.rebindSelection = 1
    game.settingsMenu.rebindPlayerType = nil
    game.settingsMenu.rebindActionList = nil
    game.settingsMenu.rebindOptions = {
        {playerType = "keyboardP1", label = "Player 1 Keyboard"},
        {playerType = "keyboardP2", label = "Player 2 Keyboard"},
        {playerType = "gamepadP1",  label = "Player 1 Gamepad"}
    }
    game.currentState = "SETTINGS"
end

function game.settingsMove(dir)
    if game.settingsMenu.mode == "rebind_select_player" or game.settingsMenu.mode == "rebind_action_list" then
        local list = (game.settingsMenu.mode == "rebind_select_player") and game.settingsMenu.rebindOptions or game.settingsMenu.rebindActionList
        if not list then return end
        local count = #list
        local idx = game.settingsMenu.rebindSelection + dir
        if idx < 1 then idx = count end
        if idx > count then idx = 1 end
        game.settingsMenu.rebindSelection = idx
        return
    elseif game.settingsMenu.mode then
        return
    end
    local count = 4
    local idx = game.settingsMenu.selected + dir
    if idx < 1 then idx = count end
    if idx > count then idx = 1 end
    game.settingsMenu.selected = idx
end

function game.settingsAdjust(dir)
    if game.settingsMenu.mode then return end
    if game.settingsMenu.selected == 1 then
        if dir ~= 0 then
            local val = Settings.get("dummyFlag")
            Settings.set("dummyFlag", not val)
        end
    elseif game.settingsMenu.selected == 2 then
        if dir ~= 0 then
            local current = Settings.get("gameSpeed") or "FAST"
            if current == "FAST" then
                current = "SLOW"
            else
                current = "FAST"
            end
            Settings.set("gameSpeed", current)
            Constants.setCastSpeedSet(current)
        end
    end
end

function game.unlockAll()
    -- Unlock all characters
    for _, characterName in ipairs(game.characterRoster) do
        game.unlockedCharacters[characterName] = true
    end
    
    -- Unlock all spells
    local allSpellIds = {
        -- Fire
        "conjurefire", "firebolt", "fireball", "blastwave", "combustMana", 
        "blazingascent", "eruption", "battleshield",
        -- Mind
        "thoughtscalp",
        -- Moon
        "conjuremoonlight", "tidalforce", "lunardisjunction", "moondance", 
        "gravity", "eclipse", "fullmoonbeam", "lunartides", "wrapinmoonlight", 
        "gravityTrap", "infiniteprocession", "enhancedmirrorshield",
        -- Salt
        "conjuresalt", "glitterfang", "burnToAsh", "saltstorm", "imprison", 
        "jaggedearth", "saltcircle", "stoneshield", "shieldbreaker",
        -- Star
        "conjurestars", "adaptivesurge", "cosmicrift",
        -- Sun
        "radiantbolt", "fusionRay", "meteor", "emberlift", "novaconjuring", 
        "burnTheSoul", "SpaceRipper", "StingingEyes", "CoreBolt", "NuclearFurnace", 
        "forcebarrier", "radiantfield",
        -- Void
        "conjurenothing", "riteofemptiness", "quenchPower", "heartripper",
        -- Water
        "watergun", "forceblast", "conjurewater", "maelstrom", "riptideguard", 
        "brinechain", "wavecrash",
        -- Generic
        "none"
    }
    
    for _, spellId in ipairs(allSpellIds) do
        game.unlockedSpells[spellId] = true
    end
    
    print("[DEV] All characters and spells unlocked!")
end

function game.settingsSelect()
    if game.settingsMenu.mode == "rebind_select_player" then
        local option = game.settingsMenu.rebindOptions[game.settingsMenu.rebindSelection]
        if option then
            game.settingsMenu.rebindPlayerType = option.playerType
            local controls = Settings.get("controls")[option.playerType] or {}
            game.settingsMenu.rebindActionList = {}
            for action, binding in pairs(controls) do
                table.insert(game.settingsMenu.rebindActionList, {action = action, binding = binding})
            end
            table.sort(game.settingsMenu.rebindActionList, function(a,b) return a.action < b.action end)
            game.settingsMenu.rebindSelection = 1
            game.settingsMenu.mode = "rebind_action_list"
        end
    elseif game.settingsMenu.mode == "rebind_action_list" then
        local entry = game.settingsMenu.rebindActionList[game.settingsMenu.rebindSelection]
        if entry then
            game.settingsMenu.waitingForKey = {playerType = game.settingsMenu.rebindPlayerType, action = entry.action, label = entry.action}
        end
    else
        if game.settingsMenu.selected == 3 then
            game.unlockAll()
        elseif game.settingsMenu.selected == 4 then
            game.settingsMenu.mode = "rebind_select_player"
            game.settingsMenu.rebindSelection = 1
        else
            game.settingsAdjust(1)
        end
    end
end

function game.settingsBack()
    if game.settingsMenu.waitingForKey then
        game.settingsMenu.waitingForKey = nil
        return
    end
    if game.settingsMenu.mode == "rebind_action_list" then
        game.settingsMenu.mode = "rebind_select_player"
        game.settingsMenu.rebindSelection = 1
        return
    elseif game.settingsMenu.mode == "rebind_select_player" then
        game.settingsMenu.mode = nil
        game.settingsMenu.rebindPlayerType = nil
        game.settingsMenu.rebindActionList = nil
        game.settingsMenu.rebindSelection = 1
        return
    end
    game.currentState = "MENU"
end

function game.startCompendium()
    game.compendium.page = 1
    game.compendium.cursor = 1
    game.compendium.scrollOffset = 0
    game.compendium.assignFeedback = {
        active = false,
        slot = 0,
        timer = 0
    }
    game.assignmentError = nil
    game.currentState = "COMPENDIUM"
end

function game.compendiumMove(dir)
    local name = game.characterRoster[game.compendium.page]
    local spells = game.characterData[name].spells or {}
    local count = #spells
    if count == 0 then return end
    
    -- Simple approach: add dir (+1 for down, -1 for up) and handle wrapping
    local newIdx = game.compendium.cursor + dir
    
    -- Handle wrapping around the list
    if newIdx < 1 then 
        newIdx = count
    elseif newIdx > count then
        newIdx = 1
    end
    
    game.compendium.cursor = newIdx
    
    -- Scrolling logic: Calculate visible items based on pane height
    if game.compendiumPanes then
        local pane = game.compendiumPanes.bottomLeft
        local spellLineHeight = 20 -- Height of each spell entry in the list
        local maxVisibleSpells = math.floor((pane.h - 50) / spellLineHeight) -- 50px for padding/header
        
        -- Adjust scroll offset if cursor moves outside visible range
        if game.compendium.cursor <= game.compendium.scrollOffset then
            -- Cursor moved above visible top
            game.compendium.scrollOffset = math.max(0, game.compendium.cursor - 1)
        elseif game.compendium.cursor > game.compendium.scrollOffset + maxVisibleSpells then
            -- Cursor moved below visible bottom
            game.compendium.scrollOffset = game.compendium.cursor - maxVisibleSpells
        end
    end
end

function game.compendiumChangePage(dir)
    local count = #game.characterRoster
    
    -- Use same approach as compendiumMove for consistency
    local newPage = game.compendium.page + dir
    
    -- Handle wrapping
    if newPage < 1 then
        newPage = count
    elseif newPage > count then
        newPage = 1
    end
    
    game.compendium.page = newPage
    game.compendium.cursor = 1 -- Reset cursor when changing pages
    game.compendium.scrollOffset = 0 -- Reset scroll offset when changing pages
    
    -- Reset feedback states
    game.compendium.assignFeedback = {
        active = false,
        slot = 0,
        timer = 0
    }
    game.assignmentError = nil
end

local slotKeys = {"1","2","3","12","13","23","123"}
function game.compendiumAssign(slot)
    local name = game.characterRoster[game.compendium.page]
    local spells = game.characterData[name].spells or {}
    local spell = spells[game.compendium.cursor]
    
    -- Check if spell is valid and unlocked
    if not spell then
        -- No spell selected
        return
    end
    
    if not game.unlockedSpells[spell.id] then
        -- Spell is locked, provide feedback
        game.assignmentError = {
            message = "Spell is locked and cannot be assigned",
            timer = 2.0 -- Show message for 2 seconds
        }
        return
    end
    
    -- Create custom spellbook if it doesn't exist yet
    if not game.customSpellbooks[name] then
        -- Copy default spellbook
        local copy = {}
        for k,v in pairs(game.characterData[name].spellbook) do copy[k]=v end
        game.customSpellbooks[name] = copy
    end
    
    -- Assign the spell to the selected slot
    game.customSpellbooks[name][slotKeys[slot]] = spell
    
    -- Trigger visual feedback
    game.compendium.assignFeedback = {
        active = true,
        slot = slot,
        timer = 0.5 -- Show highlight for 0.5 seconds
    }
    
    -- Play a sound effect for feedback (if available)
    if love.audio and game.sounds and game.sounds.click then
        game.sounds.click:stop()
        game.sounds.click:play()
    end
end

-- Initialize the campaign character selection menu
function game.startCampaignMenu()
    game.campaignMenu = { selectedCharacterIndex = 1 }
    game.currentState = "CAMPAIGN_MENU"
end

-- Move selection cursor in the campaign menu
function game.campaignMenuMove(dir)
    local unlocked = getUnlockedCharacterList()
    local count = #unlocked
    if count == 0 then return end

    local idx = game.campaignMenu.selectedCharacterIndex + dir
    if idx < 1 then idx = count end
    if idx > count then idx = 1 end
    game.campaignMenu.selectedCharacterIndex = idx
end

-- Confirm character choice and start the campaign
function game.campaignMenuConfirm()
    local unlocked = getUnlockedCharacterList()
    local name = unlocked[game.campaignMenu.selectedCharacterIndex]
    if not name then return end

    game.campaignProgress = {
        characterName = name,
        currentOpponentIndex = 1,
        wins = 0
    }

    if startCampaignBattle then
        startCampaignBattle()
    end
end
function love.update(dt)
    -- Update shake timer
    if shakeTimer > 0 then
        shakeTimer = shakeTimer - dt
        if shakeTimer < 0 then
            shakeTimer = 0
            shakeIntensity = 0
        end
    end

    -- Update input repeat timers
    Input.update(dt)
    
    -- Update Compendium assignment feedback timers
    if game.currentState == "COMPENDIUM" then
        if game.compendium.assignFeedback.active then
            game.compendium.assignFeedback.timer = game.compendium.assignFeedback.timer - dt
            if game.compendium.assignFeedback.timer <= 0 then
                game.compendium.assignFeedback.active = false
            end
        end
        
        -- Update assignment error message timer
        if game.assignmentError and game.assignmentError.timer > 0 then
            game.assignmentError.timer = game.assignmentError.timer - dt
        end
    end
    
    -- Check for hitstop - if active, decrement timer and skip all other updates
    if hitstopTimer > 0 then
        hitstopTimer = hitstopTimer - dt
        if hitstopTimer < 0 then
            hitstopTimer = 0
        end
        return -- Skip the rest of the update
    end
    
    -- Only update the game when not in hitstop
    -- Different update logic based on current game state
    if game.currentState == "MENU" then
        -- Menu state updates (minimal, just for animations)
        -- VFX system is still updated for menu animations
        if game.vfx then
            game.vfx.update(dt)
        end

        -- Update attract mode timer when in menu
        if not game.attractModeActive then
            game.menuIdleTimer = game.menuIdleTimer + dt

            -- Start attract mode if idle timer exceeds threshold
            if game.menuIdleTimer > game.ATTRACT_MODE_DELAY then
                startGameAttractMode()
            end
        end

        -- No other updates needed in menu state
        return
    elseif game.currentState == "SETTINGS" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "COMPENDIUM" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CAMPAIGN_MENU" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CAMPAIGN_VICTORY" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CAMPAIGN_DEFEAT" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CHARACTER_SELECT" then
        -- Simple animations for character select
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "BATTLE" then
        -- Check for win condition before updates
        if game.gameOver then
            -- Transition to game over state
            game.currentState = "GAME_OVER"
            game.winScreenTimer = 0
            game.currentTip = Tips.getRandomTip()
            return
        end
        
        -- Check if any wizard's health has reached zero
        for i, wizard in ipairs(game.wizards) do
            if wizard.health <= 0 then
                game.gameOver = true
                game.winner = 3 - i  -- Winner is the other wizard (3-1=2, 3-2=1)
                game.winScreenTimer = 0
                
                -- Create victory VFX around the winner
                local winner = game.wizards[game.winner]
                for j = 1, 15 do
                    local angle = math.random() * math.pi * 2
                    local distance = math.random(40, 100)
                    local x = winner.x + math.cos(angle) * distance
                    local y = winner.y + math.sin(angle) * distance
                    
                    -- Determine winner's color for effects
                    local color
                    if game.winner == 1 then -- Ashgar
                        color = {1.0, 0.5, 0.2, 0.9} -- Fire-like
                    else -- Selene
                        color = {0.3, 0.3, 1.0, 0.9} -- Moon-like
                    end
                    
                    -- Create sparkle effect with delay
                    game.vfx.createEffect("impact", x, y, nil, nil, {
                        duration = 0.8 + math.random() * 0.5,
                        color = color,
                        particleCount = 5,
                        radius = 15,
                        delay = j * 0.1
                    })
                end
                
                print(winner.name .. " wins!")

                -- Transition to game over state
                game.currentState = "GAME_OVER"
                game.currentTip = Tips.getRandomTip()
                return
            end
        end
        
        -- Update wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:update(dt)
        end
        
        -- Update mana pool
        game.manaPool:update(dt)
        
        -- Update VFX system
        game.vfx.update(dt)
        
        -- Update SustainedSpellManager for trap and shield management
        game.sustainedSpellManager.update(dt)
        
        -- Update animated health displays
        UI.updateHealthDisplays(dt, game.wizards)
        
        -- Update AI opponent if it exists and AI mode is enabled
        if game.useAI and game.opponentAI then
            game.opponentAI:update(dt)
        end

        -- Update both AI players in attract mode
        if game.attractModeActive then
            if game.player1AI then
                game.player1AI:update(dt)
            end
            if game.player2AI then
                game.player2AI:update(dt)
            end
        end
    elseif game.currentState == "GAME_OVER" then
        -- Update win screen timer
        game.winScreenTimer = game.winScreenTimer + dt

        -- When timer expires, handle post-battle flow
        if game.winScreenTimer >= game.winScreenDuration then
            if game.campaignProgress then
                if game.winner == 1 then
                    game.campaignProgress.wins = game.campaignProgress.wins + 1
                    game.campaignProgress.currentOpponentIndex = game.campaignProgress.currentOpponentIndex + 1
                    startCampaignBattle()
                else
                    handleCampaignDefeat()
                end
            else
                resetGame()
                game.currentState = "MENU"
            end
        end

        -- Still update VFX system for visual effects
        game.vfx.update(dt)
    elseif game.currentState == "BATTLE_ATTRACT" then
        -- Check for win condition before updates
        if game.gameOver then
            -- Transition to attract mode game over state
            game.currentState = "GAME_OVER_ATTRACT"
            game.winScreenTimer = 0
            game.currentTip = Tips.getRandomTip()
            return
        end

        -- Check if any wizard's health has reached zero
        for i, wizard in ipairs(game.wizards) do
            if wizard.health <= 0 then
                game.gameOver = true
                game.winner = 3 - i  -- Winner is the other wizard (3-1=2, 3-2=1)
                game.winScreenTimer = 0

                -- Create victory VFX around the winner
                local winner = game.wizards[game.winner]
                for j = 1, 15 do
                    local angle = math.random() * math.pi * 2
                    local distance = math.random(40, 100)
                    local x = winner.x + math.cos(angle) * distance
                    local y = winner.y + math.sin(angle) * distance

                    -- Determine winner's color for effects
                    local color
                    if game.winner == 1 then -- Ashgar
                        color = {1.0, 0.5, 0.2, 0.9} -- Fire-like
                    else -- Selene
                        color = {0.3, 0.3, 1.0, 0.9} -- Moon-like
                    end

                    -- Create sparkle effect with delay
                    game.vfx.createEffect("impact", x, y, nil, nil, {
                        duration = 0.8 + math.random() * 0.5,
                        color = color,
                        particleCount = 5,
                        radius = 15,
                        delay = j * 0.1
                    })
                end

                print("[Attract Mode] " .. winner.name .. " wins!")

                -- Transition to game over state
                game.currentState = "GAME_OVER_ATTRACT"
                game.currentTip = Tips.getRandomTip()
                return
            end
        end

        -- Update wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:update(dt)
        end

        -- Update mana pool
        game.manaPool:update(dt)

        -- Update VFX system
        game.vfx.update(dt)

        -- Update SustainedSpellManager for trap and shield management
        game.sustainedSpellManager.update(dt)

        -- Update animated health displays
        UI.updateHealthDisplays(dt, game.wizards)

        -- Update both AI players in attract mode
        if game.player1AI then
            game.player1AI:update(dt)
        end
        if game.player2AI then
            game.player2AI:update(dt)
        end
    elseif game.currentState == "GAME_OVER_ATTRACT" then
        -- Update win screen timer
        game.winScreenTimer = game.winScreenTimer + dt

        -- Auto-reset after duration - start a new attract mode battle
        if game.winScreenTimer >= game.winScreenDuration then
            -- Reset game and start another attract mode battle
            resetGame()

            local unlocked = getUnlockedCharacterList()
            if #unlocked >= 2 then
                local name1 = unlocked[math.random(#unlocked)]
                local name2 = unlocked[math.random(#unlocked)]
                while name2 == name1 do
                    name2 = unlocked[math.random(#unlocked)]
                end
                setupWizards(name1, name2)
                game.player1AI = OpponentAI.new(game.wizards[1], game, getPersonalityFor(name1))
                game.player2AI = OpponentAI.new(game.wizards[2], game, getPersonalityFor(name2))
            end

            -- Keep attract mode active
            game.attractModeActive = true

            -- Go back to attract mode battle
            game.currentState = "BATTLE_ATTRACT"
        end

        -- Still update VFX system for visual effects
        game.vfx.update(dt)
    end
end

function love.draw()
    -- Clear entire screen to black first (for letterboxing/pillarboxing)
    love.graphics.clear(0, 0, 0, 1)
    
    -- Calculate shake offset if active
    local shakeOffsetX, shakeOffsetY = 0, 0
    if shakeTimer > 0 then
        -- Random shake that gradually reduces as timer decreases
        local shakeFactor = shakeTimer / (shakeTimer + 0.1) -- Smooth falloff
        shakeOffsetX = math.random(-shakeIntensity, shakeIntensity) * shakeFactor
        shakeOffsetY = math.random(-shakeIntensity, shakeIntensity) * shakeFactor
    end
    
    -- Setup scaling transform with shake offset
    love.graphics.push()
    love.graphics.translate(offsetX + shakeOffsetX, offsetY + shakeOffsetY)
    love.graphics.scale(scale, scale)
    
    -- Draw based on current game state
    if game.currentState == "MENU" then
        -- Draw the main menu
        drawMainMenu()
    elseif game.currentState == "SETTINGS" then
        drawSettingsMenu()
    elseif game.currentState == "COMPENDIUM" then
        drawCompendium()
    elseif game.currentState == "CAMPAIGN_MENU" then
        drawCampaignMenu()
    elseif game.currentState == "CAMPAIGN_VICTORY" then
        drawCampaignVictory()
    elseif game.currentState == "CAMPAIGN_DEFEAT" then
        drawCampaignDefeat()
    elseif game.currentState == "CHARACTER_SELECT" then
        drawCharacterSelect()
    elseif game.currentState == "BATTLE" or game.currentState == "BATTLE_ATTRACT" then
        -- Draw background image
        love.graphics.setColor(1, 1, 1, 1)
        if game.backgroundImage then
            love.graphics.draw(game.backgroundImage, 0, 0)
        else
            -- Fallback to solid color if background image isn't loaded
            love.graphics.setColor(20/255, 20/255, 40/255, 1)
            love.graphics.rectangle("fill", 0, 0, baseWidth, baseHeight)
            love.graphics.setColor(1, 1, 1, 1) -- Reset color
        end

        -- Draw range state indicator (NEAR/FAR)
        if love.keyboard.isDown("`") then
            drawRangeIndicator()
        end

        -- Draw mana pool
        game.manaPool:draw()

        -- Draw wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:draw()
        end

        -- Draw visual effects layer (between wizards and UI)
        game.vfx.draw()

        -- Draw UI elements in proper z-order
        love.graphics.setColor(1, 1, 1)

        -- First draw health bars and basic UI components
        UI.drawSpellInfo(game.wizards)

        -- Then draw spellbook buttons (the input feedback bar)
        UI.drawSpellbookButtons()

        -- Finally draw spellbook modals on top of everything else
        UI.drawSpellbookModals(game.wizards)

        -- If in attract mode, draw the attract mode overlay
        if game.currentState == "BATTLE_ATTRACT" then
            drawAttractModeOverlay()
        end
    elseif game.currentState == "GAME_OVER" or game.currentState == "GAME_OVER_ATTRACT" then
        -- Draw background image
        love.graphics.setColor(1, 1, 1, 1)
        if game.backgroundImage then
            love.graphics.draw(game.backgroundImage, 0, 0)
        else
            -- Fallback to solid color if background image isn't loaded
            love.graphics.setColor(20/255, 20/255, 40/255, 1)
            love.graphics.rectangle("fill", 0, 0, baseWidth, baseHeight)
            love.graphics.setColor(1, 1, 1, 1) -- Reset color
        end

        -- Draw game elements in the background (frozen in time)
        -- Draw range state indicator
        drawRangeIndicator()

        -- Draw mana pool
        game.manaPool:draw()

        -- Draw wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:draw()
        end

        -- Draw visual effects layer
        game.vfx.draw()

        -- Draw win screen on top
        drawWinScreen()

        -- If in attract mode, draw the attract mode overlay
        if game.currentState == "GAME_OVER_ATTRACT" then
            drawAttractModeOverlay()
        end
    end
    
    -- Debug info only when debug key is pressed (available in all states)
    if love.keyboard.isDown("`") then
        UI.drawHelpText(game.font)
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print("FPS: " .. love.timer.getFPS(), 10, 10)
        
        -- Show current game state in debug mode
        love.graphics.print("State: " .. game.currentState, 10, 30)
        
        -- Show scaling info in debug mode
        love.graphics.print("Scale: " .. scale .. "x (" .. love.graphics.getWidth() .. "x" .. love.graphics.getHeight() .. ")", 10, 50)
        
        -- Show asset cache stats in debug mode
        local stats = AssetCache.dumpStats()
        love.graphics.print(string.format("Assets: %d images, %d sounds loaded", 
                            stats.images.loaded, stats.sounds.loaded), 10, 70)

        -- Show Pool stats in debug mode
        if love.keyboard.isDown("p") then
            -- Draw pool statistics overlay
            Pool.drawDebugOverlay()
            -- Also show VFX-specific stats
            if game.vfx and game.vfx.showPoolStats then
                game.vfx.showPoolStats()
            end
        else
            love.graphics.print("Press P while in debug mode to see object pool stats", 10, 90)
        end
        
        -- Show hotkey summary when debug overlay is active
        if love.keyboard.isDown("tab") then
            drawHotkeyHelp()
        else
            love.graphics.print("Press TAB while in debug mode to see hotkeys", 10, 110)
        end
    else
        -- Always show a small hint about the debug key
        love.graphics.setColor(0.6, 0.6, 0.6, 0.4)
        love.graphics.print("Press ` for debug controls", 10, baseHeight - 20)
    end
    
    -- End scaling transform
    love.graphics.pop()
    
    -- Draw letterbox/pillarbox borders if needed
    if offsetX > 0 or offsetY > 0 then
        love.graphics.setColor(0, 0, 0)
        -- Top letterbox
        if offsetY > 0 then
            love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), offsetY)
            love.graphics.rectangle("fill", 0, love.graphics.getHeight() - offsetY, love.graphics.getWidth(), offsetY)
        end
        -- Left/right pillarbox
        if offsetX > 0 then
            love.graphics.rectangle("fill", 0, 0, offsetX, love.graphics.getHeight())
            love.graphics.rectangle("fill", love.graphics.getWidth() - offsetX, 0, offsetX, love.graphics.getHeight())
        end
    end
end

-- Helper function to convert real screen coordinates to virtual (scaled) coordinates
function screenToGameCoords(x, y)
    if not x or not y then return nil, nil end
    
    -- Adjust for offset and scale
    local virtualX = (x - offsetX) / scale
    local virtualY = (y - offsetY) / scale
    
    -- Check if the point is outside the game area
    if virtualX < 0 or virtualX > baseWidth or virtualY < 0 or virtualY > baseHeight then
        return nil, nil  -- Out of bounds
    end
    
    return virtualX, virtualY
end

-- Override love.mouse.getPosition for seamless integration
local original_getPosition = love.mouse.getPosition
love.mouse.getPosition = function()
    local rx, ry = original_getPosition()
    local vx, vy = screenToGameCoords(rx, ry)
    return vx or 0, vy or 0
end

-- Draw the win screen
function drawWinScreen()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    local winner = game.wizards[game.winner]
    
    -- Fade in effect
    local fadeProgress = math.min(game.winScreenTimer / 0.5, 1.0)
    
    -- Draw semi-transparent overlay
    love.graphics.setColor(0, 0, 0, 0.7 * fadeProgress)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)
    
    -- Determine winner's color scheme
    local winnerColor
    if game.winner == 1 then -- Ashgar
        winnerColor = {1.0, 0.4, 0.2} -- Fire-like
    else -- Selene
        winnerColor = {0.4, 0.4, 1.0} -- Moon-like
    end
    
    -- Calculate animation progress for text
    local textProgress = math.min(math.max(game.winScreenTimer - 0.5, 0) / 0.5, 1.0)
    local textScale = 1 + (1 - textProgress) * 3 -- Text starts larger and shrinks to normal size
    local textY = screenHeight / 2 - 100
    
    -- Draw winner text with animated scale
    love.graphics.setColor(winnerColor[1], winnerColor[2], winnerColor[3], textProgress)
    
    -- Main victory text
    local victoryText = winner.name .. " WINS!"
    local victoryTextWidth = game.font:getWidth(victoryText) * textScale * 3
    love.graphics.print(
        victoryText, 
        screenWidth / 2 - victoryTextWidth / 2, 
        textY,
        0, -- rotation
        textScale * 3, -- scale X
        textScale * 3  -- scale Y
    )
    
    -- Only show restart instructions after initial animation
    if game.winScreenTimer > 1.0 then
        -- Calculate pulse effect
        local pulse = 0.7 + 0.3 * math.sin(game.winScreenTimer * 4)
        
        -- Draw restart instruction with pulse effect
        local restartText = "Press [SPACE] to play again"
        local restartTextWidth = game.font:getWidth(restartText) * 1.5
        
        love.graphics.setColor(1, 1, 1, pulse)
        love.graphics.print(
            restartText,
            screenWidth / 2 - restartTextWidth / 2,
            textY + 150,
            0, -- rotation
            1.5, -- scale X
            1.5  -- scale Y
        )
        
        -- Show auto-restart countdown
        local remainingTime = math.ceil(game.winScreenDuration - game.winScreenTimer)
        local countdownText = "Auto-restart in " .. remainingTime .. "..."
        local countdownTextWidth = game.font:getWidth(countdownText)
        
        love.graphics.setColor(0.7, 0.7, 0.7, 0.7)
        love.graphics.print(
            countdownText,
            screenWidth / 2 - countdownTextWidth / 2,
            textY + 200
        )
    end

    -- Draw gameplay tip overlay
    if game.currentTip then
        love.graphics.setColor(0, 0, 0, 0.6)
        love.graphics.rectangle("fill", 0, screenHeight - 110, screenWidth, 110)

        love.graphics.setColor(1, 1, 1, 0.9)
        local header = "TIP: " .. game.currentTip.title
        love.graphics.printf(header, 20, screenHeight - 100, screenWidth - 40, "center")

        love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        local body = game.currentTip.content .. " - " .. game.currentTip.source
        love.graphics.printf(body, 20, screenHeight - 80, screenWidth - 40, "center")
    end
    
    -- Draw some victory effect particles
    for i = 1, 3 do
        if math.random() < 0.3 then
            local x = math.random(screenWidth)
            local y = math.random(screenHeight)
            local size = math.random(10, 30)
            
            love.graphics.setColor(
                winnerColor[1], 
                winnerColor[2], 
                winnerColor[3], 
                math.random() * 0.3
            )
            love.graphics.circle("fill", x, y, size)
        end
    end
end

-- Function to draw the range indicator for NEAR/FAR states
function drawRangeIndicator()
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    local centerX = screenWidth / 2
    
    -- Only draw a subtle central line, without the text indicators
    -- The wizard positions themselves will communicate NEAR/FAR state
    
    -- Different visual style based on range state
    if game.rangeState == Constants.RangeState.NEAR then
        -- For NEAR state, draw a more vibrant, energetic line
        love.graphics.setColor(0.5, 0.5, 0.9, 0.4)
        
        -- Draw main line
        love.graphics.setLineWidth(1.5)
        love.graphics.line(centerX, 200, centerX, screenHeight - 100)
        
        -- Add a subtle energetic glow/pulse
        for i = 1, 5 do
            local pulseWidth = 3 + math.sin(love.timer.getTime() * 2.5) * 2
            local alpha = 0.12 - (i * 0.02)
            love.graphics.setColor(0.5, 0.5, 0.9, alpha)
            love.graphics.setLineWidth(pulseWidth * i)
            love.graphics.line(centerX, 200, centerX, screenHeight - 100)
        end
        love.graphics.setLineWidth(1)
    else
        -- For FAR state, draw a more distant, faded line
        love.graphics.setColor(0.3, 0.3, 0.7, 0.3)
        
        -- Draw main line with slight wave effect
        local segments = 12
        local segmentHeight = (screenHeight - 300) / segments
        local points = {}
        
        for i = 0, segments do
            local y = 200 + i * segmentHeight
            local wobble = math.sin(love.timer.getTime() + i * 0.3) * 1.5
            table.insert(points, centerX + wobble)
            table.insert(points, y)
        end
        
        love.graphics.setLineWidth(1)
        love.graphics.line(points)
        
        -- Add very subtle horizontal distortion lines
        for i = 1, 5 do
            local y = 200 + (i * (screenHeight - 300) / 6)
            local width = 15 + math.sin(love.timer.getTime() * 0.7 + i) * 5
            local alpha = 0.05
            love.graphics.setColor(0.3, 0.3, 0.7, alpha)
            love.graphics.setLineWidth(0.5)
            love.graphics.line(centerX - width, y, centerX + width, y)
        end
    end
    
    -- Reset line width
    love.graphics.setLineWidth(1)
end

-- Draw the main menu
-- Helper function to draw text with outline/drop-shadow effect
local function drawTextWithOutline(text, x, y, rotation, scaleX, scaleY, outlineWidth, textColor, outlineColor)
    rotation = rotation or 0
    scaleX = scaleX or 1
    scaleY = scaleY or scaleX
    outlineWidth = outlineWidth or 2
    outlineColor = outlineColor or {0, 0, 0, 0.8}
    
    -- Draw outline/drop-shadow by drawing the text multiple times with slight offsets
    love.graphics.setColor(outlineColor)
    for ox = -outlineWidth, outlineWidth do
        for oy = -outlineWidth, outlineWidth do
            if ox ~= 0 or oy ~= 0 then
                love.graphics.print(text, x + ox, y + oy, rotation, scaleX, scaleY)
            end
        end
    end
    
    -- Draw main text on top
    love.graphics.setColor(textColor)
    love.graphics.print(text, x, y, rotation, scaleX, scaleY)
end

function drawMainMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    
    -- Draw a magical background effect
    love.graphics.setColor(20/255, 20/255, 40/255, 1) -- Dark blue background
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)
    
    -- Draw animated arcane runes in the background
    for i = 1, 9 do
        local time = love.timer.getTime()
        local x = screenWidth * (0.1 + (i % 3) * 0.3)
        local y = screenHeight * (0.1 + math.floor(i / 3) * 0.3)
        local scale = 0.4 + 0.1 * math.sin(time + i)
        local alpha = 0.1 + 0.05 * math.sin(time * 0.5 + i * 0.7)
        local rotation = time * 0.1 * (i % 2 == 0 and 1 or -1)
        local runeTexture = AssetCache.getImage("assets/sprites/runes/rune" .. i .. ".png")
        
        if runeTexture then
            love.graphics.setColor(0.4, 0.4, 0.8, alpha)
            love.graphics.draw(
                runeTexture, 
                x, y, 
                rotation,
                scale, scale,
                runeTexture:getWidth()/2, runeTexture:getHeight()/2
            )
        end
    end
    
    -- Initialize token position history on first run
    if not game.menuTokenTrails then
        game.menuTokenTrails = {}
        for i = 1, 9 do
            game.menuTokenTrails[i] = {}
        end
    end
    
    -- Draw floating mana tokens in a circular arrangement around the content
    local centerX = screenWidth / 2
    local centerY = screenHeight / 2
    local orbitRadius = 200  -- Larger orbit radius for the tokens to circle around content
    local numTokens = 9      -- Exactly 9 tokens to show all token types
    local trailLength = 75   -- Length of the trail (5x longer than original 15)
    
    -- Track token positions for triangle drawing
    local tokenPositions = {}
    
    -- First, draw the triangles BEFORE the tokens to ensure they appear behind
    -- We'll collect positions first with a dry run through the token calculations
    for i = 1, numTokens do
        local time = love.timer.getTime()
        -- Calculate position on a circle with some oscillation
        local angle = (i / numTokens) * math.pi * 2 + time * 0.2  -- Rotate around slowly over time
        local radiusVariation = 20 * math.sin(time * 0.5 + i)     -- Make orbit radius pulse
        
        -- Calculate x,y position on the orbit
        local x = centerX + math.cos(angle) * (orbitRadius + radiusVariation)
        local y = centerY + math.sin(angle) * (orbitRadius + radiusVariation)
        
        -- Add some vertical bounce
        y = y + 15 * math.sin(time * 0.7 + i * 0.5)
        
        -- Store token position for triangle drawing
        tokenPositions[i] = {x = x, y = y}
    end
    
    -- Store triangle data for drawing later
    local triangleData = {}
    
    if #tokenPositions == numTokens then
        local time = love.timer.getTime()
        
        -- Set up triangle groups
        local triangleGroups = {
            {1, 4, 7}, -- First triangle group
            {2, 5, 8}, -- Second triangle group
            {3, 6, 9}  -- Third triangle group
        }
        
        -- Prepare triangle data
        for tIndex, group in ipairs(triangleGroups) do
            -- Get color based on the first token in the group
            local tokenType = game.tokenTypes[group[1]]
            local colorTable = Constants.getColorForTokenType(tokenType)
            
            -- Create a more pronounced pulsing effect for the lines
            local pulseRate = 0.5 + tIndex * 0.2 -- Different pulse rate for each triangle
            -- More dramatic pulsing effect
            local pulseAmount = 0.12 + 0.1 * math.sin(time * pulseRate) 
            
            -- Store color and alpha information with slightly increased base values
            local triangleInfo = {
                color = colorTable,
                alpha = 0.22 + pulseAmount, -- Higher base alpha for more visibility
                points = {}
            }
            
            -- Calculate triangle points with wobble
            for _, tokenIdx in ipairs(group) do
                if tokenPositions[tokenIdx] then
                    -- Add a small wobble to the connection points
                    local wobbleX = 2 * math.sin(time * 1.2 + tokenIdx * 0.7)
                    local wobbleY = 2 * math.cos(time * 1.1 + tokenIdx * 0.9)
                    
                    table.insert(triangleInfo.points, tokenPositions[tokenIdx].x + wobbleX)
                    table.insert(triangleInfo.points, tokenPositions[tokenIdx].y + wobbleY)
                end
            end
            
            -- Add to triangleData collection if we have enough points
            if #triangleInfo.points >= 6 then
                table.insert(triangleData, triangleInfo)
            end
        end
    end
    
    -- First draw the triangles (BEHIND the tokens and trails)
    -- Draw the triangles using the data we collected earlier
    for _, triangle in ipairs(triangleData) do
        -- Draw a glow effect behind the lines first (thicker, more transparent)
        for i = 1, 3 do -- Three layers of glow
            local glowAlpha = triangle.alpha * 0.7 * (1 - (i-1) * 0.25) -- Fade out in layers
            local glowWidth = 3.5 + (i-1) * 2.5 -- Get wider with each layer
            
            love.graphics.setColor(triangle.color[1], triangle.color[2], triangle.color[3], glowAlpha)
            love.graphics.setLineWidth(glowWidth)
            
            -- Draw the triangle outline with glow
            love.graphics.line(triangle.points[1], triangle.points[2], triangle.points[3], triangle.points[4])
            love.graphics.line(triangle.points[3], triangle.points[4], triangle.points[5], triangle.points[6])
            love.graphics.line(triangle.points[5], triangle.points[6], triangle.points[1], triangle.points[2])
        end
        
        -- Draw the main triangle lines (thicker than before)
        love.graphics.setColor(triangle.color[1], triangle.color[2], triangle.color[3], triangle.alpha * 1.2)
        love.graphics.setLineWidth(2.5) -- Thicker main line
        
        -- Draw the triangle outline
        love.graphics.line(triangle.points[1], triangle.points[2], triangle.points[3], triangle.points[4])
        love.graphics.line(triangle.points[3], triangle.points[4], triangle.points[5], triangle.points[6])
        love.graphics.line(triangle.points[5], triangle.points[6], triangle.points[1], triangle.points[2])
    end
    
    -- Now draw the tokens and their trails (on top of the triangles)
    for i = 1, numTokens do
        local time = love.timer.getTime()
        -- Ensure we display each token type exactly once
        local tokenType = game.tokenTypes[i]
        local tokenImage = AssetCache.getImage(game.tokenImages[tokenType])
        
        if tokenImage then
            -- Calculate position on a circle with some oscillation
            local angle = (i / numTokens) * math.pi * 2 + time * 0.2  -- Rotate around slowly over time
            local radiusVariation = 20 * math.sin(time * 0.5 + i)     -- Make orbit radius pulse
            
            -- Calculate x,y position on the orbit
            local x = centerX + math.cos(angle) * (orbitRadius + radiusVariation)
            local y = centerY + math.sin(angle) * (orbitRadius + radiusVariation)
            
            -- Add some vertical bounce
            y = y + 15 * math.sin(time * 0.7 + i * 0.5)
            
            -- Store token position for triangle drawing
            tokenPositions[i] = {x = x, y = y}
            
            -- Keep token size large but vary slightly for animation
            local tokenScale = 1.8 + 0.3 * math.sin(time + i * 0.3)
            local rotation = time * 0.2 * (i % 2 == 0 and 1 or -1)
            
            -- Get color for this token type
            local colorTable = Constants.getColorForTokenType(tokenType)
            
            -- Update position history for trail effect
            if not game.menuTokenTrails[i] then
                game.menuTokenTrails[i] = {}
            end
            
            -- Store new position at the beginning of history array
            table.insert(game.menuTokenTrails[i], 1, {x = x, y = y, time = time})
            
            -- Limit trail length
            if #game.menuTokenTrails[i] > trailLength then
                table.remove(game.menuTokenTrails[i])
            end
            
            -- Draw the trailing effect first (behind the token)
            -- For efficiency with longer trails, only draw every other point for trails > 30
            local stepSize = (#game.menuTokenTrails[i] > 30) and 2 or 1
            
            for j = #game.menuTokenTrails[i], 2, -stepSize do
                local pos = game.menuTokenTrails[i][j]
                local timeDiff = time - pos.time
                
                -- Calculate fade based on position in trail (older = more transparent)
                -- Use a slower fade rate for longer trails
                local trailAlpha = 0.25 * (1 - (j / trailLength)^1.5)
                
                -- Gradually reduce size for trail particles
                -- Adjusted scale formula for longer trails - slower decrease
                local trailScale = 18 * (1 - (j / trailLength) * 0.6)
                
                -- Draw trail particle
                love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], trailAlpha)
                love.graphics.circle("fill", pos.x, pos.y, trailScale)
            end
            
            -- Draw smaller glow behind token (reduced aura size)
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], 0.3)
            -- Reduce the aura size multiplier from 50 to 35
            love.graphics.circle("fill", x, y, 35 * tokenScale)
            
            -- Draw token with same large scale as before
            love.graphics.setColor(1, 1, 1, 0.9)
            love.graphics.draw(
                tokenImage, 
                x, y, 
                rotation,
                tokenScale, tokenScale,
                tokenImage:getWidth()/2, tokenImage:getHeight()/2
            )
        end
    end
    
    -- Now draw all menu text ON TOP of everything else
    
    -- Draw title with a magical glow effect and outline
    local titleY = screenHeight * 0.25
    local titleScale = 4
    local titleText = "MANASTORM"
    local titleWidth = game.font:getWidth(titleText) * titleScale
    
    -- Draw glow behind title
    local glowColor = {0.3, 0.3, 0.9, 0.3}
    local glowSize = 15 + 5 * math.sin(love.timer.getTime() * 2)
    love.graphics.setColor(glowColor)
    for i = 1, 3 do
        love.graphics.print(
            titleText,
            screenWidth/2 - titleWidth/2 + math.random(-2, 2), 
            titleY + math.random(-2, 2),
            0,
            titleScale, titleScale
        )
    end
    
    -- Draw main title with outline
    drawTextWithOutline(
        titleText,
        screenWidth/2 - titleWidth/2, 
        titleY,
        0,
        titleScale, titleScale,
        3, -- outline width
        {0.9, 0.9, 1, 1}, -- text color (light blue-white)
        {0.1, 0.1, 0.3, 0.9} -- outline color (dark blue)
    )
    
    -- Draw subtitle with outline
    local subtitleText = "Chosen of the Ninefold Circle"
    local subtitleScale = 2
    local subtitleWidth = game.font:getWidth(subtitleText) * subtitleScale
    
    drawTextWithOutline(
        subtitleText,
        screenWidth/2 - subtitleWidth/2,
        titleY + 60,
        0,
        subtitleScale, subtitleScale,
        2, -- outline width
        {0.7, 0.7, 1, 0.9}, -- text color (light blue)
        {0.1, 0.1, 0.2, 0.8} -- outline color (dark)
    )
    
    -- Draw menu options with outlines
    local menuY = screenHeight * 0.55
    local menuSpacing = 40
    local menuScale = 1.4

    local options = {
        {"[1] Campaign", {0.9, 0.9, 0.9, 0.9}},
        {"[2] Character Duel", {0.9, 0.7, 0.1, 0.9}},
        {"[3] Research Duel", {0.7, 0.9, 0.2, 0.9}},
        {"[4] Compendium", {0.7, 0.8, 1.0, 0.9}},
        {"[5] Settings", {0.8, 0.8, 0.8, 0.9}},
        {"[6] Exit", {0.7, 0.7, 0.7, 0.9}}
    }

    for i, option in ipairs(options) do
        local text, color = option[1], option[2]
        local width = game.font:getWidth(text) * menuScale
        
        drawTextWithOutline(
            text,
            screenWidth/2 - width/2,
            menuY + (i-1)*menuSpacing,
            0,
            menuScale, menuScale,
            2, -- outline width
            color, -- text color
            {0.1, 0.1, 0.1, 0.8} -- outline color (dark)
        )
    end
    
    -- Draw version and credit
    local versionText = "v0.1 - Demo"
    love.graphics.setColor(0.5, 0.5, 0.5, 0.7)
    love.graphics.print(versionText, 10, screenHeight - 30)
end

-- Draw the campaign character selection menu
function drawCampaignMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    local unlocked = getUnlockedCharacterList()
    local spacing = 30
    local startY = screenHeight * 0.4

    for i, name in ipairs(unlocked) do
        local y = startY + (i - 1) * spacing
        if i == game.campaignMenu.selectedCharacterIndex then
            love.graphics.setColor(1, 0.8, 0.3, 1)
        else
            love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        end
        local w = game.font:getWidth(name)
        love.graphics.print(name, screenWidth/2 - w/2, y)
    end

    love.graphics.setColor(0.7, 0.7, 1, 0.8)
    local hint = "Choose your wizard"
    local hw = game.font:getWidth(hint)
    love.graphics.print(hint, screenWidth/2 - hw/2, startY - spacing)
end

-- Draw the campaign defeat screen
function drawCampaignDefeat()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    local title = "Campaign Failed"
    local titleScale = 2.5
    local tw = game.font:getWidth(title) * titleScale
    love.graphics.setColor(1, 0.6, 0.6, 1)
    love.graphics.print(title, screenWidth/2 - tw/2, screenHeight*0.4, 0, titleScale, titleScale)

    local options = {
        "[R] Restart Campaign",
        "[SPACE] Retry Battle",
        "[ESC] Main Menu"
    }
    local startY = screenHeight * 0.6
    for i, text in ipairs(options) do
        local w = game.font:getWidth(text)
        love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        love.graphics.print(text, screenWidth/2 - w/2, startY + (i-1)*30)
    end
end

-- Draw the campaign victory screen
function drawCampaignVictory()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    local title = "Campaign Complete"
    local titleScale = 2.5
    local tw = game.font:getWidth(title) * titleScale
    love.graphics.setColor(0.6, 1, 0.6, 1)
    love.graphics.print(title, screenWidth/2 - tw/2, screenHeight*0.4, 0, titleScale, titleScale)

    local options = {
        "[R] Restart Campaign",
        "[ESC] Main Menu"
    }
    local startY = screenHeight * 0.6
    for i, text in ipairs(options) do
        local w = game.font:getWidth(text)
        love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        love.graphics.print(text, screenWidth/2 - w/2, startY + (i-1)*30)
    end
end

-- Draw the character selection screen
function drawCharacterSelect()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    love.graphics.setColor(20/255,20/255,40/255,1)
    love.graphics.rectangle("fill",0,0,screenWidth,screenHeight)

    local paneWidth = screenWidth/3
    local cellSize = 60
    local padding = 10
    local gridWidth = cellSize*3 + padding*2
    local gridHeight = cellSize*3 + padding*2
    local gridX = paneWidth + (paneWidth - gridWidth)/2
    local gridY = screenHeight/2 - gridHeight/2

    -- Helper to draw a character sprite
    local function drawSprite(name,x,y,scale)
        local sprite = AssetCache.getImage("assets/sprites/"..string.lower(name)..".png")
        if sprite then
            love.graphics.draw(sprite,x,y,0,scale,scale,sprite:getWidth()/2,sprite:getHeight()/2)
        else
            love.graphics.print(name,x-20,y-5)
        end
    end

    -- Draw selected characters in side panes
    if game.characterSelect.selected[1] then
        love.graphics.setColor(1,1,1)
        drawSprite(game.characterSelect.selected[1],paneWidth/2,screenHeight/2,2)
    end
    if game.characterSelect.selected[2] then
        love.graphics.setColor(1,1,1)
        drawSprite(game.characterSelect.selected[2],screenWidth-paneWidth/2,screenHeight/2,2)
    end

    -- Draw grid of characters
    for i,name in ipairs(game.characterRoster) do
        local col=(i-1)%3
        local row=math.floor((i-1)/3)
        local x=gridX+col*(cellSize+padding)
        local y=gridY+row*(cellSize+padding)

        local unlocked = game.unlockedCharacters[name]
        love.graphics.setColor(0.4,0.4,0.4)
        love.graphics.rectangle("fill",x,y,cellSize,cellSize)

        local scale = cellSize/64
        if unlocked then
            love.graphics.setColor(1,1,1)
            drawSprite(name,x+cellSize/2,y+cellSize/2,scale)
        else
            love.graphics.setColor(0,0,0)
            drawSprite(name,x+cellSize/2,y+cellSize/2,scale)
        end

        if game.characterSelect.cursor==i then
            love.graphics.setColor(1,1,0)
            love.graphics.rectangle("line",x-2,y-2,cellSize+4,cellSize+4)
        end
    end

    -- Instruction text
    love.graphics.setColor(1,1,1,0.8)
    local msg
    if game.characterSelect.stage==1 then
        msg = "Select Your Wizard"
    elseif game.characterSelect.stage==2 then
        msg = "Select Opponent"
    else
        msg = "Press F to Fight!"
    end
    local w = game.font:getWidth(msg)
    love.graphics.print(msg,screenWidth/2 - w/2,gridY+gridHeight+20)

    if game.characterSelect.stage >= 2 then
        local modeText = game.useAI and "P2: AI" or "P2: Human"
        local toggleMsg = modeText .. " (Tab to toggle)"
        local tw = game.font:getWidth(toggleMsg)
        love.graphics.print(toggleMsg, screenWidth/2 - tw/2, gridY+gridHeight+40)
    end
end

-- Draw the settings menu
function drawSettingsMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    if game.settingsMenu.mode == "rebind_select_player" or game.settingsMenu.mode == "rebind_action_list" then
        drawRebindMenu()
        return
    end

    local options = {
        "Dummy Flag: " .. tostring(Settings.get("dummyFlag")),
        "Game Speed: " .. (Settings.get("gameSpeed") or "FAST"),
        "Unlock All (Dev)",
        "Rebind Controls"
    }

    for i, text in ipairs(options) do
        local scale = 1.4
        local y = screenHeight * 0.4 + (i-1) * 40
        local w = game.font:getWidth(text) * scale
        if i == game.settingsMenu.selected and not game.settingsMenu.mode then
            love.graphics.setColor(1, 0.8, 0.3, 1)
        else
            love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        end
        love.graphics.print(text, screenWidth/2 - w/2, y, 0, scale, scale)
    end

    if game.settingsMenu.waitingForKey then
        local msg = "Press new key for " .. game.settingsMenu.waitingForKey.label
        local scale = 1.2
        local w = game.font:getWidth(msg) * scale
        love.graphics.setColor(1, 0.6, 0.6, 1)
        love.graphics.print(msg, screenWidth/2 - w/2, screenHeight - 60, 0, scale, scale)
    end
end

function drawRebindMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    if game.settingsMenu.mode == "rebind_select_player" then
        for i, opt in ipairs(game.settingsMenu.rebindOptions or {}) do
            local text = opt.label
            local scale = 1.3
            local y = screenHeight * 0.4 + (i-1)*30
            local w = game.font:getWidth(text) * scale
            if i == game.settingsMenu.rebindSelection then
                love.graphics.setColor(1,0.8,0.3,1)
            else
                love.graphics.setColor(0.9,0.9,0.9,0.9)
            end
            love.graphics.print(text, screenWidth/2 - w/2, y, 0, scale, scale)
        end
    elseif game.settingsMenu.mode == "rebind_action_list" then
        local list = game.settingsMenu.rebindActionList or {}
        local startY = screenHeight * 0.3
        for i, entry in ipairs(list) do
            local text = entry.action .. " : " .. tostring(entry.binding or "")
            local scale = 1.1
            local y = startY + (i-1)*24
            if i == game.settingsMenu.rebindSelection and not game.settingsMenu.waitingForKey then
                love.graphics.setColor(1,0.8,0.3,1)
            else
                love.graphics.setColor(0.9,0.9,0.9,0.9)
            end
            love.graphics.print(text, 60, y, 0, scale, scale)
        end
    end

    if game.settingsMenu.waitingForKey then
        local msg = "Press new input for " .. game.settingsMenu.waitingForKey.label
        local scale = 1.2
        local w = game.font:getWidth(msg) * scale
        love.graphics.setColor(1,0.6,0.6,1)
        love.graphics.print(msg, screenWidth/2 - w/2, screenHeight - 60, 0, scale, scale)
    end
end

function drawCompendium()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    
    -- Background with gradient effect
    local bgColorTop = {15/255, 15/255, 35/255, 1}
    local bgColorBottom = {30/255, 30/255, 50/255, 1}
    
    -- Draw gradient background
    love.graphics.setColor(bgColorTop)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight/2)
    love.graphics.setColor(bgColorBottom)
    love.graphics.rectangle("fill", 0, screenHeight/2, screenWidth, screenHeight/2)
    
    -- Calculate pane dimensions with padding
    local panePadding = 12
    local headerHeight = 50 -- Reduced height for the title area
    local footerHeight = 45 -- Height for the footer controls
    local paneWidth = (screenWidth - panePadding * 3) / 2
    local paneHeight = (screenHeight - panePadding * 3 - headerHeight - footerHeight) / 2
    
    -- Define pane coordinates
    local panes = {
        topLeft = {
            x = panePadding,
            y = panePadding + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Spell Details"
        },
        topRight = {
            x = panePadding * 2 + paneWidth,
            y = panePadding + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Character Info"
        },
        bottomLeft = {
            x = panePadding,
            y = panePadding * 2 + paneHeight + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Available Spells"
        },
        bottomRight = {
            x = panePadding * 2 + paneWidth,
            y = panePadding * 2 + paneHeight + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Equipped Spells - Press 1-7 to assign"
        }
    }
    
    -- Get character data
    local name = game.characterRoster[game.compendium.page]
    local data = game.characterData[name]
    
    -- Check if character is unlocked
    local isUnlocked = game.unlockedCharacters[name] or false
    
    -- Draw decorative header line
    love.graphics.setColor(0.4, 0.4, 0.7, 0.5)
    love.graphics.rectangle("fill", 20, headerHeight - 5, screenWidth - 40, 2)
    
    -- Draw main title with shadow effect
    local title
    if isUnlocked then
        title = "Compendium - " .. name
    else
        title = "Compendium - ???"
    end
    
    -- Shadow
    love.graphics.setColor(0.2, 0.2, 0.4, 0.6)
    love.graphics.print(title, screenWidth/2 - game.font:getWidth(title)/2 + 2, 22, 0, 1.5, 1.5)
    
    -- Title text
    love.graphics.setColor(0.9, 0.9, 1)
    love.graphics.print(title, screenWidth/2 - game.font:getWidth(title)/2, 20, 0, 1.5, 1.5)
    
    -- Draw the four panes with distinct colors and titles
    for paneName, pane in pairs(panes) do
        -- Draw pane background with slight transparency and gradient
        local bgColor1, bgColor2
        
        -- Different subtle coloring for each pane
        if paneName == "topLeft" then
            bgColor1 = {0.12, 0.12, 0.22, 0.9}
            bgColor2 = {0.15, 0.15, 0.25, 0.9}
        elseif paneName == "topRight" then
            bgColor1 = {0.14, 0.12, 0.22, 0.9}
            bgColor2 = {0.17, 0.15, 0.25, 0.9}
        elseif paneName == "bottomLeft" then
            bgColor1 = {0.12, 0.14, 0.22, 0.9}
            bgColor2 = {0.15, 0.17, 0.25, 0.9}
        else -- bottomRight
            bgColor1 = {0.13, 0.13, 0.23, 0.9}
            bgColor2 = {0.16, 0.16, 0.26, 0.9}
        end
        
        -- Draw gradient background
        love.graphics.setColor(bgColor1)
        love.graphics.rectangle("fill", pane.x, pane.y, pane.w, pane.h/2)
        love.graphics.setColor(bgColor2)
        love.graphics.rectangle("fill", pane.x, pane.y + pane.h/2, pane.w, pane.h/2)
        
        -- Draw pane border with rounded corners
        love.graphics.setColor(0.4, 0.4, 0.6, 0.8)
        love.graphics.rectangle("line", pane.x, pane.y, pane.w, pane.h, 3, 3)
        
        -- Draw title background
        love.graphics.setColor(0.2, 0.2, 0.3, 0.8)
        love.graphics.rectangle("fill", pane.x, pane.y, pane.w, 30, 3, 3)
        
        -- Draw separator line under title
        love.graphics.setColor(0.4, 0.4, 0.6, 0.5)
        love.graphics.rectangle("fill", pane.x + 5, pane.y + 30, pane.w - 10, 1)
        
        -- Draw pane title with slight shadow
        love.graphics.setColor(0.3, 0.3, 0.4, 0.8)
        love.graphics.print(pane.title, pane.x + 11, pane.y + 8)
        love.graphics.setColor(0.9, 0.9, 1)
        love.graphics.print(pane.title, pane.x + 10, pane.y + 7)
    end
    
    -- Draw detailed content for each pane
    
    -- Top Left: Selected Spell Details
    local selectedSpell = nil
    local spells = data.spells or {}
    if #spells > 0 and game.compendium.cursor <= #spells then
        selectedSpell = spells[game.compendium.cursor]
    end
    
    local pane = panes.topLeft
    if selectedSpell then
        -- Set scissor to clip content to pane
        setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
        
        -- Spell name with larger font
        love.graphics.setColor(1, 1, 0.8)
        local nameY = pane.y + 40
        
        if isUnlocked then
            love.graphics.print(selectedSpell.name, pane.x + 15, nameY, 0, 1.3, 1.3)
        else
            -- For locked characters, replace name with question marks
            local lockedName = string.rep("?", #selectedSpell.name)
            love.graphics.print(lockedName, pane.x + 15, nameY, 0, 1.3, 1.3)
        end
        
        -- Spell properties
        love.graphics.setColor(0.9, 0.9, 0.9)
        local propY = nameY + 30
        
        if isUnlocked then
            -- Affinity
            love.graphics.print("Affinity: " .. (selectedSpell.affinity or "None"), pane.x + 15, propY)
            
            -- Attack Type
            love.graphics.print("Type: " .. (selectedSpell.attackType or "None"), pane.x + 15, propY + 20)
            
            -- Cast Time
            local castTimeText = "Cast Time: " .. (selectedSpell.castTime or 0) .. "s"
            love.graphics.print(castTimeText, pane.x + 15, propY + 40)
            
            -- Mana Cost with token icons
            love.graphics.setColor(0.9, 0.9, 0.9)
            love.graphics.print("Cost:", pane.x + 15, propY + 60)
        else
            -- For locked characters, show mysterious text
            love.graphics.print("Affinity: ???", pane.x + 15, propY)
            love.graphics.print("Type: ???", pane.x + 15, propY + 20)
            love.graphics.print("Cast Time: ??.?s", pane.x + 15, propY + 40)
            love.graphics.print("Cost: ???", pane.x + 15, propY + 60)
        end
        
        if isUnlocked and selectedSpell.cost and #selectedSpell.cost > 0 then
            local iconSize = 16
            local spacing = 5
            local startX = pane.x + 60
            
            for i, tokenType in ipairs(selectedSpell.cost) do
                -- Position for this token icon
                local x = startX + (i-1) * (iconSize + spacing)
                
                -- Get token image if available
                if game.tokenImages and game.tokenImages[tokenType] then
                    local tokenImg = AssetCache.getImage(game.tokenImages[tokenType])
                    if tokenImg then
                        love.graphics.setColor(1, 1, 1)
                        love.graphics.draw(tokenImg, x, propY + 57, 0, iconSize/tokenImg:getWidth(), iconSize/tokenImg:getHeight())
                    else
                        -- Fallback if image not loaded
                        love.graphics.setColor(0.8, 0.7, 0.9)
                        love.graphics.print(tokenType, x, propY + 60)
                    end
                else
                    -- Fallback if no image defined
                    love.graphics.setColor(0.8, 0.7, 0.9)
                    love.graphics.print(tokenType, x, propY + 60)
                end
            end
        elseif not isUnlocked then
            -- Do not show any token images for locked characters
        else
            love.graphics.setColor(0.7, 0.7, 0.7)
            love.graphics.print("None", pane.x + 60, propY + 60)
        end
        
        -- Description (with word wrapping)
        if selectedSpell.description then
            love.graphics.setColor(0.8, 0.8, 0.8)
            local descY = propY + 90
            love.graphics.printf("Description:", pane.x + 15, descY, pane.w - 30)
            
            if isUnlocked then
                love.graphics.setColor(0.7, 0.7, 0.8)
                love.graphics.printf(selectedSpell.description, pane.x + 15, descY + 25, pane.w - 30)
            else
                -- Show redacted description for locked characters
                love.graphics.setColor(0.7, 0.7, 0.8)
                love.graphics.printf(string.rep("?", 100), pane.x + 15, descY + 25, pane.w - 30)
            end
        end
        
        -- Draw keywords if present
        if selectedSpell.keywords and next(selectedSpell.keywords) then
            local keywordY = propY + 170
            love.graphics.setColor(0.8, 0.8, 0.8)
            love.graphics.print("Keywords:", pane.x + 15, keywordY)
            
            love.graphics.setColor(0.6, 0.8, 0.6)
            local y = keywordY + 25
            for keyword, params in pairs(selectedSpell.keywords) do
                local keywordText = "- " .. keyword
                if type(params) == "table" and next(params) then
                    keywordText = keywordText .. " (" 
                    local paramTexts = {}
                    for k, v in pairs(params) do
                        table.insert(paramTexts, k .. ": " .. tostring(v))
                    end
                    keywordText = keywordText .. table.concat(paramTexts, ", ") .. ")"
                end
                love.graphics.print(keywordText, pane.x + 20, y)
                y = y + 20
            end
        end
        
        -- Reset scissor
        love.graphics.setScissor()
    elseif selectedSpell and not isUnlocked then
        -- Character is locked, show mystery message
        setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
        
        love.graphics.setColor(0.6, 0.6, 0.7)
        love.graphics.print("???", pane.x + 15, pane.y + 60, 0, 1.3, 1.3)
        
        love.graphics.setColor(0.5, 0.5, 0.6)
        love.graphics.print("Unlock this character to view spell details", 
                           pane.x + 15, pane.y + 100)
        
        love.graphics.setScissor()
    else
        -- No spell selected
        love.graphics.setColor(0.7, 0.7, 0.7)
        love.graphics.print("Select a spell to see details", pane.x + 15, pane.y + 60)
    end
    
    -- Bottom Left: Available spells with scrolling
    local pane = panes.bottomLeft
    local spells = data.spells or {}
    local spellCount = #spells
    local spellLineHeight = 20 -- Height of each spell entry
    local maxVisibleSpells = math.floor((pane.h - 50) / spellLineHeight) -- 50px for padding/header
    
    -- Set a scissor to clip content to the pane
    setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
    
    if isUnlocked then
        -- Draw visible spells for unlocked characters
        for i = 1, maxVisibleSpells do
            local spellIdx = i + game.compendium.scrollOffset
            if spellIdx <= spellCount then
                local spell = spells[spellIdx]
                local y = pane.y + 40 + (i-1)*spellLineHeight
                
                -- Highlight selected spell
                if spellIdx == game.compendium.cursor then
                    love.graphics.setColor(0.3, 0.3, 0.5, 0.7)
                    love.graphics.rectangle("fill", pane.x + 5, y - 2, pane.w - 10, spellLineHeight)
                    love.graphics.setColor(1, 1, 0)
                else
                    love.graphics.setColor(0.9, 0.9, 0.9)
                end
                
                -- Show spell name, grayed out if locked
                local text = spell.name
                if not game.unlockedSpells[spell.id] then
                    text = "[LOCKED] " .. text
                    love.graphics.setColor(0.6, 0.6, 0.6)
                end
                love.graphics.print(text, pane.x + 20, y)
            end
        end
    else
        -- For locked characters, show mystery entries
        for i = 1, 5 do
            local y = pane.y + 40 + (i-1)*spellLineHeight
            
            if i == game.compendium.cursor then
                love.graphics.setColor(0.3, 0.3, 0.5, 0.7)
                love.graphics.rectangle("fill", pane.x + 5, y - 2, pane.w - 10, spellLineHeight)
                love.graphics.setColor(0.7, 0.7, 0.7)
            else
                love.graphics.setColor(0.5, 0.5, 0.5)
            end
            
            -- Mystery text
            love.graphics.print("???", pane.x + 20, y)
        end
        
        -- Message about unlocking
        love.graphics.setColor(0.5, 0.5, 0.6)
        love.graphics.print("Unlock this character to see spells", 
                           pane.x + 20, pane.y + 40 + 6*spellLineHeight)
    end
    
    -- Draw scrollbar if needed
    if spellCount > maxVisibleSpells then
        love.graphics.setColor(0.4, 0.4, 0.6, 0.8)
        local scrollBarHeight = pane.h - 45
        local scrollThumbHeight = math.max(20, scrollBarHeight * (maxVisibleSpells / spellCount))
        local scrollThumbPos = (game.compendium.scrollOffset / (spellCount - maxVisibleSpells)) * 
                               (scrollBarHeight - scrollThumbHeight)
        
        -- Draw track
        love.graphics.setColor(0.2, 0.2, 0.3, 0.5)
        love.graphics.rectangle("fill", pane.x + pane.w - 15, pane.y + 40, 10, scrollBarHeight)
        
        -- Draw thumb
        love.graphics.setColor(0.4, 0.4, 0.6, 0.8)
        love.graphics.rectangle("fill", 
                                pane.x + pane.w - 15, 
                                pane.y + 40 + scrollThumbPos, 
                                10, 
                                scrollThumbHeight)
    end
    
    -- Reset scissor
    love.graphics.setScissor()
    
    -- Top Right: Character View
    local pane = panes.topRight
    setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
    
    -- Character name with larger font
    love.graphics.setColor(1, 1, 0.8)
    if isUnlocked then
        love.graphics.print(name, pane.x + pane.w/2 - game.font:getWidth(name)/2, pane.y + 45, 0, 1.3, 1.3)
    else
        local hiddenName = "???"
        love.graphics.print(hiddenName, pane.x + pane.w/2 - game.font:getWidth(hiddenName)/2, pane.y + 45, 0, 1.3, 1.3)
    end
    
    -- Character sprite
    local spriteY = pane.y + 80
    local spriteFileName = "assets/sprites/" .. string.lower(name) .. ".png"
    local sprite = AssetCache.getImage(spriteFileName)
    
    if sprite then
        -- For unlocked characters, show normal sprite. For locked, show silhouette
        if isUnlocked then
            love.graphics.setColor(1, 1, 1)
        else
            -- Silhouette color - complete black for a more compelling tease
            love.graphics.setColor(0, 0, 0, 1)
        end
        
        -- Calculate scaled dimensions to fit in the pane while maintaining aspect ratio
        local baseScale = 3 -- Increased base scale by 3x as requested
        local maxWidth = pane.w - 40
        local maxHeight = pane.h - 150
        
        local spriteWidth = sprite:getWidth()
        local spriteHeight = sprite:getHeight()
        
        -- Start with the 3x scale, but reduce if needed to fit
        local scale = baseScale
        if (spriteWidth * scale) > maxWidth or (spriteHeight * scale) > maxHeight then
            local scaleX = maxWidth / spriteWidth
            local scaleY = maxHeight / spriteHeight
            scale = math.min(scaleX, scaleY)
        end
        
        local scaledWidth = spriteWidth * scale
        local scaledHeight = spriteHeight * scale
        local x = pane.x + (pane.w - scaledWidth) / 2
        
        love.graphics.draw(sprite, x, spriteY, 0, scale, scale)
        
        -- Character color display as a color box (only for unlocked characters)
        if data.color and isUnlocked then
            local colorY = spriteY + scaledHeight + 20
            love.graphics.setColor(data.color[1]/255, data.color[2]/255, data.color[3]/255)
            love.graphics.rectangle("fill", pane.x + pane.w/2 - 40, colorY, 80, 20)
            love.graphics.setColor(1, 1, 1)
            love.graphics.rectangle("line", pane.x + pane.w/2 - 40, colorY, 80, 20)
            
            -- Label for the color
            love.graphics.setColor(0.9, 0.9, 0.9)
            love.graphics.print("Character Color", 
                                pane.x + pane.w/2 - game.font:getWidth("Character Color")/2, 
                                colorY + 30)
        elseif data.color and not isUnlocked then
            -- For locked characters, show a mystery color box
            local colorY = spriteY + scaledHeight + 20
            love.graphics.setColor(0.3, 0.3, 0.3)
            love.graphics.rectangle("fill", pane.x + pane.w/2 - 40, colorY, 80, 20)
            love.graphics.setColor(0.4, 0.4, 0.4)
            love.graphics.rectangle("line", pane.x + pane.w/2 - 40, colorY, 80, 20)
            
            -- Mystery label
            love.graphics.setColor(0.6, 0.6, 0.6)
            local hiddenLabel = "???"
            love.graphics.print(hiddenLabel, 
                                pane.x + pane.w/2 - game.font:getWidth(hiddenLabel)/2, 
                                colorY + 30)
        end
    else
        -- Fallback if sprite not found
        if isUnlocked then
            love.graphics.setColor(0.7, 0.7, 0.7)
            love.graphics.print("Character sprite not available", 
                                pane.x + 20, 
                                pane.y + 100)
        else
            -- Black rectangle silhouette as fallback for locked characters
            love.graphics.setColor(0, 0, 0, 1)
            love.graphics.rectangle("fill", pane.x + pane.w/2 - 40, pane.y + 100, 80, 120)
        end
    end
    
    love.graphics.setScissor()
    
    -- Bottom Right: Configured Spellbook View
    local pane = panes.bottomRight
    setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 5)
    
    -- Slot key input mappings
    local keyMapping = {
        ["1"] = "1",
        ["2"] = "2",
        ["3"] = "3",
        ["12"] = "1+2",
        ["13"] = "1+3",
        ["23"] = "2+3",
        ["123"] = "1+2+3"
    }
    
    -- Get active spellbook (custom or default)
    local active = game.customSpellbooks[name] or data.spellbook
    
    -- Draw each slot (removed instructions to save space)
    for i, key in ipairs(slotKeys) do
        local spell = active[key]
        local y = pane.y + 40 + (i-1)*28
        
        -- Check if a number key is being held to highlight slot
        local isSlotSelected = false
        if isUnlocked and game.currentState == "COMPENDIUM" and game.menuInput and game.menuInput[tostring(i)] then
            isSlotSelected = true
        end
        
        -- Check if this slot has the assignment feedback active
        local isAssignFeedback = isUnlocked and game.compendium.assignFeedback.active and 
                                game.compendium.assignFeedback.slot == i
        
        -- Slot background
        if isAssignFeedback then
            -- Bright successful assignment highlight
            love.graphics.setColor(0.3, 0.8, 0.3, 0.7)
        elseif isSlotSelected then
            -- Selection highlight when hovering
            love.graphics.setColor(0.4, 0.5, 0.4, 0.7)
        else
            -- Normal background
            love.graphics.setColor(0.25, 0.25, 0.35, 0.7)
        end
        love.graphics.rectangle("fill", pane.x + 10, y - 3, pane.w - 20, 24)
        
        -- Slot border
        love.graphics.setColor(0.4, 0.4, 0.6)
        love.graphics.rectangle("line", pane.x + 10, y - 3, pane.w - 20, 24)
        
        -- Slot input hint
        love.graphics.setColor(1, 1, 0.6)
        local inputHint = "[" .. keyMapping[key] .. "]"
        love.graphics.print(inputHint, pane.x + 15, y)
        
        -- Slot assigned spell
        local displayText
        if isUnlocked then
            if spell then
                love.graphics.setColor(1, 1, 1)
                displayText = spell.name
            else
                love.graphics.setColor(0.6, 0.6, 0.6)
                displayText = "--- Empty ---"
            end
        else
            -- For locked characters, show redacted text
            love.graphics.setColor(0.6, 0.6, 0.6)
            displayText = "??? ?????"
        end
        
        -- Calculate position for the spell name so it's properly spaced from the input hint
        local hintWidth = game.font:getWidth(inputHint)
        love.graphics.print(displayText, pane.x + 25 + hintWidth, y)
    end
    
    -- Draw explanatory text about the slot system
    love.graphics.setColor(0.7, 0.7, 0.8, 0.8)
    local explanationY = pane.y + 40 + 7 * 28 + 15
    
    if isUnlocked then
        love.graphics.printf(
            "Combine keys to cast different spells. For example, pressing 1+2 together will cast the spell assigned to slot 4.",
            pane.x + 15, 
            explanationY,
            pane.w - 30
        )
    else
        love.graphics.printf(
            "???????? ???? ?? ???? ????????? ?????? ???????? ??? ???????? ???? ???? ?? ???? ? ??????",
            pane.x + 15, 
            explanationY,
            pane.w - 30
        )
    end
    
    love.graphics.setScissor()
    
    -- Display assignment error message if present
    if game.assignmentError and game.assignmentError.timer > 0 then
        love.graphics.setColor(1, 0.3, 0.3, math.min(1, game.assignmentError.timer))
        love.graphics.printf(
            game.assignmentError.message,
            screenWidth/2 - 200,
            screenHeight - 60,
            400,
            "center"
        )
    end
    
    -- Reduce the height of the header to make room for the footer
    headerHeight = 40 -- Reduced from 50
    
    -- Calculate footer position (now above the bottom panes to avoid overlap)
    local footerTop = screenHeight - footerHeight
    
    -- Draw footer background
    love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
    love.graphics.rectangle("fill", 0, footerTop, screenWidth, footerHeight)
    
    -- Draw footer separator line
    love.graphics.setColor(0.4, 0.4, 0.7, 0.5)
    love.graphics.rectangle("fill", 20, footerTop, screenWidth - 40, 1)
    
    -- Instructions at the bottom with key highlighting
    local instructions = {
        {text = "Left/Right", color = {1, 0.8, 0.4}},
        {text = " to change wizard, ", color = {0.8, 0.8, 0.9}},
        {text = "Up/Down", color = {1, 0.8, 0.4}},
        {text = " to select spell, ", color = {0.8, 0.8, 0.9}},
        {text = "1-7", color = {1, 0.8, 0.4}},
        {text = " to assign spell to slot", color = {0.8, 0.8, 0.9}}
    }
    
    local x = 20
    local y = footerTop + 15 -- Center text in footer
    
    for _, part in ipairs(instructions) do
        love.graphics.setColor(part.color)
        love.graphics.print(part.text, x, y, 0, 0.9, 0.9)
        x = x + game.font:getWidth(part.text) * 0.9
    end
    
    -- Store pane layout in the game state for future reference
    game.compendiumPanes = panes
end

-- Draw attract mode overlay
function drawAttractModeOverlay()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    -- Draw a semi-transparent banner at the top
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 0, 0, screenWidth, 40)

    -- Draw "Attract Mode" text
    love.graphics.setColor(1, 1, 1, 0.9)
    local attractText = "ATTRACT MODE - PRESS ANY KEY TO RETURN TO MENU"
    local textWidth = game.font:getWidth(attractText) * 1.5

    -- Make text pulse slightly to draw attention
    local pulse = 0.8 + 0.2 * math.sin(love.timer.getTime() * 3)
    love.graphics.setColor(1, 1, 1, pulse)
    love.graphics.print(
        attractText,
        screenWidth / 2 - textWidth / 2,
        10,
        0, -- rotation
        1.5, -- scale X
        1.5  -- scale Y
    )

    -- Draw AI info text at bottom
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 0, screenHeight - 40, screenWidth, 40)

    -- Show which AI personalities are fighting
    local aiInfoText = "AI DUEL: " .. game.wizards[1].name .. " vs " .. game.wizards[2].name
    local aiTextWidth = game.font:getWidth(aiInfoText)

    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(
        aiInfoText,
        screenWidth / 2 - aiTextWidth / 2,
        screenHeight - 30
    )
end

-- Unified key handler using the Input module
function love.keypressed(key, scancode, isrepeat)
    -- First check if we're in attract mode - any key exits attract mode
    if game.attractModeActive then
        exitAttractMode()
        return true -- Key handled
    end

    -- Forward all key presses to the Input module for normal gameplay
    return Input.handleKey(key, scancode, isrepeat)
end

-- Unified key release handler
function love.keyreleased(key, scancode)
    -- Skip key release handling if in attract mode (already handled in keypressed)
    if game.attractModeActive then
        return true -- Key handled
    end

    -- Forward all key releases to the Input module
    return Input.handleKeyReleased(key, scancode)
end

-- Handle gamepad button presses
function love.gamepadpressed(joystick, button)
    local jid = joystick:getID()
    if not game.p1GamepadID then
        game.p1GamepadID = jid
    elseif not game.p2GamepadID and not game.useAI then
        game.p2GamepadID = jid
        game.p2UsingGamepad = true
    end
    if game.attractModeActive then
        exitAttractMode()
        return true
    end
    return Input.handleGamepadButton(jid, button, true)
end

function love.gamepadreleased(joystick, button)
    local jid = joystick:getID()
    return Input.handleGamepadButton(jid, button, false)
end

-- Handle analog stick movement
function love.gamepadaxis(joystick, axis, value)
    local jid = joystick:getID()
    return Input.handleGamepadAxis(jid, axis, value)
end

-- Track gamepad connections
function love.joystickadded(joystick)
    local jid = joystick:getID()
    if not game.p1GamepadID then
        game.p1GamepadID = jid
    elseif not game.p2GamepadID and not game.useAI then
        game.p2GamepadID = jid
        game.p2UsingGamepad = true
    end
end

function love.joystickremoved(joystick)
    local jid = joystick:getID()
    if game.p1GamepadID == jid then
        game.p1GamepadID = nil
    elseif game.p2GamepadID == jid then
        game.p2GamepadID = nil
        game.p2UsingGamepad = false
    end
end
```

## ./manapool.lua
```lua
-- ManaPool class
-- Represents the shared pool of mana tokens in the center

-- Import modules at module level so they're available to all methods
local AssetCache = require("core.AssetCache")
local Constants = require("core.Constants")
local Pool = require("core.Pool")

local ManaPool = {}
ManaPool.__index = ManaPool

function ManaPool.new(x, y)
    local self = setmetatable({}, ManaPool)
    
    self.x = x
    self.y = y
    self.tokens = {}  -- List of mana tokens
    
    -- Make elliptical shape even flatter and wider
    self.radiusX = 280  -- Wider horizontal radius
    self.radiusY = 60   -- Flatter vertical radius
    
    -- Define orbital rings (valences) for tokens to follow
    self.valences = {
        {radiusX = 180, radiusY = 25, baseSpeed = 0.35},  -- Inner valence
        {radiusX = 230, radiusY = 40, baseSpeed = 0.25},  -- Middle valence
        {radiusX = 280, radiusY = 55, baseSpeed = 0.18}   -- Outer valence
    }
    
    -- Chance for a token to switch valences
    self.valenceJumpChance = 0.002  -- Per frame chance of switching
    
    -- Initialize token trails system
    self.tokenTrails = {}
    self.trailLength = 30  -- Max number of positions to store per token
    
    -- Initialize the token pool if not already done
    if not Pool.pools["token"] then
        Pool.create("token", 50, function() 
            return {} -- Simple factory function that creates an empty table
        end, ManaPool.resetToken) -- Use our custom token reset function
    end
    
    return self
end

-- Token methods for state machine
local TokenMethods = {}

-- Set the token's state with validation
function TokenMethods:setState(newStatus)
    local oldStatus = self.status

    -- Validate state transitions
    if self.status == Constants.TokenStatus.POOLED then
        print("[TOKEN LIFECYCLE] WARNING: Cannot transition from POOLED state!")
        return false
    end

    -- Finalize scale if leaving an animation state that modifies scale
    if (oldStatus == Constants.TokenStatus.APPEARING or oldStatus == Constants.TokenStatus.ORBITING) and
       (newStatus == Constants.TokenStatus.CHANNELED or
        newStatus == Constants.TokenStatus.SHIELDING or
        newStatus == Constants.TokenStatus.FREE) then
        if self.targetScale then
            self.scale = self.targetScale
        else
            self.scale = 0.85 + math.random() * 0.3
        end
    end

    -- Update the token's status
    self.status = newStatus
    
    -- For backwards compatibility, keep the legacy state in sync with the new status
    if newStatus == Constants.TokenStatus.FREE or 
       newStatus == Constants.TokenStatus.CHANNELED or 
       newStatus == Constants.TokenStatus.SHIELDING then
        self.state = newStatus
    elseif newStatus == Constants.TokenStatus.RETURNING or
           newStatus == Constants.TokenStatus.APPEARING or
           newStatus == Constants.TokenStatus.ORBITING then
        self.state = self.originalStatus or Constants.TokenState.FREE -- Keep original state during animation
    elseif newStatus == Constants.TokenStatus.DISSOLVING then
        self.state = Constants.TokenState.DESTROYED
    elseif newStatus == Constants.TokenStatus.POOLED then
        self.state = Constants.TokenState.DESTROYED
    end
    
    return true
end

-- Request token return animation
function TokenMethods:requestReturnAnimation()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.CHANNELED and self.status ~= Constants.TokenStatus.SHIELDING then
        print("[TOKEN LIFECYCLE] WARNING: Can only return tokens from CHANNELED or SHIELDING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Store the original status for later reference
    self.originalStatus = self.status
    
    -- Set animation flags
    self.isAnimating = true
    self.returning = true  -- For backward compatibility
    
    -- Set animation parameters
    self.startX = self.x
    self.startY = self.y
    self.animTime = 0
    self.animDuration = 0.5 -- Half second return animation
    
    -- Store callback to be called when animation completes
    self.animationCallback = function() self:finalizeReturn() end
    
    -- Change state to RETURNING
    self:setState(Constants.TokenStatus.RETURNING)
    
    return true
end

-- Request token destruction animation
function TokenMethods:requestDestructionAnimation()
    -- Validate current state
    if self.status == Constants.TokenStatus.DISSOLVING or self.status == Constants.TokenStatus.POOLED then
        print("[TOKEN LIFECYCLE] Token is already dissolving or pooled")
        return false
    end
    
    -- Set animation flags
    self.isAnimating = true
    self.dissolving = true  -- For backward compatibility
    
    -- Set animation parameters
    self.dissolveTime = 0
    self.dissolveMaxTime = 0.8  -- Dissolution animation duration
    self.dissolveScale = self.scale or 1.0
    self.initialX = self.x
    self.initialY = self.y
    
    -- Store callback to be called when animation completes
    self.animationCallback = function() self:finalizeDestruction() end
    
    -- Change state to DISSOLVING
    self:setState(Constants.TokenStatus.DISSOLVING)
    
    -- Create visual particle effects at the token's position using events
    if not self.exploding and self.gameState then
        self.exploding = true
        
        -- Get token color based on its type
        local colorTable = Constants.getColorForTokenType(self.type)
        
        -- Create an EFFECT event instead of calling VFX directly
        if self.gameState.eventRunner then
            local event = {
                type = "EFFECT",
                source = "token",
                target = Constants.TargetType.SELF, -- Not targeting a wizard
                effectType = Constants.VFXType.IMPACT,
                duration = 0.7,
                vfxParams = {
                    x = self.x,  -- Pass coordinates directly in vfxParams
                    y = self.y,
                    color = colorTable,
                    particleCount = 15,
                    radius = 30,
                    tokenType = self.type
                }
            }
            
            -- Process the event immediately
            self.gameState.eventRunner.processEvents({event}, self, nil)
        else
            print("[TOKEN LIFECYCLE] Warning: No eventRunner in gameState for token VFX")
        end
    end
    
    return true
end

-- Finalize return to pool after animation (first phase)
function TokenMethods:finalizeReturn()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.RETURNING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize return from RETURNING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Reset some animation flags but keep isAnimating true for orbit animation
    self.returning = false  -- For backward compatibility
    
    -- Clear wizard/spell references
    self.wizardOwner = nil
    self.spellSlot = nil
    self.tokenIndex = nil
    
    -- Get the ManaPool instance from the token's game state or another reference
    local manaPool = self.manaPool
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token return!")
        return false
    end
    
    -- Choose a random valence for the token's destination
    local valenceIndex = math.random(1, #manaPool.valences)
    local valence = manaPool.valences[valenceIndex]
    self.valenceIndex = valenceIndex
    
    -- Calculate a random angle for the token's destination
    -- We'll use a random angle rather than the current angle to ensure
    -- tokens don't all follow the same path
    local angle = math.random() * math.pi * 2
    self.orbitAngle = angle
    
    -- Calculate target position based on valence
    local targetX = manaPool.x + math.cos(angle) * valence.radiusX
    local targetY = manaPool.y + math.sin(angle) * valence.radiusY
    
    -- Add slight position variation to the target
    local variationX = math.random(-2, 2)
    local variationY = math.random(-1, 1)
    
    -- Store current position (center of pool) as start for orbit animation
    self.startOrbitX = self.x
    self.startOrbitY = self.y
    
    -- Store target position for orbit animation
    self.targetOrbitX = targetX + variationX
    self.targetOrbitY = targetY + variationY
    
    -- Set up orbit animation parameters
    self.orbitAnimTime = 0
    self.orbitAnimDuration = 0.8  -- Slightly faster than return animation
    
    -- Set an animation callback for when the orbit animation completes
    self.animationCallback = function() self:finalizeOrbit() end
    
    -- Set transitioning to orbit state
    self:setState(Constants.TokenStatus.ORBITING)
    
    -- Randomize orbit direction and speed
    local direction = math.random(0, 1) * 2 - 1  -- -1 or 1
    self.orbitSpeed = valence.baseSpeed * (0.8 + math.random() * 0.4) * direction
    self.originalSpeed = self.orbitSpeed
    
    -- Initialize valence properties
    self.valenceJumpTimer = 2 + math.random() * 8
    self.inValenceTransition = false
    self.valenceTransitionTime = 0
    self.valenceTransitionDuration = 0.8
    self.sourceValenceIndex = valenceIndex
    self.targetValenceIndex = valenceIndex
    self.sourceRadiusX = valence.radiusX
    self.sourceRadiusY = valence.radiusY
    self.targetRadiusX = valence.radiusX
    self.targetRadiusY = valence.radiusY
    self.currentRadiusX = valence.radiusX
    self.currentRadiusY = valence.radiusY
    
    -- Visual variance
    self.scale = 0.85 + math.random() * 0.3
    self.zOrder = math.random()
    
    return true
end

-- Finalize orbit transition (second phase)
function TokenMethods:finalizeOrbit()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.ORBITING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize orbit from ORBITING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Reset animation flags
    self.isAnimating = false
    
    -- Get the ManaPool instance from the token's game state or another reference
    local manaPool = self.manaPool
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token orbit!")
        return false
    end
    
    -- Update position to make sure it's at the target
    self.x = self.targetOrbitX
    self.y = self.targetOrbitY

    -- Ensure scale is finalized
    if self.targetScale then
        self.scale = self.targetScale
    else
        self.scale = 0.85 + math.random() * 0.3
    end
    
    -- Clean up orbit animation properties
    self.startOrbitX = nil
    self.startOrbitY = nil
    self.targetOrbitX = nil
    self.targetOrbitY = nil
    self.orbitAnimTime = nil
    self.orbitAnimDuration = nil
    
    -- Set state to FREE
    self:setState(Constants.TokenStatus.FREE)
    
    -- Set transition flags for smooth animation of orbital motion
    self.transitionTime = 0
    self.transitionDuration = 0.4  -- Shorter orbital transition (was 1.0)
    self.inTransition = true
    
    return true
end

-- Initialize conjured token appearance animation
function TokenMethods:requestAppearAnimation(fromWizard)
    -- Set up animation parameters
    self.isAnimating = true
    
    -- Store the source position (wizard position)
    self.startX = fromWizard.x
    self.startY = fromWizard.y - 40  -- Start a little above the wizard
    
    -- Initialize animation timing
    self.appearAnimTime = 0
    self.appearAnimDuration = 0.7  -- Slightly longer than return animation
    
    -- Set the target scale
    self.targetScale = 0.85 + math.random() * 0.3
    
    -- Start very small
    self.scale = 0.1
    
    -- Initial position is at the wizard
    self.x = self.startX
    self.y = self.startY
    
    -- Prepare callback for when animation completes
    self.animationCallback = function() self:finalizeAppear() end
    
    -- Set status to APPEARING
    self:setState(Constants.TokenStatus.APPEARING)
    
    return true
end

-- Finalize appear animation and transition to orbiting
function TokenMethods:finalizeAppear()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.APPEARING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize appear from APPEARING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Maintain animation flag
    self.isAnimating = true
    
    -- Get the ManaPool instance from the token's game state
    local manaPool = self.manaPool
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token appearance!")
        return false
    end
    
    -- Choose a random valence for the token's destination
    local valenceIndex = math.random(1, #manaPool.valences)
    local valence = manaPool.valences[valenceIndex]
    self.valenceIndex = valenceIndex
    
    -- Calculate a random angle for the token's destination
    local angle = math.random() * math.pi * 2
    self.orbitAngle = angle
    
    -- Calculate target position based on valence
    local targetX = manaPool.x + math.cos(angle) * valence.radiusX
    local targetY = manaPool.y + math.sin(angle) * valence.radiusY
    
    -- Add slight position variation to the target
    local variationX = math.random(-2, 2)
    local variationY = math.random(-1, 1)
    
    -- Store current position (center of pool) as start for orbit animation
    self.startOrbitX = self.x
    self.startOrbitY = self.y
    
    -- Store target position for orbit animation
    self.targetOrbitX = targetX + variationX
    self.targetOrbitY = targetY + variationY
    
    -- Set up orbit animation parameters
    self.orbitAnimTime = 0
    self.orbitAnimDuration = 0.8  -- Slightly faster than return animation
    
    -- Set an animation callback for when the orbit animation completes
    self.animationCallback = function() self:finalizeOrbit() end
    
    -- Set transitioning to orbit state
    self:setState(Constants.TokenStatus.ORBITING)
    
    -- Randomize orbit direction and speed
    local direction = math.random(0, 1) * 2 - 1  -- -1 or 1
    self.orbitSpeed = valence.baseSpeed * (0.8 + math.random() * 0.4) * direction
    self.originalSpeed = self.orbitSpeed
    
    -- Initialize valence properties
    self.valenceJumpTimer = 2 + math.random() * 8
    self.inValenceTransition = false
    self.valenceTransitionTime = 0
    self.valenceTransitionDuration = 0.8
    self.sourceValenceIndex = valenceIndex
    self.targetValenceIndex = valenceIndex
    self.sourceRadiusX = valence.radiusX
    self.sourceRadiusY = valence.radiusY
    self.targetRadiusX = valence.radiusX
    self.targetRadiusY = valence.radiusY
    self.currentRadiusX = valence.radiusX
    self.currentRadiusY = valence.radiusY

    -- Visual variance set during appearing animation
    self.scale = self.targetScale
    self.zOrder = math.random()
    
    return true
end

-- Finalize token destruction and release to pool
function TokenMethods:finalizeDestruction()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.DISSOLVING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize destruction from DISSOLVING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Reset animation flags
    self.isAnimating = false
    self.dissolving = false  -- For backward compatibility
    
    -- Set new state
    self:setState(Constants.TokenStatus.POOLED)
    
    -- Get the token's index in the mana pool
    local found = false
    local manaPool = self.manaPool
    local index = nil
    
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token destruction!")
        return false
    end
    
    for i, t in ipairs(manaPool.tokens) do
        if t == self then
            index = i
            found = true
            break
        end
    end
    
    if found and index then
        -- Remove the token from the mana pool's token list
        table.remove(manaPool.tokens, index)
    else
        print("[TOKEN LIFECYCLE] WARNING: Token not found in manaPool.tokens during finalization!")
    end
    
    -- Release the token back to the object pool
    Pool.release("token", self)
    
    return true
end

-- Token reset function for the pool
function ManaPool.resetToken(token)
    -- Remove all methods first
    for name, _ in pairs(TokenMethods) do
        token[name] = nil
    end
    
    -- Clear token trails if they exist
    if token.manaPool and token.manaPool.tokenTrails and token.manaPool.tokenTrails[token] then
        token.manaPool.tokenTrails[token] = nil
    end
    
    -- Clear all references and fields
    token.type = nil
    token.image = nil
    token.x = nil
    token.y = nil
    token.state = nil
    token.status = nil  -- New field for the state machine
    token.isAnimating = nil  -- New field to track animation state
    token.animationCallback = nil  -- New field for animation completion callback
    token.originalStatus = nil  -- To store the state before transitions
    token.valenceIndex = nil
    token.orbitAngle = nil
    token.orbitSpeed = nil
    token.pulsePhase = nil
    token.pulseSpeed = nil
    token.rotAngle = nil
    token.rotSpeed = nil
    token.valenceJumpTimer = nil
    token.inValenceTransition = nil
    token.valenceTransitionTime = nil
    token.valenceTransitionDuration = nil
    token.sourceValenceIndex = nil
    token.targetValenceIndex = nil
    token.sourceRadiusX = nil
    token.sourceRadiusY = nil
    token.targetRadiusX = nil
    token.targetRadiusY = nil
    token.currentRadiusX = nil
    token.currentRadiusY = nil
    token.scale = nil
    token.targetScale = nil
    token.zOrder = nil
    
    -- Clear animation-specific fields
    token.startOrbitX = nil
    token.startOrbitY = nil
    token.targetOrbitX = nil
    token.targetOrbitY = nil
    token.orbitAnimTime = nil
    token.orbitAnimDuration = nil
    token.appearAnimTime = nil
    token.appearAnimDuration = nil
    token.startX = nil
    token.startY = nil
    token.originalSpeed = nil
    token.wizardOwner = nil
    token.spellSlot = nil
    token.dissolving = nil
    token.gameState = nil
    token.manaPool = nil  -- New field to reference the mana pool
    token.id = nil  -- New field for tracking tokens
    
    -- Clear animation-related fields
    token.returning = nil
    token.animTime = nil
    token.animDuration = nil
    token.startX = nil
    token.startY = nil
    token.targetX = nil
    token.targetY = nil
    token.tokenIndex = nil
    token.inTransition = nil
    token.transitionTime = nil
    token.transitionDuration = nil
    token.originalState = nil
    token.dissolveTime = nil
    token.dissolveMaxTime = nil
    token.dissolveScale = nil
    token.initialX = nil
    token.initialY = nil
    token.exploding = nil
    
    return token
end

-- Clear all tokens from the mana pool
function ManaPool:clear()
    -- Release all tokens back to the pool
    for _, token in ipairs(self.tokens) do
        Pool.release("token", token)
    end
    
    self.tokens = {}
    self.reservedTokens = {}
    self.tokenTrails = {} -- Clear token trails when clearing the pool
end

-- Standard token addition - creates token directly at its final position
function ManaPool:addToken(tokenType, imagePath)
    -- Pick a random valence for the token
    local valenceIndex = math.random(1, #self.valences)
    local valence = self.valences[valenceIndex]
    
    -- Calculate a random angle along the valence
    local angle = math.random() * math.pi * 2
    
    -- Calculate position based on elliptical path
    local x = self.x + math.cos(angle) * valence.radiusX
    local y = self.y + math.sin(angle) * valence.radiusY
    
    -- Generate slight positional variation to avoid tokens stacking perfectly
    local variationX = math.random(-5, 5)
    local variationY = math.random(-3, 3)
    
    -- Randomize orbit direction (clockwise or counter-clockwise)
    local direction = math.random(0, 1) * 2 - 1  -- -1 or 1
    
    -- Get image from cache, with fallback
    local tokenImage = AssetCache.getImage(imagePath)
    if not tokenImage then
        print("WARNING: Failed to load token image: " .. imagePath .. " - using placeholder")
        -- Create a placeholder image using LÖVE's built-in canvas
        tokenImage = love.graphics.newCanvas(32, 32)
        love.graphics.setCanvas(tokenImage)
        love.graphics.clear(0.8, 0.2, 0.8, 1) -- Bright color to make missing textures obvious
        love.graphics.rectangle("fill", 0, 0, 32, 32)
        love.graphics.setCanvas()
    end
    
    -- Create a new token from the pool
    local token = Pool.acquire("token")
    
    -- Add methods from TokenMethods table
    for name, method in pairs(TokenMethods) do
        token[name] = method
    end
    
    -- Initialize basic properties
    token.type = tokenType
    token.image = tokenImage
    token.x = x + variationX
    token.y = y + variationY
    
    -- Initialize state machine properties
    token.status = Constants.TokenStatus.FREE
    token.state = Constants.TokenState.FREE -- For backwards compatibility
    token.isAnimating = false
    token.manaPool = self -- Reference to this mana pool instance
    token.id = #self.tokens + 1
    
    token.valenceIndex = valenceIndex
    token.orbitAngle = angle
    token.orbitSpeed = valence.baseSpeed * (0.8 + math.random() * 0.4) * direction
    
    -- Visual effects
    token.pulsePhase = math.random() * math.pi * 2
    token.pulseSpeed = 2 + math.random() * 3
    token.rotAngle = math.random() * math.pi * 2
    token.rotSpeed = math.random(-2, 2) * 0.5
    
    -- Valence jump timer
    token.valenceJumpTimer = 2 + math.random() * 8
    
    -- Valence transition properties
    token.inValenceTransition = false
    token.valenceTransitionTime = 0
    token.valenceTransitionDuration = 0.8
    token.sourceValenceIndex = valenceIndex
    token.targetValenceIndex = valenceIndex
    token.sourceRadiusX = valence.radiusX
    token.sourceRadiusY = valence.radiusY
    token.targetRadiusX = valence.radiusX
    token.targetRadiusY = valence.radiusY
    token.currentRadiusX = valence.radiusX
    token.currentRadiusY = valence.radiusY
    
    -- Size variation for visual interest
    token.scale = 0.85 + math.random() * 0.3
    
    -- Depth/z-order variation
    token.zOrder = math.random()
    
    token.originalSpeed = token.orbitSpeed
    
    -- If game state is available, store it for VFX access
    if self.gameState then
        token.gameState = self.gameState
    end
    
    -- Add to the pool's token list
    table.insert(self.tokens, token)
    
    return token
end

-- Add token with appearance animation from wizard
function ManaPool:addTokenWithAnimation(tokenType, imagePath, sourceWizard)
    if not sourceWizard then
        -- Fall back to regular addition if no wizard provided
        return self:addToken(tokenType, imagePath)
    end
    
    -- Get image from cache, with fallback
    local tokenImage = AssetCache.getImage(imagePath)
    if not tokenImage then
        print("WARNING: Failed to load token image: " .. imagePath .. " - using placeholder")
        -- Create a placeholder image using LÖVE's built-in canvas
        tokenImage = love.graphics.newCanvas(32, 32)
        love.graphics.setCanvas(tokenImage)
        love.graphics.clear(0.8, 0.2, 0.8, 1) -- Bright color to make missing textures obvious
        love.graphics.rectangle("fill", 0, 0, 32, 32)
        love.graphics.setCanvas()
    end
    
    -- Create a new token with animation-ready properties
    local token = Pool.acquire("token")
    
    -- Add methods from TokenMethods table
    for name, method in pairs(TokenMethods) do
        token[name] = method
    end
    
    -- Initialize basic properties
    token.type = tokenType
    token.image = tokenImage
    
    -- Position will be set by animation
    token.x = sourceWizard.x
    token.y = sourceWizard.y - 40 -- Start slightly above wizard
    
    -- Initialize state machine properties
    token.status = nil -- Will be set to APPEARING by requestAppearAnimation
    token.state = Constants.TokenState.FREE -- For backwards compatibility
    token.isAnimating = true
    token.manaPool = self  -- Reference to this mana pool instance
    token.id = #self.tokens + 1
    
    -- Visual effects
    token.pulsePhase = math.random() * math.pi * 2
    token.pulseSpeed = 2 + math.random() * 3
    token.rotAngle = math.random() * math.pi * 2
    token.rotSpeed = math.random(-2, 2) * 0.5
    
    -- Scale starts small and grows during animation
    token.scale = 0.1
    
    -- If game state is available, store it for VFX access
    if self.gameState then
        token.gameState = self.gameState
    end
    
    -- Add to the pool's token list
    table.insert(self.tokens, token)
    
    -- Start appearance animation
    token:requestAppearAnimation(sourceWizard)
    
    return token
end

-- Removed token repulsion system, reverting to pure orbital motion

function ManaPool:update(dt)
    -- Update token positions and states
    for i = #self.tokens, 1, -1 do
        local token = self.tokens[i]
        
        -- Skip updating POOLED tokens, they've been reset and their properties are nil
        if token.status == Constants.TokenStatus.POOLED then
            goto continue_token
        end
        
        -- Update token trail position history
        if not self.tokenTrails[token] then
            self.tokenTrails[token] = {}
        end
        
        -- Only add a new trail point if the token has moved significantly
        local lastPosition = self.tokenTrails[token][1]
        local shouldAddTrail = true
        
        if lastPosition then
            -- Calculate distance moved since last trail point
            local dx = token.x - lastPosition.x
            local dy = token.y - lastPosition.y
            local distSquared = dx*dx + dy*dy
            
            -- Only add trail points if moved more than a minimum distance
            shouldAddTrail = distSquared > 4
        end
        
        if shouldAddTrail then
            -- Store new position at the beginning of history array
            table.insert(self.tokenTrails[token], 1, {
                x = token.x, 
                y = token.y, 
                time = love.timer.getTime()
            })
            
            -- Limit trail length
            if #self.tokenTrails[token] > self.trailLength then
                table.remove(self.tokenTrails[token])
            end
        end
        
        -- Update token based on its status in the state machine
        if token.status == Constants.TokenStatus.FREE then
            -- Handle the transition period for newly returned tokens
            if token.inTransition then
                token.transitionTime = token.transitionTime + dt
                local transProgress = math.min(1, token.transitionTime / token.transitionDuration)
                
                -- Ease transition using a smooth curve
                transProgress = transProgress < 0.5 and 4 * transProgress * transProgress * transProgress 
                            or 1 - math.pow(-2 * transProgress + 2, 3) / 2
                
                -- During transition, gradually start orbital motion
                token.orbitAngle = token.orbitAngle + token.orbitSpeed * dt * transProgress
                
                -- Check if transition is complete
                if token.transitionTime >= token.transitionDuration then
                    token.inTransition = false
                end
            else
                -- Normal FREE token behavior after transition
                -- Update orbit angle with variable speed
                token.orbitAngle = token.orbitAngle + token.orbitSpeed * dt
                
                -- Update valence jump timer
                token.valenceJumpTimer = token.valenceJumpTimer - dt
                
                -- Chance to change valence when timer expires
                if token.valenceJumpTimer <= 0 then
                    token.valenceJumpTimer = 2 + math.random() * 8  -- Reset timer
                    
                    -- Random chance to jump to a different valence
                    if math.random() < self.valenceJumpChance * 100 then
                        -- Store current valence for interpolation
                        local oldValenceIndex = token.valenceIndex
                        local oldValence = self.valences[oldValenceIndex]
                        local newValenceIndex = oldValenceIndex
                        
                        -- Ensure we pick a different valence if more than one exists
                        if #self.valences > 1 then
                            while newValenceIndex == oldValenceIndex do
                                newValenceIndex = math.random(1, #self.valences)
                            end
                        end
                        
                        -- Start valence transition
                        local newValence = self.valences[newValenceIndex]
                        local direction = token.orbitSpeed > 0 and 1 or -1
                        
                        -- Set up transition parameters
                        token.inValenceTransition = true
                        token.valenceTransitionTime = 0
                        token.valenceTransitionDuration = 0.8  -- Time to transition between valences
                        token.sourceValenceIndex = oldValenceIndex
                        token.targetValenceIndex = newValenceIndex
                        token.sourceRadiusX = oldValence.radiusX
                        token.sourceRadiusY = oldValence.radiusY
                        token.targetRadiusX = newValence.radiusX
                        token.targetRadiusY = newValence.radiusY
                        
                        -- Update speed for new valence but maintain direction
                        token.orbitSpeed = newValence.baseSpeed * (0.8 + math.random() * 0.4) * direction
                        token.originalSpeed = token.orbitSpeed
                    end
                end
                
                -- Handle valence transition if active
                if token.inValenceTransition then
                    token.valenceTransitionTime = token.valenceTransitionTime + dt
                    local progress = math.min(1, token.valenceTransitionTime / token.valenceTransitionDuration)
                    
                    -- Use easing function for smooth transition
                    progress = progress < 0.5 and 4 * progress * progress * progress 
                              or 1 - math.pow(-2 * progress + 2, 3) / 2
                    
                    -- Interpolate between source and target radiuses
                    token.currentRadiusX = token.sourceRadiusX + (token.targetRadiusX - token.sourceRadiusX) * progress
                    token.currentRadiusY = token.sourceRadiusY + (token.targetRadiusY - token.sourceRadiusY) * progress
                    
                    -- Check if transition is complete
                    if token.valenceTransitionTime >= token.valenceTransitionDuration then
                        token.inValenceTransition = false
                        token.valenceIndex = token.targetValenceIndex
                    end
                end
                
                -- Occasionally vary the speed slightly
                if math.random() < 0.01 then
                    local direction = token.orbitSpeed > 0 and 1 or -1
                    local valence = self.valences[token.valenceIndex]
                    local variation = 0.9 + math.random() * 0.2  -- Subtle variation
                    token.orbitSpeed = valence.baseSpeed * variation * direction
                end
            end
            
            -- Common behavior for all FREE tokens
            -- Update pulse phase
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
            -- Calculate new position based on elliptical orbit - maintain perfect elliptical path
            if token.inValenceTransition then
                -- Use interpolated radii during transition
                token.x = self.x + math.cos(token.orbitAngle) * token.currentRadiusX
                token.y = self.y + math.sin(token.orbitAngle) * token.currentRadiusY
            else
                -- Use valence radii when not transitioning
                local valence = self.valences[token.valenceIndex]
                token.x = self.x + math.cos(token.orbitAngle) * valence.radiusX
                token.y = self.y + math.sin(token.orbitAngle) * valence.radiusY
            end
            
            -- Minimal wobble to maintain clean orbits but add slight visual interest
            local wobbleX = math.sin(token.pulsePhase * 0.7) * 2
            local wobbleY = math.cos(token.pulsePhase * 0.5) * 1
            token.x = token.x + wobbleX
            token.y = token.y + wobbleY
            
            -- Rotate token itself for visual interest, occasionally reversing direction
            if token.rotAngle and token.rotSpeed then
                token.rotAngle = token.rotAngle + token.rotSpeed * dt
                if math.random() < 0.002 then  -- Small chance to reverse rotation
                    token.rotSpeed = -token.rotSpeed
                end
            end
            
        elseif token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
            -- For channeled or shielding tokens, animate movement to/from their spell slot
            
            if token.animTime < token.animDuration then
                -- Token is still being animated to the spell slot
                token.animTime = token.animTime + dt
                local progress = math.min(1, token.animTime / token.animDuration)
                
                -- Ease in-out function for smoother animation
                progress = progress < 0.5 and 4 * progress * progress * progress 
                            or 1 - math.pow(-2 * progress + 2, 3) / 2
                
                -- Calculate current position based on bezier curve for arcing motion
                -- Start point
                local x0 = token.startX
                local y0 = token.startY
                
                -- End point (in the spell slot)
                local wizard = token.wizardOwner
                if wizard then
                    -- Calculate position in the 3D elliptical spell slot orbit
                    -- These values must match those in wizard.lua drawSpellSlots
                    local slotYOffsets = {30, 0, -30}  -- legs, midsection, head
                    local horizontalRadii = {80, 70, 60}  -- From bottom to top
                    local verticalRadii = {20, 25, 30}    -- From bottom to top
                    
                    local slotY = wizard.y + slotYOffsets[token.slotIndex]
                    local radiusX = horizontalRadii[token.slotIndex]
                    local radiusY = verticalRadii[token.slotIndex]
                    
                    local tokenCount = #wizard.spellSlots[token.slotIndex].tokens
                    local anglePerToken = math.pi * 2 / tokenCount
                    local tokenAngle = wizard.spellSlots[token.slotIndex].progress / 
                                       wizard.spellSlots[token.slotIndex].castTime * math.pi * 2 +
                                       anglePerToken * (token.tokenIndex - 1)
                    
                    -- Calculate position using elliptical projection
                    -- Apply the NEAR/FAR offset to the target position
                    local xOffset = 0
                    local isNear = wizard.gameState and wizard.gameState.rangeState == Constants.RangeState.NEAR
                    
                    -- Apply the same NEAR/FAR offset logic as in the wizard's draw function
                    local isLeft = true
                    if wizard.gameState and wizard.gameState.wizards then
                        for _, other in ipairs(wizard.gameState.wizards) do
                            if other ~= wizard then
                                isLeft = wizard.x <= other.x
                                break
                            end
                        end
                    end
                    if isLeft then
                        xOffset = isNear and 60 or 0
                    else
                        xOffset = isNear and -60 or 0
                    end
                    
                    local x3 = wizard.x + xOffset + math.cos(tokenAngle) * radiusX
                    local y3 = slotY + math.sin(tokenAngle) * radiusY
                    
                    -- Control points for bezier (creating an arc)
                    local midX = (x0 + x3) / 2
                    local midY = (y0 + y3) / 2 - 80  -- Arc height
                    
                    -- Quadratic bezier calculation
                    local t = progress
                    local u = 1 - t
                    token.x = u*u*x0 + 2*u*t*midX + t*t*x3
                    token.y = u*u*y0 + 2*u*t*midY + t*t*y3
                    
                    -- Update token rotation during flight
                    token.rotAngle = token.rotAngle + dt * 5  -- Spin faster during flight
                    
                    -- Store target position for the drawing function
                    token.targetX = x3
                    token.targetY = y3
                end
            else
                -- Animation complete - token is now in the spell orbit
                -- Token position will be updated by the wizard's drawSpellSlots function
                token.rotAngle = token.rotAngle + dt * 2  -- Continue spinning in orbit
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.RETURNING then
            -- Token is being animated back to the mana pool
            token.animTime = token.animTime + dt
            local progress = math.min(1, token.animTime / token.animDuration)
            
            -- Ease in-out function for smoother animation
            progress = progress < 0.5 and 4 * progress * progress * progress 
                        or 1 - math.pow(-2 * progress + 2, 3) / 2
            
            -- Calculate current position based on bezier curve for arcing motion
            local x0 = token.startX
            local y0 = token.startY
            local x3 = self.x  -- Center of mana pool
            local y3 = self.y
            
            -- Control points for bezier (creating an arc)
            local midX = (x0 + x3) / 2
            local midY = (y0 + y3) / 2 - 50  -- Arc height
            
            -- Quadratic bezier calculation
            local t = progress
            local u = 1 - t
            token.x = u*u*x0 + 2*u*t*midX + t*t*x3
            token.y = u*u*y0 + 2*u*t*midY + t*t*y3
            
            -- Update token rotation during flight - spin faster
            token.rotAngle = token.rotAngle + dt * 8
            
            -- Check if animation is complete
            if token.animTime >= token.animDuration then
                -- Token has reached the pool - call the animation callback
                if token.animationCallback then
                    token.animationCallback()
                else
                    print("[MANAPOOL] WARNING: No animation callback defined for returning token")
                    -- Fallback for backward compatibility
                    token:setState(Constants.TokenStatus.FREE)
                end
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.APPEARING then
            -- Token is being animated into existence from a wizard to the mana pool
            token.appearAnimTime = token.appearAnimTime + dt
            local progress = math.min(1, token.appearAnimTime / token.appearAnimDuration)
            
            -- Ease in-out function for smoother animation
            progress = progress < 0.5 and 4 * progress * progress * progress 
                        or 1 - math.pow(-2 * progress + 2, 3) / 2
            
            -- Calculate current position based on bezier curve for arcing motion
            local x0 = token.startX
            local y0 = token.startY
            local x3 = self.x  -- Center of mana pool
            local y3 = self.y
            
            -- Calculate higher arc height for appearing tokens
            local height = 80 -- Higher arc for appearing tokens
            
            -- Control points for bezier (creating an arc)
            local midX = (x0 + x3) / 2
            local midY = (y0 + y3) / 2 - height  -- Negative for upward arc
            
            -- Quadratic bezier calculation
            local t = progress
            local u = 1 - t
            token.x = u*u*x0 + 2*u*t*midX + t*t*x3
            token.y = u*u*y0 + 2*u*t*midY + t*t*y3
            
            -- Gradual scaling up with progress
            local startScale = 0.1  -- Start very small
            local endScale = token.targetScale or 1.0
            token.scale = startScale + (endScale - startScale) * progress
            
            -- Update token rotation during flight - spin faster while appearing
            token.rotAngle = token.rotAngle + dt * 10
            
            -- Check if animation is complete
            if token.appearAnimTime >= token.appearAnimDuration then
                -- Token has reached the pool center - transition to orbiting
                token.animationCallback()
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.ORBITING then
            -- Token is in second phase of return, animating from pool center to orbit position
            token.orbitAnimTime = token.orbitAnimTime + dt
            local progress = math.min(1, token.orbitAnimTime / token.orbitAnimDuration)
            
            -- Ease in-out function for smoother animation
            progress = progress < 0.5 and 4 * progress * progress * progress 
                        or 1 - math.pow(-2 * progress + 2, 3) / 2
            
            -- Calculate current position based on bezier curve for arcing motion
            local x0 = token.startOrbitX
            local y0 = token.startOrbitY
            local x3 = token.targetOrbitX
            local y3 = token.targetOrbitY
            
            -- Control points for bezier (creating an arc)
            -- Make the arc go outward in the direction of the target
            local dx = x3 - x0
            local dy = y3 - y0
            local dist = math.sqrt(dx*dx + dy*dy)
            local nx = dx / dist  -- Normalized direction vector
            local ny = dy / dist
            
            -- Control point perpendicular to the path with a height proportional to distance
            local arcHeight = math.min(dist * 0.4, 35)  -- Cap the arc height
            local midX = (x0 + x3) / 2 + ny * arcHeight  -- Perpendicular offset
            local midY = (y0 + y3) / 2 - nx * arcHeight
            
            -- Quadratic bezier calculation
            local t = progress
            local u = 1 - t
            token.x = u*u*x0 + 2*u*t*midX + t*t*x3
            token.y = u*u*y0 + 2*u*t*midY + t*t*y3
            
            -- Update token rotation during flight - spin faster but not as fast as returning
            token.rotAngle = token.rotAngle + dt * 5
            
            -- Check if animation is complete
            if token.orbitAnimTime >= token.orbitAnimDuration then
                -- Token has reached its orbit position - call the animation callback
                if token.animationCallback then
                    token.animationCallback()
                else
                    print("[MANAPOOL] WARNING: No animation callback defined for orbiting token")
                    -- Fallback
                    token:setState(Constants.TokenStatus.FREE)
                end
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.DISSOLVING then
            -- Update dissolution animation
            token.dissolveTime = token.dissolveTime + dt
            
            -- When dissolution is complete, call the animation callback
            if token.dissolveTime >= token.dissolveMaxTime then
                -- Execute the callback to finalize destruction
                if token.animationCallback then
                    token.animationCallback()
                else
                    print("[MANAPOOL] WARNING: No animation callback defined for dissolving token")
                    -- No fallback needed; token will be removed on the next frame
                end
            end
            
        end
        
        -- Update common properties for all tokens (moved inside the token loop)
        if token.pulsePhase and token.pulseSpeed then
            token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
        end
        
        ::continue_token::
    end
end

function ManaPool:drawToken(token)
    -- Skip drawing POOLED tokens (should not happen if called correctly, but good safeguard)
    if token.status == Constants.TokenStatus.POOLED then
        return
    end
    
    -- Draw trailing effect behind the token first (similar to main menu tokens)
    if self.tokenTrails[token] and #self.tokenTrails[token] > 2 then
        local colorTable = Constants.getColorForTokenType(token.type)
        local stepSize = (#self.tokenTrails[token] > 20) and 2 or 1
        
        for j = #self.tokenTrails[token], 2, -stepSize do
            local pos = self.tokenTrails[token][j]
            local time = love.timer.getTime()
            local timeDiff = time - pos.time
            
            -- Calculate fade based on position in trail (older = more transparent)
            local trailAlpha = 0.2 * (1 - (j / self.trailLength)^1.5)
            
            -- Trail size based on position (older = smaller)
            local trailScale = 12 * (1 - (j / self.trailLength) * 0.6)
            
            -- Adjust trail appearance based on token state
            if token.status == Constants.TokenStatus.APPEARING then
                -- Enhanced trail for appearing tokens (brightest)
                trailAlpha = trailAlpha * 1.8
                trailScale = trailScale * 1.4
            elseif token.status == Constants.TokenStatus.RETURNING then
                -- Enhanced trail for returning tokens
                trailAlpha = trailAlpha * 1.5
                trailScale = trailScale * 1.2
            elseif token.status == Constants.TokenStatus.ORBITING then
                -- Enhanced trail for orbiting tokens
                trailAlpha = trailAlpha * 1.3
                trailScale = trailScale * 1.1
            elseif token.status ~= Constants.TokenStatus.FREE then
                -- Reduce trails for other token states
                trailAlpha = trailAlpha * 0.7
                trailScale = trailScale * 0.7
            end
            
            -- Draw trail particle
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], trailAlpha)
            love.graphics.circle("fill", pos.x, pos.y, trailScale)
        end
    end
    
    -- Draw a larger, more vibrant glow around the token based on its type
    local glowSize = 15 -- Larger glow radius
    local glowIntensity = 0.6  -- Stronger glow intensity
    
    -- Multiple glow layers for more visual interest
    for layer = 1, 2 do
        local layerSize = glowSize * (1.2 - layer * 0.3)
        local layerIntensity = glowIntensity * (layer == 1 and 0.4 or 0.8)
        
        -- Increase glow for tokens in transition (newly returned to pool)
        if token.status == Constants.TokenStatus.FREE and token.inTransition then
            -- Stronger glow that fades over the transition period
            local transitionBoost = 0.6 + 0.8 * (1 - token.transitionTime / token.transitionDuration)
            layerSize = layerSize * (1 + transitionBoost * 0.5)
            layerIntensity = layerIntensity + transitionBoost * 0.5
        end
        
        -- Special visual effects for APPEARING tokens
        if token.status == Constants.TokenStatus.APPEARING then
            -- Intense, bright glow for appearing tokens
            local appearProgress = token.appearAnimTime / token.appearAnimDuration
            layerSize = layerSize * (1.4 + appearProgress * 1.0) -- Extra large glow
            layerIntensity = layerIntensity + appearProgress * 0.6 -- Very bright
        -- Special visual effects for RETURNING tokens
        elseif token.status == Constants.TokenStatus.RETURNING then
            -- Bright, trailing glow for returning tokens
            local returnProgress = token.animTime / token.animDuration
            layerSize = layerSize * (1.2 + returnProgress * 0.8) -- Growing glow
            layerIntensity = layerIntensity + returnProgress * 0.4 -- Brightening
        end
        
        -- Special visual effects for DISSOLVING tokens
        if token.status == Constants.TokenStatus.DISSOLVING then
            -- Fading, expanding glow for dissolving tokens
            local dissolveProgress = token.dissolveTime / token.dissolveMaxTime
            layerSize = layerSize * (1 + dissolveProgress) -- Expanding glow
            layerIntensity = layerIntensity * (1 - dissolveProgress * 0.8) -- Fading
        end
        
        -- Set glow color based on token type with improved contrast and vibrancy
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], layerIntensity)
        
        -- Draw glow with pulsation
        local pulseAmount = 0.7 + 0.3 * math.sin(token.pulsePhase * 0.5)
        
        -- Enhanced pulsation for transitioning tokens
        if token.status == Constants.TokenStatus.FREE and token.inTransition then
            pulseAmount = pulseAmount + 0.3 * math.sin(token.transitionTime * 10)
        end
        
        -- Enhanced pulsation for returning tokens
        if token.status == Constants.TokenStatus.RETURNING then
            pulseAmount = pulseAmount + 0.4 * math.sin(token.animTime * 15)
        end
        
        love.graphics.circle("fill", token.x, token.y, layerSize * pulseAmount * token.scale)
    end
    
    -- Draw a small outer ring for better definition
    if token.status == Constants.TokenStatus.FREE then
        local ringAlpha = 0.4 + 0.2 * math.sin(token.pulsePhase * 0.8)
        
        -- Set ring color based on token type
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], ringAlpha)
        
        love.graphics.circle("line", token.x, token.y, (glowSize + 3) * token.scale)
    end
    
    -- Draw a trailing effect for returning tokens
    if token.status == Constants.TokenStatus.RETURNING then
        local progress = token.animTime / token.animDuration
        local trailAlpha = 0.6 * (1 - progress)
        
        -- Set trail color based on token type
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], trailAlpha)
        
        -- Draw the trail as small circles along the bezier path
        local numTrailPoints = 6
        for i = 0, numTrailPoints do
            local trailProgress = progress - (i / numTrailPoints) * 0.25  -- Trail behind the token
            
            -- Only draw trail points that are within the animation progress
            if trailProgress > 0 and trailProgress < 1 then
                -- Calculate position along the bezier path
                local x0 = token.startX
                local y0 = token.startY
                local x3 = self.x  -- End at center of mana pool
                local y3 = self.y
                
                -- Control points for bezier curve
                local midX = (x0 + x3) / 2
                local midY = (y0 + y3) / 2 - 50  -- Arc height
                
                -- Quadratic bezier calculation
                local t = trailProgress
                local u = 1 - t
                local trailX = u*u*x0 + 2*u*t*midX + t*t*x3
                local trailY = u*u*y0 + 2*u*t*midY + t*t*y3
                
                -- Draw trail point with decreasing size
                local pointSize = (numTrailPoints - i) / numTrailPoints * 8 * token.scale
                love.graphics.circle("fill", trailX, trailY, pointSize)
            end
        end
    end
    
    -- Draw token image based on state
    if token.status == Constants.TokenStatus.FREE then
        -- Free tokens are fully visible
        -- If token is in transition (just returned to pool), add a subtle glow effect
        if token.inTransition then
            local transitionGlow = 0.2 + 0.8 * (1 - token.transitionTime / token.transitionDuration)
            love.graphics.setColor(1, 1, 1 + transitionGlow * 0.5, 1)  -- Slightly blue-white glow during transition
        else
            love.graphics.setColor(1, 1, 1, 1)
        end
    elseif token.status == Constants.TokenStatus.CHANNELED then
        -- Channeled tokens are fully visible
        love.graphics.setColor(1, 1, 1, 1)
    elseif token.status == Constants.TokenStatus.SHIELDING then
        -- Shielding tokens have a slight colored tint based on their type
        local colorTable = Constants.getColorForTokenType(token.type)
        -- Use the color from Constants, but keep alpha = 1 for the tint
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], 1)
    elseif token.status == Constants.TokenStatus.RETURNING then
        -- Returning tokens have a bright, energetic glow
        local returnGlow = 0.3 + 0.7 * math.sin(token.animTime * 15)
        love.graphics.setColor(1, 1, 1, 0.8 + returnGlow * 0.2)
    elseif token.status == Constants.TokenStatus.DISSOLVING then
        -- Dissolving tokens fade out
        -- Calculate progress of the dissolve animation
        local progress = token.dissolveTime / token.dissolveMaxTime
        
        -- Fade out by decreasing alpha
        local alpha = (1 - progress) * 0.8
        
        -- Get token color based on its type for the fade effect
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], alpha)
    else
        -- For legacy compatibility - handle any other states (like "DESTROYED")
        -- Check for dissolving flag for backwards compatibility
        if token.dissolving then
            local progress = token.dissolveTime / token.dissolveMaxTime
            local alpha = (1 - progress) * 0.8
            love.graphics.setColor(1, 1, 1, alpha)
        else
            love.graphics.setColor(1, 1, 1, 1)
        end
    end
    
    -- Draw the token with dynamic scaling
    if token.status == Constants.TokenStatus.DISSOLVING then
        -- For dissolving tokens, add special effects
        local progress = token.dissolveTime / token.dissolveMaxTime
        
        -- Expand and fade out
        local scaleFactor = token.dissolveScale * (1 + progress * 0.5)
        local rotationSpeed = token.rotSpeed or 1.0
        
        -- Speed up rotation as it dissolves
        token.rotAngle = token.rotAngle + rotationSpeed * 5 * progress
        
        -- Draw at original position with expanding effect
        love.graphics.draw(
            token.image, 
            token.initialX, 
            token.initialY, 
            token.rotAngle,
            scaleFactor * (1 - progress * 0.7), scaleFactor * (1 - progress * 0.7),
            token.image:getWidth()/2, token.image:getHeight()/2
        )
    else
        -- Normal tokens
        love.graphics.draw(
            token.image, 
            token.x, 
            token.y, 
            token.rotAngle,  -- Use the rotation angle
            token.scale, token.scale,  -- Use token-specific scale
            token.image:getWidth()/2, token.image:getHeight()/2  -- Origin at center
        )
    end
    
    -- Draw additional effects for non-POOLED tokens only
    if token.status ~= Constants.TokenStatus.POOLED then
        -- Draw shield effect for shielding tokens
        if token.status == Constants.TokenStatus.SHIELDING then
            -- Get token color based on its mana type
            local colorTable = Constants.getColorForTokenType(token.type)
            local shieldBaseAlpha = 0.3 -- Keep the original base alpha
            
            -- Draw a subtle shield aura with slight pulsation
            local pulseScale = 0.9 + math.sin(love.timer.getTime() * 2) * 0.1
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], shieldBaseAlpha)
            love.graphics.circle("fill", token.x, token.y, 15 * pulseScale * token.scale)
            
            -- Draw shield border
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], 0.5) -- Keep original border alpha
            love.graphics.circle("line", token.x, token.y, 15 * pulseScale * token.scale)
        end
    end
end

function ManaPool:draw()
    -- No longer drawing the pool background or valence rings
    -- The pool is now completely invisible, defined only by the positions of the tokens
    
    -- Sort tokens by z-order for better layering
    local sortedTokens = {}
    for i, token in ipairs(self.tokens) do
        table.insert(sortedTokens, {token = token, index = i})
    end
    
    table.sort(sortedTokens, function(a, b)
        -- Safe sorting - handle nil zOrder values
        local zOrderA = a.token.zOrder or 0
        local zOrderB = b.token.zOrder or 0
        return zOrderA > zOrderB
    end)
    
    -- Draw tokens in sorted order, skipping those attached to wizards
    for _, tokenData in ipairs(sortedTokens) do
        local token = tokenData.token
        
        -- Only draw tokens that are NOT CHANNELED or SHIELDING
        if token.status ~= Constants.TokenStatus.CHANNELED and 
           token.status ~= Constants.TokenStatus.SHIELDING then
            self:drawToken(token)
        end
    end
    
    -- No border - the pool is now completely invisible
end

-- Helper function to draw an ellipse
function ManaPool:drawEllipse(x, y, radiusX, radiusY, mode)
    local segments = 64
    local vertices = {}
    
    for i = 1, segments do
        local angle = (i - 1) * (2 * math.pi / segments)
        local px = x + math.cos(angle) * radiusX
        local py = y + math.sin(angle) * radiusY
        table.insert(vertices, px)
        table.insert(vertices, py)
    end
    
    -- Close the shape by adding the first point again
    table.insert(vertices, vertices[1])
    table.insert(vertices, vertices[2])
    
    if mode == "fill" then
        love.graphics.polygon("fill", vertices)
    else
        love.graphics.polygon("line", vertices)
    end
end

function ManaPool:findFreeToken(tokenType)
    -- Find a free token of the specified type without changing its state
    for i, token in ipairs(self.tokens) do
        if token.type == tokenType and token.status == Constants.TokenStatus.FREE then
            return token, i  -- Return token and its index without changing state
        end
    end
    return nil  -- No token available
end

function ManaPool:getToken(tokenType)
    -- Find a free token of the specified type that's not in transition
    for i, token in ipairs(self.tokens) do
        if token.type == tokenType and token.status == Constants.TokenStatus.FREE and
           not token.returning and not token.inTransition then
            -- Mark as being used (using setState for state machine)
            token:setState(Constants.TokenStatus.CHANNELED)
            return token, i  -- Return token and its index
        end
    end
    
    -- Second pass - try with less strict requirements if nothing was found
    for i, token in ipairs(self.tokens) do
        if token.type == tokenType and token.status == Constants.TokenStatus.FREE then
            if token.returning then
                print("[MANAPOOL] WARNING: Using token in return animation - visual glitches may occur")
            elseif token.inTransition then
                print("[MANAPOOL] WARNING: Using token in transition state - visual glitches may occur")
            end
            
            -- Use setState method for state machine transition
            token:setState(Constants.TokenStatus.CHANNELED)
            
            -- Cancel any return animation
            token.returning = false
            token.inTransition = false
            return token, i
        end
    end
    
    return nil  -- No token available
end

function ManaPool:returnToken(tokenIndex)
    -- Return a token to the pool using the new state machine
    if self.tokens[tokenIndex] then
        local token = self.tokens[tokenIndex]
        
        -- Use token's method if available, otherwise fallback to legacy behavior
        if token.requestReturnAnimation then
            token:requestReturnAnimation()
        else
            -- Legacy fallback for tokens that don't have the state machine methods
            print("[MANAPOOL] WARNING: Using legacy return method for token " .. tokenIndex .. " - state machine methods not found")
            
            -- Validate the token state and ownership before return
            if token.returning then
                print("[MANAPOOL] WARNING: Token " .. tokenIndex .. " is already being returned - ignoring duplicate return")
                return
            end
            
            -- Clear any wizard ownership immediately to prevent double-tracking
            token.wizardOwner = nil
            token.spellSlot = nil
            
            -- Ensure token is in a valid state - convert any state to valid transition state
            local originalState = token.state
            if token.state == Constants.TokenState.SHIELDING or token.state == Constants.TokenState.CHANNELED then
            elseif token.state ~= Constants.TokenState.FREE then
                print("[MANAPOOL] WARNING: Returning token " .. tokenIndex .. " from unexpected state: " .. 
                     (token.state or "nil"))
            end
            
            -- Store current position as start position for return animation
            token.startX = token.x
            token.startY = token.y
            
            -- Set up return animation parameters
            token.targetX = self.x  -- Center of mana pool
            token.targetY = self.y
            token.animTime = 0
            token.animDuration = 0.5 -- Half second return animation
            token.returning = true   -- Flag that this token is returning to the pool
            token.originalState = originalState  -- Remember what state it was in before return
        end
    else
        print("[MANAPOOL] WARNING: Attempted to return invalid token index: " .. tokenIndex)
    end
end

-- This method has been replaced by token:finalizeReturn
-- Kept for backward compatibility with code that hasn't been updated yet
function ManaPool:finalizeTokenReturn(token)
    print("[MANAPOOL] WARNING: ManaPool:finalizeTokenReturn is deprecated, use token:finalizeReturn instead")
    
    -- Just call the token's method if available
    if token.finalizeReturn then
        token:finalizeReturn()
    else
        -- Legacy fallback (simplified)
        token.state = Constants.TokenState.FREE
        token.status = Constants.TokenStatus.FREE
        token.returning = false
        token.wizardOwner = nil
        token.spellSlot = nil
        token.tokenIndex = nil
    end
end

return ManaPool```

## ./spellCompiler.lua
```lua
-- spellCompiler.lua
-- Compiles spell definitions using keyword behaviors
--
-- IMPORTANT: This system now uses a pure event-based architecture.
-- All keyword behaviors should create events rather than directly modifying game state.
-- Events are processed by the EventRunner module after all behaviors have been executed.
-- The events should follow the schema defined in docs/combat_events.md.
--
-- Example event structure:
-- {
--   type = "DAMAGE",       -- Required: Type of the event
--   source = "caster",     -- Required: Source of the event (usually "caster")
--   target = "enemy",      -- Required: Target of the event (e.g., "self", "enemy", "both", etc.)
--   amount = 10,           -- Event-specific data
--   damageType = "fire"    -- Event-specific data
-- }

local SpellCompiler = {}

-- Add the EventRunner module for event-based execution
local EventRunner = nil -- Lazy-loaded to avoid circular dependencies

-- Keep track of whether we're currently trying to load EventRunner to detect circular dependencies
local isLoadingEventRunner = false

-- Helper function to merge tables
local function mergeTables(target, source)
    for k, v in pairs(source) do
        if type(v) == "table" and type(target[k]) == "table" then
            -- Recursively merge nested tables
            mergeTables(target[k], v)
        else
            -- For non-table values or if target key doesn't exist as table,
            -- simply overwrite/set the value
            target[k] = v
        end
    end
    return target
end

-- Main compilation function
-- Takes a spell definition and keyword data, returns a compiled spell
function SpellCompiler.compileSpell(spellDef, keywordData)
    -- Debug - check for onBlock in keywords.block
    if spellDef.keywords and spellDef.keywords.block and spellDef.keywords.block.onBlock then
        print("[COMPILER DEBUG] Spell " .. spellDef.id .. " has onBlock handler in keywords.block")
    end
    
    -- Create a new compiledSpell object
    local compiledSpell = {
        -- Copy base spell properties
        id = spellDef.id,
        name = spellDef.name,
        affinity = spellDef.affinity,
        description = spellDef.description,
        attackType = spellDef.attackType,
        castTime = spellDef.castTime,
        cost = spellDef.cost,
        keywords = spellDef.keywords,
        visualShape = spellDef.visualShape, -- Copy visualShape for template override
        vfx = spellDef.vfx,
        sfx = spellDef.sfx,
        -- Create empty behavior table to store merged behavior data
        behavior = {}
    }
    
    -- >>> ADDED: Also copy the getCastTime function if it exists
    if spellDef.getCastTime and type(spellDef.getCastTime) == "function" then
        compiledSpell.getCastTime = spellDef.getCastTime
    end

    -- >>> ADDED: Copy dynamic mana cost function if present
    if spellDef.getCost and type(spellDef.getCost) == "function" then
        compiledSpell.getCost = spellDef.getCost
    end
    
    -- Process keywords if they exist
    if spellDef.keywords then
        print("DEBUG: Processing keywords for spell " .. spellDef.id)
        for keyword, params in pairs(spellDef.keywords) do
            print("DEBUG:   Found keyword: " .. keyword)
            -- Check if the keyword exists in the keyword data
            if keywordData[keyword] and keywordData[keyword].behavior then
                -- Get the behavior definition for this keyword
                local keywordBehavior = keywordData[keyword].behavior
                
                -- Create behavior entry for this keyword with default behavior
                compiledSpell.behavior[keyword] = {}
                
                -- Copy the default behavior parameters
                mergeTables(compiledSpell.behavior[keyword], keywordBehavior)
                
                -- Apply specific parameters from the spell definition
                if type(params) == "table" then
                    -- For table parameters, process them first to capture any functions
                    compiledSpell.behavior[keyword].params = {}
                    
                    -- Copy params to behavior.params, preserving functions
                    for paramName, paramValue in pairs(params) do
                        compiledSpell.behavior[keyword].params[paramName] = paramValue
                    end
                elseif type(params) == "boolean" and params == true then
                    -- For boolean true parameters, just use default params
                    compiledSpell.behavior[keyword].enabled = true
                else
                    -- For any other type, store as a value parameter
                    compiledSpell.behavior[keyword].value = params
                end
                
                -- Bind the execute function from the keyword
                compiledSpell.behavior[keyword].execute = keywordData[keyword].execute
            else
                -- If keyword wasn't found in the keyword data, log an error
                print("Warning: Keyword '" .. keyword .. "' not found in keyword data for spell '" .. compiledSpell.name .. "'")
            end
        end
    end
    
    -- Handle top-level vfx field (convert to vfx keyword if not already present)
    if spellDef.vfx and not (spellDef.keywords and spellDef.keywords.vfx) and keywordData.vfx then
        print("DEBUG: Converting top-level vfx to keyword for spell " .. spellDef.id)
        
        -- Create behavior entry for vfx keyword
        compiledSpell.behavior.vfx = {}
        
        -- Copy the default behavior parameters from the keyword
        mergeTables(compiledSpell.behavior.vfx, keywordData.vfx.behavior)
        
        -- Create params based on vfx value
        compiledSpell.behavior.vfx.params = {
            effect = spellDef.vfx -- Use the vfx string as the effect name
        }
        
        -- Bind the execute function from the vfx keyword
        compiledSpell.behavior.vfx.execute = keywordData.vfx.execute
    end
    
        -- Method to get the event runner module (lazy loading)
    local function getEventRunner()
        if not EventRunner then
            -- Detect circular dependencies
            if isLoadingEventRunner then
                print("CIRCULAR DEPENDENCY DETECTED: Already trying to load EventRunner")
                -- Return dummy EventRunner to break the circular dependency
                return {
                    processEvents = function(events, caster, target, spellSlot)
                        print("CIRCULAR DEPENDENCY: Using dummy EventRunner.processEvents")
                        return {eventsProcessed = 0}
                    end,
                    debugPrintEvents = function(events)
                        print("CIRCULAR DEPENDENCY: Using dummy EventRunner.debugPrintEvents")
                    end
                }
            end
            
            -- Set flag to indicate we're trying to load EventRunner
            isLoadingEventRunner = true
            
            -- Use pcall to avoid crashes from circular dependencies
            local success, result = pcall(function() 
                return require("systems.EventRunner") 
            end)
            
            -- Reset flag after load attempt
            isLoadingEventRunner = false
            
            if success then
                EventRunner = result
            else
                print("WARNING: Failed to load EventRunner: " .. tostring(result))
                -- Return a dummy EventRunner with processEvents to avoid crashes
                return {
                    processEvents = function(events, caster, target, spellSlot)
                        print("FALLBACK: Using dummy EventRunner.processEvents")
                        return {eventsProcessed = 0}
                    end,
                    debugPrintEvents = function(events)
                        print("FALLBACK: Using dummy EventRunner.debugPrintEvents")
                    end
                }
            end
        end
        return EventRunner
    end
    
    -- Add a method to execute all behaviors for this spell
    compiledSpell.executeAll = function(caster, target, results, spellSlot)
        -- LOGGING with safety checks
        if caster and caster.spellSlots and spellSlot and caster.spellSlots[spellSlot] then
            print(string.format("DEBUG_EXECUTE_ALL: Slot %d castTimeModifier=%.4f", 
                spellSlot, caster.spellSlots[spellSlot].castTimeModifier or 0))
        else
            -- Safe fallback logging
            print(string.format("DEBUG_EXECUTE_ALL: Slot %s (safety check failed, some values are nil)", 
                tostring(spellSlot)))
        end

        results = results or {}
        
        -- Check if this spell has shield behavior (block keyword)
        local hasShieldBehavior = compiledSpell.behavior.block ~= nil
        
        -- If this is a shield spell, tag the compiled spell
        if hasShieldBehavior or compiledSpell.isShield then
            compiledSpell.isShield = true
        end
        
        -- When using the event system, we collect events instead of directly mutating state
        local events = {}
        
        -- Execute each behavior
        for keyword, behavior in pairs(compiledSpell.behavior) do
            if behavior.execute then
                local params = behavior.params or {}
                
                -- Execute the behavior to get events
                local behaviorResults = {}
                local results = {currentSlot = spellSlot}  -- Base results with slot info
                
                -- The keyword's execute function is now solely responsible 
                -- for handling its params, including function evaluation.
                if behavior.enabled then
                    -- If it's a boolean-enabled keyword with no params
                    behaviorResults = behavior.execute({}, caster, target, results, events, compiledSpell) -- Pass empty params and the spell
                elseif behavior.value ~= nil then
                    -- If it's a simple value parameter
                    behaviorResults = behavior.execute({value = behavior.value}, caster, target, results, events, compiledSpell)
                else
                    -- Normal case with params table
                    behaviorResults = behavior.execute(params, caster, target, results, events, compiledSpell)
                end
                
                -- Debug output for events immediately after execute
                if keyword == "freeze" then
                    print(string.format("DEBUG: After executing %s keyword, events table has %d entries", 
                        keyword, events and #events or 0))
                end
                
                -- Merge the behavior results into the main results for backward compatibility
                for k, v in pairs(behaviorResults) do
                    results[k] = v
                end
                
                -- Special handling for vfx keyword's effectOverride
                -- This is part of the VFX-R5 refactoring to deprecate manual VFX specification
                if keyword == "vfx" and results.effectOverride then
                    -- Remember the override for when a damage event generates an EFFECT event
                    compiledSpell.effectOverride = results.effectOverride
                    compiledSpell.effectTarget = results.effectTarget
                    compiledSpell.effectDuration = results.effectDuration
                    compiledSpell.vfxParams = results.vfxParams
                end
                
                -- DEBUG ONLY: Log info about block keyword, but don't create duplicate events
                if keyword == "block" then
                    -- Debug the block keyword behavior 
                    print("[COMPILER DEBUG] Processing block keyword in executeAll")
                    
                    -- Check for onBlock in params
                    if params and params.onBlock then
                        print("[COMPILER DEBUG] Found onBlock handler in params")
                    else
                        print("[COMPILER DEBUG] No onBlock handler in params")
                    end
                    
                    -- NOTE: We no longer create a CREATE_SHIELD event here
                    -- The Keywords.block.execute function already creates this event
                    -- Creating it here would cause a duplicate event
                    
                    -- Debug info about shield parameters if available
                    if behaviorResults and behaviorResults.shieldParams then
                        local defenseType = behaviorResults.shieldParams.defenseType or Constants.ShieldType.BARRIER
                        print("[COMPILER DEBUG] Shield type: " .. defenseType)
                    end
                end
            end
        end
        
        -- If this is a shield spell, mark this in the results
        if hasShieldBehavior or compiledSpell.isShield then
            results.isShield = true
        end
        
        -- Check for sustain keyword or block keyword (which marks spells as sustained)
        if compiledSpell.behavior.sustain or 
           (compiledSpell.behavior.block and compiledSpell.behavior.block.marksSpellAsSustained) then
            -- This will be picked up by Wizard:castSpell to handle sustained spells
            results.isSustained = true
            print("DEBUG: Spell " .. compiledSpell.id .. " marked as sustained")
        else
            print("DEBUG: Spell " .. compiledSpell.id .. " not marked as sustained. Checking for sustain/shield keywords...")
            
            -- Debug: Print out the behavior table keys to see if sustain or block is there
            for behaviorKey, _ in pairs(compiledSpell.behavior) do
                print("  Behavior found: " .. behaviorKey)
                
                -- If it's the block keyword, check if it has marksSpellAsSustained
                if behaviorKey == "block" then
                    print("    Block keyword found. marksSpellAsSustained = " .. 
                        tostring(compiledSpell.behavior.block.marksSpellAsSustained))
                end
            end
        end
        
        -- Check for trap keywords and ensure they're in the results
        -- These trap-related fields will be used by the SustainedSpellManager later
        if compiledSpell.behavior.trap_trigger then
            -- Make sure trapTrigger data is in the results
            if not results.trapTrigger then
                results.trapTrigger = compiledSpell.behavior.trap_trigger.params or {}
                print("DEBUG: Adding trapTrigger data to results: " .. tostring(results.trapTrigger))
            end
        end


        if compiledSpell.behavior.trap_effect then
            -- Make sure trapEffect data is in the results
            if not results.trapEffect then
                results.trapEffect = compiledSpell.behavior.trap_effect.params or {}
                print("DEBUG: Adding trapEffect data to results: " .. tostring(results.trapEffect))
            end
        end

        if compiledSpell.behavior.field_status then
            if not results.fieldStatus then
                results.fieldStatus = compiledSpell.behavior.field_status.params or {}
                print("DEBUG: Adding fieldStatus data to results: " .. tostring(results.fieldStatus))
            end
        end
        
        -- Wrap event processing in pcall to avoid crashing the game
        local success, result = pcall(function()
            -- Debug output for events
            if _G.DEBUG_EVENTS then
                local debugRunner = getEventRunner()
                if debugRunner and debugRunner.debugPrintEvents then
                    debugRunner.debugPrintEvents(events)
                end
            end
            
            -- Process the events to apply them to the game state
            local eventResults = {}
            if events and #events > 0 then
                print(string.format("DEBUG_EVENTS: Processing %d events for spell %s", 
                    #events, compiledSpell.id or "unknown"))
                
                -- Print type of first event as sanity check
                if events[1] and events[1].type then
                    print(string.format("DEBUG_EVENTS: First event type is %s", events[1].type))
                end
                
                -- If spell is blocked, convert DAMAGE events to BLOCKED_DAMAGE
                -- This preserves visuals while preventing actual damage application
                if results.blockInfo and results.blockInfo.blockable then
                    print("[COMPILER] Spell blocked - converting DAMAGE to BLOCKED_DAMAGE events")
                    
                    -- Ensure blockInfo has a blockPoint for visuals
                    if not results.blockInfo.blockPoint then
                        print("[COMPILER] WARNING: blockInfo missing blockPoint, setting default 0.75")
                        results.blockInfo.blockPoint = 0.75
                    end
                    
                    -- Enhanced debugging for blockInfo
                    print("[COMPILER] BlockInfo details:")
                    for k, v in pairs(results.blockInfo) do
                        print("  " .. k .. ": " .. tostring(v))
                    end
                    
                    -- Process each event
                    local blockEventsFound = false
                    for i, event in ipairs(events) do
                        if event.type == "DAMAGE" then
                            blockEventsFound = true
                            
                            -- Convert to BLOCKED_DAMAGE event type
                            event.type = "BLOCKED_DAMAGE"
                            
                            -- Add blockInfo for visuals, deep copy to avoid modification issues
                            event.blockInfo = {
                                blockable = results.blockInfo.blockable,
                                blockType = results.blockInfo.blockType,
                                blockPoint = results.blockInfo.blockPoint,
                                blockingSlot = results.blockInfo.blockingSlot
                            }
                            
                            -- Explicitly set blockPoint at both levels for redundancy
                            event.blockPoint = results.blockInfo.blockPoint
                            
                            -- Add shield block tag
                            event.tags = event.tags or {}
                            event.tags.SHIELD_BLOCKED = true
                            
                            print(string.format("[COMPILER] Converted DAMAGE to BLOCKED_DAMAGE event with blockPoint=%.2f", 
                                event.blockPoint))
                        end
                    end
                    
                    -- Warning if no DAMAGE events were found to convert
                    if not blockEventsFound then
                        print("[COMPILER] WARNING: Spell was blocked but no DAMAGE events found to convert")
                    end
                end
                
                -- Get the EventRunner and process events with additional error handling
                local runner = getEventRunner()
                if runner and runner.processEvents then
                    -- Try to process events, but handle any errors gracefully
                    local ok, result = pcall(function()
                        return runner.processEvents(events, caster, target, spellSlot)
                    end)
                    
                    if ok then
                        eventResults = result
                    else
                        print("ERROR processing events: " .. tostring(result))
                        -- Return a default result structure
                        eventResults = { eventsProcessed = 0 }
                    end
                else
                    print("WARNING: EventRunner not available for processing")
                    eventResults = { eventsProcessed = 0 }
                end
            else
                print("WARNING: No events generated for spell " .. (compiledSpell.id or "unknown"))
            end
            
            -- Add event processing results to the main results
            results.events = events
            results.eventsProcessed = eventResults.eventsProcessed
            
            -- Set blocked flag in results if blockInfo present
            if results.blockInfo and results.blockInfo.blockable then
                results.blocked = true
                results.blockType = results.blockInfo.blockType
                
                print("[COMPILER] Spell was blocked by shield - setting blocked flag")
            end
            
            return results
        end)
        
        if success then
            -- Return the combined results if everything went well
            return result
        else
            -- Log the error but still return the original results for fallback
            print("ERROR in event processing: " .. tostring(result))
            print("Falling back to direct results without event processing")
            return results
        end
    end
    
    -- Add method for direct event generation without execution
    -- Useful for testing and debugging
    compiledSpell.generateEvents = function(caster, target, spellSlot)
        local events = {}
        
        -- Execute each behavior to generate events
        for keyword, behavior in pairs(compiledSpell.behavior) do
            if behavior.execute then
                local params = behavior.params or {}
                local localResults = {}
                
                -- Execute the behavior to generate events directly
                -- No state modification occurs
                if behavior.enabled then
                    -- Call the keyword execute function with an empty results table
                    -- The events parameter allows keywords to add events directly via table.insert
                    behavior.execute(params, caster, target, {currentSlot = spellSlot}, events, compiledSpell)
                elseif behavior.value ~= nil then
                    behavior.execute({value = behavior.value}, caster, target, {currentSlot = spellSlot}, events, compiledSpell)
                else
                    behavior.execute(params, caster, target, {currentSlot = spellSlot}, events, compiledSpell)
                end
                
                -- DEBUG ONLY: Log info about block keyword, but don't create duplicate events
                if keyword == "block" then
                    -- Debug the block keyword behavior
                    print("[COMPILER DEBUG] Processing block keyword in generateEvents")
                    
                    -- NOTE: We no longer create a CREATE_SHIELD event here
                    -- The Keywords.block.execute function already creates this event
                    -- Creating it here would cause a duplicate event
                    
                    -- Debug info about shield parameters
                    local shieldParams = localResults.shieldParams or {}
                    local defenseType = shieldParams.defenseType or Constants.ShieldType.BARRIER
                    print("[COMPILER DEBUG] Shield type from generateEvents: " .. defenseType)
                    
                    -- Check if onBlock is in the params (just for debug info)
                    if params and params.onBlock then
                        print("[COMPILER DEBUG] Found onBlock handler in params")
                    end
                end
            end
        end
        
        return events
    end
    
    return compiledSpell
end

-- Function to test compile a spell and display its components
function SpellCompiler.debugCompiled(compiledSpell)
    print("=== Debug Compiled Spell: " .. compiledSpell.name .. " ===")
    print("ID: " .. compiledSpell.id)
    print("Attack Type: " .. compiledSpell.attackType)
    print("Cast Time: " .. compiledSpell.castTime)
    
    print("Cost: ")
    for _, token in ipairs(compiledSpell.cost) do
        print("  - " .. token)
    end
    
    print("Behaviors: ")
    for keyword, behavior in pairs(compiledSpell.behavior) do
        print("  - " .. keyword .. ":")
        if behavior.category then
            print("    Category: " .. behavior.category)
        end
        if behavior.targetType then
            print("    Target Type: " .. behavior.targetType)
        end
        if behavior.params then
            print("    Parameters:")
            for param, value in pairs(behavior.params) do
                if type(value) ~= "function" then
                    print("      " .. param .. ": " .. tostring(value))
                else
                    print("      " .. param .. ": <function>")
                end
            end
        end
    end
    
    print("=====================================================")
end

-- Function to enable/disable debug event output
function SpellCompiler.setDebugEvents(debugEvents)
    _G.DEBUG_EVENTS = debugEvents
    print("Event debugging " .. (debugEvents and "ENABLED" or "DISABLED"))
end

-- Initialize event debugging to disabled by default
_G.DEBUG_EVENTS = false

return SpellCompiler```

## ./spells/elements/fire.lua
```lua
-- spells/elements/fire.lua
-- Contains fire-element spells

local Constants = require("core.Constants")
local expr = require("expr")

local FireSpells = {}

-- Basic Fire Conjuring
FireSpells.conjurefire = {
    id = "conjurefire",
    name = "Conjure Fire",
    affinity = "fire",
    description = "Conjures a Fire mana token. Takes longer to cast the more Fire tokens already present.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "surge",
    castTime = Constants.CastSpeed.FAST,
    cost = {},  -- No mana cost
    keywords = {
        conjure = {
            token = Constants.TokenType.FIRE,
            amount = 1
        },
    },
    
    -- Custom cast time calculation based on existing fire tokens
    getCastTime = function(caster)
        -- Base cast time
        local baseCastTime = Constants.CastSpeed.FAST
        
        -- Count fire tokens in the mana pool
        local fireCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.FIRE and token.state == Constants.TokenState.FREE then
                    fireCount = fireCount + 1
                end
            end
        else
            print("WARN: ConjureFire getCastTime - caster.manaPool is nil!")
        end
        return baseCastTime + (fireCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Firebolt spell
FireSpells.firebolt = {
    id = "firebolt",
    name = "Firebolt",
    affinity = "fire",
    description = "Superheated bolt. Maximum damage at FAR RANGE.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "bolt",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.gameState.rangeState == Constants.RangeState.FAR then
                    return 9
                end
                return 5
            end,
            type = Constants.DamageType.FIRE
        },
    },
    sfx = "fire_whoosh",
}

-- Fireball spell
FireSpells.fireball = {
    id = "fireball",
    name = "Fireball",
    affinity = "fire",
    description = "Fireball that deals damage and burns.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "orb",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = 10,
            burn = {
                amount = 2,
                duration = 2
            }
        },
    }
}

-- Blastwave spell
FireSpells.blastwave = {
    id = "blastwave",
    name = "Blast Wave",
    affinity = "fire",
    description = "Blast of flame. Maximum damage at NEAR RANGE and matched ELEVATION.",
    castTime = Constants.CastSpeed.SLOW,
    attackType = Constants.AttackType.ZONE,
    visualShape = "blast",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDmg = 2
                if target and target.elevation == caster.elevation then
                    baseDmg = baseDmg + 5
                end
                if target and target.gameState.rangeState == Constants.RangeState.NEAR then
                    baseDmg = baseDmg + 12
                end
                return baseDmg
            end,
            type = Constants.DamageType.FIRE,
        },
    },
    sfx = "blastwave",
}

-- Combust Mana spell
FireSpells.combustMana = {
    id = "combustMana",
    name = "Combust Mana",
    affinity = "fire",
    description = "Disrupts opponent channeling, burning one token to Salt.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "affectManaPool",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE},
    keywords = {
        disruptAndShift = {
            targetType = "salt"
        },
    },
}

-- Blazing Ascent spell
FireSpells.blazingAscent = {
    id = "blazingascent",
    name = "Blazing Ascent",
    affinity = "fire",
    description = "Rockets upward in a burst of fire, dealing damage and becoming AERIAL.",
    attackType = Constants.AttackType.ZONE,
    visualShape = "blast",
    castTime = Constants.CastSpeed.SLOW,
    cost = {"fire", "fire", "star"},
    keywords = {
        damage = {
            amount = function(caster, target)
                -- More damage if already AERIAL (harder to cast while falling)
                return caster.elevation == "AERIAL" and 15 or 10
            end,
            type = "fire"
        },
        elevate = {
            duration = 6.0
        },
        dissipate = {
            token = Constants.TokenType.WATER,
            amount = 1
        },
    },
    sfx = "fire_whoosh",
}

-- Eruption spell
FireSpells.eruption = {
    id = "eruption",
    name = "Molten Ash",
    affinity = "fire",
    description = "Creates a volcanic eruption under the opponent. Only works at NEAR range.",
    attackType = Constants.AttackType.ZONE,
    visualShape = "groundBurst",
    castTime = Constants.CastSpeed.SLOW,
    cost = {"fire", "fire", "salt"},
    unlockSpell = "blazingascent",
    keywords = {
        zoneAnchor = {
            range = function(caster, target)
                return caster.gameState.rangeState
            end,
            elevation = "GROUNDED",
            requireAll = true
        },
        damage = {
            amount = 16,
            type = "fire"
        },
        burn = {
            duration = 4.0,
            tickDamage = 3
        },
    },
    sfx = "volcano_rumble",
    
    onMiss = function(caster, target, slot)
        print(string.format("[MISS] %s's Lava Eruption misses because conditions aren't right!", caster.name))
        return {
            missBackfire = true,
            backfireDamage = 4,
            backfireMessage = "Lava Eruption backfires when cast at wrong range!"
        }
    end,
    
    onSuccess = function(caster, target, slot, results)
        print(string.format("[SUCCESS] %s's Lava Eruption hits %s with full force!", caster.name, target.name))
        return {
            successMessage = "The ground trembles with volcanic fury!",
            extraEffect = "area_burn",
            burnDuration = 2.0
        }
    end
}

-- Battle Shield with multiple effects on block (Fire-based shield)
FireSpells.battleshield = {
    id = "battleshield",
    name = "Flamewreath",
    affinity = "fire", 
    description = "A Barrier of flames that stops Projectile and Zone attacks, burning NEAR attackers.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "barrier",
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.FIRE},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
            
            onBlock = function(defender, attacker, slotIndex, blockInfo)
                print("[SPELL DEBUG] Flamewreath onBlock handler executing!")
                local events = {}
                
                if attacker.elevation == Constants.ElevationState.NEAR then
                    table.insert(events, {
                        type = "APPLY_STATUS",
                        source = "caster",
                        target = "enemy",
                        statusType = Constants.StatusType.BURN,
                        duration = 1.5,
                        tickDamage = 4,
                        targetSlot = "NEAR"
                    })
                end
                
                table.insert(events, {
                    type = "EFFECT",
                    source = "caster",
                    target = "self",
                    effectType = "battle_shield_counter",
                    duration = 0.8,
                    color = {1.0, 0.7, 0.2, 0.8}
                })
                
                print("[SPELL DEBUG] Battle Shield returning " .. #events .. " events")
                return events
            end
        },
    },
    sfx = "fire_shield",
}

-- Desperation Fire - cost decreases as caster health drops
FireSpells.desperationFire = {
    id = "desperationfire",
    name = "Desperation Fire",
    affinity = Constants.TokenType.FIRE,
    description = "A fiery attack whose Fire cost decreases as your health lowers.",
    attackType = Constants.AttackType.PROJECTILE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = { Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.FIRE },
    keywords = {
        damage = { amount = 15, type = Constants.DamageType.FIRE }
    },
    getCost = function(caster, target)
        local fireCost = 3
        if caster and caster.health < 75 then fireCost = 2 end
        if caster and caster.health < 40 then fireCost = 1 end
        if caster and caster.health < 20 then fireCost = 0 end

        local finalCost = {}
        for i = 1, fireCost do
            table.insert(finalCost, Constants.TokenType.FIRE)
        end
        return finalCost
    end,
}

return FireSpells```

## ./spells/elements/generic.lua
```lua
-- spells/elements/generic.lua
-- Contains generic spells with no elemental affinity

local Constants = require("core.Constants")

local GenericSpells = {}

-- Placeholder spell for empty slots
GenericSpells.none = {
    id = "none",
    name = "<None>",
    affinity = "generic",
    description = "Empty spell slot. Cast to do nothing.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "none",
    castTime = Constants.CastSpeed.INSTANT,
    cost = {},  -- No mana cost
    keywords = {
        -- No effect - this is a no-op spell
    },
}

return GenericSpells```

## ./spells/elements/life.lua
```lua
-- spells/elements/life.lua
-- Contains life-element spells

local Constants = require("core.Constants")

local LifeSpells = {}

-- Placeholder for future Life element spells

return LifeSpells```

## ./spells/elements/mind.lua
```lua
-- spells/elements/mind.lua
-- Contains mind-element spells

local Constants = require("core.Constants")

local MindSpells = {}

-- Placeholder for future Mind element spells

-- TODO: add "spell state" tracking to support this (and probably other Mind and Star spells in particular)
MindSpells.thoughtscalp = {
    id = "thoughtscalp",
    name = "Thought Scalp",
    affinity = "mind",
    description = "Picks at opponent's worst fear, dealing slightly more damage every time.",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "slash", -- Constants.VisualShape.SLASH,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MIND},
    keywords = {
      damage = 10
    }
}

return MindSpells```

## ./spells/elements/moon.lua
```lua
-- spells/elements/moon.lua
-- Contains moon-element spells

local Constants = require("core.Constants")
local expr = require("expr")

local MoonSpells = {}

-- Basic Moon Conjuring
MoonSpells.conjuremoonlight = {
    id = "conjuremoonlight",
    name = "Conjure Moonlight",
    affinity = Constants.TokenType.MOON,
    description = "Conjures a Moon mana token. Takes longer to cast the more Moon tokens already present.",
    attackType = "utility",
    visualShape = "affectManaPool",
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.MOON,
            amount = 1
        },
    },
    
    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local moonCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.MOON and token.state == "FREE" then
                    moonCount = moonCount + 1
                end
            end
        end
        return baseCastTime + (moonCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Tidal Force spell
MoonSpells.tidalforce = {
    id = "tidalforce",
    name = "Tidal Force",
    affinity = Constants.TokenType.MOON,
    description = "Chip damage, forces AERIAL enemies out of the air",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.WATER, Constants.TokenType.MOON},
    keywords = {
        damage = {
            amount = 5,
            type = Constants.TokenType.MOON
        },
        ground = {
            conditional = function(caster, target)
                return target and target.elevation == "AERIAL"
            end,
            target = "ENEMY",
        },
    },
    sfx = "tidal_wave",
}

-- Lunar Disjunction spell
MoonSpells.lunardisjunction = {
    id = "lunardisjunction",
    name = "Lunar Disjunction",
    affinity = Constants.TokenType.MOON,
    description = "Cleansing moonlight cancels an opponent's spell and dissolves its mana",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "zap",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON},
    keywords = {
        disjoint = {
            slot = function(caster, target, slot) 
                local slotNum = tonumber(slot) or 0
                if slotNum > 0 and slotNum <= 3 then
                    return slotNum
                else
                    return 0  -- 0 means find the first active slot
                end
            end,
            target = "SLOT_ENEMY"
        },
    },
    sfx = "lunardisjunction_sound",
}

-- Moon Dance spell
MoonSpells.moondance = {
    id = "moondance",
    name = "Moon Dance",
    affinity = Constants.TokenType.MOON,
    description = "Warp space to switch range, deal chip damage, and Freeze xxx enemy Root slot.",
    attackType = "remote",
    visualShape = "warp",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MOON},
    keywords = {
        damage = {
            amount = 6,
            type = Constants.TokenType.MOON
        },
        rangeShift = {
            position = expr.byRange({
                NEAR = "FAR",
                FAR = "NEAR",
                default = "NEAR"
            }),
            target = "SELF" 
        },
        freeze = {
            duration = 3,
            target = "SLOT_ENEMY",
            slot = 1
        }
    }
}

-- Gravity spell
MoonSpells.gravity = {
    id = "gravity",
    name = "Increase Gravity",
    affinity = Constants.TokenType.MOON,
    description = "Grounds AERIAL enemies",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.MOON, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.elevation then
                    return target.elevation == "AERIAL" and 15 or 3
                end
                return 3
            end,
            type = Constants.TokenType.MOON
        },
        ground = {
            conditional = function(caster, target)
                return target and target.elevation == "AERIAL"
            end,
            target = "ENEMY",
        },
        stagger = {
            duration = 2.0
        },
    },
    sfx = "gravity_slam",
}

-- Eclipse spell
MoonSpells.eclipse = {
    id = "eclipse",
    name = "Total Eclipse",
    affinity = Constants.TokenType.MOON,
    description = "Freeze xxx your Heart slot. Conjure Sun.",
    attackType = "utility", 
    visualShape = "eclipse",
    castTime = Constants.CastSpeed.VERY_FAST,
    cost = {Constants.TokenType.MOON, Constants.TokenType.SUN},
    keywords = {
        freeze = {
            duration = 3,
            slot = 2,
            target = "self"
        },
        conjure = {
            token = Constants.TokenType.SUN,
            amount = 1
        },
    },
    sfx = "eclipse_shatter",
}

-- Full Moon Beam spell
MoonSpells.fullmoonbeam = {
    id = "fullmoonbeam",
    name = "Full Moon Beam",
    affinity = Constants.TokenType.MOON,
    description = "Channels moonlight into a beam that deals more damage the longer it's delayed.",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "beam",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.MOON},
    unlockSpell = "lunartides",
    keywords = {
        damage = {
            amount = function(caster, target, slot)
                local baseCastTime = Constants.CastSpeed.FAST
                local accruedModifier = 0
                
                if slot and caster.spellSlots[slot] then
                    local spellSlotData = caster.spellSlots[slot]
                    print(string.format("DEBUG_FMB_SLOT_CHECK: Slot=%d, Active=%s, Progress=%.2f, CastTime=%.1f, Modifier=%.4f, Frozen=%s",
                        slot, tostring(spellSlotData.active), spellSlotData.progress or -1, spellSlotData.castTime or -1, spellSlotData.castTimeModifier or -99, tostring(spellSlotData.frozen)))
                    
                    baseCastTime = spellSlotData.castTime 
                    accruedModifier = spellSlotData.castTimeModifier or 0
                    print(string.format("DEBUG_FMB: Read castTimeModifier=%.4f from spellSlotData", accruedModifier))
                else
                    print(string.format("DEBUG_FMB_WARN: Slot %s or caster.spellSlots[%s] is nil!", tostring(slot), tostring(slot)))
                end
                
                local effectiveCastTime = math.max(0.1, baseCastTime + accruedModifier)
                local damage = math.floor(effectiveCastTime * 2.5)
                
                print(string.format("Full Moon Beam: Base Cast=%.1fs, Modifier=%.1fs, Effective=%.1fs => Damage=%d", 
                    baseCastTime, accruedModifier, effectiveCastTime, damage))
                
                return damage
            end,
            type = Constants.TokenType.MOON
        }
    },
    sfx = "beam_charge",
}

-- Lunar Tides spell
MoonSpells.lunarTides = {
    id = "lunartides",
    name = "Lunar Tides",
    affinity = Constants.TokenType.MOON,
    description = "Manipulates the battle flow based on range and elevation",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    castTime = 7.0,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.ANY, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = expr.byElevation({
                GROUNDED = 8,
                AERIAL = 12,
                default = 8
            }),
            type = Constants.TokenType.MOON,
            target = "ENEMY"
        },
        rangeShift = {
            position = expr.byRange({
                NEAR = "FAR",
                FAR = "NEAR",
                default = "NEAR"
            }),
            target = "SELF"
        },
    },
    sfx = "tide_rush",
}

-- Wings of Moonlight (shield spell)
MoonSpells.wrapinmoonlight = {
    id = "wrapinmoonlight",
    name = "Wings of Moonlight",
    affinity = Constants.TokenType.MOON,
    description = "A runic Ward that stops Projectile and Remote attacks, elevating the caster.",
    attackType = "utility",
    visualShape = "wings",
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.MOON, "any"},
    unlockSpell = "lunardisjunction",
    keywords = {
        block = {
            type = Constants.ShieldType.WARD,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.REMOTE},
            
            onBlock = function(defender, attacker, slot, info)
                print("[SPELL DEBUG] Wings of Moonlight onBlock handler executing!")
                
                local events = {}
                
                table.insert(events, {
                    type = "SET_ELEVATION",
                    source = "caster",
                    target = "self",
                    elevation = Constants.ElevationState.AERIAL,
                    duration = 4.0,
                })
                
                print("[SPELL DEBUG] Wings of Moonlight returning " .. #events .. " events")
                return events
            end
        },
    },
    sfx = "mist_shimmer",
}

-- Gravity Trap spell
MoonSpells.gravityTrap = {
    id = "gravityTrap",
    name = "Icarus Trap",
    affinity = Constants.TokenType.MOON,
    description = "Gravitational trap that triggers when an enemy becomes AERIAL, grounding and damaging them.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "warp",
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.MOON, Constants.TokenType.SUN},
    keywords = {
        sustain = true,
        
        trap_trigger = { 
            condition = "on_opponent_elevate" 
        },
        
        
        trap_effect = {
            damage = { 
                amount = 3, 
                type = Constants.TokenType.MOON,  
                target = "ENEMY" 
            },
            ground = { 
                target = "ENEMY", 
            },
            burn = { 
                duration = 1.5,
                tickDamage = 3,
                tickInterval = 0.5,
                target = "ENEMY"
            },
        },
    },
    sfx = "gravity_trap_set",
}

-- Infinite Procession spell
-- TODO: Improve token-shift keyword to allow _input token_ to be specified
MoonSpells.infiniteprocession = {
    id = "infiniteprocession",
    name = "Infinite Procession",
    affinity = Constants.TokenType.MOON,
    description = "Transmutes MOON tokens into SUN or SUN into MOON.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "affectManaPool",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {},
    keywords = {
        tokenShift = {
            type = expr.more(Constants.TokenType.SUN, Constants.TokenType.MOON),
            amount = 1
        },
    },
    sfx = "conjure_infinite",
}

-- Enhanced Mirror Shield (moon-based shield)
MoonSpells.enhancedmirrorshield = {
    id = "enhancedmirrorshield",
    name = "Celestial Mirror",
    affinity = Constants.TokenType.MOON,
    description = "A powerful reflective barrier that returns damage to attackers with interest",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "mirror",
    castTime = Constants.CastSpeed.VERY_SLOW,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.STAR},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
            
            onBlock = function(defender, attacker, slotIndex, blockInfo)
                if not attacker then return {} end
                
                local events = {}
                
                table.insert(events, {
                    type = "DAMAGE",
                    source = "caster",
                    target = "enemy",
                    amount = 10,
                    damageType = "star",
                    reflectedDamage = true
                })
                
                table.insert(events, {
                    type = "EFFECT",
                    source = "caster",
                    target = "enemy",
                    effectType = "reflect",
                    duration = 0.5
                })
                
                return events
            end
        },
    },
    sfx = "crystal_ring",
}

-- Moon Drain - cost increases with opponent's STAR tokens
MoonSpells.moonDrain = {
    id = "moondrain",
    name = "Moon Drain",
    affinity = Constants.TokenType.MOON,
    description = "Drains opponent. Costs more Moon tokens if opponent is channeling Star mana.",
    attackType = Constants.AttackType.REMOTE,
    castTime = Constants.CastSpeed.FAST,
    cost = { Constants.TokenType.MOON },
    keywords = {
        damage = { amount = 8, type = Constants.DamageType.MOON }
    },
    getCost = function(caster, target)
        local moonTokens = 1
        if target then
            for _, slot in ipairs(target.spellSlots) do
                if slot.active and slot.tokens then
                    for _, tokenData in ipairs(slot.tokens) do
                        if tokenData.token.type == Constants.TokenType.STAR then
                            moonTokens = moonTokens + 1
                        end
                    end
                end
            end
        end

        local finalCost = {}
        for i = 1, math.min(moonTokens, 4) do
            table.insert(finalCost, Constants.TokenType.MOON)
        end
        return finalCost
    end,
}

return MoonSpells```

## ./spells/elements/salt.lua
```lua
-- spells/elements/salt.lua
-- Contains salt-element spells

local Constants = require("core.Constants")

local SaltSpells = {}

-- Conjure Salt spell
SaltSpells.conjuresalt = {
    id = "conjuresalt",
    name = "Conjure Salt",
    affinity = "salt",
    description = "Creates a new Salt mana token",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.SALT,
            amount = 1
        },
    },

    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local saltCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.SALT and token.state == Constants.TokenState.FREE then
                    saltCount = saltCount + 1
                end
            end
        end
        return baseCastTime + (saltCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Glitter Fang spell
SaltSpells.glitterfang = {
    id = "glitterfang",
    name = "Glitter Fang",
    affinity = "salt",
    description = "Very fast, unblockable attack. Only hits NEAR/GROUNDED enemies",
    castTime = Constants.CastSpeed.VERY_FAST,
    attackType = Constants.AttackType.UTILITY,
    cost = {Constants.TokenType.SALT, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = 7,
            type = Constants.DamageType.SALT,
            condition = function(caster, target, slot)
                return target and target.gameState.rangeState == Constants.RangeState.NEAR
                    and target.elevation == Constants.ElevationState.GROUNDED
            end
        },
    },
    sfx = "glitter_fang",
}

SaltSpells.burnToAsh = {
    id = "burnToAsh",
    name = "Burn to Ash",
    affinity = "salt",
    description = "Disrupts opponent channeling, burning one token to Salt.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "zap",
    cost = {Constants.TokenType.FIRE},
    unlockSpell = "combustMana",
    keywords = {
        disruptAndShift = {
            targetType = "salt"
        },
        consume = true,
    }
}

-- Salt Storm spell
SaltSpells.saltstorm = {
    id = "saltstorm",
    name = "Salt Storm",
    affinity = "salt",
    description = "Slow, hard-hitting, shield-breaking area attack.",
    castTime = Constants.CastSpeed.VERY_SLOW,
    attackType = Constants.AttackType.ZONE,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT, Constants.TokenType.SALT},
    unlockSpell = "jaggedearth",
    keywords = {
        damage = {
            amount = 15,
            type = Constants.DamageType.SALT
        },
        zoneMulti = true,
        shieldBreaker = 2,
    },
    sfx = "salt_storm",
}

-- Imprison spell (Salt trap)
SaltSpells.imprison = {
    id = "imprison",
    name = "Imprison",
    affinity = "salt",
    description = "Trap: Deals damage and prevents enemy movement to FAR",
    attackType = "utility",
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        sustain = true,
        
        trap_trigger = { 
            condition = "on_opponent_far" 
        },
        
        
        trap_effect = {
            damage = { 
                amount = 7, 
                type = Constants.DamageType.SALT,  
                target = "ENEMY" 
            },
            rangeShift = { 
                position = Constants.RangeState.NEAR,
            },
        },
    },
    sfx = "gravity_trap_set",
}

-- Jagged Earth spell (Salt trap)
SaltSpells.jaggedearth = {
    id = "jaggedearth",
    name = "Jagged Earth",
    affinity = "salt",
    description = "Trap: Creates a zone of jagged earth that hurts enemies when they become Grounded.",
    castTime = Constants.CastSpeed.SLOW,
    attackType = Constants.AttackType.ZONE,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = 7, 
            type = Constants.DamageType.SALT,
            condition = function(caster, target, slot)
                return target and target.elevation == Constants.ElevationState.GROUNDED
            end
        },
        rangeShift = {  
            position = Constants.RangeState.NEAR,
        },
    },
    sfx = "jagged_earth",
}

-- Salt Circle spell (Ward)
SaltSpells.saltcircle = {
    id = "saltcircle",
    name = "Salt Circle",
    affinity = "salt",
    description = "Ward: Creates a circle of Salt around the caster",
    castTime = Constants.CastSpeed.VERY_FAST,
    attackType = Constants.AttackType.ZONE,
    cost = {Constants.TokenType.SALT},
    keywords = {
        block = {
            type = Constants.ShieldType.WARD,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.REMOTE},
        }
    },
    sfx = "salt_circle",
}

-- Stone Shield spell (Barrier)
SaltSpells.stoneshield = {
    id = "stoneshield",
    name = "Stone Shield",
    affinity = "salt",
    description = "Barrier: Creates a shield of stone around the caster",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
        }
    },
    sfx = "stone_shield",
}

-- Shield-breaking spell
SaltSpells.shieldbreaker = {
    id = "shieldbreaker",
    name = "Salt Spear",
    affinity = "salt",
    description = "A mineral lance that shatters wards and barriers",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = Constants.VisualShape.ZAP,
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDamage = 8
                
                local shieldBonus = 0
                if target and target.spellSlots then
                    for _, slot in ipairs(target.spellSlots) do
                        if slot.active and slot.isShield then
                            shieldBonus = shieldBonus + 6
                            break
                        end
                    end
                end
                
                return baseDamage + shieldBonus
            end,
            type = "force"
        },
    },
    shieldBreaker = 3,
    sfx = "shield_break",
    
    onBlock = function(caster, target, slot, blockInfo)
        print(string.format("[SHIELD BREAKER] %s's Shield Breaker is testing the %s shield's strength!", 
            caster.name, blockInfo.blockType))
        
        return {
            specialBlockMessage = "Shield Breaker collides with active shield!",
            damageShield = true,
            continueExecution = false
        }
    end
}

return SaltSpells```

## ./spells/elements/star.lua
```lua
-- spells/elements/star.lua
-- Contains star-element spells

local Constants = require("core.Constants")
local expr = require("expr")
local ManaHelpers = require("systems.ManaHelpers")

local StarSpells = {}

-- Conjure Stars spell
StarSpells.conjurestars = {
    id = "conjurestars",
    name = "Conjure Stars",
    affinity = "star",
    description = "Creates a new Star mana token",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.STAR,
            amount = 1
        },
    },

    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local starCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.STAR and token.state == Constants.TokenState.FREE then
                    starCount = starCount + 1
                end
            end
        end
        return baseCastTime + (starCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Adaptive Surge test spell
StarSpells.adaptive_surge = {
    id = "adaptivesurge",
    name = "Starstuff",
    affinity = "star",
    description = "A spell that adapts its effects based on the current mana pool",
    attackType = Constants.AttackType.PROJECTILE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.STAR, Constants.TokenType.SUN, Constants.TokenType.MOON},
    keywords = {
        damage = {
            amount = expr.countScale(Constants.TokenType.SUN, 5, 2),
            type = expr.more(Constants.TokenType.SUN, Constants.TokenType.MOON)
        },
        burn = expr.ifCond(
            function(caster, target) 
                return ManaHelpers.count(Constants.TokenType.SUN, caster.manaPool) > 
                    ManaHelpers.count(Constants.TokenType.MOON, caster.manaPool)
            end,
            {
                duration = 3.0,
                tickDamage = 2
            },
            nil
        ),
        slow = expr.ifCond(
            function(caster, target) 
                return ManaHelpers.count(Constants.TokenType.MOON, caster.manaPool) >= 
                    ManaHelpers.count(Constants.TokenType.SUN, caster.manaPool)
            end,
            {
                magnitude = 1.0,
                duration = 5.0
            },
            nil
        ),
    },
    sfx = "adaptive_sound",
}

-- Cosmic Rift spell
StarSpells.cosmicRift = {
    id = "cosmicrift",
    name = "Cosmic Rift",
    affinity = "star",
    description = "Opens a rift that damages opponents and disrupts spellcasting",
    attackType = Constants.AttackType.ZONE,
    castTime = 5.5,
    cost = {"star", "star", "star"},
    keywords = {
        damage = {
            amount = 12,
            type = "star"
        },
        slow = {
            magnitude = 2.0,
            duration = 10.0,
            slot = nil
        },
        zoneMulti = true,
    },
    sfx = "space_tear",
}

return StarSpells```

## ./spells/elements/sun.lua
```lua
-- spells/elements/sun.lua
-- Contains sun-element spells

local Constants = require("core.Constants")
local expr = require("expr")

local SunSpells = {}

-- Sunbolt spell
SunSpells.radiantbolt = {
    id = "radiantbolt",
    name = "Radiant Bolt",
    affinity = "sun",
    description = "Bolt of radiation that deals more damage against AERIAL opponents",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "bolt",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN, Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.elevation == Constants.Elevation.AERIAL then
                    return 25
                end
                return 10
            end,
            type = Constants.DamageType.SUN
        },
    },
    sfx = "fire_whoosh",
}

SunSpells.fusionRay = {
    id = "fusionRay",
    name = "Fusion Ray",
    affinity = "sun",
    description = "A powerful beam of sunlight. Burns the user.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "beam",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = 18,
            target = Constants.TargetType.ENEMY
        },
        burn = {
            amount = 1,
            duration = 5,
            target = Constants.TargetType.SELF  
        }
    },
    sfx = "fire_whoosh",
}

-- Meteor spell
SunSpells.meteor = {
    id = "meteor",
    name = "Meteor Dive",
    affinity = "sun",
    description = "Aerial finisher - GROUND self and create a fiery explosion. Only hits GROUNDED enemies.",
    castTime = Constants.CastSpeed.SLOW,
    attackType = Constants.AttackType.ZONE,
    visualShape = "meteor",
    cost = {Constants.TokenType.SUN, Constants.TokenType.FIRE, Constants.TokenType.SUN, Constants.TokenType.FIRE},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.elevation == Constants.ElevationState.GROUNDED and caster.elevation == Constants.ElevationState.AERIAL then
                    return 30
                end
                return 0
            end,
            type = Constants.DamageType.SUN,
        },
        rangeShift = {
            position = Constants.RangeState.NEAR
        },
        ground = {
            target = Constants.TargetType.SELF 
        }
    },
    sfx = "meteor_impact",
}

-- Emberlift spell
SunSpells.emberlift = {
    id = "emberlift",
    name = "Emberlift",
    affinity = "sun",
    description = "Launches caster into the air, shifts RANGE, and conjures a Fire token.",
    castTime = Constants.CastSpeed.FAST,
    attackType = "utility",
    visualShape = "surge",
    cost = {"sun"},
    keywords = {
        conjure = {
            token = Constants.TokenType.FIRE,
            amount = 1
        },
        elevate = {
            duration = 5.0,
            target = "SELF",
        },
        rangeShift = {
            position = expr.byRange({
                NEAR = "FAR",
                FAR = "NEAR",
                default = "NEAR"
            }),
        }
    },
    sfx = "whoosh_up",
}

-- Nova Conjuring (Combine 3 x FIRE into SUN)
SunSpells.novaconjuring = {
    id = "novaconjuring",
    name = "Nova Conjuring",
    affinity = "sun",
    description = "Expends Fire tokens to conjure a Sun token.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "surge",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {"fire", "fire", "fire"},
    keywords = {
        consume = true,
        conjure = {
            token = {
                Constants.TokenType.SUN,
            },
            amount = 1
        },
    },
    sfx = "conjure_nova",
}

-- Burn the Soul (Inflict Burn on self to conjure a Sun token)
SunSpells.burnTheSoul = {
    id = "burnTheSoul",
    name = "Burn the Soul",
    affinity = "sun",
    description = "Inflict Burn on self to conjure a Sun token.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "surge",
    cost = {},
    keywords = {
        burn = {
            amount = 1,
            duration = 10,
            target = Constants.TargetType.SELF
        },
        conjure = {
            token = Constants.TokenType.SUN,
            amount = 1
        }
    }
}

SunSpells.SpaceRipper = {
    id = "SpaceRipper",
    name = "Space Ripper",
    affinity = "sun",
    description = "Range swap to NEAR. Burn both self and target. Turn SUN to VOID.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    cost = {Constants.TokenType.SUN},
    keywords = {
        rangeShift = {
            position = Constants.RangeState.NEAR
        },
        burn = {
            amount = 3,
            duration = 3,
            target = Constants.TargetType.ALL
        },
        consume = true,
        conjure = {
            token = Constants.TokenType.VOID,
            amount = 1
        }
    }
}

SunSpells.StingingEyes = {
    id = "StingingEyes",
    name = "Stinging Eyes",
    affinity = "sun",
    description = "Damage based on user's Burn level.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "beam",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDamage = 3
                local selfBurnIntensity = 0
                local bonusPerIntensityPoint = 8 -- How much extra damage per point of self-burn tickDamage

                -- Check if the caster is burning
                if caster.statusEffects and
                   caster.statusEffects.burn and
                   caster.statusEffects.burn.active then
                    selfBurnIntensity = caster.statusEffects.burn.tickDamage or 0
                end

                local totalDamage = baseDamage + (selfBurnIntensity * bonusPerIntensityPoint)

                return totalDamage
            end,
            type = Constants.DamageType.SUN
        },
        burn = {
            amount = function(caster, target)
                -- Check if the caster is burning
                if caster.statusEffects and
                   caster.statusEffects.burn and
                   caster.statusEffects.burn.active then
                    local selfBurnIntensity = caster.statusEffects.burn.tickDamage or 0
                    return selfBurnIntensity
                end
                return 0
            end,
            duration = 1,
            target = Constants.TargetType.ENEMY
        }
    }
}

SunSpells.CoreBolt = {
    id = "CoreBolt",
    name = "Core Bolt",
    affinity = "sun",
    description = "Expend SUN and VOID for a powerful energy bolt.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "bolt",
    cost = {Constants.TokenType.SUN, Constants.TokenType.VOID, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = 25,
            target = Constants.TargetType.ENEMY
        },
        consume = true,
    },
    sfx = "fire_whoosh",
    blockableBy = {Constants.ShieldType.BARRIER, Constants.ShieldType.WARD}
}
SunSpells.NuclearFurnace = {
    id = "NuclearFurnace",
    name = "Nuclear Furnace",
    affinity = "sun",
    description = "Damage based on user's Burn level. Burn user further. Conjure Fire.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.ZONE,
    visualShape = "blast",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDamage = 10
                local selfBurnIntensity = 0
                local bonusPerIntensityPoint = 10 -- How much extra damage per point of self-burn tickDamage

                -- Check if the caster is burning
                if caster.statusEffects and
                   caster.statusEffects.burn and
                   caster.statusEffects.burn.active then
                    selfBurnIntensity = caster.statusEffects.burn.tickDamage or 0
                end

                local attackStrength = baseDamage + (selfBurnIntensity * bonusPerIntensityPoint)

                if caster.elevation ~= target.elevation then
                    attackStrength = attackStrength * 0.5
                end

                if caster.gameState.rangeState ~= Constants.RangeState.NEAR then
                    attackStrength = attackStrength * 0.5
                end

                return attackStrength
            end,
            type = Constants.DamageType.SUN
        },
        conjure = {
            token = Constants.TokenType.FIRE,
            amount = 1
        },
        burn = {
            amount = 2,
            duration = 7,
            target = Constants.TargetType.SELF
        }
    },
    sfx = "fire_whoosh",
    blockableBy = {Constants.ShieldType.BARRIER}
}

-- Force Barrier spell (Sun-based shield)
SunSpells.forcebarrier = {
    id = "forcebarrier",
    name = "Sun Block",
    affinity = "sun",
    description = "A protective barrier that blocks projectile and area attacks",
    castTime = Constants.CastSpeed.SLOW,
    attackType = "utility",
    visualShape = "surge",
    cost = {"sun", "sun"},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE}
        },
    },
    sfx = "shield_up",
}

-- Radiant Field spell applying slow to both wizards
SunSpells.radiantfield = {
    id = "radiantfield",
    name = "Radiant Field",
    affinity = "sun",
    description = "Blinding field that slows both wizards while active.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "blast",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        field_status = {
            statusType = Constants.StatusType.SLOW,
            magnitude = Constants.CastSpeed.ONE_TIER
        }
    },
    sfx = "radiant_field"
}

return SunSpells
```

## ./spells/elements/void.lua
```lua
-- spells/elements/void.lua
-- Contains void-element spells

local Constants = require("core.Constants")

local VoidSpells = {}

-- Hilarious Void "conjuring" spell
VoidSpells.conjurenothing = {
    id = "conjurenothing",
    name = "Conjure Nothing",
    affinity = "void",
    description = "Bring nothing into existence",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.VOID, Constants.TokenType.ANY, Constants.TokenType.ANY},
    keywords = {
        expend = {
            amount = 3
        }
    },
    sfx = "void_conjure",
}

-- TODO: Implement this spell. Might need dynamic costing to be implemented first.
-- Design
VoidSpells.riteofemptiness = {
    id = "riteofemptiness",
    name = "Rite of Emptiness",
    affinity = "void",
    description = "Consumes SALT to create STAR, consumes STAR to create VOID.",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {},
    keywords = {
        --todo
    }
}

VoidSpells.quenchPower = {
    id = "quenchPower",
    name = "Quench Power",
    affinity = "void",
    description = "Consumes Celestial or Material mana to create VOID.",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {},
    keywords = {
        --todo
    }
}

-- One-shot kill combo payoff/mega-nuke
VoidSpells.heartripper = {
    id = "heartripper",
    name = "Heart Ripper",
    affinity = "void",
    description = "A terrible curse that strikes down the target with a single instant-kill hit.",
    attackType = Constants.AttackType.REMOTE,
    castTime = Constants.CastSpeed.VERY_SLOW,
    cost = {Constants.TokenType.VOID, Constants.TokenType.STAR, Constants.TokenType.STAR, Constants.TokenType.SALT, Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = 100,
            type = Constants.TokenType.VOID
        }
    },
    sfx = "heartripper",
}

return VoidSpells```

## ./spells/elements/water.lua
```lua
-- spells/elements/water.lua
-- Contains water-element spells

local Constants = require("core.Constants")
local ManaHelpers = require("systems.ManaHelpers")

local WaterSpells = {}

-- Water Gun spell
WaterSpells.watergun = {
    id = "watergun",
    name = "Water Gun",
    affinity = "water",
    description = "Quick ranged hit, more damage against NEAR opponents",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = Constants.VisualShape.BOLT,
    cost = {Constants.TokenType.WATER, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.gameState.rangeState == Constants.RangeState.NEAR then
                    return 15
                end
                return 10
            end,
            type = Constants.DamageType.WATER
        }
    },
    sfx = "fire_whoosh",
}

-- Force blast spell (Steam Vent) - water and fire combo
WaterSpells.forceBlast = {
    id = "forceblast",
    name = "Steam Vent",
    affinity = "water",
    description = "Unleashes a blast of steam that launches opponents into the air",
    attackType = "remote",
    castTime = 4.0,
    cost = {"fire", "water"},
    keywords = {
        damage = {
            amount = 8,
            type = "force"
        },
        elevate = {
            duration = 3.0,
            target = "ENEMY",
        },
    },
    sfx = "force_wind",
}

-- Conjure Water spell
WaterSpells.conjurewater = {
    id = "conjurewater",
    name = "Conjure Water",
    affinity = Constants.TokenType.WATER,
    description = "Conjures a Water mana token. Takes longer to cast the more Water tokens already present.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = Constants.VisualShape.CONJURE_BASE,
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.WATER,
            amount = 1
        }
    },

    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local waterCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.WATER and token.state == Constants.TokenState.FREE then
                    waterCount = waterCount + 1
                end
            end
        end
        return baseCastTime + (waterCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Maelstrom spell - damage scales with WATER tokens in the pool
WaterSpells.maelstrom = {
    id = "maelstrom",
    name = "Maelstrom",
    affinity = Constants.TokenType.WATER,
    description = "Remote blast that grows stronger with each Water token in the mana pool",
    attackType = Constants.AttackType.REMOTE,
    visualShape = Constants.VisualShape.WAVE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.WATER, Constants.TokenType.WATER},
    keywords = {
        damage = {
            amount = function(caster, target)
                local count = ManaHelpers.count(Constants.TokenType.WATER, caster.manaPool)
                return 6 + (count * 2)
            end,
            type = Constants.DamageType.WATER
        }
    },
    sfx = "water_surge",
}

-- Riptide Guard shield - switches range when it blocks
WaterSpells.riptideguard = {
    id = "riptideguard",
    name = "Riptide Guard",
    affinity = Constants.TokenType.WATER,
    description = "Barrier that swaps range with the opponent when it blocks an attack",
    attackType = Constants.AttackType.UTILITY,
    visualShape = Constants.VisualShape.WAVE,
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.WATER, Constants.TokenType.WATER},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},

            onBlock = function(defender, attacker, slotIndex, info)
                local events = {}
                local gameState = defender.gameState
                local newRange = Constants.RangeState.NEAR
                if gameState and gameState.rangeState == Constants.RangeState.NEAR then
                    newRange = Constants.RangeState.FAR
                end
                table.insert(events, {
                    type = "SET_RANGE",
                    source = "caster",
                    target = "both",
                    position = newRange
                })
                return events
            end
        }
    },
    sfx = "tide_rush",
}

-- Brine Chain spell - salt infused lash that slows
WaterSpells.brinechain = {
    id = "brinechain",
    name = "Brine Chain",
    affinity = Constants.TokenType.WATER,
    description = "Salt-laced lash that slows the enemy. Damage scales with Water tokens in the pool",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = Constants.VisualShape.ZAP,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.WATER, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = function(caster, target)
                local count = ManaHelpers.count(Constants.TokenType.WATER, caster.manaPool)
                return 5 + count
            end,
            type = Constants.DamageType.WATER
        },
        slow = {
            magnitude = 1.0,
            duration = 2.0
        }
    },
    sfx = "water_whip",
}

-- Wave Crash spell - consumes tokens for a powerful strike
WaterSpells.wavecrash = {
    id = "wavecrash",
    name = "Wave Crash",
    affinity = Constants.TokenType.WATER,
    description = "Consumes its channeled tokens to unleash a devastating wave",
    attackType = Constants.AttackType.ZONE,
    visualShape = Constants.VisualShape.WAVE,
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.WATER, Constants.TokenType.WATER, Constants.TokenType.WATER},
    unlockSpell = "forceblast",
    keywords = {
        damage = {
            amount = function(caster, target)
                local count = ManaHelpers.count(Constants.TokenType.WATER, caster.manaPool)
                return 10 + count * 3
            end,
            type = Constants.DamageType.WATER
        },
        consume = { amount = "all" },
        conjure = {
            token = Constants.TokenType.SALT,
            amount = 1
        }
    },
    sfx = "wave_crash",
}

return WaterSpells
```

## ./spells/init.lua
```lua
-- spells/init.lua
-- Main entry point for the spells module

local Constants = require("core.Constants")
local Keywords = require("keywords")
local SpellCompiler = require("spellCompiler")
local expr = require("expr")
local ManaHelpers = require("systems.ManaHelpers")
local Schema = require("spells.schema")

-- Import all elemental spell collections
local FireSpells = require("spells.elements.fire")
local WaterSpells = require("spells.elements.water")
local SaltSpells = require("spells.elements.salt")
local SunSpells = require("spells.elements.sun")
local MoonSpells = require("spells.elements.moon")
local StarSpells = require("spells.elements.star")
local LifeSpells = require("spells.elements.life")
local MindSpells = require("spells.elements.mind")
local VoidSpells = require("spells.elements.void")
local GenericSpells = require("spells.elements.generic")

-- Combine all spells into a single table
local Spells = {}

-- Add spells from each collection
local function addSpells(spellCollection)
    for id, spell in pairs(spellCollection) do
        Spells[id] = spell
    end
end

-- Add all elemental spell collections
addSpells(FireSpells)
addSpells(WaterSpells)
addSpells(SaltSpells)
addSpells(SunSpells)
addSpells(MoonSpells)
addSpells(StarSpells)
addSpells(LifeSpells)
addSpells(MindSpells)
addSpells(VoidSpells)
addSpells(GenericSpells)

-- Prepare the return table with all spells and utility functions
local SpellsModule = {
    spells = Spells,
    validateSpell = Schema.validateSpell,
    
    -- Public method to compile all spells
    compileAll = function()
        local compiled = {}
        for id, spell in pairs(Spells) do
            Schema.validateSpell(spell, id)
            -- References to SpellCompiler and Keywords need to be passed from game object
            -- This function will be called with the correct context from main.lua
            print("Waiting for SpellCompiler to compile: " .. spell.name)
        end
        return compiled
    end,
    
    -- Public method to get a compiled spell by ID
    getCompiledSpell = function(spellId, spellCompiler, keywords)
        if not Spells[spellId] then
            print("ERROR: Spell not found: " .. spellId)
            return nil
        end
        
        -- Make sure we have the required objects
        if not spellCompiler or not keywords then
            print("ERROR: Missing SpellCompiler or Keywords for compiling spell: " .. spellId)
            return nil
        end
        
        return spellCompiler.compileSpell(Spells[spellId], keywords)
    end
}

-- Validate all spells at module load time to catch errors early
for spellId, spell in pairs(Spells) do
    Schema.validateSpell(spell, spellId)
end

return SpellsModule```

## ./spells/schema.lua
```lua
-- spells/schema.lua
-- Contains schema definition and validation for spells

local Constants = require("core.Constants")

local Schema = {}

-- Schema for spell object:
-- id: Unique identifier for the spell (string)
-- name: Display name of the spell (string)
-- affinity: The element of the spell (string)
-- description: Text description of what the spell does (string)
-- attackType: How the spell is delivered - Constants.AttackType.PROJECTILE, REMOTE, ZONE, UTILITY
--   * PROJECTILE: Physical projectile attacks - can be blocked by barriers and wards
--   * REMOTE:     Magical attacks at a distance - can only be blocked by wards
--   * ZONE:       Area effect attacks - can be blocked by barriers and fields
--   * UTILITY:    Non-offensive spells that affect the caster - cannot be blocked
-- castTime: Duration in seconds to cast the spell (number)
-- cost: Array of token types required (array using Constants.TokenType.FIRE, etc.)
-- getCost: Optional function(caster, target) -> cost table for dynamic costs
-- keywords: Table of effect keywords and their parameters (table)
--   - Available keywords: damage, burn, stagger, elevate, ground, rangeShift, forcePull, 
--     tokenShift, conjure, dissipate, lock, delay, accelerate, dispel, disjoint, freeze,
--     block, reflect, echo, zoneAnchor, zoneMulti
-- visualShape: Visual shape identifier to override default template based on attackType (string, optional)
-- vfx: Visual effect identifier (string, optional)
-- sfx: Sound effect identifier (string, optional)
--
-- Shield Types and Blocking Rules:
-- * barrier: Physical shield that blocks projectiles and zones
-- * ward:    Magical shield that blocks projectiles and remotes
-- * field:   Energy field that blocks remotes and zones

-- Function to validate spell schema - Basic schema validation
function Schema.validateSpell(spell, spellId)
    -- Add a missing ID based on spell name if needed
    if not spell.id and spell.name then
        spell.id = spell.name:lower():gsub(" ", "")
        print("INFO: Added missing ID for spell: " .. spell.name .. " -> " .. spell.id)
    end
    
    -- Check essential properties with better error handling
    if not spell.id then
        print("WARNING: Spell " .. spellId .. " missing required property: id, creating a default")
        spell.id = "spell_" .. spellId
    end
    
    if not spell.name then
        print("WARNING: Spell " .. spellId .. " missing required property: name, creating a default")
        spell.name = "Unnamed Spell " .. spellId
    end

    if not spell.affinity then
        print("WARNING: Spell " .. spellId .. " missing required property: affinity, creating a default")
        spell.affinity = "fire"
    end
    
    if not spell.description then
        print("WARNING: Spell " .. spellId .. " missing required property: description, creating a default")
        spell.description = "No description available for " .. spell.name
    end
    
    if not spell.castTime then
        print("WARNING: Spell " .. spellId .. " missing required property: castTime, setting default")
        spell.castTime = 5.0 -- Default cast time
    end
    
    if type(spell.castTime) ~= "number" then
        print("WARNING: Spell " .. spellId .. " castTime must be a number, fixing")
        spell.castTime = tonumber(spell.castTime) or 5.0
    end
    
    -- Ensure cost is a table if provided, or create an empty table when neither
    -- cost nor getCost are specified. When getCost exists it's considered the
    -- runtime source of truth so we don't warn about a missing cost table.
    if not spell.cost then
        if spell.getCost and type(spell.getCost) == "function" then
            spell.cost = {}
        else
            print("WARNING: Spell " .. spellId .. " missing required property: cost, creating empty cost")
            spell.cost = {}
        end
    elseif type(spell.cost) ~= "table" then
        print("WARNING: Spell " .. spellId .. " cost must be a table, fixing")
        -- Try to convert to a table if possible
        local originalCost = spell.cost
        spell.cost = {}
        if originalCost then
            print("INFO: Converting non-table cost to table for: " .. spell.name)
            table.insert(spell.cost, tostring(originalCost))
        end
    end
    
    -- Check attackType is valid
    if spell.attackType then
        local validTypes = {
            projectile = true,
            remote = true,
            zone = true,
            utility = true
        }
        
        if not validTypes[spell.attackType] then
            print("WARNING: Spell " .. spellId .. " has invalid attackType: " .. spell.attackType .. ", fixing to utility")
            spell.attackType = "utility" -- Default to utility
        end
    else
        -- Default to utility if not specified
        print("WARNING: Spell " .. spellId .. " missing attackType, setting to utility")
        spell.attackType = "utility"
    end
    
    -- Check keywords are valid (if present)
    if spell.keywords then
        if type(spell.keywords) ~= "table" then
            print("WARNING: Spell " .. spellId .. " keywords must be a table, fixing")
            spell.keywords = {}
        else
            -- Keyword validation is done in the Keywords module
        end
    else
        -- Create empty keywords table if missing
        spell.keywords = {}
    end
    
    return true
end

return Schema```

## ./systems/EventRunner.lua
```lua
-- EventRunner.lua
-- Processes spell events and applies them to game state
--
-- IMPORTANT: Visual Effects Pattern
-- =================================
-- This module now uses the VisualResolver for determining which VFX to trigger.
-- The pattern for creating visuals is:
--
-- 1. For typical gameplay events (damage, status, etc.):
--    - Keywords in keywords.lua should include visual metadata in their events
--    - The EFFECT handler in this module will use VisualResolver.pick() to determine visuals
--
-- 2. For specialized effects in other handlers:
--    - Generate an EFFECT event with proper metadata and dispatch it
--    - This ensures consistent visual handling through the VisualResolver
--
-- 3. Legacy direct VFX calls:
--    - Some handlers still use safeCreateVFX() directly (marked with TODO comments)
--    - These will be gradually migrated to use the VisualResolver pattern

local Constants = require("core.Constants")
local VisualResolver = require("systems.VisualResolver")
local Log = require("core.Log")
local EventRunner = {}

-- Constants for event processing order
local PROCESSING_PRIORITY = {
    -- State setting events (first)
    SET_ELEVATION = 10,
    SET_RANGE = 20,
    FORCE_POSITION = 30,
    ZONE_ANCHOR = 40,
    
    -- Resource events (second)
    CONJURE_TOKEN = 100,
    DISSIPATE_TOKEN = 110,
    SHIFT_TOKEN = 120,
    LOCK_TOKEN = 130,
    CONSUME_TOKENS = 140,
    
    -- Spell timeline events (third)
    ACCELERATE_SPELL = 210,
    CANCEL_SPELL = 220,
    FREEZE_SPELL = 230,
    
    -- Defense events (fourth)
    CREATE_SHIELD = 300,
    REFLECT = 310,
    
    -- Status effects (fifth)
    APPLY_STATUS = 400,
    
    -- Damage events (sixth)
    DAMAGE = 500,
    BLOCKED_DAMAGE = 501, -- Same priority as DAMAGE but won't apply health changes
    
    -- Visual effects (before special effects)
    EFFECT = 550,
    
    -- Special effects (last)
    ECHO = 600,
    ZONE_MULTI = 610
}

-- Sort events by their processing priority
local function sortEventsByPriority(events)
    table.sort(events, function(a, b)
        local priorityA = PROCESSING_PRIORITY[a.type] or 999
        local priorityB = PROCESSING_PRIORITY[b.type] or 999
        return priorityA < priorityB
    end)
    return events
end

-- Safe VFX creation helper function
local function safeCreateVFX(vfx, methodName, fallbackType, x, y, params)
    if not vfx then
        Log.debug("DEBUG: VFX system is nil")
        return false
    end
    
    -- Make sure x and y are valid numbers
    if not x or not y or type(x) ~= "number" or type(y) ~= "number" then
        x = 0
        y = 0
        Log.debug("DEBUG: Invalid coordinates for VFX, using (0,0)")
    end
    
    -- Debug the parameters
    Log.debug(string.format("[safeCreateVFX] Method: %s, EffectType: '%s', Coords: (%d, %d)",
        methodName, tostring(fallbackType), x or 0, y or 0))
        
    -- Try to call the specific method
    if type(vfx[methodName]) == "function" then
        -- Method needs to be called as vfx:methodName() for self to be passed properly
        local success, err = pcall(function() 
            if methodName == "createEffect" then
                -- Print the type of vfx and fallbackType for debugging
                Log.debug("[safeCreateVFX] vfx is type: " .. type(vfx) .. ", fallbackType is type: " .. type(fallbackType))
                
                -- IMPORTANT: Need to use dot notation and pass VFX module as first arg for module functions
                -- DO NOT use colon notation (vfx:createEffect) as it passes vfx as self which makes effectName a table
                Log.debug("[safeCreateVFX] Calling vfx.createEffect with effectName: " .. tostring(fallbackType))
                vfx.createEffect(fallbackType, x, y, nil, nil, params)
            else
                -- For other methods
                Log.debug("[safeCreateVFX] Calling vfx." .. methodName)
                vfx[methodName](vfx, x, y, params) 
            end
        end)
        
        if not success then
            Log.debug("DEBUG: Error calling " .. methodName .. ": " .. tostring(err))
            -- Try fallback on error
            if methodName ~= "createEffect" and type(vfx.createEffect) == "function" then
                pcall(function() vfx.createEffect(fallbackType, x, y, nil, nil, params) end)
            end
        end
        return true
    -- Fall back to generic createEffect if available
    elseif type(vfx.createEffect) == "function" then
        local success, err = pcall(function() 
            vfx.createEffect(fallbackType, x, y, nil, nil, params) 
        end)
        
        if not success then
            Log.debug("DEBUG: Error calling createEffect: " .. tostring(err))
        end
        return true
    else
        -- Debug output if no VFX methods are available
        Log.debug("DEBUG: VFX system lacks both " .. methodName .. " and createEffect methods")
        return false
    end
end

-- Process all events and apply them to game state
function EventRunner.processEvents(events, caster, target, spellSlot)
    -- Double check we actually have valid input
    if not events or type(events) ~= "table" then
        print("WARNING: Nil or invalid events list passed to processEvents")
        return {
            eventsProcessed = 0,
            damageDealt = 0,
            statusEffectsApplied = {},
            shieldCreated = false,
            tokensAffected = 0,
            error = "Invalid events list"
        }
    end
    
    -- Verify caster and target are valid
    if not caster then
        print("WARNING: Nil caster passed to processEvents")
        return {
            eventsProcessed = 0,
            error = "Invalid caster"
        }
    end
    
    -- Create a results table to track effects 
    local results = {
        eventsProcessed = 0,
        damageDealt = 0,
        statusEffectsApplied = {},
        shieldCreated = false,
        tokensAffected = 0
    }
    
    -- Sort events by processing priority
    local success, sortedEvents = pcall(function() 
        return sortEventsByPriority(events)
    end)
    
    if not success then
        print("WARNING: Error sorting events: " .. tostring(sortedEvents))
        sortedEvents = events -- Use unsorted events as fallback
    end
    
    -- Process each event
    for _, event in ipairs(sortedEvents) do
        -- Skip invalid events
        if not event or not event.type then
            print("WARNING: Skipping invalid event")
            goto continue
        end
        
        -- Wrap event handling in pcall to prevent crashes
        local success, handled = pcall(function()
            return EventRunner.handleEvent(event, caster, target, spellSlot, results)
        end)
        
        if success and handled then
            results.eventsProcessed = results.eventsProcessed + 1
        elseif not success then
            -- Log error but continue processing other events
            print("ERROR processing event type " .. (event.type or "unknown") .. ": " .. tostring(handled))
        end
        
        ::continue::
    end
    
    return results
end

-- Handle a single event
function EventRunner.handleEvent(event, caster, target, spellSlot, results)
    -- Validate inputs
    if not event or not event.type then
        print("WARNING: Invalid event passed to handleEvent")
        return false
    end
    
    if not caster then
        print("WARNING: Nil caster in handleEvent for event type " .. event.type)
        return false
    end
    
    if not results then
        print("WARNING: Nil results in handleEvent for event type " .. event.type)
        results = {}
    end
    
    -- Get the event handler for this event type
    local handler = EventRunner.EVENT_HANDLERS[event.type]
    if not handler then
        print("WARNING: No handler for event type " .. event.type)
        return false
    end
    
    -- Call the handler with the event and context in protected mode
    local success, result = pcall(function()
        return handler(event, caster, target, spellSlot, results)
    end)
    
    if not success then
        print("ERROR in event handler for " .. event.type .. ": " .. tostring(result))
        return false
    end
    
    return result
end

-- Resolve the actual target entity for an event
-- This function handles both raw string target types (like "enemy_slot") 
-- and Constants.TargetType enum values (like Constants.TargetType.SLOT_ENEMY)
-- Always returns a table like { wizard, slotIndex } or nil
function EventRunner.resolveTarget(event, caster, target)
    -- Validate inputs
    if not event then
        print("WARNING: Nil event in resolveTarget")
        return {wizard = caster, slotIndex = nil} -- Default to caster as fallback
    end
    
    if not caster then
        print("WARNING: Nil caster in resolveTarget")
        return nil
    end
    
    local targetType = event.target
    local slotIndex = event.slotIndex -- Extract slotIndex from event
    
    -- Handle nil target type
    if targetType == nil then
        print("WARNING: Nil target type in event, defaulting to 'self'")
        return {wizard = caster, slotIndex = slotIndex}
    end
    
    -- Normalize target types to handle both string literals and Constants.TargetType values
    local normalizedTargetType = ""
    if type(targetType) == "string" then
        normalizedTargetType = string.lower(targetType)
    else
        print("WARNING: Non-string target type: " .. type(targetType) .. ", defaulting to 'self'")
        return {wizard = caster, slotIndex = slotIndex}
    end
    
    -- Handle Constants.TargetType values (mapping to strings)
    if targetType == Constants.TargetType.SLOT_ENEMY then
        normalizedTargetType = "enemy_slot"
    elseif targetType == Constants.TargetType.SLOT_SELF then
        normalizedTargetType = "self_slot"
    elseif targetType == Constants.TargetType.SELF then
        normalizedTargetType = "self"
    elseif targetType == Constants.TargetType.ENEMY then
        normalizedTargetType = "enemy"
    elseif targetType == Constants.TargetType.POOL_SELF or targetType == Constants.TargetType.POOL_ENEMY then
        -- Pool targets are handled differently, return nil for wizard/slot structure
        -- The handler must specifically check for pool targets
        return nil 
    end
    
    -- Process normalized target types
    if normalizedTargetType == "self" then
        return {wizard = caster, slotIndex = slotIndex}
    elseif normalizedTargetType == "enemy" then
        if not target then
            print("WARNING: Event targets 'enemy' but target is nil, cannot resolve")
            return nil
        end
        return {wizard = target, slotIndex = slotIndex}
    elseif normalizedTargetType == "self_slot" then
        return {wizard = caster, slotIndex = slotIndex}
    elseif normalizedTargetType == "enemy_slot" then
        if not target then
            print(string.format("WARNING: Event targets 'enemy_slot' but target is nil (event: %s)", event and event.type or "nil"))
            return nil
        end
        return {wizard = target, slotIndex = slotIndex}
    else
        -- Default case for unrecognized types
        print("WARNING: Unrecognized target type: " .. tostring(event.target) .. ", defaulting to 'self'")
        return {wizard = caster, slotIndex = slotIndex}
    end
end

-- Event handler functions
EventRunner.EVENT_HANDLERS = {
    -- ===== Damage Events =====
    
    DAMAGE = function(event, caster, target, spellSlot, results)
        -- Resolve target, expecting { wizard, slotIndex } table or nil
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        
        -- Check if target resolution failed OR if the wizard object is missing
        if not targetInfo or not targetInfo.wizard then 
            print("ERROR: DAMAGE handler could not resolve target wizard")
            return false 
        end
        
        -- Get the actual wizard object
        local targetWizard = targetInfo.wizard
        
        -- Check if we should delay damage application for visual synchronization
        local delayDamage = event.delayDamage or false
        
        -- We don't need to check for blocked spells here anymore
        -- The Wizard:castSpell method now returns early for blocked spells
        -- and they never reach the damage events
        
        -- If the damage isn't delayed, apply it immediately
        if not delayDamage then
            -- Apply damage to the target wizard's health
            targetWizard.health = targetWizard.health - event.amount
            
            -- Ensure health doesn't go below zero
            if targetWizard.health < 0 then targetWizard.health = 0 end
            
            -- Set hit flash timer for visual feedback
            targetWizard.hitFlashTimer = 0.125 -- 125ms flash duration
            
            -- Trigger screen shake and hitstop for high-impact hits
            if event.amount >= 15 or (event.tags and event.tags.HIGH_IMPACT) then
                -- Strong hit - significant screenshake and hitstop
                if targetWizard.gameState and targetWizard.gameState.triggerShake then
                    local intensity = math.min(10, 5 + (event.amount / 10))
                    targetWizard.gameState.triggerShake(0.35, intensity) -- Longer, stronger shake
                    targetWizard.gameState.triggerHitstop(0.12) -- Strong hitstop
                    print(string.format("[DAMAGE EVENT] High impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                        0.35, intensity, 0.12))
                end
            elseif event.amount >= 8 then
                -- Medium hit - moderate screenshake and brief hitstop
                if targetWizard.gameState and targetWizard.gameState.triggerShake then
                    targetWizard.gameState.triggerShake(0.25, 6) -- Medium shake
                    targetWizard.gameState.triggerHitstop(0.08) -- Medium hitstop
                    print(string.format("[DAMAGE EVENT] Medium impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                        0.25, 6, 0.08))
                end
            elseif event.amount >= 3 then
                -- Light hit - minimal screenshake, no hitstop
                if targetWizard.gameState and targetWizard.gameState.triggerShake then
                    targetWizard.gameState.triggerShake(0.15, 4) -- Light shake
                    print(string.format("[DAMAGE EVENT] Light impact hit! Triggering shake (%.2f, %.2f)",
                        0.15, 4))
                end
            end
            
            -- Debug log damage application
            print(string.format("[DAMAGE EVENT] Applied %d damage to %s. New health: %d", 
                event.amount, targetWizard.name, targetWizard.health))
        else
            -- Store damage in the event for deferred application
            print(string.format("[DAMAGE EVENT] Delaying %d damage to %s for visual sync", 
                event.amount, targetWizard.name))
        end
            
        -- Debug log visual metadata
        print(string.format("[DAMAGE EVENT] Visual metadata: affinity=%s, attackType=%s, damageType=%s, manaCost=%s", 
            tostring(event.affinity),
            tostring(event.attackType),
            tostring(event.damageType),
            tostring(event.manaCost)))
        print(string.format("[DAMAGE EVENT] More metadata: tags=%s, rangeBand=%s, elevation=%s", 
            event.tags and "present" or "nil",
            tostring(event.rangeBand),
            tostring(event.elevation)))
        
        -- Track damage for results, even if delayed
        results.damageDealt = results.damageDealt + event.amount
        
        -- Generate an EFFECT event for the damage
        -- Check if we have a spell with effectOverride first
        local effectOverride = nil
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
           caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.effectOverride then
            effectOverride = caster.spellSlots[spellSlot].spell.effectOverride
        end
        
        -- Create EFFECT event
        local effectEvent = {
            type = "EFFECT",
            source = "caster",
            target = event.target,
            effectOverride = effectOverride, -- Use override if we have one
            
            -- Copy visual metadata from the damage event
            affinity = event.affinity,
            attackType = event.attackType,
            damageType = event.damageType,
            manaCost = event.manaCost,
            tags = event.tags or { DAMAGE = true },
            rangeBand = event.rangeBand,
            elevation = event.elevation,
            visualShape = event.visualShape, -- Copy visualShape if present
            
            -- Add delayed damage information
            delayedDamage = delayDamage and event.amount or nil,
            delayedDamageTarget = delayDamage and targetWizard or nil,
            
            -- Copy blockInfo if present for shield block visualization
            blockInfo = event.blockInfo
        }
        
        -- If this is a blocked spell, add SHIELD_BLOCKED tag
        if event.blockInfo and event.blockInfo.blockable then
            effectEvent.tags = effectEvent.tags or {}
            effectEvent.tags.SHIELD_BLOCKED = true
            
            -- Add standard blockPoint
            effectEvent.blockPoint = event.blockInfo.blockPoint or 0.75
            
            print("[DAMAGE->EFFECT] Passing blockInfo to EFFECT event for shield block visuals")
        end
        
        -- Debug log the generated EFFECT event
        print(string.format("[DAMAGE->EFFECT] Generated EFFECT event with effectOverride=%s", 
            tostring(effectOverride)))
        print(string.format("[DAMAGE->EFFECT] Transferred metadata: affinity=%s, attackType=%s, damageType=%s", 
            tostring(effectEvent.affinity),
            tostring(effectEvent.attackType),
            tostring(effectEvent.damageType)))
        print(string.format("[DAMAGE->EFFECT] More metadata: tags=%s, rangeBand=%s, elevation=%s", 
            effectEvent.tags and "present" or "nil",
            tostring(effectEvent.rangeBand),
            tostring(effectEvent.elevation)))
        
        -- Process the effect event to create visuals
        EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        
        return true
    end,
    
    -- Handler for blocked damage events - similar to DAMAGE but doesn't apply health changes
    BLOCKED_DAMAGE = function(event, caster, target, spellSlot, results)
        -- Resolve target, expecting { wizard, slotIndex } table or nil
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        
        -- Check if target resolution failed OR if the wizard object is missing
        if not targetInfo or not targetInfo.wizard then 
            print("ERROR: BLOCKED_DAMAGE handler could not resolve target wizard")
            return false 
        end
        
        -- Get the actual wizard object
        local targetWizard = targetInfo.wizard
        
        -- Log the blocked damage (no damage is applied)
        print(string.format("[BLOCKED_DAMAGE] %s's spell blocked by shield! No damage applied to %s (would have been %d)", 
            caster.name, targetWizard.name, event.amount or 0))
            
        -- Track in results that a block occurred
        results.damageBlocked = (results.damageBlocked or 0) + (event.amount or 0)
        
        -- The block shake will be triggered in vfx.lua when the projectile actually hits the shield
        -- instead of when the BLOCKED_DAMAGE event is first generated
        -- We'll add the shield hit info to the event instead
        
        -- Enhanced debugging for BLOCKED_DAMAGE event
        print("[BLOCKED_DAMAGE] Full event details:")
        for k, v in pairs(event) do
            if type(v) == "table" then
                print("  " .. k .. ": [table]")
            else
                print("  " .. k .. ": " .. tostring(v))
            end
        end
        
        -- Verify we have blockInfo
        if not event.blockInfo then
            print("[BLOCKED_DAMAGE] WARNING: Missing blockInfo in BLOCKED_DAMAGE event!")
            -- Create a default blockInfo to ensure visuals still work
            event.blockInfo = {
                blockable = true,
                blockType = event.shieldType or "ward",
                blockPoint = event.blockPoint or 0.75
            }
        end
        
        -- Generate an EFFECT event for the blocked damage visuals
        -- Check if we have a spell with effectOverride first
        local effectOverride = nil
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
           caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.effectOverride then
            effectOverride = caster.spellSlots[spellSlot].spell.effectOverride
        end
        
        -- Create EFFECT event with block info
        local effectEvent = {
            type = "EFFECT",
            source = "caster",
            target = event.target,
            effectOverride = effectOverride,
            
            -- Copy visual metadata from the damage event
            affinity = event.affinity,
            attackType = event.attackType or "projectile", -- Default to projectile if missing
            damageType = event.damageType,
            manaCost = event.manaCost,
            tags = event.tags or { DAMAGE = true, SHIELD_BLOCKED = true },
            rangeBand = event.rangeBand,
            elevation = event.elevation,
            visualShape = event.visualShape or "bolt", -- Default to bolt if missing
            
            -- Copy block info for visual effects - ensure it's always present
            blockInfo = event.blockInfo,
            blockPoint = event.blockPoint or 0.75,
            
            -- Add the amount of damage for screen shake calculation
            amount = event.amount or 10
        }
        
        -- Debug log the generated EFFECT event
        print(string.format("[BLOCKED_DAMAGE->EFFECT] Generated EFFECT event with blockPoint=%.2f", 
            effectEvent.blockPoint))
        print("[BLOCKED_DAMAGE->EFFECT] Full effectEvent details:")
        for k, v in pairs(effectEvent) do
            if type(v) == "table" then
                print("  " .. k .. ": [table]")
            else
                print("  " .. k .. ": " .. tostring(v))
            end
        end
        
        -- Process the effect event to create visuals
        local success, err = pcall(function()
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        end)
        
        if not success then
            print("[BLOCKED_DAMAGE->EFFECT] ERROR: Failed to process effect event: " .. tostring(err))
        end
        
        return true
    end,
    
    -- ===== Status Effect Events =====
    
    APPLY_STATUS = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then 
            print("ERROR: APPLY_STATUS handler could not resolve target wizard")
            return false 
        end
        local targetWizard = targetInfo.wizard
        
        -- Initialize status effects table if it doesn't exist
        targetWizard.statusEffects = targetWizard.statusEffects or {}
        
        -- Build effect data table
        local effectData = {
            active = true,
            duration = event.duration or 0,
            tickDamage = event.tickDamage,
            tickInterval = event.tickInterval,
            magnitude = event.magnitude,
            targetSlot = event.targetSlot,
            elapsed = 0,
            totalTime = 0,
            source = caster
        }

        if event.statusType == Constants.StatusType.STUN then
            -- Explicitly store under "stun" key for easy access
            targetWizard.statusEffects[Constants.StatusType.STUN] = effectData
        else
            -- Generic status effect storage
            targetWizard.statusEffects[event.statusType] = effectData
        end
        
        -- Log the application
        print(string.format("[STATUS] Applied %s to %s (Duration: %.1f, Magnitude: %s, Slot: %s)", 
            event.statusType, targetWizard.name, event.duration or 0, tostring(event.magnitude), tostring(event.targetSlot)))

        -- Track applied status for results
        table.insert(results.statusEffectsApplied, event.statusType)
        
        -- Create status effect VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Assuming createStatusEffect takes the wizard object
            caster.gameState.vfx.createStatusEffect(targetWizard, event.statusType)
        end
        
        return true
    end,
    
    -- ===== Elevation Events =====
    
    SET_ELEVATION = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then 
             print("ERROR: SET_ELEVATION handler could not resolve target wizard")
             return false
        end
        local targetWizard = targetInfo.wizard
        
        -- Set elevation state
        targetWizard.elevation = event.elevation
        
        -- Set duration if provided
        if event.duration then
            targetWizard.elevationEffects = targetWizard.elevationEffects or {}
            targetWizard.elevationEffects[event.elevation] = {
                duration = event.duration,
                expireAction = function()
                    -- When effect expires, return to default elevation (usually GROUNDED)
                    targetWizard.elevation = Constants.ElevationState.GROUNDED
                end
            }
        end
        
        -- No need to manually trigger position animation here -
        -- The wizard's positionAnimation is automatically detected and handled
        -- in WizardVisuals.drawWizard when elevation changes
        
        -- Create elevation change VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Interim Approach: Generate an EFFECT event to handle VFX consistently
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = event.target,
                -- If the event has a custom vfx specified, use it as an override
                effectOverride = (event.vfx and type(event.vfx) == "string") and event.vfx or nil,
                -- Provide elevation metadata for the resolver
                affinity = event.affinity, -- Use affinity from original event
                attackType = Constants.AttackType.UTILITY,    -- Elevation is a utility spell type
                manaCost = event.manaCost or 1,
                tags = { MOVEMENT = true, [event.elevation == Constants.ElevationState.AERIAL and "ELEVATE" or "GROUND"] = true },
                rangeBand = caster.gameState.rangeState,
                elevation = event.elevation,
                visualShape = event.visualShape, -- Preserve visualShape if specified
                duration = 1.0
            }
            
            -- Process the effect event, which will use the VisualResolver internally
            -- This ensures consistent visual handling for all effects
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
            
            -- Note: The above approach is cleaner than calling VisualResolver directly
            -- as it ensures all event parameters are properly passed through
        end
        
        return true
    end,
    
    -- ===== Range Events =====
    
    SET_RANGE = function(event, caster, target, spellSlot, results)
        local targetEntities
        
        -- Range changes always affect both wizards
        if event.target == "both" then
            targetEntities = {caster, target}
        else
            targetEntities = {EventRunner.resolveTarget(event, caster, target)}
        end
        
        -- Update game state with new range
        if caster.gameState then
            -- Store the new range state
            caster.gameState.rangeState = event.position
            
            -- No need to call any extra position animation functions - the wizards'
            -- positionAnimation state is automatically detected and updated in 
            -- WizardVisuals.drawWizard when it sees the range state has changed
        end
        
        -- Create range change VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Generate an EFFECT event for consistent handling through VisualResolver
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = "both", -- Range changes affect both wizards
                effectOverride = Constants.VFXType.RANGE_CHANGE, -- Use explicit override for this special effect
                -- Provide relevant metadata for the resolver
                affinity = event.affinity,
                attackType = Constants.AttackType.UTILITY,
                manaCost = 1,
                tags = { MOVEMENT = true },
                rangeBand = event.position, -- The new range state
                elevation = caster.elevation,
                visualShape = event.visualShape, -- Preserve visualShape if specified
                duration = 1.0,
                -- Extra params specific to range changes
                position = event.position
            }
            
            -- Process the effect event through the standard pipeline
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        end
        
        return true
    end,
    
    FORCE_POSITION = function(event, caster, target, spellSlot, results)
        -- Force opponent to match caster's range
        -- Range is stored in game state, not on individual wizards
        if caster.gameState then
            -- Just a shortcut to quickly force range change - could be expanded if needed
            caster.gameState.rangeState = caster.gameState.rangeState
            
            -- Create position force VFX if available
            if caster.gameState.vfx then
                -- TODO: VFX-R5 - Update this to use VisualResolver pattern
                -- This handler should be refactored to generate an EFFECT event
                -- for consistency, but we'll leave it for now as it's a specialized effect
                local params = {
                    duration = 1.0,
                    source = caster.name,
                    target = target.name
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createPositionForceEffect",
                    Constants.VFXType.FORCE_POSITION,
                    (caster.x + target.x) / 2,  -- Midpoint
                    (caster.y + target.y) / 2,  -- Midpoint
                    params
                )
            end
        end
        
        return true
    end,
    
    -- ===== Resource & Token Events =====
    
    CONJURE_TOKEN = function(event, caster, target, spellSlot, results)
        local manaPool = caster.manaPool
        if not manaPool then return false end
        
        -- Create VFX for token conjuration using the rule-driven approach
        if caster.gameState and caster.gameState.vfx then
            -- Create an EFFECT event to use the VisualResolver pattern
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = "caster", -- Token conjuration affects the caster
                
                -- Check if there's a specific effect for this token type
                effectOverride = nil, -- Will be set conditionally below
                
                -- Token type determines appearance through VisualResolver
                affinity = event.tokenType,
                attackType = Constants.AttackType.UTILITY,
                manaCost = event.amount, -- Scale with the amount of tokens
                
                -- Metadata to determine visuals and behavior
                tags = { CONJURE = true, RESOURCE = true },
                
                -- Token-specific parameters
                tokenType = event.tokenType,
                amount = event.amount
            }
            
            -- Check if there's a specific effect for this token type
            local specificEffect = "conjure" .. event.tokenType
            if Constants.VFXType[specificEffect:upper()] then
                effectEvent.effectOverride = Constants.VFXType[specificEffect:upper()]
            end
            
            -- Let the EFFECT handler process this with VisualResolver
            EventRunner.handleEvent(effectEvent, caster, caster, spellSlot, results)
        end
        
        -- Add tokens to the mana pool with animation
        for i = 1, event.amount do
            local assetPath = "assets/sprites/v2Tokens/" .. event.tokenType .. "-token.png"
            manaPool:addTokenWithAnimation(event.tokenType, assetPath, caster)
            results.tokensAffected = results.tokensAffected + 1
        end
        
        return true
    end,
    
    DISSIPATE_TOKEN = function(event, caster, target, spellSlot, results)
        local manaPool = caster.manaPool
        if not manaPool then return false end
        
        -- Find and remove tokens from the mana pool
        local tokensRemoved = 0
        
        -- Logic to find and mark tokens for removal
        for i, token in ipairs(manaPool.tokens) do
            local isFree = (token.status == Constants.TokenStatus.FREE)
            local matchesType = (event.tokenType == Constants.TokenType.ANY or token.type == event.tokenType)
            
            if isFree and matchesType then
                -- Request destruction animation using state machine
                token:requestDestructionAnimation()
                
                tokensRemoved = tokensRemoved + 1
                results.tokensAffected = results.tokensAffected + 1
                
                -- Stop once we've marked enough tokens
                if tokensRemoved >= event.amount then
                    break
                end
            end
        end
        
        return true
    end,
    
    SHIFT_TOKEN = function(event, caster, target, spellSlot, results)
        local manaPool = caster.manaPool
        if not manaPool then return false end
        
        -- Count how many tokens we successfully shifted
        local tokensShifted = 0
        
        -- Handle random token shifting
        if event.tokenType == Constants.TokenType.RANDOM then
            local tokenTypes = Constants.getAllTokenTypes()
            
            -- Find FREE tokens and shift them to random types
            for i, token in ipairs(manaPool.tokens) do
                if token.status == Constants.TokenStatus.FREE then
                    -- Pick a random token type
                    local randomType = tokenTypes[math.random(#tokenTypes)]
                    local oldType = token.type
                    
                    -- Only change if it's a different type
                    if randomType ~= oldType then
                        token.type = randomType
                        token.image = love.graphics.newImage("assets/sprites/v2Tokens/" .. randomType .. "-token.png")
                        tokensShifted = tokensShifted + 1
                        results.tokensAffected = results.tokensAffected + 1
                    end
                    
                    -- Stop once we've shifted enough tokens
                    if tokensShifted >= event.amount then
                        break
                    end
                end
            end
        else
            -- Find FREE tokens and shift them to the specified type
            for i, token in ipairs(manaPool.tokens) do
                if token.status == Constants.TokenStatus.FREE and token.type ~= event.tokenType then
                    token.type = event.tokenType
                    token.image = love.graphics.newImage("assets/sprites/v2Tokens/" .. event.tokenType .. "-token.png")
                    tokensShifted = tokensShifted + 1
                    results.tokensAffected = results.tokensAffected + 1
                    
                    -- Stop once we've shifted enough tokens
                    if tokensShifted >= event.amount then
                        break
                    end
                end
            end
        end
        
        return true
    end,
    
    LOCK_TOKEN = function(event, caster, target, spellSlot, results)
        -- Target the SHARED mana pool via gameState
        local manaPool = caster.gameState.manaPool 
        if not manaPool then 
            print("ERROR: LOCK_TOKEN handler could not find shared manaPool via caster.gameState")
            return false 
        end
        
        -- Find all FREE tokens matching the type (or 'any')
        local freeTokens = {}
        for i, token in ipairs(manaPool.tokens) do
            if token.status == Constants.TokenStatus.FREE and (event.tokenType == "any" or token.type == event.tokenType) then
                table.insert(freeTokens, token)
            end
        end
        
        -- If no free tokens found, do nothing
        if #freeTokens == 0 then
            return false -- Indicate event didn't successfully apply
        end
        
        -- Lock the specified amount (usually 1) of random free tokens
        local tokensLocked = 0
        local lockAmount = event.amount or 1
        
        while tokensLocked < lockAmount and #freeTokens > 0 do
            -- Select a random token from the list
            local randomIndex = math.random(#freeTokens)
            local tokenToLock = table.remove(freeTokens, randomIndex)
            
            -- Lock the selected token
            if tokenToLock.setState then
                tokenToLock:setState(Constants.TokenStatus.LOCKED)
            end
            tokenToLock.lockTimer = event.duration
            tokensLocked = tokensLocked + 1
            results.tokensAffected = results.tokensAffected + 1
            
            -- Create lock visual effect if VFX system available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = event.duration,
                    tokenType = tokenToLock.type
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createTokenLockEffect",
                    Constants.VFXType.TOKEN_LOCK,
                    tokenToLock.x,
                    tokenToLock.y,
                    params
                )
            end
        end
        
        return tokensLocked > 0 -- Return true if at least one token was locked
    end,
    
    -- ===== Spell Timing Events =====
    
    ACCELERATE_SPELL = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex
        
        -- If slotIndex is not specified, use the current slot
        if not slotIndex or slotIndex == 0 then
            slotIndex = spellSlot
        end
        
        -- Apply acceleration to the slot
        local slot = wizard.spellSlots[slotIndex]
        if slot and slot.active and not slot.isShield then
            slot.progress = slot.progress + event.amount
            
            -- Create acceleration VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = 1.0,
                    amount = event.amount,
                    slotIndex = slotIndex
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createSpellAccelerateEffect",
                    Constants.VFXType.SPELL_ACCELERATE,
                    wizard.x,
                    wizard.y,
                    params
                )
            end
            
            return true
        end
        
        return false
    end,
    
    CANCEL_SPELL = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex
        
        -- If slotIndex is not specified, pick a random active slot
        if not slotIndex or slotIndex == 0 then
            local activeSlots = {}
            for i, slot in ipairs(wizard.spellSlots) do
                if slot.active and not slot.isShield then
                    table.insert(activeSlots, i)
                end
            end
            
            if #activeSlots > 0 then
                slotIndex = activeSlots[math.random(#activeSlots)]
            else
                -- No active slots, nothing to cancel
                return false
            end
        end
        
        -- Apply cancel to the slot
        local slot = wizard.spellSlots[slotIndex]
        if slot and slot.active and not slot.isShield then
            -- Check if mana should be returned to the pool
            if event.returnMana then
                -- Return tokens to the pool (dispel)
                for _, tokenData in ipairs(slot.tokens) do
                    if tokenData.token then
                        tokenData.token:requestReturnAnimation()
                    end
                end
            else
                -- Destroy tokens (disjoint)
                for _, tokenData in ipairs(slot.tokens) do
                    if tokenData.token then
                        tokenData.token:requestDestructionAnimation()
                    end
                end
            end
            
            -- Reset the slot
            wizard:resetSpellSlot(slotIndex)
            
            -- Create cancel VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = 1.0,
                    returnMana = event.returnMana,
                    slotIndex = slotIndex
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createSpellCancelEffect",
                    Constants.VFXType.SPELL_CANCEL,
                    wizard.x,
                    wizard.y,
                    params
                )
            end
            
            return true
        end
        
        return false
    end,
    
    FREEZE_SPELL = function(event, caster, target, spellSlot, results)
        local resolvedTarget = EventRunner.resolveTarget(event, caster, target)
        
        -- Determine the actual wizard and slot index
        local wizardToFreeze = nil
        local slotIndexToFreeze = event.slotIndex or 3 -- Get slot from event, default to 2
        
        if not resolvedTarget then
            print("ERROR: FREEZE_SPELL target resolution failed.")
            return false
        end
        
        -- Check the type of the resolved target
        if type(resolvedTarget) == "table" then
            if resolvedTarget.wizard then 
                -- It's a slot target table: {wizard, slotIndex}
                wizardToFreeze = resolvedTarget.wizard
                -- Use slot index from table if provided, otherwise stick to event/default
                slotIndexToFreeze = resolvedTarget.slotIndex or slotIndexToFreeze 
            elseif resolvedTarget.name then 
                -- It's likely a direct wizard object (check for 'name' as indicator)
                wizardToFreeze = resolvedTarget
            else
                -- It's some other table type (e.g., manaPool), which is invalid for FREEZE
                 print("ERROR: FREEZE_SPELL resolved target is an unexpected table type.")
                 return false
            end
        else
            -- Should not happen if resolveTarget is working, but handle unexpected types
            print("ERROR: FREEZE_SPELL resolved target is not a table (wizard or slot table expected).")
            return false
        end

        -- Final check for wizard object
        if not wizardToFreeze then
            print("ERROR: FREEZE_SPELL could not determine target wizard.")
            return false
        end

        -- Handle case where slot index is nil or 0 (needs default/random logic)
        if not slotIndexToFreeze or slotIndexToFreeze == 0 then
            slotIndexToFreeze = 2 -- Default to middle slot
            
            -- If default slot 2 is not active, find *any* active, non-shield slot
            if not wizardToFreeze.spellSlots[slotIndexToFreeze] or not wizardToFreeze.spellSlots[slotIndexToFreeze].active or wizardToFreeze.spellSlots[slotIndexToFreeze].isShield then
                local activeSlots = {}
                for i, slotData in ipairs(wizardToFreeze.spellSlots) do
                    if slotData.active and not slotData.isShield then
                        table.insert(activeSlots, i)
                    end
                end
                
                if #activeSlots > 0 then
                    slotIndexToFreeze = activeSlots[math.random(#activeSlots)]
                else
                    return false -- No valid target slot
                end
            end
        end
        
        -- Apply freeze to the determined wizard and slot index
        local slot = wizardToFreeze.spellSlots[slotIndexToFreeze]

        if slot and slot.active and not slot.isShield then
            slot.frozen = true
            slot.freezeTimer = event.duration
            
            -- Create freeze VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = event.duration,
                    slotIndex = slotIndexToFreeze
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createSpellFreezeEffect",
                    Constants.VFXType.SPELL_FREEZE,
                    wizardToFreeze.x,
                    wizardToFreeze.y,
                    params
                )
            end
            
            -- Return true and results structure
            results.freezeApplied = true
            results.frozenSlot = slotIndexToFreeze
            results.freezeDuration = event.duration
            return true
        end
        
        return false
    end,
    
    -- NEW HANDLER: Disrupts channeling, shifts token type, returns it to pool
    DISRUPT_AND_SHIFT = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex
        
        -- If slotIndex is 0 or nil, pick a random active slot (including shields)
        if not slotIndex or slotIndex == 0 then
            local activeSlots = {}
            for i, slot in ipairs(wizard.spellSlots) do
                if slot.active then 
                    table.insert(activeSlots, i)
                end
            end
            
            if #activeSlots > 0 then
                slotIndex = activeSlots[math.random(#activeSlots)]
            else
                return false -- No valid target slot
            end
        end
        
        -- Get the target slot
        local slot = wizard.spellSlots[slotIndex]
        if not slot or not slot.active or not slot.tokens or #slot.tokens == 0 then
            return false -- Invalid target slot
        end
        
        -- Select 1 random token from the slot's tokens
        local tokenIndexToRemove = math.random(#slot.tokens)
        local tokenDataToRemove = slot.tokens[tokenIndexToRemove]
        local removedTokenObject = tokenDataToRemove.token
        local originalType = removedTokenObject and removedTokenObject.type or "unknown"

        -- Remove the token data reference from the slot
        table.remove(slot.tokens, tokenIndexToRemove)

        -- Shift the REMOVED token object's type and request return animation
        if removedTokenObject then
            local newType = event.newType or Constants.TokenType.FIRE
            local oldType = removedTokenObject.type
            removedTokenObject.type = newType
            removedTokenObject.image = love.graphics.newImage("assets/sprites/v2Tokens/" .. newType .. "-token.png")
            results.tokensAffected = (results.tokensAffected or 0) + 1
            
            -- Request token return animation
            removedTokenObject:requestReturnAnimation()

            -- Trigger a VFX for the type shift
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = 0.8,
                    oldType = oldType,
                    newType = newType
                }
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createTokenShiftEffect", -- Need to add this VFX method
                    Constants.VFXType.TOKEN_SHIFT,
                    removedTokenObject.x, 
                    removedTokenObject.y,
                    params
                )
            end
        else
            print("WARNING: Could not find token object to shift after removal from slot.")
        end

        -- Call the centralized Law of Completion check on the target wizard
        wizard:checkFizzleOnTokenRemoval(slotIndex, removedTokenObject)
        
        return true -- Event succeeded
    end,
    
    -- CONSUME_TOKENS: Permanently removes the tokens channeled to cast a spell
    CONSUME_TOKENS = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = event.slotIndex or spellSlot
        
        -- Get the target slot
        local slot = wizard.spellSlots[slotIndex]
        if not slot or not slot.active or not slot.tokens or #slot.tokens == 0 then
            return false -- Invalid target slot
        end
        
        -- Track how many tokens we consume
        local tokensConsumed = 0
        
        -- Go through all tokens in the slot and mark them for destruction
        for _, tokenData in ipairs(slot.tokens) do
            if tokenData.token then
                -- Check if we should consume this token based on amount parameter
                local shouldConsume = true
                if event.amount ~= "all" and tokensConsumed >= event.amount then
                    shouldConsume = false
                end
                
                if shouldConsume then
                    -- Request destruction animation
                    tokenData.token:requestDestructionAnimation()
                    
                    tokensConsumed = tokensConsumed + 1
                    results.tokensAffected = (results.tokensAffected or 0) + 1
                end
            end
        end
        
        -- Create VFX for token consumption if available
        if tokensConsumed > 0 and caster.gameState and caster.gameState.vfx then
            local params = {
                slotIndex = slotIndex,
                tokensConsumed = tokensConsumed
            }
            
            safeCreateVFX(
                caster.gameState.vfx,
                "createTokenConsumeEffect",
                Constants.VFXType.TOKEN_CONSUME,
                wizard.x,
                wizard.y,
                params
            )
        end
        
        print(string.format("[CONSUME] Consumed %d tokens from slot %d", tokensConsumed, slotIndex))
        
        return tokensConsumed > 0 -- Success if at least one token was consumed
    end,
    
    -- ===== Defense Events =====
    
    CREATE_SHIELD = function(event, caster, target, spellSlot, results)
        -- For shields, we need to handle events differently because the wizard is always the caster
        -- and the target is always a spell slot on the caster
        local wizard = nil
        local slotIndex = nil
        
        -- Determine which wizard and slot to use
        if event.target == "self_slot" then
            wizard = caster
            slotIndex = event.slotIndex or spellSlot
        elseif event.target == Constants.TargetType.SELF or event.target == "self" then
            -- Handle case when target is just "SELF" (shield spells often use this)
            wizard = caster
            slotIndex = spellSlot
        else
            -- Try the normal target resolution for other cases
            local targetInfo = EventRunner.resolveTarget(event, caster, target)
            if targetInfo and targetInfo.wizard then
                wizard = targetInfo.wizard
                slotIndex = targetInfo.slotIndex or spellSlot
            end
        end
        
        -- Verify we have a valid wizard and slot
        if not wizard or not slotIndex then
            print("ERROR: Invalid wizard or slot for shield creation")
            return false
        end
        
        -- Check that the slot exists and has tokens
        local slot = wizard.spellSlots[slotIndex]
        if not slot or not slot.tokens or #slot.tokens == 0 then 
            print("ERROR: Slot " .. slotIndex .. " invalid or has no tokens for shield")
            return false 
        end
        
        -- Create shield parameters from the event
        local shieldParams = {
            createShield = true,
            defenseType = event.defenseType or Constants.ShieldType.BARRIER,
            type = event.defenseType or Constants.ShieldType.BARRIER, -- Add type as well for compatibility
            blocksAttackTypes = event.blocksAttackTypes or {Constants.AttackType.PROJECTILE},
            reflect = event.reflect or false,
            onBlock = event.onBlock or nil
        }
        
        -- Debug logging for onBlock
        if event.onBlock then
            Log.debug("[EVENT DEBUG] CREATE_SHIELD event contains onBlock handler")
            Log.debug("[EVENT DEBUG] Type of onBlock: " .. type(event.onBlock))
            
            -- Check if it's actually a function
            if type(event.onBlock) == "function" then
                Log.debug("[EVENT DEBUG] onBlock is a valid function")
            else
                Log.debug("[EVENT DEBUG] WARNING: onBlock is not a function!")
            end
        else
            Log.debug("[EVENT DEBUG] CREATE_SHIELD event has no onBlock handler")
        end
        
        -- Check if the wizard has a createShield method
        if type(wizard.createShield) ~= "function" then
            print("ERROR: Wizard " .. wizard.name .. " does not have createShield method")
            
            -- Default implementation if the method is missing
            print("Using fallback shield creation")
            slot.isShield = true
            slot.defenseType = shieldParams.defenseType
            slot.blocksAttackTypes = shieldParams.blocksAttackTypes
            slot.reflect = shieldParams.reflect
            slot.onBlock = shieldParams.onBlock
            
            -- Mark tokens as shielding
            for _, tokenData in ipairs(slot.tokens) do
                if tokenData.token then
                    tokenData.token:setState(Constants.TokenStatus.SHIELDING)
                    Log.debug("DEBUG: Marked token as SHIELDING to prevent return to pool")
                end
            end
        else
            -- Call the wizard's createShield method
            wizard:createShield(slotIndex, shieldParams)
        end
        
        -- Track shield creation in results
        results.shieldCreated = true
        
        return true
    end,
    
    REFLECT = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then 
             print("ERROR: REFLECT handler could not resolve target wizard")
            return false
        end
        local targetWizard = targetInfo.wizard
        
        -- Set reflect property on the wizard
        targetWizard.reflectActive = true
        targetWizard.reflectDuration = event.duration
        
        -- Create reflect VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Generate an EFFECT event for consistent handling through VisualResolver
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = event.target,
                effectOverride = Constants.VFXType.REFLECT, -- Use explicit override for now
                -- Provide relevant metadata for the resolver
                affinity = event.affinity, 
                attackType = Constants.AttackType.UTILITY,
                manaCost = event.manaCost or 2,
                tags = { DEFENSE = true, SHIELD = true },
                rangeBand = caster.gameState.rangeState,
                elevation = targetWizard.elevation,
                duration = event.duration or 3.0
            }
            
            -- Process the effect event through the standard pipeline
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        end
        
        return true
    end,
    
    -- ===== Special Events =====
    
    ECHO = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex or spellSlot
        
        -- Schedule an echo of the current spell
        local slot = wizard.spellSlots[slotIndex]
        if slot and slot.spell then
            -- Create an echo entry in the wizard's echo queue
            wizard.echoQueue = wizard.echoQueue or {}
            table.insert(wizard.echoQueue, {
                spell = slot.spell,
                delay = event.delay,
                timer = event.delay
            })
            
            -- Create echo VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    delay = event.delay,
                    slotIndex = slotIndex,
                    spellName = slot.spell.name
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createEchoEffect",
                    Constants.VFXType.SPELL_ECHO,
                    wizard.x,
                    wizard.y,
                    params
                )
            end
            
            return true
        end
        
        return false
    end,
    
    ZONE_ANCHOR = function(event, caster, target, spellSlot, results)
        local targetEntity = EventRunner.resolveTarget(event, caster, target)
        if not targetEntity then return false end
        
        -- Store zone anchor information on the spell itself 
        -- This will be checked during spell resolution
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] then
            local slot = caster.spellSlots[spellSlot]
            slot.zoneAnchored = true
            slot.anchorRange = event.anchorRange
            slot.anchorElevation = event.anchorElevation
            slot.anchorRequireAll = event.requireAll
            
            return true
        end
        
        return false
    end,
    
    ZONE_MULTI = function(event, caster, target, spellSlot, results)
        local targetEntity = EventRunner.resolveTarget(event, caster, target)
        if not targetEntity then return false end
        
        -- Mark this spell as affecting both ranges
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] then
            local slot = caster.spellSlots[spellSlot]
            slot.affectsBothRanges = true
            
            return true
        end
        
        return false
    end,
    
    -- Add a new EFFECT event handler for pure visual effects
    EFFECT = function(event, caster, target, spellSlot, results)
        Log.debug("[EFFECT EVENT] Processing EFFECT event")
        
        -- Detailed event inspection for debugging
        Log.debug("[EFFECT EVENT] Full event details:")
        Log.debug(string.format("  effectOverride=%s", tostring(event.effectOverride)))
        Log.debug(string.format("  effectType=%s", tostring(event.effectType)))
        Log.debug(string.format("  affinity=%s, attackType=%s, damageType=%s",
            tostring(event.affinity),
            tostring(event.attackType),
            tostring(event.damageType)))
        Log.debug(string.format("  source=%s, target=%s",
            tostring(event.source),
            tostring(event.target)))
            
        -- Check if spell has override
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
           caster.spellSlots[spellSlot].spell then
            local spell = caster.spellSlots[spellSlot].spell
            Log.debug(string.format("[EFFECT EVENT] Associated spell: name=%s, effectOverride=%s",
                tostring(spell.name), tostring(spell.effectOverride)))
        end
        
        -- Get source and target coordinates for the effect
        local srcX, srcY, tgtX, tgtY = nil, nil, nil, nil
        
        -- CASE 1: If vfxParams contains direct coordinates, use those
        if event.vfxParams and event.vfxParams.x and event.vfxParams.y then
            srcX = event.vfxParams.x
            srcY = event.vfxParams.y
            tgtX = event.vfxParams.targetX or srcX  -- Use target coords if provided, otherwise same as source
            tgtY = event.vfxParams.targetY or srcY
            Log.debug(string.format("[EFFECT EVENT] Using direct coordinates from vfxParams: (%d, %d) -> (%d, %d)",
                srcX, srcY, tgtX, tgtY))
        
        -- CASE 2: Otherwise resolve based on source/target entities
        else
            -- Source coordinates (caster)
            srcX = caster and caster.x or 0
            srcY = caster and caster.y or 0
            
            -- Target coordinates 
            local targetInfo = EventRunner.resolveTarget(event, caster, target)
            if targetInfo and targetInfo.wizard then 
                local targetWizard = targetInfo.wizard
                tgtX = targetWizard.x
                tgtY = targetWizard.y
                Log.debug(string.format("[EFFECT EVENT] Using wizard coordinates: (%d, %d) -> (%d, %d)",
                    srcX, srcY, tgtX or srcX, tgtY or srcY))
            else
                -- If target resolution fails, use same coordinates as source
                tgtX = srcX
                tgtY = srcY
                Log.debug("[EFFECT EVENT] WARNING: Could not resolve target coordinates, using source as target")
            end
        end
        
        -- Check if this spell slot contains a spell with an effectOverride
        local overrideName = nil
        
        -- Check in priority order for effect name
        if event.effectOverride then
            -- First check the event for an effectOverride (highest priority)
            overrideName = event.effectOverride
            Log.debug("[EFFECT EVENT] Using event effectOverride: " .. tostring(overrideName))
        elseif event.effectType then
            -- Then check if there's an effectType directly in the event (legacy VFX keyword)
            overrideName = event.effectType
            Log.debug("[EFFECT EVENT] Using event effectType: " .. tostring(overrideName))
        elseif spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
               caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.effectOverride then
            -- Finally check the spell slot for effectOverride (set by vfx keyword)
            overrideName = caster.spellSlots[spellSlot].spell.effectOverride
            Log.debug("[EFFECT EVENT] Using spell effectOverride: " .. tostring(overrideName))
        end
        
        -- Create visual effect if VFX system is available
        if caster.gameState and caster.gameState.vfx then
            -- Use the override or let VisualResolver pick based on metadata
            local baseEffectName, vfxOpts
            
            -- Debug before VisualResolver.pick
            Log.debug("[EFFECT EVENT] About to call VisualResolver.pick()")
            Log.debug("[EFFECT EVENT] Override strategy: " .. (overrideName and "Using override: " .. tostring(overrideName) or "Using metadata resolution"))
            
            if overrideName then
                -- Manual override - use it directly but still get options from resolver
                event.effectOverride = overrideName -- Ensure the event has the override
                Log.debug("[EFFECT EVENT] Set event.effectOverride = " .. tostring(overrideName))
                baseEffectName, vfxOpts = VisualResolver.pick(event)
            else
                -- Standard resolver path using event metadata
                baseEffectName, vfxOpts = VisualResolver.pick(event)
            end
            
            -- Debug after VisualResolver.pick
            Log.debug(string.format("[EFFECT EVENT] VisualResolver.pick() returned: effectName=%s, options=%s",
                tostring(baseEffectName),
                vfxOpts and "present" or "nil"))
            
            -- Skip VFX if no valid base effect name
            if not baseEffectName then
                Log.debug("[EFFECT EVENT] Warning: No valid effect name provided by VisualResolver")
                return false
            end
            
            -- Merge additional parameters from event
            if not vfxOpts then vfxOpts = {} end
            
            -- Add source/target names and entities for positional tracking
            if caster and caster.name then
                vfxOpts.source = caster.name
                vfxOpts.sourceEntity = caster
                
                -- If this is from a spell with a visualShape, add it to the options
                if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
                   caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.visualShape then
                    vfxOpts.visualShape = caster.spellSlots[spellSlot].spell.visualShape
                end
                
                -- Make sure to pass the damage amount for determining shake intensity
                vfxOpts.amount = event.amount or vfxOpts.amount or 10
                
                -- Debug entity references
                Log.debug(string.format("[EFFECT EVENT] Setting sourceEntity = %s", tostring(caster)))
            end
            if target and target.name then
                vfxOpts.target = target.name
                vfxOpts.targetEntity = target
                Log.debug(string.format("[EFFECT EVENT] Setting targetEntity = %s", tostring(target)))
            end
            
            -- For SHIELD_BLOCKED events, make sure we have all needed references
            if event.tags and event.tags.SHIELD_BLOCKED then
                Log.debug("[EFFECT EVENT] This is a SHIELD_BLOCKED event")
                vfxOpts.gameState = caster.gameState
            end
            
            -- Handle shield blocked effects
            if event.tags and event.tags.SHIELD_BLOCKED then
                Log.debug("[EFFECT EVENT] Processing shield blocked effect")
                
                -- Pass blockInfo to VFX system
                if event.blockInfo then
                    vfxOpts.blockInfo = event.blockInfo
                    
                    -- Set blockPoint for visual impact
                    vfxOpts.blockPoint = event.blockPoint or 0.75
                    
                    -- Set shield type
                    if event.blockInfo.blockType then
                        vfxOpts.shieldType = event.blockInfo.blockType
                    end
                    
                    Log.debug("[EFFECT EVENT] Shield block visual at " .. tostring(vfxOpts.blockPoint))
                else
                    -- Create fallback blockInfo if missing but event has SHIELD_BLOCKED tag
                    Log.debug("[EFFECT EVENT] WARNING: SHIELD_BLOCKED tag but no blockInfo, creating default blockInfo")
                    vfxOpts.blockInfo = {
                        blockable = true,
                        blockType = event.shieldType or "ward",
                        blockPoint = event.blockPoint or 0.75
                    }
                    vfxOpts.blockPoint = event.blockPoint or 0.75
                    vfxOpts.shieldType = event.shieldType or "ward"
                    
                    -- Ensure SHIELD_BLOCKED flag is present
                    vfxOpts.tags = vfxOpts.tags or {}
                    vfxOpts.tags.SHIELD_BLOCKED = true
                    
                    Log.debug("[EFFECT EVENT] Created fallback shield block visual at " .. tostring(vfxOpts.blockPoint))
                end
            elseif event.blockInfo then
                -- Legacy handling for other events with blockInfo
                Log.debug("[EFFECT EVENT] Found blockInfo in event, passing to VFX system")
                vfxOpts.blockInfo = event.blockInfo
                
                -- Add standard blockPoint ratio for visual impact
                vfxOpts.blockPoint = event.blockInfo.blockPoint or 0.75
                
                -- Ensure shield type is set
                if event.blockInfo.blockType then
                    vfxOpts.shieldType = event.blockInfo.blockType
                end
                
                -- Ensure SHIELD_BLOCKED tag is set in vfxOpts
                vfxOpts.tags = vfxOpts.tags or {}
                vfxOpts.tags.SHIELD_BLOCKED = true
            end
            
            -- Set default duration if not provided
            if not vfxOpts.duration then
                vfxOpts.duration = event.duration or 0.5
            end
            
            -- Check if we need to add delayed damage to the options
            if event.delayedDamage and event.delayedDamageTarget then
                Log.debug(string.format("[EFFECT EVENT] Adding delayed damage %d to effect options", event.delayedDamage))
                vfxOpts.delayedDamage = event.delayedDamage
                vfxOpts.delayedDamageTarget = event.delayedDamageTarget
                
                -- Provide a callback function to apply the damage when the animation completes
                vfxOpts.onComplete = function(effect)
                    -- Apply the delayed damage
                    local target = vfxOpts.delayedDamageTarget
                    local amount = vfxOpts.delayedDamage
                    
                    if target and amount then
                        target.health = target.health - amount
                        if target.health < 0 then target.health = 0 end
                        
                        -- Set hit flash timer for delayed damage visual feedback
                        target.hitFlashTimer = 0.125 -- 125ms flash duration
                        
                        -- Apply screen shake and hitstop for delayed damage too
                        if amount >= 15 or (event.tags and event.tags.HIGH_IMPACT) then
                            -- Strong hit
                            if target.gameState and target.gameState.triggerShake then
                                local intensity = math.min(10, 5 + (amount / 10))
                                target.gameState.triggerShake(0.35, intensity)
                                target.gameState.triggerHitstop(0.12)
                                Log.debug(string.format("[DELAYED DAMAGE] High impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                                    0.35, intensity, 0.12))
                            end
                        elseif amount >= 8 then
                            -- Medium hit
                            if target.gameState and target.gameState.triggerShake then
                                target.gameState.triggerShake(0.25, 6)
                                target.gameState.triggerHitstop(0.08)
                                Log.debug(string.format("[DELAYED DAMAGE] Medium impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                                    0.25, 6, 0.08))
                            end
                        elseif amount >= 3 then
                            -- Light hit
                            if target.gameState and target.gameState.triggerShake then
                                target.gameState.triggerShake(0.15, 4)
                                Log.debug(string.format("[DELAYED DAMAGE] Light impact hit! Triggering shake (%.2f, %.2f)",
                                    0.15, 4))
                            end
                        end
                        
                        Log.debug(string.format("[DELAYED DAMAGE] Applied %d damage to %s. New health: %d",
                            amount, target.name, target.health))
                    end
                end
            end
            
            -- Extra debug info
            Log.debug(string.format("[EFFECT EVENT] Creating effect: '%s' at coords: (%d, %d) -> (%d, %d)",
                tostring(baseEffectName), srcX or 0, srcY or 0, tgtX or srcX, tgtY or srcY))
                
            -- Call VFX.createEffect directly instead of using safeCreateVFX
            -- This pattern matches how we want VFX module to be called in the future
            -- with directional information (source -> target)
            local vfxModule = caster.gameState.vfx
            if vfxModule and vfxModule.createEffect then
                local success, err = pcall(function()
                    vfxModule.createEffect(baseEffectName, srcX, srcY, tgtX, tgtY, vfxOpts)
                end)
                
                if not success then
                    print("ERROR: Failed to create effect: " .. tostring(err))
                    return false
                end
            else
                Log.debug("[EFFECT EVENT] ERROR: VFX.createEffect not available")
                return false
            end
        else
            Log.debug("[EFFECT EVENT] ERROR: VFX system not available")
            return false
        end
        
        return true
    end
}

-- Debug function to print all events
function EventRunner.debugPrintEvents(events)
    Log.debug("===== DEBUG: Event List =====")
    for i, event in ipairs(events) do
        Log.debug(string.format("[%d] %s - Source: %s, Target: %s",
            i, event.type, event.source, event.target))
        
        -- Print additional event-specific fields
        for k, v in pairs(event) do
            if k ~= "type" and k ~= "source" and k ~= "target" then
                Log.debug(string.format("  %s: %s", k, tostring(v)))
            end
        end
    end
    Log.debug("=============================")
end

return EventRunner```

## ./systems/ManaHelpers.lua
```lua
-- systems/ManaHelpers.lua
-- Provides utility functions for working with tokens in the mana pool

local ManaHelpers = {}

-- Count tokens of a specific type in the mana pool
function ManaHelpers.count(tokenType, manaPool)
    local count = 0
    
    -- If the manaPool isn't provided directly, try to find it from the game state
    if not manaPool then return 0 end
    
    local Constants = require("core.Constants")
    
    for _, token in ipairs(manaPool.tokens or {}) do
        if token.type == tokenType and token.state == Constants.TokenState.FREE then
            count = count + 1
        end
    end
    
    return count
end

-- Get the most abundant token type from options
function ManaHelpers.most(tokenTypes, manaPool)
    local maxCount = -1
    local maxType = nil
    
    for _, tokenType in ipairs(tokenTypes) do
        local count = ManaHelpers.count(tokenType, manaPool)
        if count > maxCount then
            maxCount = count
            maxType = tokenType
        end
    end
    
    return maxType
end

-- Get the least abundant token type from options
function ManaHelpers.least(tokenTypes, manaPool)
    local minCount = math.huge
    local minType = nil
    
    for _, tokenType in ipairs(tokenTypes) do
        local count = ManaHelpers.count(tokenType, manaPool)
        if count < minCount and count > 0 then
            minCount = count
            minType = tokenType
        end
    end
    
    -- If no token was found with count > 0, return first type as fallback
    return minType or tokenTypes[1]
end

-- Find whether a specific token type exists in the pool
function ManaHelpers.exists(tokenType, manaPool)
    return ManaHelpers.count(tokenType, manaPool) > 0
end

-- Get a random token type from the mana pool
function ManaHelpers.random(manaPool)
    if not manaPool or not manaPool.tokens or #manaPool.tokens == 0 then 
        return nil
    end
    
    -- Get a list of free token types that are available
    local availableTypes = {}
    local typesPresent = {}
    
    local Constants = require("core.Constants")
    
    for _, token in ipairs(manaPool.tokens) do
        if token.state == Constants.TokenState.FREE and not typesPresent[token.type] then
            table.insert(availableTypes, token.type)
            typesPresent[token.type] = true
        end
    end
    
    -- Return a random token type from available types
    if #availableTypes > 0 then
        return availableTypes[math.random(#availableTypes)]
    end
    
    return nil
end

return ManaHelpers```

## ./systems/ShieldSystem.lua
```lua
-- ShieldSystem.lua
-- Centralized shield management system for Manastorm

local Constants = require("core.Constants")
local ShieldSystem = {}

-- Get appropriate shield color based on defense type
function ShieldSystem.getShieldColor(defenseType)
    local shieldColor = {0.8, 0.8, 0.8}  -- Default gray
    
    if defenseType == Constants.ShieldType.BARRIER then
        shieldColor = {1.0, 1.0, 0.3}    -- Yellow for barriers
    elseif defenseType == Constants.ShieldType.WARD then
        shieldColor = {0.3, 0.3, 1.0}    -- Blue for wards
    elseif defenseType == Constants.ShieldType.FIELD then
        shieldColor = {0.3, 1.0, 0.3}    -- Green for fields
    end
    
    return shieldColor
end

-- Create a shield in the specified slot
function ShieldSystem.createShield(wizard, spellSlot, blockParams)
    -- Check that the slot is valid
    if not wizard.spellSlots[spellSlot] then
        print("[SHIELD ERROR] Invalid spell slot for shield creation: " .. tostring(spellSlot))
        return { shieldCreated = false }
    end
    
    local slot = wizard.spellSlots[spellSlot]
    
    -- DEFENSIVE CHECK: Don't create shield if slot already has one
    if slot.isShield then
        print("[SHIELD ERROR] Slot " .. spellSlot .. " already has a shield! Preventing duplicate creation.")
        return { shieldCreated = false, reason = "duplicate" }
    end
    
    -- Set shield parameters - simplified to use token count as the only source of truth
    slot.isShield = true
    
    -- Look for shield type in both parameters for compatibility
    slot.defenseType = blockParams.defenseType or blockParams.type or Constants.ShieldType.BARRIER
    
    -- Store the original spell completion
    slot.active = true
    slot.progress = slot.castTime -- Mark as fully cast
    
    -- Store the onBlock handler if provided
    slot.onBlock = blockParams.onBlock
    
    -- Debug log for onBlock handler
    if blockParams.onBlock then
        print("[SHIELD DEBUG] Shield creation: onBlock handler saved to slot")
    else
        print("[SHIELD DEBUG] Shield creation: No onBlock handler provided")
    end
    
    -- Remove duplicate onBlock assignment from line 67
    
    -- Set which attack types this shield blocks
    slot.blocksAttackTypes = {}
    -- Support both `blocks` and `blocksAttackTypes` for compatibility
    local blockTypes = blockParams.blocks or blockParams.blocksAttackTypes or {Constants.AttackType.PROJECTILE}
    for _, attackType in ipairs(blockTypes) do
        slot.blocksAttackTypes[attackType] = true
    end
    
    -- Also store as array for compatibility
    slot.blockTypes = blockTypes
    
    -- ALL shields are mana-linked (consume tokens when hit) - simplified model
    
    -- Set reflection capability
    slot.reflect = blockParams.reflect or false
    
    -- Note: onBlock is already set above (line 48)
    
    -- Get TokenManager module
    local TokenManager = require("systems.TokenManager")
    
    -- Mark tokens as shielding using TokenManager
    TokenManager.markTokensAsShielding(slot.tokens)
    
    -- Add additional shield-specific properties to tokens
    for _, tokenData in ipairs(slot.tokens) do
        local token = tokenData.token
        if token then
            -- Add specific shield type info to the token for visual effects
            token.shieldType = slot.defenseType
            -- Slow down the rotation speed for shield tokens
            if token.orbitSpeed then
                token.orbitSpeed = token.orbitSpeed * 0.5  -- 50% slower
            end
        end
    end
    
    -- Get shield color based on type
    local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
    
    -- Create shield effect using event system
    if wizard.gameState and wizard.gameState.eventRunner then
        local shieldEvent = {
            type = "EFFECT",
            source = "shield",
            target = Constants.TargetType.SELF,
            effectType = Constants.VFXType.SHIELD,
            duration = 1.0,
            vfxParams = {
                x = wizard.x,
                y = wizard.y,
                color = {shieldColor[1], shieldColor[2], shieldColor[3], 0.7},
                shieldType = slot.defenseType
            }
        }
        
        -- Process the event immediately
        wizard.gameState.eventRunner.processEvents({shieldEvent}, wizard, nil)
    end
    
    -- Print debug info - simplified to only show token count
    print(string.format("[SHIELD] %s created a %s shield in slot %d with %d tokens",
        wizard.name or "Unknown wizard",
        slot.defenseType,
        spellSlot,
        #slot.tokens))
    
    -- Return result for further processing - simplified for token-based shields only
    return {
        shieldCreated = true,
        defenseType = slot.defenseType,
        blockTypes = blockParams.blocks
    }
end

-- Check if a spell can be blocked by a shield
function ShieldSystem.checkShieldBlock(spell, attackType, defender, attacker)
    -- Default response - not blockable
    local result = {
        blockable = false,
        blockType = nil,
        blockingShield = nil,
        blockingSlot = nil,
        manaLinked = nil,
        processBlockEffect = false
    }
    
    -- Early exit cases
    if not defender or not spell or not attackType then
        print("[SHIELD DEBUG] checkShieldBlock early exit - missing parameter")
        return result
    end
    
    -- Utility spells can't be blocked
    if attackType == Constants.AttackType.UTILITY then
        print("[SHIELD DEBUG] checkShieldBlock early exit - utility spell can't be blocked")
        return result
    end
    
    print("[SHIELD DEBUG] Checking if " .. attackType .. " spell can be blocked by " .. defender.name .. "'s shields")
    
    -- Check each of the defender's spell slots for active shields
    for i, slot in ipairs(defender.spellSlots) do
        -- Skip inactive slots or non-shield slots
        if not slot.active or not slot.isShield then
            goto continue
        end
        
        -- Check if this shield has tokens remaining (token count is the source of truth for shield strength)
        if #slot.tokens <= 0 then
            goto continue
        end
        
        -- Verify this shield can block this attack type
        local canBlock = false
        
        -- Check blocksAttackTypes or blockTypes properties
        if slot.blocksAttackTypes and slot.blocksAttackTypes[attackType] then
            canBlock = true
        elseif slot.blockTypes then
            -- Iterate through blockTypes array to find a match
            for _, blockType in ipairs(slot.blockTypes) do
                if blockType == attackType then
                    canBlock = true
                    break
                end
            end
        end
        
        -- If we found a shield that can block this attack
        if canBlock then
            result.blockable = true
            result.blockType = slot.defenseType
            result.blockingShield = slot
            result.blockingSlot = i
            -- All shields are mana-linked by default
            result.manaLinked = true
            
            -- Handle mana consumption for the block
            if #slot.tokens > 0 then
                result.processBlockEffect = true
                
                -- Get amount of hits based on the spell's shield breaker power (if any)
                local shieldBreakPower = spell.shieldBreaker or 1
                
                -- Determine how many tokens to consume (up to shield breaker power or tokens available)
                local tokensToConsume = math.min(shieldBreakPower, #slot.tokens)
                result.tokensToConsume = tokensToConsume
                
                -- No need to track shield strength separately anymore
                -- Token consumption is handled by removing tokens directly
                
                -- Check if this will destroy the shield (when all tokens are consumed)
                if tokensToConsume >= #slot.tokens then
                    result.destroyShield = true
                end
            end
            
            -- Return after finding the first blocking shield
            return result
        end
        
        ::continue::
    end
    
    -- If we get here, no shield can block this spell
    return result
end

-- Handle the effects of a spell being blocked by a shield
function ShieldSystem.handleShieldBlock(wizard, slotIndex, incomingSpell)
    local slot = wizard.spellSlots[slotIndex]
    if not slot or not slot.active then
        print(string.format("WARNING: handleShieldBlock called on invalid or inactive slot %d for %s", slotIndex, wizard.name))
        return false
    end
    
    -- Additional safety check for shield status
    if not slot.isShield then
        print(string.format("WARNING: handleShieldBlock called on non-shield slot %d for %s", slotIndex, wizard.name))
        return false
    end

    -- Safety check for incomingSpell
    if not incomingSpell then
        print("WARNING: handleShieldBlock called with nil incomingSpell")
        return false
    end

    -- Get defense type with safety check
    local defenseType = slot.defenseType or Constants.ShieldType.BARRIER -- Default to barrier if unknown

    -- Determine how many tokens to remove based on incoming spell's shieldBreaker property
    local shieldBreakPower = (incomingSpell and incomingSpell.shieldBreaker) or 1
    local tokensToConsume = math.min(shieldBreakPower, #slot.tokens)

    -- Get spell name with safety check
    local spellName = incomingSpell.name or "unknown spell"

    print(string.format("[SHIELD BLOCK] %s's %s shield (slot %d) hit by %s (%d break power). Consuming %d token(s).", 
        wizard.name, defenseType, slotIndex, spellName, shieldBreakPower, tokensToConsume))

    -- Consume the tokens
    for i = 1, tokensToConsume do
        -- misnomer since default bahvior changed
        -- TODO: restore logic to actually "consume" tokens if shield has some keyword
        if #slot.tokens > 0 then
            -- Remove token data from the end (doesn't matter which one for shields)
            local removedTokenData = table.remove(slot.tokens)
            local removedTokenObject = removedTokenData and removedTokenData.token
            
            -- Safety check for removed token object
            if removedTokenObject and removedTokenObject.type then
                print(string.format("[TOKEN LIFECYCLE] Shield Token (%s) freed by block -> FREE", 
                    tostring(removedTokenObject.type)))
            else
                print("[TOKEN LIFECYCLE] Shield Token (unknown type) freed by block -> FREE")
            end
                
            -- Mark the consumed token for freeing using TokenManager
            if removedTokenObject then
                -- Get TokenManager
                local TokenManager = require("systems.TokenManager")
                
                -- Create a token array for TokenManager to handle
                local tokenToFree = {
                    {token = removedTokenObject, index = 1}
                }
                
                -- Use TokenManager to free the token
                TokenManager.returnTokensToPool(tokenToFree)
                
                -- Call the wizard's centralized check *after* removing the token
                wizard:checkFizzleOnTokenRemoval(slotIndex, removedTokenObject)
            else
                print("WARNING: Shield block consumed a token reference that had no token object.")
                -- Still need to check fizzle even if token object missing
                wizard:checkFizzleOnTokenRemoval(slotIndex, nil)
            end
        else
            -- Should not happen if tokensToConsume calculation is correct, but break just in case
            print("WARNING: Tried to consume more tokens than available in shield slot.")
            break 
        end
    end
    
    -- Emit shield hit event for visual feedback through VisualResolver
    if wizard.gameState and wizard.gameState.eventRunner then
        local Constants = require("core.Constants")
        local shieldHitEvent = {
            type = "EFFECT",
            source = Constants.TargetType.TARGET,  -- defender is both source & target visually
            target = Constants.TargetType.TARGET,
            effectType = "shield_hit", -- logical tag for VisualResolver
            affinity = defenseType, -- Use defense type as affinity for color mapping
            tags = { SHIELD_HIT = true },
            shieldType = defenseType,
            vfxParams = {
                x = wizard.x,
                y = wizard.y,
            },
            rangeBand = wizard.rangeBand,
            elevation = wizard.elevation,
        }
        
        -- Process the event immediately
        wizard.gameState.eventRunner.processEvents({shieldHitEvent}, wizard, nil)
    end
    
    -- Add support for on-block effects
    -- Add safety check for slot.defenseType
    local defenseType = slot.defenseType or Constants.ShieldType.BARRIER -- Default to barrier if unknown
    print("[SHIELD DEBUG] Checking onBlock handler for " .. wizard.name .. "'s " .. defenseType .. " shield")
    
    if slot.onBlock then
        print("[SHIELD DEBUG] onBlock handler found, executing")
        -- Avoid importing EventRunner directly to prevent circular dependency
        local ok, blockEvents = pcall(slot.onBlock,
                                      wizard,          -- defender (owner of the shield)
                                      incomingSpell and incomingSpell.caster, -- attacker (may be nil)
                                      slotIndex,
                                      { blockType = defenseType })
        if ok and type(blockEvents) == "table" and #blockEvents > 0 then
            print("[SHIELD DEBUG] onBlock returned " .. #blockEvents .. " events, processing")
            -- Lazy load EventRunner only when needed
            local EventRunner = require("systems.EventRunner")
            EventRunner.processEvents(blockEvents, wizard, incomingSpell and incomingSpell.caster, slotIndex)
        elseif not ok then
            print("[SHIELD ERROR] Error executing onBlock handler: " .. tostring(blockEvents))
        else
            print("[SHIELD DEBUG] onBlock successful but no events returned or invalid events format")
            print("[SHIELD DEBUG] Return value: " .. type(blockEvents))
            if type(blockEvents) == "table" then
                print("[SHIELD DEBUG] Table length: " .. #blockEvents)
            end
        end
    else
        print("[SHIELD DEBUG] No onBlock handler found for this shield")
    end
    
    -- The checkFizzleOnTokenRemoval method handles the actual shield breaking (slot reset)
    
    return true
end

-- Update shield visuals and animations
function ShieldSystem.updateShieldVisuals(wizard, dt)
    -- This function will be expanded to handle shield pulse effects
    -- Currently a placeholder for future shield visual updates
    
    -- For each spell slot that contains a shield
    for i, slot in ipairs(wizard.spellSlots) do
        if slot.active and slot.isShield then
            -- Here we could add shield-specific visual updates
            -- Such as pulsing effects, particle emissions, etc.
        end
    end
end

-- Create block VFX for spell being blocked by a shield
-- DEPRECATED: This function is no longer needed as the block effects are now handled
-- directly in the EFFECT event processing with blockInfo. It's kept for backward
-- compatibility but will be removed in a future version.
function ShieldSystem.createBlockVFX(caster, target, blockInfo, spellInfo)
    print("[SHIELD SYSTEM] WARNING: ShieldSystem.createBlockVFX is deprecated")
    print("[SHIELD SYSTEM] Shield block visuals are now handled by the VFX system")
    
    -- No-op function, kept for backward compatibility
    return 
end

return ShieldSystem```

## ./systems/SustainedSpellManager.lua
```lua
-- SustainedSpellManager.lua
-- Centralized management system for sustained spells (shields, traps, etc.)

local Constants = require("core.Constants")
local Log = require("core.Log")
local SustainedSpellManager = {}

-- Track all active sustained spells
-- Each entry contains: {
--   id = unique identifier,
--   wizard = reference to wizard who cast the spell,
--   slotIndex = index of the spell slot,
--   spell = reference to the spell,
--   triggerData = trigger conditions (for traps),
--   effectData = effect to apply when triggered (for traps),
--   type = "shield" or "trap" or "generic"
-- }
SustainedSpellManager.activeSpells = {}

-- Generate a unique ID for a sustained spell
local function generateUniqueId(wizard, slotIndex)
    return wizard.name .. "_" .. slotIndex .. "_" .. os.time() .. "_" .. math.random(1000)
end

-- Apply field status effect to both wizards
local function applyFieldStatus(entry)
    if not entry or not entry.fieldStatus then return end

    local gameState = entry.wizard and entry.wizard.gameState
    if not gameState or not gameState.wizards then return end

    for _, wiz in ipairs(gameState.wizards) do
        wiz.statusEffects = wiz.statusEffects or {}
        wiz.statusEffects[entry.fieldStatus.statusType] = wiz.statusEffects[entry.fieldStatus.statusType] or {}
        local effect = wiz.statusEffects[entry.fieldStatus.statusType]
        effect.active = true
        effect.duration = 0
        effect.tickDamage = entry.fieldStatus.tickDamage
        effect.tickInterval = entry.fieldStatus.tickInterval
        effect.magnitude = entry.fieldStatus.magnitude
        effect.elapsed = 0
        effect.totalTime = 0
    end
end

-- Remove field status effect from both wizards
local function removeFieldStatus(entry)
    if not entry or not entry.fieldStatus then return end

    local gameState = entry.wizard and entry.wizard.gameState
    if not gameState or not gameState.wizards then return end

    for _, wiz in ipairs(gameState.wizards) do
        if wiz.statusEffects and wiz.statusEffects[entry.fieldStatus.statusType] then
            wiz.statusEffects[entry.fieldStatus.statusType].active = false
            wiz.statusEffects[entry.fieldStatus.statusType].duration = 0
            wiz.statusEffects[entry.fieldStatus.statusType].elapsed = 0
            wiz.statusEffects[entry.fieldStatus.statusType].totalTime = 0
        end
    end
end

-- Add a sustained spell to the manager
function SustainedSpellManager.addSustainedSpell(wizard, slotIndex, spellData)
    if not wizard or not slotIndex or not spellData then
        print("[SustainedManager] Error: Missing required parameters")
        return nil
    end
    
    Log.debug("[DEBUG] SustainedSpellManager.addSustainedSpell: Spell data:")
    Log.debug("[DEBUG]   isSustained: " .. tostring(spellData.isSustained))
    Log.debug("[DEBUG]   trapTrigger exists: " .. tostring(spellData.trapTrigger ~= nil))
    Log.debug("[DEBUG]   trapWindow exists: " .. tostring(spellData.trapWindow ~= nil))
    Log.debug("[DEBUG]   trapEffect exists: " .. tostring(spellData.trapEffect ~= nil))
    Log.debug("[DEBUG]   fieldStatus exists: " .. tostring(spellData.fieldStatus ~= nil))
    
    -- Generate a unique ID for this sustained spell
    local uniqueId = generateUniqueId(wizard, slotIndex)
    
    -- Determine the type of sustained spell
    local spellType = Constants.DamageType.GENERIC
    if spellData.isShield then
        spellType = "shield"
    elseif spellData.trapTrigger then
        spellType = "trap"
    elseif spellData.fieldStatus then
        spellType = "field"
    end

    -- If a field already exists, remove it before adding the new one
    if spellType == "field" then
        for id, existing in pairs(SustainedSpellManager.activeSpells) do
            if existing.type == "field" then
                existing.wizard:resetSpellSlot(existing.slotIndex)
                break
            end
        end
    end
    
    -- Create the entry
    local entry = {
        id = uniqueId,
        wizard = wizard,
        slotIndex = slotIndex,
        spell = wizard.spellSlots[slotIndex].spell,
        type = spellType,
        creationTime = os.time()
    }
    
    -- Add trap-specific data if present
    if spellType == "trap" then
        entry.triggerData = spellData.trapTrigger or {}
        entry.effectData = spellData.trapEffect or {}
    end
    
    -- Add shield-specific data if present
    if spellType == "shield" then
        entry.shieldParams = spellData.shieldParams or {}
    end

    -- Add field-specific data if present
    if spellType == "field" then
        entry.fieldStatus = spellData.fieldStatus or {}
    end
    
    -- Store the entry in the activeSpells table
    SustainedSpellManager.activeSpells[uniqueId] = entry

    -- Apply field status immediately
    if spellType == "field" then
        applyFieldStatus(entry)
    end

    -- Log the addition
    print(string.format("[SustainedManager] Added %s '%s' for %s in slot %d",
        spellType, entry.spell.name or "unnamed spell", wizard.name, slotIndex))
    
    return uniqueId
end

-- Remove a sustained spell from the manager
function SustainedSpellManager.removeSustainedSpell(id)
    local entry = SustainedSpellManager.activeSpells[id]
    if not entry then
        print("[SustainedManager] Warning: Tried to remove non-existent sustained spell: " .. id)
        return false
    end
    
    -- Log removal
    print(string.format("[SustainedManager] Removed %s '%s' for %s in slot %d",
        entry.type, entry.spell.name or "unnamed spell", entry.wizard.name, entry.slotIndex))

    if entry.type == "field" then
        removeFieldStatus(entry)
    end

    -- Remove from the active spells table
    SustainedSpellManager.activeSpells[id] = nil
    
    return true
end

-- Update all active sustained spells
function SustainedSpellManager.update(dt)
    -- Count active spells by type
    local shieldCount = 0
    local trapCount = 0
    local fieldCount = 0
    local genericCount = 0
    
    -- Spells to remove after iteration
    local spellsToRemove = {}
    
    -- Update each active spell
    for id, entry in pairs(SustainedSpellManager.activeSpells) do
        -- Debug: check what types of sustained spells we have
        if math.floor(os.time()) % 10 == 0 then -- Only log every 10 seconds to avoid spam
            Log.debug(string.format("[DEBUG] Sustained spell: id=%s, type=%s, spell=%s",
                id, entry.type, entry.spell and entry.spell.name or "unknown"))
        end
        
        -- Count by type
        if entry.type == "shield" then
            shieldCount = shieldCount + 1
        elseif entry.type == "trap" then
            trapCount = trapCount + 1
        elseif entry.type == "field" then
            fieldCount = fieldCount + 1
        else
            genericCount = genericCount + 1
        end
        
        
        -- Process trap trigger conditions if this is a trap
        if entry.type == "trap" and entry.triggerData and not entry.triggered then
            local casterWizard = entry.wizard
            local targetWizard = nil
            
            -- Find target wizard (the other wizard)
            if casterWizard and casterWizard.gameState and casterWizard.gameState.wizards then
                for _, wizard in ipairs(casterWizard.gameState.wizards) do
                    if wizard ~= casterWizard then
                        targetWizard = wizard
                        break
                    end
                end
            end
            
            -- Evaluate trigger conditions
            if targetWizard and entry.triggerData.condition then
                local condition = entry.triggerData.condition
                local conditionMet = false
                
                -- Check elevation trigger condition
                if condition == "on_opponent_elevate" and targetWizard.elevation == Constants.ElevationState.AERIAL then
                    -- Enhancement idea: Track state changes rather than continuous state
                    -- For now, trigger continuously while the opponent is elevated
                    conditionMet = true
                    print(string.format("[SustainedManager] Trap triggered by opponent elevation: %s", targetWizard.elevation))
                end

                if condition == "on_opponent_far" and targetWizard.rangeState == Constants.RangeState.FAR then
                    conditionMet = true
                    print(string.format("[SustainedManager] Trap triggered by opponent being far"))
                end
                
                -- Check cast trigger condition
                if condition == "on_opponent_cast" and targetWizard.justCastSpellThisFrame then
                    conditionMet = true
                    print(string.format("[SustainedManager] Trap triggered by opponent casting spell"))
                end
                
                -- Check other trigger conditions as needed...
                -- Add more conditions here as the trap system expands
                
                -- If any condition is met, mark the trap as triggered
                if conditionMet then
                    entry.triggered = true
                    print(string.format("[SustainedManager] Trap triggered for %s slot %d", 
                        casterWizard.name, entry.slotIndex))
                end
            end
        end
        
        -- Process triggered traps
        if entry.type == "trap" and entry.triggered and not entry.processed then
            -- Mark as processed to avoid duplicate execution
            entry.processed = true
            
            local casterWizard = entry.wizard
            local targetWizard = nil
            
            -- Find target wizard (the other wizard)
            if casterWizard and casterWizard.gameState and casterWizard.gameState.wizards then
                for _, wizard in ipairs(casterWizard.gameState.wizards) do
                    if wizard ~= casterWizard then
                        targetWizard = wizard
                        break
                    end
                end
            end
            
            -- Execute trap effect via EventRunner
            if casterWizard and targetWizard and entry.effectData then
                print(string.format("[SustainedManager] Executing trap effect for %s slot %d", 
                    casterWizard.name, entry.slotIndex))
                
                -- Get Keywords module to execute the effect keywords
                local Keywords = nil
                if casterWizard.gameState and casterWizard.gameState.keywords then
                    Keywords = casterWizard.gameState.keywords
                else
                    print("[SustainedManager] ERROR: Cannot access Keywords module")
                    table.insert(spellsToRemove, id)
                    goto continue
                end
                
                -- Create events list to collect events from each keyword
                local events = {}
                
                -- Iterate through each keyword in the trap effect
                for keyword, params in pairs(entry.effectData) do
                    if Keywords[keyword] and type(Keywords[keyword].execute) == "function" then
                        local results = {}
                        
                        -- Call the keyword's execute function to generate events
                        -- Note: Different keywords expect different parameters, we pass consistent ones
                        -- and let each keyword pick what it needs
                        local updated_results = Keywords[keyword].execute(
                            params,          -- Parameters for the keyword
                            casterWizard,    -- Caster
                            targetWizard,    -- Target
                            results,         -- Results table (legacy)
                            events           -- Events list to populate
                        )
                        
                        -- Merge results for backward compatibility
                        if updated_results then
                            for k, v in pairs(updated_results) do
                                results[k] = v
                            end
                        end
                    else
                        print(string.format("[SustainedManager] WARNING: Keyword '%s' not found or not executable", 
                            tostring(keyword)))
                    end
                end
                
                -- Process generated events with EventRunner
                if #events > 0 then
                    -- Process events - Use pcall for safety
                    local result = { eventsProcessed = 0 }
                    local ok, err = pcall(function()
                        -- Get EventRunner at last possible moment
                        local EventRunner = require("systems.EventRunner")
                        result = EventRunner.processEvents(
                            events,         -- Events to process
                            casterWizard,   -- Caster
                            targetWizard,   -- Target
                            nil             -- No specific spell slot for effect execution
                        )
                    end)
                    
                    if not ok then
                        print("[SustainedManager] ERROR: Failed to process events: " .. tostring(err))
                    end
                    
                    print(string.format("[SustainedManager] Processed %d trap events", 
                        result and result.eventsProcessed or 0))
                else
                    print("[SustainedManager] WARNING: No events generated from trap effect")
                end
                
                -- Clean up the trap after execution
                local TokenManager = require("systems.TokenManager")
                
                -- Get the spell slot
                local slot = entry.wizard.spellSlots[entry.slotIndex]
                if slot then
                    -- Return tokens to the mana pool
                    if #slot.tokens > 0 then
                        TokenManager.returnTokensToPool(slot.tokens)
                        print(string.format("[SustainedManager] Returning %d tokens from triggered trap", 
                            #slot.tokens))
                    end
                    
                    -- Reset the spell slot
                    entry.wizard:resetSpellSlot(entry.slotIndex)
                end
                
                -- Mark for removal from manager
                table.insert(spellsToRemove, id)
            else
                print("[SustainedManager] ERROR: Missing wizard or effect data for trap execution")
                table.insert(spellsToRemove, id)
            end
        end

        ::continue::
    end
    
    -- Remove triggered spells after iteration
    for _, id in ipairs(spellsToRemove) do
        local entry = SustainedSpellManager.activeSpells[id]
        if entry then
            -- Remove the spell from the manager
            SustainedSpellManager.removeSustainedSpell(id)
        end
    end
    
    -- Log active spell counts (reduced frequency to avoid console spam)
    if math.floor(os.time()) % 5 == 0 then  -- Log every 5 seconds
        -- If we have at least one spell, log more details
        if shieldCount + trapCount + fieldCount + genericCount > 0 then
            for id, entry in pairs(SustainedSpellManager.activeSpells) do
                local wizardName = entry.wizard and entry.wizard.name or "unknown"
                local spellName = entry.spell and entry.spell.name or "unknown spell"
                print(string.format("  - %s: %s's %s in slot %d (id: %s)",
                    entry.type, wizardName, spellName, entry.slotIndex, id))
            end
        end
    end
end

return SustainedSpellManager```

## ./systems/TokenManager.lua
```lua
-- TokenManager.lua
-- Centralized management of token acquisition, positioning, and state transitions

local Constants = require("core.Constants")

local TokenManager = {}

-- Acquires tokens for a spell based on its mana cost
-- Returns success (boolean) and tokenData (list of tokens with positioning info)
function TokenManager.acquireTokensForSpell(wizard, slotIndex, manaCost)
    if not wizard or not wizard.manaPool then
        print("[TOKEN MANAGER] Error: Invalid wizard or missing manaPool reference")
        return false, {}
    end
    
    if not manaCost or type(manaCost) ~= "table" then
        print("[TOKEN MANAGER] Error: Invalid mana cost")
        return false, {}
    end
    
    -- Handle empty cost (free spells)
    if next(manaCost) == nil or #manaCost == 0 then
        print("[TOKEN MANAGER] Free spell (no mana cost)")
        return true, {} -- Success with no tokens
    end
    
    local manaPool = wizard.manaPool
    local requiredTokens = {}
    
    -- Check if mana cost is in array format (numbered indices) or key-value format
    local isArrayFormat = #manaCost > 0 or manaCost[1] ~= nil
    
    -- Handle array-style format (legacy format)
    if isArrayFormat then
        print("[TOKEN MANAGER] Processing array-style mana cost with " .. #manaCost .. " components")
        
        -- Process each component in the array
        for i, component in ipairs(manaCost) do
            if type(component) == "table" and component.type and component.amount then
                -- Handle {type="fire", amount=2} format
                local tokenType = component.type
                local count = component.amount
                
                for j = 1, count do
                    local token, tokenIndex = manaPool:findFreeToken(tokenType)
                    if token then
                        table.insert(requiredTokens, {
                            type = tokenType,
                            token = token,
                            index = tokenIndex
                        })
                    else
                        print("[TOKEN MANAGER] Error: Could not find free token of type " .. tokenType)
                        return false, {}
                    end
                end
            elseif type(component) == "string" then
                -- Handle "fire" format (single token) or "any" special case
                local tokenType = component
                
                if tokenType == Constants.TokenType.ANY then
                    -- Special case for "any" - try to find any token type
                    local foundAny = false
                    
                    -- Get all available token types
                    local availableTypes = Constants.getAllTokenTypes()
                    -- Shuffle the types to randomize selection
                    for i = #availableTypes, 2, -1 do
                        local j = math.random(i)
                        availableTypes[i], availableTypes[j] = availableTypes[j], availableTypes[i]
                    end
                    
                    -- Try each token type in random order
                    for _, availableType in ipairs(availableTypes) do
                        local token, tokenIndex = manaPool:findFreeToken(availableType)
                        if token then
                            table.insert(requiredTokens, {
                                type = availableType,
                                token = token,
                                index = tokenIndex
                            })
                            foundAny = true
                            break
                        end
                    end
                    
                    if not foundAny then
                        print("[TOKEN MANAGER] Error: Could not find any free token for '" .. Constants.TokenType.ANY .. "' cost")
                        return false, {}
                    end
                else
                    -- Normal token type
                    local token, tokenIndex = manaPool:findFreeToken(tokenType)
                    
                    if token then
                        table.insert(requiredTokens, {
                            type = tokenType,
                            token = token,
                            index = tokenIndex
                        })
                    else
                        print("[TOKEN MANAGER] Error: Could not find free token of type " .. tokenType)
                        return false, {}
                    end
                end
            elseif type(component) == "number" then
                -- Handle numeric value (random tokens)
                local count = component
                for j = 1, count do
                    local foundRandom = false
                    
                    -- Get all available token types
                    local availableTypes = Constants.getAllTokenTypes()
                    -- Shuffle the types to randomize selection
                    for i = #availableTypes, 2, -1 do
                        local j = math.random(i)
                        availableTypes[i], availableTypes[j] = availableTypes[j], availableTypes[i]
                    end
                    
                    -- Try each token type in random order
                    for _, tokenType in ipairs(availableTypes) do
                        local token, tokenIndex = manaPool:findFreeToken(tokenType)
                        if token then
                            table.insert(requiredTokens, {
                                type = tokenType,
                                token = token,
                                index = tokenIndex
                            })
                            foundRandom = true
                            break
                        end
                    end
                    
                    if not foundRandom then
                        print("[TOKEN MANAGER] Error: Could not find any free token for random cost")
                        return false, {}
                    end
                end
            else
                print("[TOKEN MANAGER] Warning: Unknown cost component type: " .. type(component))
            end
        end
    else
        -- Handle key-value format (new standardized format)
        print("[TOKEN MANAGER] Processing key-value style mana cost")
        
        -- Check if a specific mana cost can be paid from available tokens
        for tokenType, count in pairs(manaCost) do
            -- Skip special metadata fields like description or zone
            if tokenType ~= Constants.SpellMetadata.DESCRIPTION and tokenType ~= Constants.SpellMetadata.ZONE and type(count) == "number" then
                for i = 1, count do
                    -- For "random" token type, pick any available token
                    if tokenType == Constants.TokenType.RANDOM or tokenType == Constants.TokenType.ANY then
                        local foundRandom = false
                        
                        -- Get all available token types
                        local availableTypes = Constants.getAllTokenTypes()
                        -- Shuffle the types to randomize selection
                        for i = #availableTypes, 2, -1 do
                            local j = math.random(i)
                            availableTypes[i], availableTypes[j] = availableTypes[j], availableTypes[i]
                        end
                        
                        -- Try each token type in random order
                        for _, type in ipairs(availableTypes) do
                            local token, tokenIndex = manaPool:findFreeToken(type)
                            if token then
                                table.insert(requiredTokens, {
                                    type = type, 
                                    token = token, 
                                    index = tokenIndex
                                })
                                foundRandom = true
                                break
                            end
                        end
                        
                        if not foundRandom then
                            print("[TOKEN MANAGER] Error: Could not find any free token for '" .. Constants.TokenType.RANDOM .. "' cost")
                            return false, {}
                        end
                    else
                        -- Look for a specific token type
                        local token, tokenIndex = manaPool:findFreeToken(tokenType)
                        if token then
                            table.insert(requiredTokens, {
                                type = tokenType, 
                                token = token, 
                                index = tokenIndex
                            })
                        else
                            print("[TOKEN MANAGER] Error: Could not find free token of type " .. tokenType)
                            return false, {}
                        end
                    end
                end
            end
        end
    end
    
    -- Actually acquire the tokens (change their state)
    local acquiredTokens = {}
    
    for i, reservedToken in ipairs(requiredTokens) do
        -- Get the token and change its state
        local token = manaPool:getToken(reservedToken.type)
        if token then
            -- Set token references and ownership
            token.wizardOwner = wizard
            token.spellSlot = slotIndex
            token.tokenIndex = i
            
            -- Add token to the acquired list with positioning data
            table.insert(acquiredTokens, {
                token = token,
                index = i
            })
        else
            print("[TOKEN MANAGER] Error: Failed to acquire reserved token of type " .. reservedToken.type)
            -- Return all previously acquired tokens
            TokenManager.returnTokensToPool(acquiredTokens)
            return false, {}
        end
    end
    
    -- Position tokens in the spell slot
    TokenManager.positionTokensInSpellSlot(wizard, slotIndex, acquiredTokens)
    
    return true, acquiredTokens
end

-- Positions tokens in a spell slot with proper animation parameters
function TokenManager.positionTokensInSpellSlot(wizard, slotIndex, tokens)
    if not wizard or not slotIndex or not tokens then
        print("[TOKEN MANAGER] Error: Missing parameters for positionTokensInSpellSlot")
        return false
    end
    
    -- Initialize tokens with animation parameters
    local tokenCount = #tokens
    
    -- Calculate the visual parameters for the spell slot
    local slotYOffsets = {30, 0, -30}  -- legs, midsection, head
    local horizontalRadii = {80, 70, 60}
    local verticalRadii = {20, 25, 30}
    
    for i, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Store token's current position as the starting point for animation
        token.startX = token.x
        token.startY = token.y

        -- Ensure the token appears at a consistent scale while channeled
        if token.targetScale then
            token.scale = token.targetScale
        else
            token.scale = Constants.TokenVisuals and Constants.TokenVisuals.CHANNELED_SCALE or 1.0
        end
        
        -- Initialize animation parameters
        token.animTime = 0
        token.animDuration = 0.6  -- Animation duration in seconds
        token.isAnimating = true
        
        -- Set up references for the token
        token.wizardOwner = wizard
        token.spellSlot = slotIndex
        token.slotIndex = slotIndex
        token.tokenIndex = tokenData.index
        
        -- Calculate target position in the spell slot based on 3D positioning
        local targetY = wizard.y + slotYOffsets[slotIndex]
        local targetX = wizard.x
        
        -- Animation data
        token.targetX = targetX
        token.targetY = targetY
        
        -- 3D perspective data for rotation
        token.radiusX = horizontalRadii[slotIndex]
        token.radiusY = verticalRadii[slotIndex]
        
        -- Set proper token state
        if token.setState then
            token:setState(Constants.TokenStatus.CHANNELED)
        else
            -- Fallback for backward compatibility
            token.state = Constants.TokenState.CHANNELED
        end
        
        ::continue_token::
    end
    
    return true
end

-- Prepares tokens for use in a shield
function TokenManager.prepareTokensForShield(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to prepareTokensForShield")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Set flag that this token will become a shield
        token.willBecomeShield = true
        
        ::continue_token::
    end
    
    return true
end

-- Marks tokens as being used in a shield (called after shield creation)
function TokenManager.markTokensAsShielding(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to markTokensAsShielding")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Set proper token state using state machine if available
        if token.setState then
            token:setState(Constants.TokenStatus.SHIELDING)
        else
            -- Fallback for backward compatibility
            token.state = Constants.TokenState.SHIELDING
        end
        
        -- Clear the willBecomeShield flag since it's now a shield
        token.willBecomeShield = nil
        
        ::continue_token::
    end
    
    return true
end

-- Returns tokens to the mana pool
function TokenManager.returnTokensToPool(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to returnTokensToPool")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Use token state machine if available
        if token.requestReturnAnimation then
            token:requestReturnAnimation()
        else
            -- Fallback for backward compatibility
            token.returning = true
            token.startX = token.x
            token.startY = token.y
            token.animTime = 0
            token.animDuration = 0.5
            
            -- Clear references
            token.wizardOwner = nil
            token.spellSlot = nil
        end
        
        ::continue_token::
    end
    
    return true
end

-- Destroys tokens (for disjunction effects)
function TokenManager.destroyTokens(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to destroyTokens")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Clear token trails if available
        if token.manaPool and token.manaPool.tokenTrails and token.manaPool.tokenTrails[token] then
            token.manaPool.tokenTrails[token] = nil
        end
        
        -- Use token state machine if available
        if token.requestDestructionAnimation then
            token:requestDestructionAnimation()
        else
            -- Fallback for backward compatibility
            token.state = Constants.TokenState.DESTROYED
        end
        
        ::continue_token::
    end
    
    return true
end

-- Checks if a spell should fizzle when a token is removed
function TokenManager.checkFizzleCondition(wizard, slotIndex, removedToken)
    if not wizard or not slotIndex then
        print("[TOKEN MANAGER] Error: Missing parameters for checkFizzleCondition")
        return false
    end
    
    local slot = wizard.spellSlots[slotIndex]
    if not slot or not slot.active then
        return false
    end
    
    -- If slot has no tokens left, reset it
    if not slot.tokens or #slot.tokens == 0 then
        print("[TOKEN MANAGER] Spell in slot " .. slotIndex .. " fizzled - no tokens left")
        wizard:resetSpellSlot(slotIndex)
        return true
    end
    
    -- Check if spell has lost a required token type (Law of Completion)
    if slot.spell and slot.spell.manaCost then
        local remainingTokensByType = {}
        
        -- Count remaining tokens by type
        for _, tokenData in ipairs(slot.tokens) do
            local tokenType = tokenData.token and tokenData.token.type or nil
            if tokenType then
                remainingTokensByType[tokenType] = (remainingTokensByType[tokenType] or 0) + 1
            end
        end
        
        -- Check against the required mana cost
        for tokenType, count in pairs(slot.spell.manaCost) do
            -- Skip special metadata fields
            if tokenType ~= Constants.SpellMetadata.DESCRIPTION and tokenType ~= Constants.SpellMetadata.ZONE then
                -- Handle random token type
                if tokenType == Constants.TokenType.RANDOM then
                    local totalRemaining = 0
                    for _, typeCount in pairs(remainingTokensByType) do
                        totalRemaining = totalRemaining + typeCount
                    end
                    
                    if totalRemaining < count then
                        print("[TOKEN MANAGER] Spell in slot " .. slotIndex .. " fizzled - not enough tokens for '" .. Constants.TokenType.RANDOM .. "' cost")
                        wizard:resetSpellSlot(slotIndex)
                        return true
                    end
                else
                    -- Check specific token type
                    local remaining = remainingTokensByType[tokenType] or 0
                    if remaining < count then
                        print("[TOKEN MANAGER] Spell in slot " .. slotIndex .. " fizzled - not enough " .. tokenType .. " tokens")
                        wizard:resetSpellSlot(slotIndex)
                        return true
                    end
                end
            end
        end
    end
    
    return false
end

-- Returns all tokens in a specific spell slot
function TokenManager.getTokensInSlot(wizard, slotIndex)
    if not wizard or not slotIndex or not wizard.spellSlots[slotIndex] then
        return {}
    end
    
    local slot = wizard.spellSlots[slotIndex]
    return slot.tokens or {}
end

-- Filters a list of tokens by type
function TokenManager.getTokensByType(tokens, tokenType)
    if not tokens or not tokenType then
        return {}
    end
    
    local filteredTokens = {}
    
    for _, tokenData in ipairs(tokens) do
        if tokenData.token and tokenData.token.type == tokenType then
            table.insert(filteredTokens, tokenData)
        end
    end
    
    return filteredTokens
end

-- Validates if a token is in the expected state
function TokenManager.validateTokenState(token, expectedState)
    if not token then
        return false, "Token is nil"
    end
    
    if not expectedState then
        return false, "Expected state is nil"
    end
    
    -- Check state using the status field
    return token.status == expectedState, 
           "Token state is " .. (token.status or "unknown") .. ", expected " .. expectedState
end

return TokenManager```

## ./systems/UnlockSystem.lua
```lua
-- systems/UnlockSystem.lua
-- Simple character unlock logic

local UnlockSystem = {}

--- Check if a spell unlocks any characters
-- Currently unlocks Silex when a Salt spell is cast
-- @param spell table Executed spell definition
-- @param caster table Wizard casting the spell
function UnlockSystem.checkSpellUnlock(spell, caster)
    if not spell or not caster then return end
    if spell.affinity == "salt" and game and not game.unlockedCharacters.Silex then
        game.unlockedCharacters.Silex = true
        print("[UNLOCK] Silex has been unlocked!")
        if caster.spellCastNotification then
            caster.spellCastNotification.text = "Unlocked Silex!"
            caster.spellCastNotification.timer = 2.0
        else
            caster.spellCastNotification = {
                text = "Unlocked Silex!",
                timer = 2.0,
                x = caster.x,
                y = caster.y + 70,
                color = {1,1,0,1}
            }
        end
    end

    -- Unlock additional spells
    if spell.unlockSpell and game and not game.unlockedSpells[spell.unlockSpell] then
        game.unlockedSpells[spell.unlockSpell] = true
        print("[UNLOCK] Spell unlocked: " .. spell.unlockSpell)
    end
end

return UnlockSystem
```

## ./systems/VisualResolver.lua
```lua
-- systems/VisualResolver.lua
-- Resolves events to appropriate visual effects based on event metadata

local Constants = require("core.Constants")

local VisualResolver = {}

-- Map visualShape strings to base VFX template names
-- This is the primary mapping table for determining visual template from spell shape
local TEMPLATE_BY_SHAPE = {
    
    -- Projectile-like effects
    ["beam"] = Constants.VFXType.BEAM_BASE,
    ["zap"] = Constants.VFXType.ZAP_BASE,
    ["bolt"] = Constants.VFXType.BOLT_BASE,
    ["orb"] = Constants.VFXType.ORB_BASE,
    ["wave"] = Constants.VFXType.WAVE_BASE,
    
    -- Area/zone effects
    ["blast"] = Constants.VFXType.BLAST_BASE,  -- Updated to new BLAST_BASE template
    ["cone"] = Constants.VFXType.BLAST_BASE,   -- Alternative name for same template
    ["groundBurst"] = Constants.VFXType.ZONE_BASE,
    ["meteor"] = Constants.VFXType.METEOR,
    
    -- Remote/direct effects
    ["warp"] = Constants.VFXType.WARP_BASE,
    
    -- Utility effects
    ["surge"] = Constants.VFXType.SURGE_BASE,
    ["affectManaPool"] = Constants.VFXType.UTIL_BASE,
    
    -- Shield-like effects
    ["wings"] = Constants.VFXType.SHIELD_OVERLAY,
    ["mirror"] = Constants.VFXType.SHIELD_OVERLAY,
    
    -- Special effects with unique templates
    ["eclipse"] = "eclipse_base"
}

-- Map attack types to base VFX template names
-- This is used as a fallback when visualShape is not specified
local BASE_BY_ATTACK = {
    [Constants.AttackType.PROJECTILE] = Constants.VFXType.PROJ_BASE,
    [Constants.AttackType.REMOTE] = Constants.VFXType.REMOTE_BASE,
    [Constants.AttackType.ZONE] = Constants.VFXType.ZONE_BASE,
    [Constants.AttackType.UTILITY] = Constants.VFXType.UTIL_BASE
}

-- Map affinities (token types) to colors
local COLOR_BY_AFF = {
    [Constants.TokenType.FIRE] = Constants.getColorForTokenType(Constants.TokenType.FIRE),
    [Constants.TokenType.WATER] = Constants.getColorForTokenType(Constants.TokenType.WATER),
    [Constants.TokenType.SALT] = Constants.getColorForTokenType(Constants.TokenType.SALT),
    [Constants.TokenType.SUN] = Constants.getColorForTokenType(Constants.TokenType.SUN),
    [Constants.TokenType.MOON] = Constants.getColorForTokenType(Constants.TokenType.MOON),
    [Constants.TokenType.STAR] = Constants.getColorForTokenType(Constants.TokenType.STAR),
    [Constants.TokenType.LIFE] = Constants.getColorForTokenType(Constants.TokenType.LIFE),
    [Constants.TokenType.MIND] = Constants.getColorForTokenType(Constants.TokenType.MIND),
    [Constants.TokenType.VOID] = Constants.getColorForTokenType(Constants.TokenType.VOID)
}

-- Map specific tags to overlay visual effects
local TAG_ADDONS = {
    DAMAGE = Constants.VFXType.DAMAGE_OVERLAY,
    BURN = Constants.VFXType.EMBER_OVERLAY,
    DOT = Constants.VFXType.DOT_OVERLAY,
    CONJURE = Constants.VFXType.SPARKLE_OVERLAY,
    RESOURCE = Constants.VFXType.RESOURCE_OVERLAY,
    MOVEMENT = Constants.VFXType.MOVEMENT_OVERLAY,
    ELEVATE = Constants.VFXType.RISE_OVERLAY,
    GROUND = Constants.VFXType.FALL_OVERLAY,
    SHIELD = Constants.VFXType.SHIELD_OVERLAY,
    DEFENSE = Constants.VFXType.BARRIER_OVERLAY
}

-- Map affinities to motion styles
local AFFINITY_MOTION = {
    [Constants.TokenType.FIRE] = Constants.MotionStyle.RISE,
    [Constants.TokenType.WATER] = Constants.MotionStyle.SWIRL,
    [Constants.TokenType.SALT] = Constants.MotionStyle.FALL,
    [Constants.TokenType.SUN] = Constants.MotionStyle.PULSE,
    [Constants.TokenType.MOON] = Constants.MotionStyle.RIPPLE,
    [Constants.TokenType.STAR] = Constants.MotionStyle.DIRECTIONAL,
    [Constants.TokenType.LIFE] = Constants.MotionStyle.RISE,
    [Constants.TokenType.MIND] = Constants.MotionStyle.SWIRL,
    [Constants.TokenType.VOID] = Constants.MotionStyle.STATIC
}

-- Default values
local DEFAULT_BASE = Constants.VFXType.IMPACT_BASE
local DEFAULT_COLOR = Constants.Color.SMOKE
local DEFAULT_MOTION = Constants.MotionStyle.RADIAL

-- Helper function for debug output without requiring vfx module dependency
function VisualResolver.debug(message)
    print("[VisualResolver] " .. message)
end

-- Main resolver function: Maps event data to visual parameters
-- Returns (baseTemplateName, options) as two separate values
function VisualResolver.pick(event)
    VisualResolver.debug("==========================================")
    VisualResolver.debug("VisualResolver.pick() called with event:")
    VisualResolver.debug("Event type: " .. (event and event.type or "nil"))
    VisualResolver.debug("Event source: " .. (event and event.source or "nil"))
    VisualResolver.debug("Event target: " .. (event and event.target or "nil"))
    VisualResolver.debug("==========================================")
    
    -- Validate event
    if not event or type(event) ~= "table" then
        VisualResolver.debug("Invalid event provided to pick()")
        return DEFAULT_BASE, { color = DEFAULT_COLOR, scale = 1.0, motion = DEFAULT_MOTION, addons = {} }
    end
    
    -- Debug output for visualShape if present
    if event.visualShape then
        VisualResolver.debug("Event contains visualShape: " .. tostring(event.visualShape))
    end
    
    -- Step 1: Determine base template with priority: effectOverride > legacy > shield_hit > visualShape > attackType > default
    local baseTemplate = DEFAULT_BASE
    local selectionPath = "DEFAULT" -- Track which path determined the template
    
    -- PRIORITY 1: Handle manual override: If the event has an effectOverride, use it directly
    -- This handles the manual vfx specifications from the vfx keyword
    if event.effectOverride then
        baseTemplate = event.effectOverride
        selectionPath = "EFFECT_OVERRIDE"
        
        VisualResolver.debug("Using explicit effect override: " .. event.effectOverride)
        VisualResolver.debug("Effect override source event details:")
        VisualResolver.debug("  - Event type: " .. (event.type or "nil"))
        VisualResolver.debug("  - Affinity: " .. (event.affinity or "nil"))
        VisualResolver.debug("  - Attack type: " .. (event.attackType or "nil"))
        VisualResolver.debug("  - Tags: " .. (event.tags and "present" or "nil"))
        
        -- Use the specified effect but still use the new parameter system
        return baseTemplate, {
            color = COLOR_BY_AFF[event.affinity] or DEFAULT_COLOR,
            scale = 1.0,
            motion = AFFINITY_MOTION[event.affinity] or DEFAULT_MOTION,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation
        }
    end
    
    -- PRIORITY 2: Also handle the case where we get the effect directly within an event.effect property
    -- This is needed for the showcase examples in spells.lua
    if event.effect and type(event.effect) == "string" then
        baseTemplate = event.effect
        selectionPath = "EVENT_EFFECT"
        
        VisualResolver.debug("Using effect from direct event.effect property: " .. event.effect)
        return baseTemplate, {
            color = COLOR_BY_AFF[event.affinity] or DEFAULT_COLOR,
            scale = 1.0, 
            motion = AFFINITY_MOTION[event.affinity] or DEFAULT_MOTION,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation
        }
    end
    
    -- PRIORITY 3: Handle shield hit event (from shield system)
    if event.effectType == "shield_hit" then
        baseTemplate = "shield_hit_base"
        selectionPath = "SHIELD_HIT"
        
        VisualResolver.debug("Handling shield hit effect")
        
        -- Determine shield color based on shield type
        local color = DEFAULT_COLOR
        
        if event.shieldType == Constants.ShieldType.BARRIER then
            color = {1.0, 1.0, 0.3, 0.8}  -- Yellow for barriers
        elseif event.shieldType == Constants.ShieldType.WARD then 
            color = {0.3, 0.3, 1.0, 0.8}  -- Blue for wards
        elseif event.shieldType == Constants.ShieldType.FIELD then
            color = {0.3, 1.0, 0.3, 0.8}  -- Green for fields
        end
        
        -- Build options with shield-specific values
        local opts = {
            color = color,
            scale = 1.2,  -- Slightly larger scale for impact emphasis
            motion = Constants.MotionStyle.PULSE,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation,
            -- VFX system will use vfxParams.x/y first, so we don't need to duplicate
        }
        
        VisualResolver.debug(string.format(
            "Resolved shield hit event to base=%s via %s, color=%s, scale=%.2f, motion=%s",
            baseTemplate,
            selectionPath,
            table.concat(color, ","),
            opts.scale,
            opts.motion
        ))
        
        return baseTemplate, opts
    end
    
    -- PRIORITY 4: Legacy manual VFX: If the event has manualVfx flag and effectType
    if event.manualVfx and event.effectType then
        baseTemplate = event.effectType
        selectionPath = "LEGACY_MANUAL"
        
        VisualResolver.debug("Using legacy manual effect via effectType: " .. event.effectType)
        -- Use the specified effect but still use the new parameter system
        return baseTemplate, {
            color = COLOR_BY_AFF[event.affinity] or DEFAULT_COLOR,
            scale = 1.0,
            motion = AFFINITY_MOTION[event.affinity] or DEFAULT_MOTION,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation
        }
    end
    
    -- PRIORITY 5: Use visualShape to look up template in TEMPLATE_BY_SHAPE
    if event.visualShape then
        local visualShape = event.visualShape
        local template = TEMPLATE_BY_SHAPE[visualShape]
        
        if template then
            baseTemplate = template
            selectionPath = "VISUAL_SHAPE"
            VisualResolver.debug("Using visualShape mapping: " .. visualShape .. " -> " .. baseTemplate)
        else
            -- For unknown visualShapes, log warning and fall back to attackType
            VisualResolver.debug("Unknown visualShape: " .. visualShape .. ", falling back to attackType")
        end
    end
    
    -- PRIORITY 6: If no visualShape match, use attack type mapping
    if selectionPath == "DEFAULT" and event.attackType and BASE_BY_ATTACK[event.attackType] then
        baseTemplate = BASE_BY_ATTACK[event.attackType]
        selectionPath = "ATTACK_TYPE"
        VisualResolver.debug("Using attackType mapping: " .. event.attackType .. " -> " .. baseTemplate)
    end
    
    -- If we still have no valid template, use the default
    if selectionPath == "DEFAULT" then
        VisualResolver.debug("No mapping found, using DEFAULT_BASE: " .. DEFAULT_BASE)
    end
    
    -- Step 2: Determine color from affinity
    local color = DEFAULT_COLOR
    if event.affinity and COLOR_BY_AFF[event.affinity] then
        color = COLOR_BY_AFF[event.affinity]
    end
    
    -- Step 3: Calculate scale based on mana cost
    local manaValue = event.manaCost or 1
    local scale = 0.8 + (0.15 * manaValue)
    if scale > 2.0 then scale = 2.0 end  -- Cap at 2.0x scale
    
    -- Step 4: Determine motion style from affinity
    local motion = DEFAULT_MOTION
    if event.affinity and AFFINITY_MOTION[event.affinity] then
        motion = AFFINITY_MOTION[event.affinity]
    end
    
    -- Step 5: Build addons list from tags
    local addons = {}
    if event.tags and type(event.tags) == "table" then
        for tag, _ in pairs(event.tags) do
            if TAG_ADDONS[tag] then
                table.insert(addons, TAG_ADDONS[tag])
            end
        end
    end
    
    -- Build and return the options table
    local opts = {
        color = color,
        scale = scale,
        motion = motion,
        addons = addons,
        rangeBand = event.rangeBand,
        elevation = event.elevation
    }
    
    VisualResolver.debug(string.format(
        "Resolved event to base=%s via %s, color=%s, scale=%.2f, motion=%s, addons=%d",
        baseTemplate,
        selectionPath,
        table.concat(color, ","),
        scale,
        motion,
        #addons
    ))
    
    -- Additional debug for tag processing
    if event.tags and type(event.tags) == "table" then
        local tagList = ""
        for tag, _ in pairs(event.tags) do
            tagList = tagList .. tag .. ", "
        end
        VisualResolver.debug("Event tags: " .. tagList)
        
        local addonList = ""
        for _, addon in ipairs(addons) do
            addonList = addonList .. addon .. ", "
        end
        VisualResolver.debug("Resolved addons: " .. (addonList ~= "" and addonList or "none"))
    else
        VisualResolver.debug("Event has no tags")
    end
    
    VisualResolver.debug("==========================================")
    return baseTemplate, opts
end

-- Helper function to test the resolver with sample events
function VisualResolver.test()
    local testEvents = {
        -- Test 1: Fire projectile spell (using attackType)
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            manaCost = 2,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 2: Water remote spell with higher cost (using attackType)
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.WATER,
            attackType = Constants.AttackType.REMOTE,
            manaCost = 4,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.AERIAL
        },
        -- Test 3: Moon-based shield (using attackType)
        {
            type = "CREATE_SHIELD",
            affinity = Constants.TokenType.MOON,
            attackType = Constants.AttackType.UTILITY,
            manaCost = 3,
            tags = { SHIELD = true, DEFENSE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 4: Manually specified effect (vfx keyword)
        {
            type = "EFFECT",
            effectOverride = Constants.VFXType.FIREBOLT,
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            manaCost = 2,
            tags = { VFX = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 5: Legacy manual VFX
        {
            type = "EFFECT",
            effectType = Constants.VFXType.METEOR,
            manualVfx = true,
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            manaCost = 3,
            tags = { VFX = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.AERIAL
        },
        -- Test 6: REMOTE attack with "beam" visualShape override
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.MOON,
            attackType = Constants.AttackType.REMOTE,
            visualShape = "beam",
            manaCost = 3,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 7: Projectile attack with "blast" visualShape override
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            visualShape = "blast",
            manaCost = 3,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 8: Testing "orb" visualShape
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.STAR,
            attackType = Constants.AttackType.ZONE, -- This would normally use ZONE_BASE
            visualShape = "orb",                    -- But visualShape overrides to PROJ_BASE
            manaCost = 2,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 9: Testing "warp" visualShape
        {
            type = "EFFECT",
            affinity = Constants.TokenType.VOID,
            attackType = Constants.AttackType.PROJECTILE, -- This would normally use PROJ_BASE
            visualShape = "warp",                         -- But visualShape overrides to UTIL_BASE
            manaCost = 1,
            tags = { MOVEMENT = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 10: Testing "mirror" visualShape
        {
            type = "CREATE_SHIELD",
            affinity = Constants.TokenType.WATER,
            attackType = Constants.AttackType.UTILITY,
            visualShape = "mirror",
            manaCost = 2,
            tags = { SHIELD = true, DEFENSE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 11: Testing "eclipse" visualShape
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.VOID,
            attackType = Constants.AttackType.ZONE,
            visualShape = "eclipse",
            manaCost = 5,
            tags = { DAMAGE = true, DOT = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.AERIAL
        },
        -- Test 12: Testing unknown visualShape (should fall back to attackType)
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            visualShape = "unknown_shape",  -- Not in TEMPLATE_BY_SHAPE
            manaCost = 2,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 13: Shield hit effect
        {
            type = "SHIELD_HIT",
            effectType = "shield_hit",
            shieldType = Constants.ShieldType.BARRIER,
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        }
    }
    
    print("===== VisualResolver Test =====")
    for i, event in ipairs(testEvents) do
        print("\nTest " .. i .. ": " .. event.type .. " event with " .. (event.affinity or "unknown") .. " affinity")
        if event.visualShape then
            print("visualShape: " .. event.visualShape)
        end
        if event.attackType then
            print("attackType: " .. event.attackType)
        end
        
        local base, opts = VisualResolver.pick(event)
        print("Base template: " .. base)
        print("Color: " .. table.concat(opts.color, ","))
        print("Scale: " .. opts.scale)
        print("Motion: " .. opts.motion)
        print("Addons: " .. (#opts.addons > 0 and table.concat(opts.addons, ", ") or "none"))
        print("Range: " .. (opts.rangeBand or "none"))
        print("Elevation: " .. (opts.elevation or "none"))
    end
    print("\n================================")
end

-- Execute test function if called directly
-- Only run if arg exists and this file is being run directly
if arg and arg[0] and type(arg[0]) == "string" and arg[0]:find("VisualResolver.lua") then
    VisualResolver.test()
end

return VisualResolver```

## ./systems/WizardVisuals.lua
```lua
-- WizardVisuals.lua
-- Centralized visualization system for Wizard entities in Manastorm

local WizardVisuals = {}
local Constants = require("core.Constants")
local ShieldSystem = require("systems.ShieldSystem")
local VFX = require("vfx") -- Added for accessing rune assets

-- Particle asset helpers for cast arc effects
local function getParticleImages()
    return {
        pixel = VFX.getAsset and VFX.getAsset("pixel") or nil,
        twinkle1 = VFX.getAsset and VFX.getAsset("twinkle1") or nil,
        twinkle2 = VFX.getAsset and VFX.getAsset("twinkle2") or nil
    }
end

-- Get appropriate status effect color
function WizardVisuals.getStatusEffectColor(effectType)
    local effectColors = {
        aerial = {0.7, 0.7, 1.0, 0.8},
        stun = {1.0, 1.0, 0.1, 0.8},
        shield = {0.5, 0.7, 1.0, 0.8},
        burn = {1.0, 0.4, 0.1, 0.8}
    }
    
    return effectColors[effectType] or {0.8, 0.8, 0.8, 0.8} -- Default to gray
end

-- Helper function to draw an ellipse
function WizardVisuals.drawEllipse(x, y, radiusX, radiusY, mode)
    local segments = 32
    local vertices = {}
    
    for i = 1, segments do
        local angle = (i - 1) * (2 * math.pi / segments)
        local px = x + math.cos(angle) * radiusX
        local py = y + math.sin(angle) * radiusY
        table.insert(vertices, px)
        table.insert(vertices, py)
    end
    
    -- Close the shape by adding the first point again
    table.insert(vertices, vertices[1])
    table.insert(vertices, vertices[2])
    
    if mode == "fill" then
        love.graphics.polygon("fill", vertices)
    else
        love.graphics.polygon("line", vertices)
    end
end

-- Helper function to draw an elliptical arc
function WizardVisuals.drawEllipticalArc(x, y, radiusX, radiusY, startAngle, endAngle, segments)
    segments = segments or 16
    
    -- Calculate the angle increment
    local angleRange = endAngle - startAngle
    local angleIncrement = angleRange / segments
    
    -- Create points for the arc
    local points = {}
    
    for i = 0, segments do
        local angle = startAngle + angleIncrement * i
        local px = x + math.cos(angle) * radiusX
        local py = y + math.sin(angle) * radiusY
        table.insert(points, px)
        table.insert(points, py)
    end
    
    -- Draw the arc as a line
    love.graphics.line(points)
end

-- Easing function for smoother animations
function WizardVisuals.easeOutCubic(t)
    return 1 - math.pow(1 - t, 3)
end

-- Simple particle object for arc spark effects
local function spawnArcSpark(slot, x, y, angle, color)
    slot._arcParticles = slot._arcParticles or {}
    local images = getParticleImages()
    local imgChoices = {images.pixel, images.twinkle1, images.twinkle2}
    local img = imgChoices[math.random(#imgChoices)]
    if not img then return end

    local speed = 40 + math.random() * 40
    local particle = {
        x = x,
        y = y,
        vx = math.cos(angle) * speed + (math.random() - 0.5) * 20,
        vy = math.sin(angle) * speed + (math.random() - 0.5) * 20,
        life = 0.35,
        maxLife = 0.35,
        img = img,
        color = {color[1], color[2], color[3], 1}
    }
    table.insert(slot._arcParticles, particle)
end

-- Update arc spark particles for a wizard
function WizardVisuals.updateArcParticles(wizard, dt)
    for _, slot in ipairs(wizard.spellSlots) do
        if slot._arcParticles then
            local i = 1
            while i <= #slot._arcParticles do
                local p = slot._arcParticles[i]
                p.life = p.life - dt
                if p.life <= 0 then
                    table.remove(slot._arcParticles, i)
                else
                    p.x = p.x + p.vx * dt
                    p.y = p.y + p.vy * dt
                    i = i + 1
                end
            end
        end
    end
end

-- Draw status effects with durations using horizontal bars
function WizardVisuals.drawStatusEffects(wizard)
    -- Get screen dimensions
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    
    -- Get position offsets
    local xOffset = wizard.currentXOffset or 0
    local yOffset = wizard.currentYOffset or 0
    
    -- Properties for status effect bars
    local barWidth = 130
    local barHeight = 12
    local barSpacing = 18
    local barPadding = 15  -- Additional padding between effect bars
    
    -- Position status bars above the spellbook area
    local baseY = screenHeight - 150  -- Higher up from the spellbook
    local effectCount = 0
    
    -- Position bars above the wizard with the same offsets as the sprite
    local x = wizard.x + xOffset
    
    local Constants = require("core.Constants")
    
    -- Draw AERIAL duration if active
    if wizard.elevation == Constants.ElevationState.AERIAL and wizard.elevationTimer > 0 then
        effectCount = effectCount + 1
        local y = baseY - (effectCount * (barHeight + barPadding))
        
        -- Calculate progress (1.0 to 0.0 as time depletes)
        local maxDuration = 5.0  -- Assuming 5 seconds is max aerial duration
        local progress = wizard.elevationTimer / maxDuration
        progress = math.min(1.0, progress)  -- Cap at 1.0
        
        -- Get color for aerial state
        local color = WizardVisuals.getStatusEffectColor("aerial")
        
        -- Draw background bar (darker)
        love.graphics.setColor(color[1] * 0.5, color[2] * 0.5, color[3] * 0.5, color[4] * 0.5)
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth, barHeight, 4, 4)
        
        -- Draw progress bar
        love.graphics.setColor(color[1], color[2], color[3], color[4])
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth * progress, barHeight, 4, 4)
        
        -- Draw label
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print(Constants.ElevationState.AERIAL, x - 25, y - 2)
        
        -- Add some particle effects for AERIAL state
        if wizard.gameState and wizard.gameState.vfx and math.random() < 0.02 then
            local particleX = x + math.random(-barWidth/2, barWidth/2)
            local particleY = y + math.random(-10, 10)
            
            wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, particleX, particleY, nil, nil, {
                duration = 0.3,
                color = {0.5, 0.5, 1.0, 0.7},
                particleCount = 3,
                radius = 5
            })
        end
    end
    
    -- Draw STUN duration if active
    if wizard.statusEffects.stun and wizard.statusEffects.stun.active then
        effectCount = effectCount + 1
        local y = baseY - (effectCount * (barHeight + barPadding))

        -- Calculate progress (1.0 to 0.0 as time depletes)
        local stun = wizard.statusEffects.stun
        local maxDuration = stun.duration
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        local progress = maxDuration > 0 and remaining / maxDuration or 0

        -- Get color for stun state
        local color = WizardVisuals.getStatusEffectColor(Constants.StatusType.STUN)
        
        -- Draw background bar (darker)
        love.graphics.setColor(color[1] * 0.5, color[2] * 0.5, color[3] * 0.5, color[4] * 0.5)
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth, barHeight, 4, 4)
        
        -- Draw progress bar
        love.graphics.setColor(color[1], color[2], color[3], color[4])
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth * progress, barHeight, 4, 4)
        
        -- Draw label
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print("STUNNED", x - 30, y - 2)
        
        -- Add some particle effects for STUN state
        if wizard.gameState and wizard.gameState.vfx and math.random() < 0.05 then
            local particleX = x + math.random(-barWidth/2, barWidth/2)
            local particleY = y + math.random(-5, 5)
            
            wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, particleX, particleY, nil, nil, {
                duration = 0.2,
                color = {1.0, 1.0, 0.0, 0.7},
                particleCount = 2,
                radius = 5
            })
        end
    end
    
    -- Draw BURN effect if active
    if wizard.statusEffects[Constants.StatusType.BURN] and wizard.statusEffects[Constants.StatusType.BURN].active then
        effectCount = effectCount + 1
        local y = baseY - (effectCount * (barHeight + barPadding))

        -- Get burn effect data
        local burnEffect = wizard.statusEffects[Constants.StatusType.BURN]
        
        -- Calculate progress (1.0 to 0.0 as time depletes)
        local progress = 1.0
        if burnEffect.duration > 0 then
            progress = (burnEffect.duration - burnEffect.totalTime) / burnEffect.duration
            progress = math.max(0.0, math.min(1.0, progress))  -- Clamp between 0 and 1
        end
        
        -- Get tick progress for pulsing effect
        local tickProgress = burnEffect.elapsed / burnEffect.tickInterval
        local pulseEffect = math.sin(tickProgress * math.pi) * 0.2  -- Pulse effect strongest right before tick
        
        -- Get color for burn state
        local color = WizardVisuals.getStatusEffectColor(Constants.StatusType.BURN)
        
        -- Draw background bar (darker)
        love.graphics.setColor(color[1] * 0.5, color[2] * 0.5, color[3] * 0.5, color[4] * 0.5)
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth, barHeight, 4, 4)
        
        -- Draw progress bar with pulse effect
        love.graphics.setColor(
            color[1] * (1 + pulseEffect), 
            color[2] * (1 + pulseEffect), 
            color[3] * (1 + pulseEffect), 
            color[4]
        )
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth * progress, barHeight, 4, 4)
        
        -- Draw label with damage per tick
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print("BURN "..burnEffect.tickDamage, x - 30, y - 2)
        
        -- Add some particle effects for BURN state
        if wizard.gameState and wizard.gameState.vfx and math.random() < 0.1 then
            local particleX = wizard.x + math.random(-20, 20)
            local particleY = wizard.y + math.random(-30, 10)
            
            wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, particleX, particleY, nil, nil, {
                duration = 0.3,
                color = {1.0, 0.4, 0.1, 0.6},
                particleCount = 3,
                radius = 8
            })
        end
    end
end

-- Draw spell slots with token orbits
function WizardVisuals.drawSpellSlots(wizard, layer)
    -- Draw 3 orbiting spell slots as elliptical paths at different vertical positions
    -- Position the slots at legs, midsection, and head levels
    -- Get position offsets to apply the same offsets as the wizard
    local xOffset = wizard.currentXOffset or 0
    local yOffset = wizard.currentYOffset or 0
    local slotYOffsets = {30, 0, -30}  -- From bottom to top
    
    -- Horizontal and vertical radii for each elliptical path
    local horizontalRadii = {80, 70, 60}   -- Wider at the bottom, narrower at the top
    local verticalRadii = {20, 25, 30}     -- Flatter at the bottom, rounder at the top
    
    -- Get the ManaPool instance (ensure gameState and manaPool exist)
    local manaPool = wizard.gameState and wizard.gameState.manaPool
    if not manaPool then
        print("ERROR: ManaPool instance not found in WizardVisuals.drawSpellSlots")
        return
    end

    for i, slot in ipairs(wizard.spellSlots) do
        -- Position parameters for each slot, applying both offsets
        local slotY = wizard.y + slotYOffsets[i] + yOffset
        local slotX = wizard.x + xOffset
        local radiusX = horizontalRadii[i]
        local radiusY = verticalRadii[i]
        
        -- Calculate base position and animation values for all tokens
        -- This is crucial for both normal and shield tokens to get consistent positions
        if slot.active and #slot.tokens > 0 then
            -- For normal spells, angle based on cast progress
            -- For shields, use time-based constant rotation
            local baseAngle
            if slot.isShield then
                -- Shield rotation is time-based and continuous
                baseAngle = love.timer.getTime() * 0.3  -- Slightly faster to make orbiting more visible
            else
                -- Normal spell rotation is based on cast progress
                baseAngle = slot.progress / slot.castTime * math.pi * 2
            end
            
            -- Pre-calculate token positions for ALL tokens in this slot
            -- This ensures consistent positioning regardless of front/back rendering order
            local tokenCount = #slot.tokens
            local anglePerToken = math.pi * 2 / tokenCount
            
            -- First pass: calculate positions and draw based on layer
            for j, tokenData in ipairs(slot.tokens) do
                local token = tokenData.token
                
                -- Skip invalid or transitioning tokens
                if not token or 
                   token.status == Constants.TokenStatus.RETURNING or 
                   token.status == Constants.TokenStatus.DISSOLVING then
                    -- No goto needed here, just continue to next token
                else
                    -- Calculate angle for each token based on its index
                    local tokenAngle = baseAngle + anglePerToken * (j - 1)
                    
                    -- Store the token's orbit angle (for continuity)
                    token.orbitAngle = tokenAngle
                    
                    -- Calculate position - used for both rendering and token state
                    -- Note: If the token is animating towards the slot (CHANNELED state, animTime < animDuration),
                    -- its x, y might be updated by ManaPool:update. We should use the calculated orbit position
                    -- for layer determination, but let ManaPool:drawToken use the token's current x,y.
                    local orbitX = slotX + math.cos(tokenAngle) * radiusX
                    local orbitY = slotY + math.sin(tokenAngle) * radiusY
                    
                    -- If token isn't fully animated to the slot yet, keep its animating position
                    -- but use the calculated orbit position for determining front/back
                    if token.status == Constants.TokenStatus.CHANNELED and token.animTime < token.animDuration then
                        -- Position is being animated, use orbitAngle for layering check only
                    else
                        -- Token is in orbit, update its position directly
                        token.x = orbitX
                        token.y = orbitY
                    end
                    
                    -- Determine if token is in the front or back half based on its *intended* orbit angle
                    local normalizedAngle = token.orbitAngle % (math.pi * 2)
                    local tokenLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"

                    -- Draw the token if its layer matches the requested layer
                    if tokenLayer == layer then
                         -- Check if the token is actually supposed to be drawn (not animating away)
                        if token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
                             manaPool:drawToken(token)
                        end
                    end
                end
            end
        end
        
        -- Draw the elliptical orbit paths (only need to do this once, e.g., during the 'back' pass)
        if layer == "back" then 
            -- Clear stale casting arc data if this slot is not currently in an active casting phase
            if not slot.active or (slot.castTime or 0) == 0 or slot.progress >= (slot.castTime or 0) then
                slot._castArcActive = false
            end

            local shouldDrawOrbit = false
            local orbitColor = {0.5, 0.5, 0.5, 0.4} -- Default inactive/dim color
            local drawProgressArc = false
            local progressArcColor = {1.0, 1.0, 1.0, 0.9} -- Default progress color
            local stateText = nil -- Text like "FROZEN", "TRAP"
            local stateTextColor = {1, 1, 1, 0.8}

            -- First, check for keyed spell highlight on an inactive slot
            if wizard.currentKeyedSpell and not slot.active then
                local wouldUseThisSlot = true
                for j = 1, i-1 do
                    if not wizard.spellSlots[j].active then
                        wouldUseThisSlot = false
                        break
                    end
                end
                
                if wouldUseThisSlot then
                    local affinity = wizard.currentKeyedSpell.affinity
                    orbitColor = affinity and Constants.getColorForTokenType(affinity) or {0.8, 0.8, 0.2}
                    orbitColor[4] = 0.7 -- Set alpha
                    shouldDrawOrbit = true
                    -- Skip further checks for this slot if it's just a highlight
                    goto DrawOrbitAndArc -- Use goto to jump past active slot logic
                end
            end

            -- Handle active slots (casting or sustained/finished)
            if slot.active then
                -- Determine if the spell is currently in its casting phase
                local isActuallyCasting = (slot.castTime or 0) > 0 and slot.progress < slot.castTime

                if isActuallyCasting then
                    -- CASTING PHASE: Show affinity-colored progress arc only
                    drawProgressArc = true
                    shouldDrawOrbit = false -- Hide the full orbit during cast

                    local affinity = slot.spell and slot.spell.affinity
                    local baseArcColor = affinity and Constants.getColorForTokenType(affinity) or {1.0, 0.7, 0.3} -- Default yellowish
                    local brightness = 0.9 + math.sin(love.timer.getTime() * 5) * 0.1
                    progressArcColor = {
                        baseArcColor[1] * brightness, 
                        baseArcColor[2] * brightness, 
                        baseArcColor[3] * brightness, 
                        0.9
                    }

                    -- Store arc information so the complementary half can be rendered in the "front" pass
                    slot._castArcActive = true
                    slot._castArcColor = {progressArcColor[1], progressArcColor[2], progressArcColor[3], progressArcColor[4]}
                    slot._castArcProgress = (slot.castTime or 1) > 0 and (slot.progress / slot.castTime) or 0

                else
                    -- POST-CASTING PHASE (or instant spell): Show full orbit based on state
                    drawProgressArc = false
                    slot._castArcActive = false -- Clear cached arc
                    shouldDrawOrbit = true 

                    if slot.isShield then
                        -- New shield rendering logic based on type
                        local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
                        -- Use slot.defenseType directly instead of looking at the spell keywords, which are not always available
                        local shieldType = slot.defenseType
                        local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3
                        local alpha = 0.7 + pulseAmount * 0.3 -- Pulsing alpha

                        -- Compare against Constants instead of string literals
                        if shieldType == Constants.ShieldType.BARRIER then
                            -- Do NOT draw the horizontal orbit for Barrier; only vertical hedge lines
                            shouldDrawOrbit = false
                            -- Vertical cylinder lines are handled later in their dedicated block
                        
                        elseif shieldType == Constants.ShieldType.WARD then
                            shouldDrawOrbit = false -- Don't draw the standard orbit for Ward
                            local numRunes = 5
                            local runeYOffset = 0 -- Position runes above the orbit
                            local runeScale = 1.0

                            -- Get runes with more robust handling
                            local runeAssets
                            -- First try using the public getAsset function 
                            if VFX.getAsset then
                                runeAssets = VFX.getAsset("runes")
                            end
                            
                            -- Fall back to direct access if needed
                            if not runeAssets and VFX.assets then
                                runeAssets = VFX.assets.runes
                            end
                            
                            -- Last resort: create a dummy fallback for this frame
                            if not runeAssets or #runeAssets == 0 then
                                print("[WIZARD VISUALS] Warning: Unable to get rune assets, using fallback")
                                shouldDrawOrbit = true
                            end
                            
                            if runeAssets and #runeAssets > 0 then
                                -- Determine rune color based on spell affinity if available
                                local baseColor
                                if slot.spell and slot.spell.affinity then
                                    -- Use spell affinity color for more visual variety
                                    baseColor = Constants.getColorForTokenType(slot.spell.affinity)
                                else
                                    -- Fall back to shield type color
                                    baseColor = shieldColor
                                end
                                
                                -- Enhanced contrast and visibility
                                local runeColor = {
                                    math.min(1.0, baseColor[1] * (1.2 + pulseAmount * 0.8)),
                                    math.min(1.0, baseColor[2] * (1.2 + pulseAmount * 0.8)),
                                    math.min(1.0, baseColor[3] * (1.2 + pulseAmount * 0.8)),
                                    0.95 + pulseAmount * 0.05  -- Higher base alpha for better visibility
                                }

                                for r = 1, numRunes do
                                    -- Deterministic seed so both passes pick the same rune image
                                    local seed = i * 10 + r + math.floor(love.timer.getTime())
                                    math.randomseed(seed)
                                    local runeIndex = math.random(1, #runeAssets)
                                    math.randomseed(os.time() + os.clock()*1000000)

                                    local runeImg = runeAssets[runeIndex]
                                    local angle = (r / numRunes) * math.pi * 2 + love.timer.getTime() * 0.7
                                    local runeX = slotX + math.cos(angle) * radiusX
                                    local runeY = slotY + math.sin(angle) * radiusY + runeYOffset

                                    -- Determine if rune is front or back half
                                    local normalizedAngle = (angle % (math.pi * 2))
                                    local runeLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"

                                    if runeLayer == layer then
                                        -- Dark outline for better contrast against backgrounds
                                        love.graphics.setColor(0, 0, 0, runeColor[4] * 0.8)
                                        for dx = -1, 1 do
                                            for dy = -1, 1 do
                                                if dx ~= 0 or dy ~= 0 then
                                                    love.graphics.draw(
                                                        runeImg,
                                                        runeX + dx, runeY + dy,
                                                        0,
                                                        runeScale, runeScale,
                                                        runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                                    )
                                                end
                                            end
                                        end
                                        
                                        -- Bright glow pass for visibility
                                        local prevBlendSrc, prevBlendDst = love.graphics.getBlendMode()
                                        love.graphics.setBlendMode("add")
                                        love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4] * 0.8)
                                        love.graphics.draw(
                                            runeImg,
                                            runeX, runeY,
                                            0,
                                            runeScale * 1.6, runeScale * 1.6,
                                            runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                        )
                                        love.graphics.setBlendMode(prevBlendSrc, prevBlendDst)

                                        -- Main rune sprite with full opacity
                                        love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4])
                                        love.graphics.draw(
                                            runeImg,
                                            runeX, runeY,
                                            0,
                                            runeScale, runeScale,
                                            runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                        )
                                    end
                                end
                            else
                                -- Fallback: Draw the orbit if runes aren't loaded
                                shouldDrawOrbit = true
                                orbitColor = { shieldColor[1] * (1 + pulseAmount), shieldColor[2] * (1 + pulseAmount), shieldColor[3] * (1 + pulseAmount), alpha }
                            end

                        else
                            -- Fallback for unknown shield types or missing data: Draw original pulsating orbit
                            shouldDrawOrbit = true
                            orbitColor = { shieldColor[1] * (1 + pulseAmount), shieldColor[2] * (1 + pulseAmount), shieldColor[3] * (1 + pulseAmount), alpha }
                        end
                        
                        -- The old shield orbit drawing logic is now replaced by the type-specific drawing above
                        -- or handled by the fallback cases setting shouldDrawOrbit = true.

                    elseif slot.frozen then
                        orbitColor = {0.5, 0.5, 1.0, 0.7} -- Blue for frozen
                        stateText = "FROZEN"
                        stateTextColor = {0.7, 0.7, 1.0, 0.8}
                        -- Flickering ice effect
                        if math.random() < 0.03 then
                            if wizard.gameState and wizard.gameState.vfx then
                                local angle = math.random() * math.pi * 2
                                local sparkleX = slotX + math.cos(angle) * radiusX * 0.7
                                local sparkleY = slotY + math.sin(angle) * radiusY * 0.7
                                wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, sparkleX, sparkleY, nil, nil, {
                                    duration = 0.3, color = {0.6, 0.6, 1.0, 0.5}, particleCount = 3, radius = 5
                                })
                            end
                        end

                    elseif slot.spell and slot.spell.behavior and slot.spell.behavior.trap_trigger then
                        orbitColor = {0.7, 0.3, 0.9, 0.7} -- Purple for traps
                        stateText = "TRAP"
                        stateTextColor = {0.7, 0.3, 0.9, 0.8}
                        -- Trap sigil effect
                        -- this is the "explosions" bit on the caster rn - replace with overhead rune
                        if math.random() < 0.05 then
                            if wizard.gameState and wizard.gameState.vfx then
                                local angle = math.random() * math.pi * 2
                                local sparkleX = slotX + math.cos(angle) * radiusX * 0.6
                                local sparkleY = slotY + math.sin(angle) * radiusY * 0.6
                                wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, sparkleX, sparkleY, nil, nil, {
                                    duration = 0.3, color = {0.7, 0.2, 0.9, 0.5}, particleCount = 2, radius = 4
                                })
                            end
                        end

                    elseif slot.spell and slot.spell.behavior and slot.spell.behavior.field_status then
                        orbitColor = {0.3, 1.0, 0.3, 0.7}
                        stateText = "FIELD"
                        stateTextColor = {0.3, 1.0, 0.3, 0.8}
                        
                    elseif slot.spell and slot.spell.behavior and slot.spell.behavior.sustain then
                        orbitColor = {0.9, 0.9, 0.9, 0.7} -- Light grey for sustained
                        stateText = "SUSTAIN"
                        stateTextColor = {0.9, 0.9, 0.9, 0.8}
                        -- Add potential sustain VFX here if desired

                    else 
                        -- Completed normal spell (not shield/frozen/trap/sustain)
                        -- Keep orbit briefly visible with affinity color (or maybe dim grey?)
                        local affinity = slot.spell and slot.spell.affinity
                        orbitColor = affinity and Constants.getColorForTokenType(affinity) or {0.9, 0.4, 0.2}
                        orbitColor[4] = 0.5 -- Make it slightly dimmer after completion
                    end
                end
            end -- End of active slot handling
            
            ::DrawOrbitAndArc::
            
            -- Draw the orbit ellipse if needed
            if shouldDrawOrbit then
                -- Store information so the corresponding bottom half can be drawn in the "front" pass
                slot._orbitShouldDraw = true
                slot._orbitColor = {orbitColor[1], orbitColor[2], orbitColor[3], orbitColor[4]}

                love.graphics.setColor(orbitColor[1], orbitColor[2], orbitColor[3], orbitColor[4])
                -- Draw ONLY the TOP half of the ellipse (π to 2π) during the "back" pass so it appears behind the wizard
                WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, math.pi, math.pi * 2, 32)

                -- Periodic sparks along the full orbit for sustained spells
                if slot.isShield or (slot.spell and slot.spell.behavior and slot.spell.behavior.sustain) then
                    local now = love.timer.getTime()
                    slot._nextOrbitSpark = slot._nextOrbitSpark or 0
                    if now >= slot._nextOrbitSpark then
                        local angle = math.random() * math.pi * 2
                        local px = slotX + math.cos(angle) * radiusX
                        local py = slotY + math.sin(angle) * radiusY
                        spawnArcSpark(slot, px, py, angle, orbitColor)
                        slot._nextOrbitSpark = now + 0.3 + math.random() * 0.3
                    end
                end
            else
                -- Make sure we do not accidentally reuse stale data on the next frame
                slot._orbitShouldDraw = false
            end

            -- NEW: Draw Barrier vertical cylinder lines if applicable
            if slot.active and slot.isShield then
                 -- Use the slot's defenseType value directly rather than trying to check the spell
                 if slot.defenseType == Constants.ShieldType.BARRIER then
                    -- Recalculate color/alpha or retrieve if stored (recalculating is safer here)
                    local shieldColor = ShieldSystem.getShieldColor(slot.defenseType) 
                    local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3
                    local alpha = 0.7 + pulseAmount * 0.3 

                    local cylinderHeight = 20 -- Height of the barrier effect
                    local numLines = 72 -- Number of vertical lines to simulate the cylinder
                    local lineAlpha = alpha * 0.6 -- Make vertical lines slightly more transparent

                    love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                    local prevWidth = love.graphics.getLineWidth()
                    love.graphics.setLineWidth(1.5) -- thicker

                    for k = 1, numLines do
                        local angle = (k / numLines) * math.pi * 2
                        local normalizedAngle = angle % (math.pi * 2)
                        -- Draw only BACK half lines in the back pass (π → 2π)
                        if normalizedAngle > math.pi then
                            local px = slotX + math.cos(angle) * radiusX
                            local py = slotY + math.sin(angle) * radiusY

                            -- Glow pass (thicker, additive blend)
                            local prevSrc, prevDst = love.graphics.getBlendMode()
                            love.graphics.setBlendMode("add")
                            love.graphics.setLineWidth(4)
                            love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha * 0.35)
                            love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                            love.graphics.setBlendMode(prevSrc, prevDst)

                            -- Main line
                            love.graphics.setLineWidth(1.5)
                            love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                            love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                        end
                    end
                    love.graphics.setLineWidth(prevWidth) -- restore
                 end
            end
            
            -- Draw progress arc if needed (only during casting phase)
            if drawProgressArc then
                -- Compute end angle once
                local endAngle = ((slot.castTime or 1) > 0) and (slot.progress / slot.castTime) * (math.pi * 2) or 0

                -- Draw only the TOP half (π → 2π) of the arc for the back layer
                if endAngle > math.pi then
                    local segStart = math.max(math.pi, 0) -- will always be π
                    local segEnd = endAngle
                    love.graphics.setColor(progressArcColor[1], progressArcColor[2], progressArcColor[3], progressArcColor[4])
                    -- Glow pass
                    local prevSrc, prevDst = love.graphics.getBlendMode()
                    love.graphics.setBlendMode("add")
                    local prevWidth = love.graphics.getLineWidth()
                    love.graphics.setLineWidth(3)
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, segStart, segEnd, 32)
                    love.graphics.setBlendMode(prevSrc, prevDst)
                    love.graphics.setLineWidth(prevWidth)
                    -- Main arc
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, segStart, segEnd, 32)

                    -- Spawn multiple sparkles at the arc head for more dramatic effect
                    if not slot._lastArcSpark or love.timer.getTime() - slot._lastArcSpark > 0.02 then
                        local hx = slotX + math.cos(endAngle) * radiusX
                        local hy = slotY + math.sin(endAngle) * radiusY
                        -- Spawn 3-5 particles per frame for much more generous particle effect
                        local particleCount = 3 + math.random(0, 2)
                        for p = 1, particleCount do
                            spawnArcSpark(slot, hx, hy, endAngle, progressArcColor)
                        end
                        slot._lastArcSpark = love.timer.getTime()
                    end
                end
            end

            -- Draw state text (TRAP, FROZEN, SUSTAIN) above the orbit if applicable
            if stateText then
                love.graphics.setColor(stateTextColor[1], stateTextColor[2], stateTextColor[3], stateTextColor[4])
                local textWidth = love.graphics.getFont():getWidth(stateText)
                love.graphics.print(stateText, 
                    slotX - textWidth / 2, -- Center text
                    slotY - verticalRadii[i] - 15) -- Position above the orbit
            end

            -- Re-draw tokens so they sit on top of the just-drawn orbit / arc graphics (maintains depth vs wizard)
            if slot.active and #slot.tokens > 0 then
                for j, tokenData in ipairs(slot.tokens) do
                    local token = tokenData.token
                    if token and token.status ~= Constants.TokenStatus.RETURNING and token.status ~= Constants.TokenStatus.DISSOLVING then
                        -- token.orbitAngle was set earlier in the first pass through tokens
                        local normalizedAngle = (token.orbitAngle or 0) % (math.pi * 2)
                        local tokenLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"

                        if tokenLayer == layer then
                            if token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
                                manaPool:drawToken(token)
                            end
                        end
                    end
                end
            end
        end -- End of drawing orbits only on 'back' pass

        -- NEW: Draw the BOTTOM half of the orbit ellipse during the "front" layer pass
        if layer == "front" then
            if slot._orbitShouldDraw and slot._orbitColor then
                local oc = slot._orbitColor
                love.graphics.setColor(oc[1], oc[2], oc[3], oc[4])
                WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, 0, math.pi, 32)
            end

            -- Draw bottom half of casting progress arc if there is one
            if slot._castArcActive and slot._castArcColor then
                local endAngle = (slot._castArcProgress or 0) * (math.pi * 2)
                local segEnd = math.min(endAngle, math.pi)
                if segEnd > 0.01 then -- Avoid drawing if not progressed into bottom half yet
                    local cac = slot._castArcColor
                    love.graphics.setColor(cac[1], cac[2], cac[3], cac[4])
                    local prevSrc, prevDst = love.graphics.getBlendMode()
                    love.graphics.setBlendMode("add")
                    local prevWidth = love.graphics.getLineWidth()
                    love.graphics.setLineWidth(3)
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, 0, segEnd, 32)
                    love.graphics.setBlendMode(prevSrc, prevDst)
                    love.graphics.setLineWidth(prevWidth)
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, 0, segEnd, 32)

                    if not slot._lastArcSpark or love.timer.getTime() - slot._lastArcSpark > 0.02 then
                        local hx = slotX + math.cos(endAngle) * radiusX
                        local hy = slotY + math.sin(endAngle) * radiusY
                        -- Spawn 3-5 particles per frame for much more generous particle effect
                        local particleCount = 3 + math.random(0, 2)
                        for p = 1, particleCount do
                            spawnArcSpark(slot, hx, hy, endAngle, cac)
                        end
                        slot._lastArcSpark = love.timer.getTime()
                    end
                end
            end

            -- Draw WARD runes that belong to the FRONT half
            if slot.active and slot.isShield and slot.defenseType == Constants.ShieldType.WARD then
                local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
                local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3

                local numRunes = 5
                local runeYOffset = 0
                local runeScale = 1.0

                local runeAssets
                if VFX.getAsset then
                    runeAssets = VFX.getAsset("runes")
                end
                if not runeAssets and VFX.assets then
                    runeAssets = VFX.assets.runes
                end

                if runeAssets and #runeAssets > 0 then
                    -- Determine rune color based on spell affinity if available
                    local baseColor
                    if slot.spell and slot.spell.affinity then
                        -- Use spell affinity color for more visual variety
                        baseColor = Constants.getColorForTokenType(slot.spell.affinity)
                    else
                        -- Fall back to shield type color
                        baseColor = shieldColor
                    end
                    
                    -- Enhanced contrast and visibility
                    local runeColor = {
                        math.min(1.0, baseColor[1] * (1.2 + pulseAmount * 0.8)),
                        math.min(1.0, baseColor[2] * (1.2 + pulseAmount * 0.8)),
                        math.min(1.0, baseColor[3] * (1.2 + pulseAmount * 0.8)),
                        0.95 + pulseAmount * 0.05  -- Higher base alpha for better visibility
                    }

                    for r = 1, numRunes do
                        local seed = i * 10 + r + math.floor(love.timer.getTime())
                        math.randomseed(seed)
                        local runeIndex = math.random(1, #runeAssets)
                        math.randomseed(os.time() + os.clock()*1000000)

                        local runeImg = runeAssets[runeIndex]
                        local angle = (r / numRunes) * math.pi * 2 + love.timer.getTime() * 0.7
                        local runeX = slotX + math.cos(angle) * radiusX
                        local runeY = slotY + math.sin(angle) * radiusY + runeYOffset

                        local normalizedAngle = angle % (math.pi * 2)
                        if normalizedAngle >= 0 and normalizedAngle <= math.pi then -- Front half
                            -- Dark outline for better contrast against backgrounds
                            love.graphics.setColor(0, 0, 0, runeColor[4] * 0.8)
                            for dx = -1, 1 do
                                for dy = -1, 1 do
                                    if dx ~= 0 or dy ~= 0 then
                                        love.graphics.draw(
                                            runeImg,
                                            runeX + dx, runeY + dy,
                                            0,
                                            runeScale, runeScale,
                                            runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                        )
                                    end
                                end
                            end
                            
                            -- Bright glow pass for visibility
                            local prevBlendSrc, prevBlendDst = love.graphics.getBlendMode()
                            love.graphics.setBlendMode("add")
                            love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4] * 0.8)
                            love.graphics.draw(runeImg, runeX, runeY, 0, runeScale * 1.6, runeScale * 1.6, runeImg:getWidth()/2, runeImg:getHeight()/2)
                            love.graphics.setBlendMode(prevBlendSrc, prevBlendDst)

                            -- Main rune sprite with full opacity
                            love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4])
                            love.graphics.draw(runeImg, runeX, runeY, 0, runeScale, runeScale, runeImg:getWidth()/2, runeImg:getHeight()/2)
                        end
                    end
                end
            end

            -- Draw Barrier vertical hedge lines for the FRONT half
            if slot.active and slot.isShield and slot.defenseType == Constants.ShieldType.BARRIER then
                local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
                local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3
                local alpha = 0.7 + pulseAmount * 0.3
                local cylinderHeight = 20
                local numLines = 72
                local lineAlpha = alpha * 0.6

                love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                local prevWidthF = love.graphics.getLineWidth()
                love.graphics.setLineWidth(1.5)

                for k = 1, numLines do
                    local angle = (k / numLines) * math.pi * 2
                    local normalizedAngle = angle % (math.pi * 2)
                    -- FRONT half is 0 → π
                    if normalizedAngle <= math.pi then
                        local px = slotX + math.cos(angle) * radiusX
                        local py = slotY + math.sin(angle) * radiusY

                        -- Glow pass
                        local prevSrc, prevDst = love.graphics.getBlendMode()
                        love.graphics.setBlendMode("add")
                        love.graphics.setLineWidth(4)
                        love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha * 0.35)
                        love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                        love.graphics.setBlendMode(prevSrc, prevDst)

                        -- Main line
                        love.graphics.setLineWidth(1.5)
                        love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                        love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                    end
                end
                love.graphics.setLineWidth(prevWidthF)
            end

            -- Re-draw tokens again in front layer to ensure they sit atop orbit/arc
            if slot.active and #slot.tokens > 0 then
                for j, tokenData in ipairs(slot.tokens) do
                    local token = tokenData.token
                    if token and token.status ~= Constants.TokenStatus.RETURNING and token.status ~= Constants.TokenStatus.DISSOLVING then
                        local normalizedAngle = (token.orbitAngle or 0) % (math.pi * 2)
                        local tokenLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"
                        if tokenLayer == layer then
                            if token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
                                manaPool:drawToken(token)
                            end
                        end
                    end
                end
            end

            -- Draw spark particles for this slot
            if slot._arcParticles and #slot._arcParticles > 0 then
                for _, p in ipairs(slot._arcParticles) do
                    local alpha = (p.life / p.maxLife)
                    love.graphics.setColor(p.color[1], p.color[2], p.color[3], alpha)
                    love.graphics.draw(p.img, p.x, p.y, 0, 1, 1, p.img:getWidth()/2, p.img:getHeight()/2)
                end
            end
        end
    end -- End of loop through spell slots
end

-- Main function to draw the wizard
function WizardVisuals.drawWizard(wizard)
    -- Calculate target position adjustments based on elevation and range state
    local targetYOffset = 0
    local targetXOffset = 0
    
    -- Vertical adjustment for AERIAL state - increased for more dramatic effect
    if wizard.elevation == Constants.ElevationState.AERIAL then
        targetYOffset = -50  -- Lift the wizard up more significantly when AERIAL
    end
    
    -- Horizontal adjustment for NEAR/FAR state
    local isNear = wizard.gameState and wizard.gameState.rangeState == Constants.RangeState.NEAR
    local centerX = love.graphics.getWidth() / 2
    
    -- Determine relative position compared to the other combatant
    local isLeft = true
    if wizard.gameState and wizard.gameState.wizards then
        for _, other in ipairs(wizard.gameState.wizards) do
            if other ~= wizard then
                isLeft = wizard.x <= other.x
                break
            end
        end
    end

    -- Push wizards closer to center in NEAR mode, further in FAR mode
    if isLeft then
        targetXOffset = isNear and 60 or 0 -- Move right when NEAR
    else
        targetXOffset = isNear and -60 or 0 -- Move left when NEAR
    end
    
    -- Check if position needs to change and start animation if needed
    if not wizard.positionAnimation.active and
       ((wizard.currentXOffset or 0) ~= targetXOffset or 
        (wizard.currentYOffset or 0) ~= targetYOffset) then
        -- Start animation
        wizard.positionAnimation.active = true
        wizard.positionAnimation.startX = wizard.currentXOffset or 0
        wizard.positionAnimation.startY = wizard.currentYOffset or 0
        wizard.positionAnimation.targetX = targetXOffset
        wizard.positionAnimation.targetY = targetYOffset
        wizard.positionAnimation.progress = 0
    end
    
    -- Calculate and apply current offsets (animated or target)
    local xOffset, yOffset
    if wizard.positionAnimation.active then
        -- Use interpolated position with easing
        local progress = WizardVisuals.easeOutCubic(wizard.positionAnimation.progress)
        xOffset = wizard.positionAnimation.startX + 
                 (wizard.positionAnimation.targetX - wizard.positionAnimation.startX) * progress
        yOffset = wizard.positionAnimation.startY + 
                 (wizard.positionAnimation.targetY - wizard.positionAnimation.startY) * progress
    else
        -- Use target position directly
        xOffset = targetXOffset
        yOffset = targetYOffset
    end
    
    -- Determine the wizard sprite color based on state
    local wizardColor = {1, 1, 1, 1} -- Default white color
    
    if wizard.hitFlashTimer > 0 then
        -- Store the default wizard color
        wizard.flashBlendMode = "add" -- Will use additive blending for flash
        
        -- Use bright white (values > 1 for over-brightness effect)
        wizardColor = {2.0, 2.0, 2.0, 1} -- Super bright white
        
        -- Flash effect is now implemented with additive blending
    elseif wizard.statusEffects.stun and wizard.statusEffects.stun.active then
        -- Apply a yellow/white flash for stunned wizards
        local flashIntensity = 0.5 + math.sin(love.timer.getTime() * 10) * 0.5
        wizardColor = {1, 1, flashIntensity, 1}
    end
    
    -- Set initial color for ground indicator
    love.graphics.setColor(1, 1, 1, 1)
    
    -- Draw elevation effect (GROUNDED only - AERIAL clouds moved after wizard)
    if wizard.elevation == Constants.ElevationState.GROUNDED then
        -- Draw ground indicator below wizard, applying the x offset
        love.graphics.setColor(0.6, 0.6, 0.6, 0.5)
        love.graphics.ellipse("fill", wizard.x + xOffset, wizard.y + 40, 40, 10)  -- Simple shadow/ground indicator
    end
    
    -- Store current offsets for other functions to use
    wizard.currentXOffset = xOffset
    wizard.currentYOffset = yOffset

    -- Draw spell slots and tokens behind the wizard
    WizardVisuals.drawSpellSlots(wizard, "back")
    
    -- Draw the wizard sprite
    if wizard.sprite then
        -- Flip sprite based on whether this wizard is on the left or right
        local isLeft = true
        if wizard.gameState and wizard.gameState.wizards then
            for _, other in ipairs(wizard.gameState.wizards) do
                if other ~= wizard then
                    isLeft = wizard.x <= other.x
                    break
                end
            end
        end
        local flipX = isLeft and 1 or -1
        local adjustedScale = wizard.scale * flipX

        -- Determine which sprite to draw based on positional animation sets
        local spriteToDraw
        local posKey = wizard:getPositionalKey()
        local castSprite = wizard:getCastFrameForKey(posKey)
        local idleFrames = wizard:getIdleFramesForKey(posKey)

        if wizard.castFrameTimer > 0 and castSprite then
            spriteToDraw = castSprite
        elseif idleFrames and #idleFrames > 0 then
            spriteToDraw = idleFrames[wizard.currentIdleFrame]
        else
            spriteToDraw = wizard.sprite
        end

        -- Ensure spriteToDraw is not nil before attempting to draw
        if not spriteToDraw then
            print("Error: No sprite to draw for wizard " .. wizard.name)
            -- Draw a placeholder rectangle as a last resort
            love.graphics.setColor(1, 0, 0, 1) -- Red error color
            love.graphics.rectangle("fill", wizard.x + xOffset - 20, wizard.y + yOffset - 30, 40, 60)
            love.graphics.setColor(1, 1, 1, 1) -- Reset color
            return
        end

        -- Draw shadow first (when not AERIAL)
        if wizard.elevation == Constants.ElevationState.GROUNDED then
            love.graphics.setColor(0, 0, 0, 0.2)
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + 40, -- Shadow on ground
                0, -- No rotation
                adjustedScale * 0.8, -- Slightly smaller shadow
                wizard.scale * 0.3, -- Flatter shadow
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )
        end

        -- Draw the actual wizard with the appropriate color based on state

        -- For hit flash, we use a special blend mode and draw the sprite twice
        if wizard.hitFlashTimer > 0 then
            -- First draw the normal sprite
            love.graphics.setColor(1, 1, 1, 1)
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + yOffset,
                0, -- No rotation
                adjustedScale * 2, -- Double scale
                wizard.scale * 2, -- Double scale
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )

            -- Save current blend mode
            local prevBlendMode = love.graphics.getBlendMode()

            -- Set additive blend mode for glow effect
            love.graphics.setBlendMode("add")

            -- Draw the bright overlay
            love.graphics.setColor(wizardColor[1], wizardColor[2], wizardColor[3], wizardColor[4])

            -- Then overdraw with bright additive color
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + yOffset,
                0, -- No rotation
                adjustedScale * 2, -- Double scale
                wizard.scale * 2, -- Double scale
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )

            -- Restore previous blend mode
            love.graphics.setBlendMode(prevBlendMode)
        else
            -- Normal drawing
            love.graphics.setColor(wizardColor[1], wizardColor[2], wizardColor[3], wizardColor[4])
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + yOffset,
                0, -- No rotation
                adjustedScale * 2, -- Double scale
                wizard.scale * 2, -- Double scale
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )
        end -- End of if wizard.hitFlashTimer > 0 block
        
        -- Reset color back to default after drawing wizard
        love.graphics.setColor(1, 1, 1, 1)

        -- Draw AERIAL cloud effect after wizard for proper layering
        if wizard.elevation == Constants.ElevationState.AERIAL then
            love.graphics.setColor(0.8, 0.8, 1.0, 0.3)

            -- Draw more numerous, smaller animated cloud particles
            for i = 1, 8 do
                -- Calculate wobble in both x and y directions
                local time = love.timer.getTime()
                local angle = (i / 8) * math.pi * 2 + time
                local xWobble = math.sin(time * 2 + i * 1.5) * 15
                local yWobble = math.cos(time * 1.8 + i * 1.7) * 10

                -- Vary sizes for more natural look
                local width = 20 + math.sin(time + i) * 5
                local height = 6 + math.cos(time + i) * 2

                love.graphics.ellipse(
                    "fill",
                    wizard.x + xOffset + xWobble,
                    wizard.y + yOffset + 40 + yWobble,
                    width,
                    height
                )
            end
        end
    else
        -- Fallback if sprite not loaded - draw a colored circle
        love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255)
        love.graphics.circle("fill", wizard.x + xOffset, wizard.y + yOffset, 30)
    end
    
    -- Draw block visual effect if active
    if wizard.blockVFX and wizard.blockVFX.active then
        wizard.blockVFX.timer = wizard.blockVFX.timer - love.timer.getDelta()
        
        if wizard.blockVFX.timer <= 0 then
            wizard.blockVFX.active = false
        else
            -- Pulse effect for shield block
            local pulseSize = 50 * (1 - wizard.blockVFX.timer / 0.5)
            local alpha = wizard.blockVFX.timer / 0.5
            
            love.graphics.setColor(0.2, 0.8, 1.0, alpha)
            love.graphics.circle("line", wizard.blockVFX.x + xOffset, wizard.blockVFX.y + yOffset, pulseSize)
        end
    end
    
    -- Draw spell slots and tokens in front of the wizard
    WizardVisuals.drawSpellSlots(wizard, "front")
    
    -- Draw status effects
    WizardVisuals.drawStatusEffects(wizard)
    
    -- Draw casting notification if present
    if wizard.spellCastNotification then
        -- Update timer
        wizard.spellCastNotification.timer = wizard.spellCastNotification.timer - love.timer.getDelta()
        
        if wizard.spellCastNotification.timer <= 0 then
            wizard.spellCastNotification = nil
        else
            -- Draw the notification text
            love.graphics.setColor(
                wizard.spellCastNotification.color[1],
                wizard.spellCastNotification.color[2],
                wizard.spellCastNotification.color[3],
                wizard.spellCastNotification.timer / 2.0  -- Fade out
            )
            
            love.graphics.print(
                wizard.spellCastNotification.text,
                wizard.spellCastNotification.x - 40 + xOffset,  -- Center text approximately
                wizard.spellCastNotification.y + yOffset
            )
        end
    end
end

return WizardVisuals```

## ./tools/check_magic_strings.lua
```lua
-- check_magic_strings.lua
-- CI tool to detect magic strings that should be using Constants

-- List of patterns to search for in the codebase
local magicStringPatterns = {
    -- Token Types
    '"fire"', "'fire'", '"water"', "'water'", '"salt"', "'salt'", '"sun"', "'sun'",
    '"moon"', "'moon'", '"star"', "'star'", '"life"', "'life'", '"mind"', "'mind'", '"void"', "'void'",
    '"random"', "'random'",
    '"any"', "'any'",
    
    -- Token States
    '"FREE"', "'FREE'", '"CHANNELED"', "'CHANNELED'",
    '"SHIELDING"', "'SHIELDING'", '"LOCKED"', "'LOCKED'",
    '"DESTROYED"', "'DESTROYED'",
    
    -- Range States
    '"NEAR"', "'NEAR'", '"FAR"', "'FAR'",
    
    -- Elevation States
    '"GROUNDED"', "'GROUNDED'", '"AERIAL"', "'AERIAL'",
    
    -- Shield Types
    '"barrier"', "'barrier'", '"ward"', "'ward'",
    '"field"', "'field'",
    
    -- Attack Types
    '"projectile"', "'projectile'", '"remote"', "'remote'",
    '"zone"', "'zone'", '"utility"', "'utility'",
    
    -- Target Types
    '"SELF"', "'SELF'", '"ENEMY"', "'ENEMY'",
    
    -- Damage Types
    '"generic"', "'generic'", '"mixed"', "'mixed'"
}

-- Files to exclude from checking (e.g., test files, documentation)
local excludedPaths = {
    "spec/",
    "test_",
    "docs/",
    "tools/",
    "check_magic_strings.lua",
    "Constants.lua",
    "assets/",
    "vfx/",
    -- Exclude legacy/data files that will be difficult to update
    "spells.lua", -- Legacy data
    "test_spells.lua" -- Test file
}

-- Check if a file should be excluded
local function isExcluded(filepath)
    for _, pattern in ipairs(excludedPaths) do
        if filepath:find(pattern) then
            return true
        end
    end
    return false
end

-- Scan a file for magic strings
local function scanFile(filepath)
    if isExcluded(filepath) then
        return {}
    end
    
    local file = io.open(filepath, "r")
    if not file then
        print("Warning: Could not open file: " .. filepath)
        return {}
    end
    
    local content = file:read("*all")
    file:close()
    
    local issues = {}
    local lineNumber = 1
    
    -- Process file line by line
    for line in content:gmatch("[^\r\n]+") do
        for _, pattern in ipairs(magicStringPatterns) do
            -- Simple pattern matching for demonstration
            if line:find(pattern) then
                -- Check if it's not in a comment or string explanation
                if not line:match("^%s*%-%-") then
                    -- Ignore if it's part of a Constants reference
                    if not line:find("Constants%.") then
                        -- Ignore if it's in a comment at end of line
                        if not line:match("%-%-.*" .. pattern) then
                            -- Ignore if it appears to be in a block definition context (for legacy compatibility)
                            if not line:match("supportedTypes%s*=%s*{.*" .. pattern .. ".*}") and
                               not line:match("cost%s*=%s*{.*" .. pattern .. ".*}") and
                               not line:match("return%s+.*" .. pattern) then
                                table.insert(issues, {
                                    line = lineNumber,
                                    pattern = pattern,
                                    content = line:gsub("^%s+", ""):sub(1, 80) -- Trim and truncate for display
                                })
                            end
                        end
                    end
                end
            end
        end
        lineNumber = lineNumber + 1
    end
    
    return issues
end

-- Recursively scan directory for .lua files
local function scanDirectory(dirPath)
    local issues = {}
    local files = {}
    
    -- In a real implementation, use io.popen to list files
    -- For now, let's just hardcode a list of main files to check
    files = {
        "main.lua",
        "wizard.lua",
        "manapool.lua",
        "spellCompiler.lua",
        "ui.lua",
        "vfx.lua",
        "systems/ManaHelpers.lua",
        "systems/WizardVisuals.lua",
        "systems/ShieldSystem.lua",
        "systems/TokenManager.lua",
        "systems/VisualResolver.lua",
        "systems/EventRunner.lua",
        "systems/SustainedSpellManager.lua",
        "ai/OpponentAI.lua"
    }
    
    for _, filename in ipairs(files) do
        local filepath = dirPath .. "/" .. filename
        local fileIssues = scanFile(filepath)
        
        if #fileIssues > 0 then
            issues[filepath] = fileIssues
        end
    end
    
    return issues
end

-- Main function
local function main()
    local startDir = arg[1] or "."
    local allIssues = scanDirectory(startDir)
    
    -- Count total issues
    local totalIssues = 0
    for _, fileIssues in pairs(allIssues) do
        totalIssues = totalIssues + #fileIssues
    end
    
    -- Print results
    print("Magic String Check Results")
    print("=========================")
    print("Found " .. totalIssues .. " potential magic string issues")
    
    for filepath, fileIssues in pairs(allIssues) do
        print("\n" .. filepath .. " (" .. #fileIssues .. " issues):")
        for _, issue in ipairs(fileIssues) do
            print(string.format("  Line %d: %s => %s", 
                issue.line, issue.pattern, issue.content))
        end
    end
    
    -- Set exit code for CI
    os.exit(totalIssues > 0 and 1 or 0)
end

main()```

## ./tools/fix_vfx_events.lua
```lua
-- fix_vfx_events.lua
-- Script to update spells to properly use the event system for VFX

local Spells = require("spells").spells
local Keywords = require("keywords")
local Constants = require("core.Constants")
local SpellCompiler = require("spellCompiler")

-- Color formatting for console output
local colors = {
    reset = "\27[0m",
    red = "\27[31m",
    green = "\27[32m",
    yellow = "\27[33m",
    blue = "\27[34m",
    magenta = "\27[35m",
    cyan = "\27[36m"
}

-- Convert a spell's top-level VFX property to a vfx keyword
local function updateSpellVfx(spell)
    if not spell then return false end
    
    -- Skip spells that already use the vfx keyword properly
    if spell.keywords and spell.keywords.vfx then
        print(colors.green .. "✓ " .. spell.name .. " already using vfx keyword" .. colors.reset)
        return false
    end
    
    -- Skip utility spells without VFX if they're not meant to have visuals
    if spell.attackType == Constants.AttackType.UTILITY and not spell.vfx then
        print(colors.yellow .. "⚠ Skipping utility spell without VFX: " .. spell.name .. colors.reset)
        return false
    end
    
    -- If the spell has a top-level VFX property but no vfx keyword,
    -- add the vfx keyword using the top-level VFX value
    if spell.vfx then
        -- Create the keywords table if it doesn't exist
        spell.keywords = spell.keywords or {}
        
        -- Different handling based on attack type to determine target
        local targetType = Constants.TargetType.ENEMY
        if spell.attackType == Constants.AttackType.UTILITY then
            -- For utility spells, target self
            targetType = Constants.TargetType.SELF
        elseif spell.vfx:find("conjure") then
            -- For conjuration effects, target the pool
            targetType = "POOL_SELF"
        end
        
        -- Get the proper VFX type from Constants if possible
        local effectType = spell.vfx
        for typeName, typeValue in pairs(Constants.VFXType) do
            if typeValue == spell.vfx then
                effectType = typeValue
                break
            end
        end
        
        -- Add the vfx keyword with appropriate parameters
        spell.keywords.vfx = {
            effect = effectType,
            target = targetType
        }
        
        print(colors.green .. "✓ Added vfx keyword to " .. spell.name .. 
              " with effect=" .. effectType .. ", target=" .. targetType .. colors.reset)
        return true
    end
    
    -- Check for special cases like ground/elevate that have built-in VFX
    local hasBuiltInVfx = false
    if spell.keywords then
        for keyword, _ in pairs(spell.keywords) do
            if keyword == "ground" or keyword == "elevate" then
                hasBuiltInVfx = true
                break
            end
        end
    end
    
    if hasBuiltInVfx then
        print(colors.blue .. "ℹ " .. spell.name .. " uses keywords with built-in VFX" .. colors.reset)
        return false
    end
    
    -- If we get here, the spell has no VFX defined and should probably have one
    print(colors.red .. "✗ " .. spell.name .. " has no VFX defined" .. colors.reset)
    return false
end

-- Main function to update all spells
local function updateAllSpells()
    print(colors.cyan .. "=== Updating Spells VFX Events ===" .. colors.reset)
    
    local stats = {
        total = 0,
        updated = 0,
        alreadyCorrect = 0,
        skipped = 0,
        noVfx = 0
    }
    
    -- Process all spells
    for spellId, spell in pairs(Spells) do
        stats.total = stats.total + 1
        
        local updated = updateSpellVfx(spell)
        if updated then
            stats.updated = stats.updated + 1
        elseif spell.keywords and spell.keywords.vfx then
            stats.alreadyCorrect = stats.alreadyCorrect + 1
        elseif spell.attackType == Constants.AttackType.UTILITY and not spell.vfx then
            stats.skipped = stats.skipped + 1
        else
            stats.noVfx = stats.noVfx + 1
        end
    end
    
    -- Print summary statistics
    print(colors.cyan .. "\n=== Summary ===" .. colors.reset)
    print("Total spells: " .. stats.total)
    print(colors.green .. "Already using vfx keyword: " .. stats.alreadyCorrect .. colors.reset)
    print(colors.green .. "Updated to use vfx keyword: " .. stats.updated .. colors.reset)
    print(colors.yellow .. "Skipped (utility without VFX): " .. stats.skipped .. colors.reset)
    print(colors.red .. "Still missing VFX: " .. stats.noVfx .. colors.reset)
    
    return stats
end

-- Run the update process
local stats = updateAllSpells()

-- Return stats for use in automated systems
return stats```

## ./tools/generate_docs.lua
```lua
#!/usr/bin/env lua
-- Script to generate keyword documentation

-- Add manastorm root directory to lua path
package.path = package.path .. ";../?.lua"

-- Import the documentation generator
local DocGenerator = require("docs.keywords")

-- Generate the documentation
DocGenerator.writeDocumentation("../docs/KEYWORDS.md")

print("Documentation generation complete!")```

## ./tools/generate_vfx_report.lua
```lua
-- generate_vfx_report.lua
-- Script to generate a detailed report of spell VFX usage

local Spells = require("spells").spells
local Keywords = require("keywords")
local Constants = require("core.Constants")
local SpellCompiler = require("spellCompiler")

-- Function to determine the correct VFX type for a spell based on its properties
local function determineCorrectVfx(spell)
    -- If the spell already uses vfx keyword, assume it's correct
    if spell.keywords and spell.keywords.vfx then
        local effect = spell.keywords.vfx.effect
        -- Handle both string and Constants.VFXType references
        if type(effect) == "string" then
            return effect
        else
            return tostring(effect) -- Convert constant to string
        end
    end
    
    -- If the spell has a top-level vfx property, use that
    if spell.vfx then
        return spell.vfx
    end
    
    -- Check for keywords with built-in VFX
    if spell.keywords then
        -- Check ground keyword
        if spell.keywords.ground then
            local groundVfx = spell.keywords.ground.vfx
            if groundVfx then
                return groundVfx
            else
                return "tidal_force_ground" -- Default for ground
            end
        end
        
        -- Check elevate keyword
        if spell.keywords.elevate then
            local elevateVfx = spell.keywords.elevate.vfx
            if elevateVfx then
                return elevateVfx
            else
                return "emberlift" -- Default for elevate
            end
        end
    end
    
    -- Otherwise, determine based on spell type and element
    local spellElement = spell.affinity
    local attackType = spell.attackType
    
    -- Mapping of element + attack type to suggested VFX
    local elementAttackMap = {
        -- Fire element
        fire = {
            projectile = "firebolt",
            remote = "firebolt",
            zone = "meteor",
            utility = "conjurefire"
        },
        -- Moon element
        moon = {
            projectile = "lunardisjunction",
            remote = "fullmoonbeam",
            zone = "mistveil",
            utility = "conjuremoonlight"
        },
        -- Sun element
        sun = {
            projectile = "firebolt",
            remote = "meteor",
            zone = "blazing_ascent",
            utility = "nova_conjure"
        },
        -- Water element
        water = {
            projectile = "tidal_force",
            remote = "tidal_force",
            zone = "tidal_force_ground",
            utility = "mistveil"
        },
        -- Generic fallbacks
        generic = {
            projectile = "firebolt",
            remote = "impact",
            zone = "impact",
            utility = "impact"
        }
    }
    
    -- Get the element-specific map or fall back to generic
    local elementMap = elementAttackMap[spellElement] or elementAttackMap.generic
    
    -- Get the attack-specific VFX or fall back to impact
    return elementMap[attackType] or "impact"
end

-- Function to get the proper formatting for VFX values
local function formatVfxValue(value)
    if not value then return "N/A" end
    
    -- Check if it's a Constants.VFXType value
    for typeName, typeValue in pairs(Constants.VFXType) do
        if typeValue == value then
            return string.format("Constants.VFXType.%s", typeName)
        end
    end
    
    -- If it's just a string, return it with quotes
    return string.format('"%s"', value)
end

-- Function to check if a spell has events in the test
local function hasEffectEvents(spell)
    -- Skip if no spell
    if not spell then return false end
    
    -- Dummy objects for testing
    local dummyCaster = {
        name = "Test Caster",
        elevation = Constants.ElevationState.GROUNDED,
        gameState = { rangeState = Constants.RangeState.NEAR },
        spellSlots = { {}, {}, {} },
        manaPool = { tokens = {} }
    }
    
    local dummyTarget = {
        name = "Test Target",
        elevation = Constants.ElevationState.GROUNDED,
        gameState = { rangeState = Constants.RangeState.NEAR },
        spellSlots = { {}, {}, {} },
        manaPool = { tokens = {} }
    }
    
    -- Compile the spell
    local compiledSpell = SpellCompiler.compileSpell(spell, Keywords)
    if not compiledSpell then return false end
    
    -- Generate events but don't execute them
    local events = compiledSpell.generateEvents(dummyCaster, dummyTarget, 1)
    
    -- Check for EFFECT events
    for _, event in ipairs(events or {}) do
        if event.type == "EFFECT" then
            return true
        end
    end
    
    return false
end

-- Main function to generate the report
local function generateReport()
    print("Generating VFX report...")
    
    -- Table headers for markdown
    local report = "# Spells VFX Audit Report\n\n"
    report = report .. "This report shows the current VFX setup for each spell and recommendations for improvement.\n\n"
    report = report .. "| Spell Name | Element | Attack Type | Current VFX | Using VFX Keyword | Generates EFFECT Events | Recommended VFX | Status |\n"
    report = report .. "|------------|---------|-------------|-------------|-------------------|------------------------|-----------------|--------|\n"
    
    -- Process all spells and add to report
    local stats = {
        total = 0,
        correct = 0,
        needsKeyword = 0,
        noVfx = 0
    }
    
    -- Sort spells by name
    local sortedSpells = {}
    for _, spell in pairs(Spells) do
        table.insert(sortedSpells, spell)
    end
    
    table.sort(sortedSpells, function(a, b) return a.name < b.name end)
    
    -- Process sorted spells
    for _, spell in ipairs(sortedSpells) do
        stats.total = stats.total + 1
        
        local currentVfx = spell.vfx or "None"
        local usesVfxKeyword = (spell.keywords and spell.keywords.vfx) and "Yes" or "No"
        local hasEvents = hasEffectEvents(spell) and "Yes" or "No"
        local recommendedVfx = determineCorrectVfx(spell)
        
        -- Determine status
        local status
        if hasEvents == "Yes" then
            status = "✅ Correct"
            stats.correct = stats.correct + 1
        elseif usesVfxKeyword == "No" and currentVfx ~= "None" then
            status = "⚠️ Needs VFX Keyword"
            stats.needsKeyword = stats.needsKeyword + 1
        elseif currentVfx == "None" and spell.attackType ~= "utility" then
            status = "❌ Missing VFX"
            stats.noVfx = stats.noVfx + 1
        else
            status = "⚠️ Review"
            stats.needsKeyword = stats.needsKeyword + 1
        end
        
        -- Add row to report
        report = report .. string.format("| %s | %s | %s | %s | %s | %s | %s | %s |\n",
            spell.name,
            spell.affinity or "N/A",
            spell.attackType or "N/A",
            currentVfx,
            usesVfxKeyword,
            hasEvents,
            recommendedVfx,
            status
        )
    end
    
    -- Add statistics section
    report = report .. "\n## Summary Statistics\n\n"
    report = report .. string.format("- **Total Spells:** %d\n", stats.total)
    report = report .. string.format("- **Correctly Implemented:** %d (%.1f%%)\n", 
        stats.correct, (stats.correct / stats.total) * 100)
    report = report .. string.format("- **Needs VFX Keyword:** %d (%.1f%%)\n", 
        stats.needsKeyword, (stats.needsKeyword / stats.total) * 100)
    report = report .. string.format("- **Missing VFX:** %d (%.1f%%)\n", 
        stats.noVfx, (stats.noVfx / stats.total) * 100)
    
    -- Implementation recommendations
    report = report .. "\n## Implementation Recommendations\n\n"
    report = report .. "1. **Replace top-level VFX properties with VFX keywords:**\n"
    report = report .. "   ```lua\n"
    report = report .. "   -- Before:\n"
    report = report .. "   vfx = \"firebolt\",\n\n"
    report = report .. "   -- After:\n"
    report = report .. "   keywords = {\n"
    report = report .. "       -- other keywords...\n"
    report = report .. "       vfx = { effect = Constants.VFXType.FIREBOLT, target = Constants.TargetType.ENEMY }\n"
    report = report .. "   },\n"
    report = report .. "   ```\n\n"
    
    report = report .. "2. **Add VFX keywords to spells missing visual effects:**\n"
    report = report .. "   - Use Constants.VFXType for standard effect names\n"
    report = report .. "   - Match the effect type to the spell's element and attack pattern\n"
    report = report .. "   - Consider spell's role when selecting the visual effect\n\n"
    
    report = report .. "3. **Run the automated fix tool:**\n"
    report = report .. "   ```bash\n"
    report = report .. "   lua tools/fix_vfx_events.lua\n"
    report = report .. "   ```\n\n"
    
    report = report .. "4. **Test with the VFX events test:**\n"
    report = report .. "   ```bash\n"
    report = report .. "   lua tools/test_vfx_events.lua\n"
    report = report .. "   ```\n"
    
    print("Report generated successfully!")
    return report
end

-- Generate the report
local report = generateReport()

-- Write report to file
local reportPath = "/Users/russell/Manastorm/docs/VFX_Audit_Report.md"
local file = io.open(reportPath, "w")
if file then
    file:write(report)
    file:close()
    print("Report written to: " .. reportPath)
else
    print("Error: Could not write report to file")
end

-- Return success
return true```

## ./tools/test_particle_manager.lua
```lua
-- test_particle_manager.lua
-- A script to test ParticleManager integration with vfx.lua

local Pool = require("core.Pool")
local ParticleManager = require("vfx.ParticleManager")
local VFX = require("vfx")

-- Initialize the VFX system
VFX.init()

-- Count the total particles created and returned to pool
local function testParticlePooling()
    print("\n=== TESTING PARTICLE POOLING ===")
    
    -- Get initial stats
    local initialStats = ParticleManager.getStats()
    print(string.format("Initial pool: %d total (%d active, %d available)", 
        initialStats.poolSize, initialStats.active, initialStats.available))
    
    -- Create effects with different types
    local effects = {}
    
    print("\nCreating test effects...")
    
    -- Test a projectile effect
    local projectile = VFX.createEffect("proj_base", 100, 100, 500, 300, {
        color = {1, 0, 0, 1}, -- Red
    })
    table.insert(effects, projectile)
    print("Created projectile effect with " .. #projectile.particles .. " particles")
    
    -- Test an impact effect
    local impact = VFX.createEffect("impact_base", 300, 300, 300, 300, {
        color = {0, 1, 0, 1}, -- Green
    })
    table.insert(effects, impact)
    print("Created impact effect with " .. #impact.particles .. " particles")
    
    -- Test a cone effect
    local cone = VFX.createEffect("blast_base", 200, 400, 500, 200, {
        color = {0, 0, 1, 1}, -- Blue
    })
    table.insert(effects, cone)
    print("Created cone effect with " .. #cone.particles .. " particles")
    
    -- Test a beam effect
    local beam = VFX.createEffect("beam_base", 100, 400, 600, 400, {
        color = {1, 1, 0, 1}, -- Yellow
    })
    table.insert(effects, beam)
    print("Created beam effect with " .. #beam.particles .. " particles")
    
    -- Test an aura effect
    local aura = VFX.createEffect("zone_base", 400, 300, 400, 300, {
        color = {1, 0, 1, 1}, -- Purple
    })
    table.insert(effects, aura)
    print("Created aura effect with " .. #aura.particles .. " particles")
    
    -- Test a remote effect
    local remote = VFX.createEffect("remote_base", 300, 100, 300, 100, {
        color = {0, 1, 1, 1}, -- Cyan
    })
    table.insert(effects, remote)
    print("Created remote effect with " .. #remote.particles .. " particles")
    
    -- Test a surge effect
    local surge = VFX.createEffect("surge_base", 500, 500, 500, 500, {
        color = {1, 0.5, 0, 1}, -- Orange
    })
    table.insert(effects, surge)
    print("Created surge effect with " .. #surge.particles .. " particles")
    
    -- Test a conjure effect
    local conjure = VFX.createEffect("conjure_base", 200, 500, 200, 500, {
        color = {0.5, 0.5, 1, 1}, -- Light blue
    })
    table.insert(effects, conjure)
    print("Created conjure effect with " .. #conjure.particles .. " particles")
    
    -- Get stats after creating effects
    local afterCreateStats = ParticleManager.getStats()
    print(string.format("\nAfter creating effects: %d total (%d active, %d available)", 
        afterCreateStats.poolSize, afterCreateStats.active, afterCreateStats.available))
    
    -- Count total particles created
    local totalParticles = 0
    for _, effect in ipairs(effects) do
        totalParticles = totalParticles + #effect.particles
    end
    print("Total particles created: " .. totalParticles)
    
    -- Release all effects and their particles
    print("\nReleasing all effects and particles...")
    for i, effect in ipairs(effects) do
        print("Releasing effect " .. i .. " with " .. #effect.particles .. " particles")
        -- First release all particles
        for _, particle in ipairs(effect.particles) do
            ParticleManager.releaseParticle(particle)
        end
        -- Then release the effect
        Pool.release("vfx_effect", effect)
    end
    
    -- Get final stats
    local finalStats = ParticleManager.getStats()
    print(string.format("\nFinal pool: %d total (%d active, %d available)", 
        finalStats.poolSize, finalStats.active, finalStats.available))
    
    -- Verify all particles were returned to the pool
    if finalStats.active == 0 and finalStats.available == finalStats.poolSize then
        print("\n✓ SUCCESS: All particles were returned to the pool!")
    else
        print("\n✗ FAILURE: Not all particles were returned to the pool.")
        print("  Expected active=0, got " .. finalStats.active)
        print("  Expected available=" .. finalStats.poolSize .. ", got " .. finalStats.available)
    end
end

-- Run the test
testParticlePooling()

return {
    testParticlePooling = testParticlePooling
}```

## ./tools/test_vfx_events.lua
```lua
-- test_vfx_events.lua
-- Test script to verify all spells generate VFX events correctly

local SpellCompiler = require("spellCompiler")
local Spells = require("spells").spells
local Keywords = require("keywords")
local Constants = require("core.Constants")

-- Create dummy caster/target/slot objects for testing
local dummyCaster = {
    name = "Test Caster",
    elevation = Constants.ElevationState.GROUNDED,
    gameState = {
        rangeState = Constants.RangeState.NEAR
    },
    spellSlots = {
        { active = false },
        { active = false },
        { active = false }
    },
    manaPool = {
        tokens = {}
    }
}

local dummyTarget = {
    name = "Test Target",
    elevation = Constants.ElevationState.GROUNDED,
    gameState = {
        rangeState = Constants.RangeState.NEAR
    },
    spellSlots = {
        { active = false },
        { active = false },
        { active = false }
    },
    manaPool = {
        tokens = {}
    }
}

local dummySlot = 1

-- Main test function
local function runTest()
    print("=== VFX Events Test ===")
    print("Testing all spells for EFFECT events...")
    
    local results = {
        total = 0,
        passed = 0,
        failed = 0,
        skipped = 0,
        utilityNoVfx = 0
    }
    
    local failures = {}
    
    -- Process all spells
    for spellId, spell in pairs(Spells) do
        results.total = results.total + 1
        
        -- Skip certain spells known to have no visuals
        if spell.skipVfxTest then
            results.skipped = results.skipped + 1
            print(string.format("[SKIP] %s (marked to skip VFX test)", spell.name))
            goto continue
        end
        
        -- Compile the spell
        local compiledSpell = SpellCompiler.compileSpell(spell, Keywords)
        if not compiledSpell then
            table.insert(failures, string.format("Failed to compile spell: %s", spell.name))
            results.failed = results.failed + 1
            goto continue
        end
        
        -- Generate events but don't execute them
        local events = compiledSpell.generateEvents(dummyCaster, dummyTarget, dummySlot)
        
        -- Check for at least one EFFECT event
        local hasEffectEvent = false
        if events then
            for _, event in ipairs(events) do
                if event.type == "EFFECT" then
                    hasEffectEvent = true
                    break
                end
            end
        end
        
        -- Handle utility spells without VFX specially 
        if not hasEffectEvent and spell.attackType == Constants.AttackType.UTILITY and not spell.vfx then
            print(string.format("[INFO] Utility spell with no VFX: %s", spell.name))
            results.utilityNoVfx = results.utilityNoVfx + 1
            goto continue
        end
        
        -- Check if the spell has a VFX defined at the top level
        local hasTopLevelVfx = (spell.vfx ~= nil)
        
        -- Check if the spell has keywords that should generate VFX
        local hasVfxKeyword = false
        if spell.keywords and spell.keywords.vfx then
            hasVfxKeyword = true
        end
        
        -- Check for keywords that have built-in VFX
        local hasBuiltInVfx = false
        if spell.keywords then
            for keyword, _ in pairs(spell.keywords) do
                if keyword == "ground" or keyword == "elevate" then
                    hasBuiltInVfx = true
                    break
                end
            end
        end
        
        -- Test result
        if hasEffectEvent then
            print(string.format("[PASS] %s generates EFFECT events", spell.name))
            results.passed = results.passed + 1
        else
            -- Log what's missing
            local missing = ""
            if not hasTopLevelVfx and not hasVfxKeyword and not hasBuiltInVfx then
                missing = "both top-level VFX and VFX keyword"
            elseif not hasVfxKeyword then
                missing = "VFX keyword (has top-level VFX)"
            else
                missing = "proper event generation"
            end
            
            table.insert(failures, string.format("%s: Missing %s", spell.name, missing))
            results.failed = results.failed + 1
        end
        
        ::continue::
    end
    
    -- Print test results
    print("\n=== Test Results ===")
    print(string.format("Total spells tested: %d", results.total))
    print(string.format("Passed: %d (%.1f%%)", results.passed, (results.passed / results.total) * 100))
    print(string.format("Failed: %d (%.1f%%)", results.failed, (results.failed / results.total) * 100))
    print(string.format("Skipped: %d", results.skipped))
    print(string.format("Utility spells without VFX: %d", results.utilityNoVfx))
    
    -- Print failures if any
    if #failures > 0 then
        print("\n=== Failed Spells ===")
        for _, failure in ipairs(failures) do
            print(failure)
        end
    end
    
    return results.failed == 0
end

-- Run the test
local success = runTest()
print(string.format("\nTest %s!", success and "PASSED" and "FAILED"))

-- Return success status (for automated testing)
return success```

## ./ui.lua
```lua
-- UI helper module

-- Load core modules
local Constants = require("core.Constants")

local UI = {}

-- Spellbook visibility state
UI.spellbookVisible = {
    player1 = false,
    player2 = false
}

-- Delayed health damage display state
UI.healthDisplay = {
    player1 = {
        currentHealth = 100,        -- Current display health (smoothly animated)
        targetHealth = 100,         -- Actual health to animate towards
        pendingDamage = 0,          -- Damage that's pending animation (yellow bar)
        lastDamageTime = 0,         -- Time when last damage was taken
        pendingDrainDelay = 0.5,    -- Delay before yellow bar starts draining
        drainRate = 30              -- How fast the yellow bar drains (health points per second)
    },
    player2 = {
        currentHealth = 100,
        targetHealth = 100,
        pendingDamage = 0,
        lastDamageTime = 0,
        pendingDrainDelay = 0.5,
        drainRate = 30
    }
}

function UI.drawHelpText(font)
    -- Set font and color
    love.graphics.setFont(font)
    
    -- Draw a semi-transparent background for the debug panel
    love.graphics.setColor(0.1, 0.1, 0.2, 0.7)
    local panelWidth = 600
    local y = _G.game.baseHeight - 130 -- Use _G.game.baseHeight directly
    love.graphics.rectangle("fill", 5, y + 30, panelWidth, 95, 5, 5)
    
    -- Draw a border
    love.graphics.setColor(0.3, 0.3, 0.5, 0.8)
    love.graphics.rectangle("line", 5, y + 30, panelWidth, 95, 5, 5)
    
    -- Draw header
    love.graphics.setColor(1, 1, 0.7, 0.9)
    love.graphics.print("DEBUG MODE", 15, y + 35)
    
    -- Show debug controls with brighter text
    love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
    love.graphics.print("Debug Controls: T (Add tokens), R (Toggle range), A/S (Toggle elevations), ESC (Quit)", 15, y + 55)
    love.graphics.print("VFX Test Keys: 1 (Firebolt), 2 (Meteor), 3 (Mist Veil), 4 (Emberlift), 5 (Full Moon Beam)", 15, y + 75)
    love.graphics.print("Conjure Test Keys: 6 (Fire), 7 (Moonlight), 8 (Volatile)", 15, y + 95)
    
    -- No longer calling UI.drawSpellbookButtons() here as it's now handled in the main loop
end

-- Toggle spellbook visibility for a player
-- Each player can now independently toggle their spellbook without affecting the other
function UI.toggleSpellbook(player)
    if player == 1 then
        UI.spellbookVisible.player1 = not UI.spellbookVisible.player1
    elseif player == 2 then
        UI.spellbookVisible.player2 = not UI.spellbookVisible.player2
    end
end

-- Draw skeuomorphic spellbook components for both players
function UI.drawSpellbookButtons()
    local screenWidth = _G.game.baseWidth -- Use _G.game.baseWidth directly
    local screenHeight = _G.game.baseHeight -- Use _G.game.baseHeight directly
    
    -- Draw Player 1's spellbook (Ashgar - pinned to left side)
    UI.drawPlayerSpellbook(1, 0, screenHeight - 70)
    
    -- Draw Player 2's spellbook (Selene - pinned to right side)
    UI.drawPlayerSpellbook(2, screenWidth - 250, screenHeight - 70)
end

-- Draw an individual player's spellbook component
function UI.drawPlayerSpellbook(playerNum, x, y)
    local width = 250  -- Balanced width
    local height = 50
    local player = (playerNum == 1) and "Ashgar" or "Selene"
    local keyLabel = (playerNum == 1) and "B" or "M"
    local keyPrefix = (playerNum == 1) and {"Q", "W", "E"} or {"I", "O", "P"}
    local wizard = _G.game.wizards[playerNum]
    local color = {wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255}
    
    -- Draw book background with slight gradient
    love.graphics.setColor(0.2, 0.2, 0.3, 0.9)
    love.graphics.rectangle("fill", x, y, width, height)
    love.graphics.setColor(0.25, 0.25, 0.35, 0.9)
    love.graphics.rectangle("fill", x, y, width, height/2)
    
    -- Draw book binding/spine effect
    love.graphics.setColor(color[1], color[2], color[3], 0.9)
    love.graphics.rectangle("fill", x, y, 6, height)
    
    -- Draw book edge
    love.graphics.setColor(0.8, 0.8, 0.8, 0.3)
    love.graphics.rectangle("line", x, y, width, height)
    
    -- Draw dividers between sections
    love.graphics.setColor(0.4, 0.4, 0.5, 0.4)
    love.graphics.line(x + 120, y + 5, x + 120, y + height - 5)
    
    -- Center everything vertically in pane
    local centerY = y + height/2
    local runeSize = 14
    local groupSpacing = 35  -- Original spacing between keys
    
    -- GROUP 1: SPELL INPUT KEYS
    -- Add a subtle background for the key group
    love.graphics.setColor(0.2, 0.2, 0.3, 0.3)
    love.graphics.rectangle("fill", x + 15, centerY - 20, 95, 40, 5, 5)  -- Maintain original padding for keys
    
    -- Calculate positions for centered spell input keys
    local inputStartX = x + 30  -- Original position for better centering
    local inputY = centerY
    
    for i = 1, 3 do
        -- Draw rune background
        love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
        love.graphics.circle("fill", inputStartX + (i-1)*groupSpacing, inputY, runeSize)
        
        if wizard.activeKeys[i] then
            -- Active rune with glow effect
            -- Multiple layers for glow
            for j = 3, 1, -1 do
                local alpha = 0.3 * (4-j) / 3
                local size = runeSize + j * 2
                love.graphics.setColor(1, 1, 0.3, alpha)
                love.graphics.circle("fill", inputStartX + (i-1)*groupSpacing, inputY, size)
            end
            
            -- Bright center
            love.graphics.setColor(1, 1, 0.7, 0.9)
            love.graphics.circle("fill", inputStartX + (i-1)*groupSpacing, inputY, runeSize * 0.7)
            
            -- Properly centered rune symbol
            local keyText = keyPrefix[i]
            local keyTextWidth = love.graphics.getFont():getWidth(keyText)
            local keyTextHeight = love.graphics.getFont():getHeight()
            love.graphics.setColor(0.2, 0.2, 0.3, 0.9)
            love.graphics.print(keyText, 
                inputStartX + (i-1)*groupSpacing - keyTextWidth/2, 
                inputY - keyTextHeight/2)
        else
            -- Inactive rune
            love.graphics.setColor(0.5, 0.5, 0.6, 0.6)
            love.graphics.circle("line", inputStartX + (i-1)*groupSpacing, inputY, runeSize)
            
            -- Properly centered inactive symbol
            local keyText = keyPrefix[i]
            local keyTextWidth = love.graphics.getFont():getWidth(keyText)
            local keyTextHeight = love.graphics.getFont():getHeight()
            love.graphics.setColor(0.6, 0.6, 0.7, 0.6)
            love.graphics.print(keyText, 
                inputStartX + (i-1)*groupSpacing - keyTextWidth/2, 
                inputY - keyTextHeight/2)
        end
    end
    
    -- Removed "Input Keys" label for cleaner UI
    
    -- GROUP 2: CAST BUTTON & FREE BUTTON
    -- Create a shared container/background for both action buttons - more compact
    local actionSectionWidth = 90
    local actionX = x + 125
    
    -- Draw a shared background container for both action buttons
    love.graphics.setColor(0.18, 0.18, 0.25, 0.5)
    love.graphics.rectangle("fill", actionX, centerY - 18, actionSectionWidth, 36, 5, 5)  -- More compact
    
    -- Calculate positions for both buttons with tighter spacing
    local castX = actionX + actionSectionWidth/3 - 5
    local freeX = actionX + actionSectionWidth*2/3 + 5
    local castKey = (playerNum == 1) and "F" or "J"
    local freeKey = (playerNum == 1) and "G" or "H"
    
    -- CAST BUTTON
    -- Subtle highlighting background
    love.graphics.setColor(0.3, 0.2, 0.1, 0.3)
    love.graphics.rectangle("fill", castX - 17, centerY - 16, 34, 32, 5, 5)  -- More compact
    
    -- Draw cast button background
    love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
    love.graphics.circle("fill", castX, inputY, runeSize)
    
    -- Cast button border
    love.graphics.setColor(0.8, 0.4, 0.1, 0.8)  -- Orange-ish for cast button
    love.graphics.circle("line", castX, inputY, runeSize)
    
    -- Cast button symbol
    local castTextWidth = love.graphics.getFont():getWidth(castKey)
    local castTextHeight = love.graphics.getFont():getHeight()
    love.graphics.setColor(1, 0.8, 0.3, 0.9)
    love.graphics.print(castKey, 
        castX - castTextWidth/2, 
        inputY - castTextHeight/2)
    
    -- Removed "Cast" label for cleaner UI
    
    -- FREE BUTTON
    -- Subtle highlighting background
    love.graphics.setColor(0.1, 0.3, 0.3, 0.3)
    love.graphics.rectangle("fill", freeX - 17, centerY - 16, 34, 32, 5, 5)  -- More compact
    
    -- Draw free button background
    love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
    love.graphics.circle("fill", freeX, inputY, runeSize)
    
    -- Free button border
    love.graphics.setColor(0.2, 0.6, 0.8, 0.8)  -- Blue-ish for free button
    love.graphics.circle("line", freeX, inputY, runeSize)
    
    -- Free button symbol
    local freeTextWidth = love.graphics.getFont():getWidth(freeKey)
    local freeTextHeight = love.graphics.getFont():getHeight()
    love.graphics.setColor(0.5, 0.8, 1.0, 0.9)
    love.graphics.print(freeKey, 
        freeX - freeTextWidth/2, 
        inputY - freeTextHeight/2)
    
    -- Removed "Free" label for cleaner UI
    
    -- GROUP 3: KEYED SPELL POPUP (appears above the spellbook when a spell is keyed)
    if wizard.currentKeyedSpell then
        -- Make the popup exactly match the width of the spellbook
        local popupWidth = width
        local popupHeight = 30
        local popupX = x  -- Align with spellbook
        local popupY = y - popupHeight - 10  -- Position above the spellbook with slightly larger gap
        
        -- Get spell name and calculate its width for centering
        local spellName = wizard.currentKeyedSpell.name
        local spellNameWidth = love.graphics.getFont():getWidth(spellName)
        
        -- Draw popup background with a slight "connected" look
        -- Use the same color as the spellbook for visual cohesion
        love.graphics.setColor(0.2, 0.2, 0.3, 0.9)
        
        -- Main popup body (rounded rectangle)
        love.graphics.rectangle("fill", popupX, popupY, popupWidth, popupHeight, 5, 5)
        
        -- Connection piece (small triangle pointing down)
        love.graphics.polygon("fill", 
            x + width/2 - 8, popupY + popupHeight,  -- Left point
            x + width/2 + 8, popupY + popupHeight,  -- Right point
            x + width/2, popupY + popupHeight + 8   -- Bottom point
        )
        
        -- Add a subtle border with the wizard's color
        love.graphics.setColor(color[1], color[2], color[3], 0.5)
        love.graphics.rectangle("line", popupX, popupY, popupWidth, popupHeight, 5, 5)
        
        -- Subtle gradient for the background (matches the spellbook aesthetic)
        love.graphics.setColor(0.25, 0.25, 0.35, 0.7)
        love.graphics.rectangle("fill", popupX, popupY, popupWidth, popupHeight/2, 5, 5)
        
        -- Simple glow effect for the text
        for i = 3, 1, -1 do
            local alpha = 0.1 * (4-i) / 3
            local size = i * 2
            love.graphics.setColor(1, 1, 0.5, alpha)
            love.graphics.rectangle("fill", 
                x + width/2 - spellNameWidth/2 - size, 
                popupY + popupHeight/2 - 7 - size/2, 
                spellNameWidth + size*2, 
                14 + size,
                5, 5
            )
        end
        
        -- Spell name centered in the popup
        love.graphics.setColor(1, 1, 0.5, 0.9)
        love.graphics.print(spellName, 
            x + width/2 - spellNameWidth/2, 
            popupY + popupHeight/2 - 7
        )
    end
    
    -- GROUP 4: SPELLBOOK HELP (bottom-right corner) - more compact design
    local helpX = x + width - 15
    local helpY = y + height - 10
    
    -- Draw key hint - make it slightly bigger
    local helpSize = 8  -- Increased size
    love.graphics.setColor(0.4, 0.4, 0.6, 0.5)
    love.graphics.circle("fill", helpX, helpY, helpSize)
    
    -- Properly centered key symbol - BIGGER
    local smallFont = love.graphics.getFont()
    local keyTextWidth = smallFont:getWidth(keyLabel)
    local keyTextHeight = smallFont:getHeight()
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(keyLabel, 
        helpX - keyTextWidth/3, 
        helpY - keyTextHeight/3,
        0, 0.7, 0.7)  -- Significantly larger
    
    -- LARGER "?" indicator placed HIGHER above the button
    love.graphics.setColor(0.7, 0.7, 0.8, 0.8)  -- Brighter
    local helpLabel = "?"
    local helpLabelWidth = smallFont:getWidth(helpLabel)
    -- Position the ? significantly higher up
    love.graphics.print(helpLabel, 
        helpX - helpLabelWidth/3, 
        helpY - helpSize - smallFont:getHeight() - 2,  -- Position much higher above the button
        0, 0.7, 0.7)  -- Make it larger
    
    -- Highlight when active - just color tint, no white outline
    if (playerNum == 1 and UI.spellbookVisible.player1) or 
       (playerNum == 2 and UI.spellbookVisible.player2) then
        love.graphics.setColor(color[1], color[2], color[3], 0.4)
        love.graphics.rectangle("fill", x, y, width, height)
        -- Removed white outline rectangle
    end
end

function UI.drawSpellInfo(wizards)
    -- Function to format mana cost for display
    local function formatCost(cost)
        if not cost or #cost == 0 then
            return "Free"
        end
        
        -- Handle both old and new cost formats
        local regularTokens = {}
        local anyTokens = {}
        
        -- Check if this is the new array-style format (simple array of strings)
        local isNewFormat = type(cost[1]) == "string"
        
        if isNewFormat then
            -- Collect each token individually, separating ANY tokens
            for _, tokenType in ipairs(cost) do
                if tokenType:lower() == Constants.TokenType.ANY then
                    table.insert(anyTokens, tokenType)
                else
                    table.insert(regularTokens, tokenType)
                end
            end
        else
            -- Old format with type and count properties
            for _, component in ipairs(cost) do
                local typeText = component.type
                local isAnyToken = false
                
                if type(typeText) == "table" then
                    typeText = table.concat(typeText, "/")
                end
                
                if typeText:lower() == Constants.TokenType.ANY then
                    isAnyToken = true
                end
                
                -- Add the token the appropriate number of times
                for i = 1, component.count do
                    if isAnyToken then
                        table.insert(anyTokens, typeText)
                    else
                        table.insert(regularTokens, typeText)
                    end
                end
            end
        end
        
        -- Combine regular tokens and any tokens (any tokens always last)
        local allTokens = {}
        for _, token in ipairs(regularTokens) do
            table.insert(allTokens, token)
        end
        for _, token in ipairs(anyTokens) do
            table.insert(allTokens, token)
        end
        
        -- Build the final cost text
        if #allTokens == 0 then
            return "Free"
        else
            return table.concat(allTokens, ", ")
        end
    end
    
    -- Draw the fighting game style health bars
    UI.drawHealthBars(wizards)
    
    -- Note: spellbook modals are now drawn separately to ensure proper z-ordering
    -- Spell notification is now handled by the wizard's castSpell function
end

-- Function to draw spellbook modals (now separated to ensure proper z-ordering)
function UI.drawSpellbookModals(wizards)
    -- Local function to format costs for spellbook display
    local function formatCost(cost)
        if not cost or type(cost) ~= "table" or #cost == 0 then
            return "Free"
        end
        
        -- Handle both old and new cost formats
        local regularTokens = {}
        local anyTokens = {}
        
        -- Check if this is the new array-style format (simple array of strings)
        local isNewFormat = type(cost[1]) == "string"
        
        if isNewFormat then
            -- Collect each token individually, separating ANY tokens
            for _, tokenType in ipairs(cost) do
                if tokenType:lower() == Constants.TokenType.ANY then
                    table.insert(anyTokens, tokenType)
                else
                    table.insert(regularTokens, tokenType)
                end
            end
        else
            -- Old format with type and count properties
            for _, component in ipairs(cost) do
                local typeText = component.type
                local isAnyToken = false
                
                if type(typeText) == "table" then
                    typeText = table.concat(typeText, "/")
                end
                
                if typeText:lower() == Constants.TokenType.ANY then
                    isAnyToken = true
                end
                
                -- Add the token the appropriate number of times
                for i = 1, component.count do
                    if isAnyToken then
                        table.insert(anyTokens, typeText)
                    else
                        table.insert(regularTokens, typeText)
                    end
                end
            end
        end
        
        -- Combine regular tokens and any tokens (any tokens always last)
        local allTokens = {}
        for _, token in ipairs(regularTokens) do
            table.insert(allTokens, token)
        end
        for _, token in ipairs(anyTokens) do
            table.insert(allTokens, token)
        end
        
        -- Build the final cost text
        if #allTokens == 0 then
            return "Free"
        else
            return table.concat(allTokens, ", ")
        end
    end
    
    -- Draw spellbook popups if visible
    if UI.spellbookVisible.player1 then
        UI.drawSpellbookModal(wizards[1], wizards[2], 1, formatCost)
    end

    if UI.spellbookVisible.player2 then
        UI.drawSpellbookModal(wizards[2], wizards[1], 2, formatCost)
    end
end

-- Draw dramatic fighting game style health bars
function UI.drawHealthBars(wizards)
    local screenWidth = _G.game.baseWidth -- Use _G.game.baseWidth directly
    local barHeight = 40
    local centerGap = 60 -- Space between bars in the center
    local barWidth = (screenWidth - centerGap) / 2
    local padding = 0 -- No padding from screen edges
    local y = 5
    
    -- Player 1 (Ashgar) health bar (left side, right-to-left depletion)
    local p1 = wizards[1]
    local display1 = UI.healthDisplay.player1
    
    -- Get the animated health percentage (from the delayed damage system)
    local p1HealthPercent = display1.currentHealth / 100
    local p1PendingDamagePercent = display1.pendingDamage / 100
    
    -- Background and border
    love.graphics.setColor(0.15, 0.15, 0.15, 0.8)
    love.graphics.rectangle("fill", padding, y, barWidth, barHeight)
    love.graphics.setColor(0.3, 0.3, 0.3, 0.8)
    love.graphics.rectangle("line", padding, y, barWidth, barHeight)
    
    -- Health fill with gradient
    local ashgarGradient = {
        {0.8, 0.2, 0.2},  -- Red base color
        {1.0, 0.3, 0.1}   -- Brighter highlight
    }
    
    -- Calculate the total visible health (current + pending)
    local totalVisibleHealth = p1HealthPercent
    
    -- Draw gradient health bar for current health (excluding pending damage part)
    for i = 0, barWidth * p1HealthPercent, 1 do
        local gradientPos = i / (barWidth * p1HealthPercent)
        local r = ashgarGradient[1][1] + (ashgarGradient[2][1] - ashgarGradient[1][1]) * gradientPos
        local g = ashgarGradient[1][2] + (ashgarGradient[2][2] - ashgarGradient[1][2]) * gradientPos
        local b = ashgarGradient[1][3] + (ashgarGradient[2][3] - ashgarGradient[1][3]) * gradientPos
        love.graphics.setColor(r, g, b, 0.9)
        love.graphics.line(padding + i, y + 2, padding + i, y + barHeight - 2)
    end
    
    -- Add a single halfway marker at 50% health, anchored to the bottom
    love.graphics.setColor(0.2, 0.2, 0.2, 0.5)
    local halfwayX = padding + (barWidth / 2)
    local markerHeight = barHeight / 2  -- The marker extends halfway up the bar
    love.graphics.line(halfwayX, y + barHeight - markerHeight, halfwayX, y + barHeight)
    
    -- Get actual health from the wizard for comparison
    local p1ActualHealthPercent = p1.health / 100
    
    -- Health lost "after damage" effect (fading darker region)
    -- This is displayed UNDER everything else, so draw it first
    local permanentDamageAmount = 1.0 - p1ActualHealthPercent
    if permanentDamageAmount > 0 then
        love.graphics.setColor(0.5, 0.1, 0.1, 0.3)
        love.graphics.rectangle("fill", 
            padding + barWidth * p1ActualHealthPercent, 
            y, 
            barWidth * permanentDamageAmount, 
            barHeight)
    end
    
    -- Pending damage effect (yellow bar segment)
    -- This shows the section of health that will drain away
    if p1PendingDamagePercent > 0 then
        -- Calculate where the pending damage begins and ends
        local pendingStart = p1HealthPercent  -- Where current health ends
        local pendingEnd = math.min(p1HealthPercent + p1PendingDamagePercent, p1ActualHealthPercent)
        local pendingWidth = pendingEnd - pendingStart
        
        -- Only draw if there's actual width to display
        if pendingWidth > 0 then
            -- Draw yellow segment for pending damage (as it's actually depleting)
            love.graphics.setColor(1.0, 0.9, 0.2, 0.8)
            
            -- Draw the pending section as yellow bars to match the health bar style
            for i = 0, barWidth * pendingWidth, 1 do
                local x = padding + barWidth * pendingStart + i
                love.graphics.line(x, y + 2, x, y + barHeight - 2)
            end
            
            -- Add some shading effects to the pending damage zone
            love.graphics.setColor(1.0, 1.0, 0.5, 0.2)
            love.graphics.rectangle("fill", 
                padding + barWidth * pendingStart, 
                y, 
                barWidth * pendingWidth, 
                barHeight/3)
        end
    end
    
    -- Gleaming highlight
    local time = love.timer.getTime()
    local hilight = math.abs(math.sin(time))
    love.graphics.setColor(1, 1, 1, 0.2 * hilight)
    love.graphics.rectangle("fill", padding, y, barWidth * p1HealthPercent, barHeight/3)
    
    -- Name printed directly on the health bar
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(p1.name, padding + 20, y + barHeight/2 - 8, 0, 1.2, 1.2)
    
    -- Health percentage only in debug mode
    if love.keyboard.isDown("`") then
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print(math.floor(p1HealthPercent * 100) .. "%", padding + barWidth - 40, y + 7)
    end
    
    
    -- Player 2 (Selene) health bar (right side, left-to-right depletion)
    local p2 = wizards[2]
    local display2 = UI.healthDisplay.player2
    
    -- Get the animated health percentage (from the delayed damage system)
    local p2HealthPercent = display2.currentHealth / 100
    local p2PendingDamagePercent = display2.pendingDamage / 100
    local p2X = screenWidth - barWidth
    
    -- Background and border
    love.graphics.setColor(0.15, 0.15, 0.15, 0.8)
    love.graphics.rectangle("fill", p2X, y, barWidth, barHeight)
    love.graphics.setColor(0.3, 0.3, 0.3, 0.8)
    love.graphics.rectangle("line", p2X, y, barWidth, barHeight)
    
    -- Health fill with gradient
    local seleneGradient = {
        {0.1, 0.3, 0.8},  -- Blue base color
        {0.2, 0.5, 1.0}   -- Brighter highlight
    }
    
    -- Calculate the total visible health
    local totalVisibleHealth = p2HealthPercent
    
    -- Draw gradient health bar (left-to-right depletion)
    for i = 0, barWidth * p2HealthPercent, 1 do
        local gradientPos = i / (barWidth * p2HealthPercent)
        local r = seleneGradient[1][1] + (seleneGradient[2][1] - seleneGradient[1][1]) * gradientPos
        local g = seleneGradient[1][2] + (seleneGradient[2][2] - seleneGradient[1][2]) * gradientPos
        local b = seleneGradient[1][3] + (seleneGradient[2][3] - seleneGradient[1][3]) * gradientPos
        love.graphics.setColor(r, g, b, 0.9)
        love.graphics.line(p2X + barWidth - i, y + 2, p2X + barWidth - i, y + barHeight - 2)
    end
    
    -- Add a single halfway marker at 50% health, anchored to the bottom
    love.graphics.setColor(0.2, 0.2, 0.2, 0.5)
    local halfwayX = p2X + (barWidth / 2)
    local markerHeight = barHeight / 2  -- The marker extends halfway up the bar
    love.graphics.line(halfwayX, y + barHeight - markerHeight, halfwayX, y + barHeight)
    
    -- Get actual health from the wizard for comparison
    local p2ActualHealthPercent = p2.health / 100
    
    -- Health lost "after damage" effect (fading darker region)
    -- This is displayed UNDER everything else, so draw it first
    local permanentDamageAmount = 1.0 - p2ActualHealthPercent
    if permanentDamageAmount > 0 then
        love.graphics.setColor(0.1, 0.1, 0.5, 0.3)
        love.graphics.rectangle("fill", p2X, y, barWidth * permanentDamageAmount, barHeight)
    end
    
    -- Pending damage effect (yellow bar segment)
    if p2PendingDamagePercent > 0 then
        -- Calculate where the pending damage begins and ends
        -- For player 2, the bar fills from right to left
        local pendingStart = 1.0 - p2HealthPercent  -- Where current health ends (from left)
        local pendingEnd = math.min(pendingStart + p2PendingDamagePercent, 1.0 - p2ActualHealthPercent)
        local pendingWidth = pendingEnd - pendingStart
        
        -- Only draw if there's actual width to display
        if pendingWidth > 0 then
            -- Draw yellow segment for pending damage (as it's actually depleting)
            love.graphics.setColor(1.0, 0.9, 0.2, 0.8)
            
            -- Draw the pending section as yellow bars to match the health bar style
            for i = 0, barWidth * pendingWidth, 1 do
                local x = p2X + barWidth * pendingStart + i
                love.graphics.line(x, y + 2, x, y + barHeight - 2)
            end
            
            -- Add some shading effects to the pending damage zone
            love.graphics.setColor(1.0, 1.0, 0.5, 0.2)
            love.graphics.rectangle("fill", 
                p2X + barWidth * pendingStart, 
                y, 
                barWidth * pendingWidth, 
                barHeight/3)
        end
    end
    
    -- Gleaming highlight
    love.graphics.setColor(1, 1, 1, 0.2 * hilight)
    love.graphics.rectangle("fill", p2X + barWidth * (1 - p2HealthPercent), y, barWidth * p2HealthPercent, barHeight/3)
    
    -- Name printed directly on the health bar
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(p2.name, p2X + barWidth - 80, y + barHeight/2 - 8, 0, 1.2, 1.2)
    
    -- Health percentage only in debug mode
    if love.keyboard.isDown("`") then
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print(math.floor(p2HealthPercent * 100) .. "%", p2X + 10, y + 7)
    end
end

-- Update the health display animation
function UI.updateHealthDisplays(dt, wizards)
    local currentTime = love.timer.getTime()
    
    for i, wizard in ipairs(wizards) do
        local display = UI.healthDisplay["player" .. i]
        local actualHealth = wizard.health
        
        -- If actual health is different from our target, register new damage
        if actualHealth < display.targetHealth then
            -- Calculate how much new damage was taken
            local newDamage = display.targetHealth - actualHealth
            
            -- Add to pending damage
            display.pendingDamage = display.pendingDamage + newDamage
            
            -- Update target health to match actual health
            display.targetHealth = actualHealth
            
            -- Reset the damage timer to restart the delay
            display.lastDamageTime = currentTime
        end
        
        -- Check if we should start draining the pending damage
        if display.pendingDamage > 0 and (currentTime - display.lastDamageTime) > display.pendingDrainDelay then
            -- Calculate how much to drain based on time passed
            local drainAmount = display.drainRate * dt
            
            -- Don't drain more than what's pending
            drainAmount = math.min(drainAmount, display.pendingDamage)
            
            -- Reduce pending damage and update current health
            display.pendingDamage = display.pendingDamage - drainAmount
            display.currentHealth = display.currentHealth - drainAmount
            
            -- Ensure we don't go below target health
            if display.currentHealth < display.targetHealth then
                display.currentHealth = display.targetHealth
                display.pendingDamage = 0
            end
            
            -- Debug output to help track the animation
            -- print(string.format("Player %d: Health %.1f, Pending %.1f, Target %.1f", 
            --     i, display.currentHealth, display.pendingDamage, display.targetHealth))
        end
    end
end

function UI.drawSpellbookModal(wizard, opponentWizard, playerNum, formatCost)
    local screenWidth = _G.game.baseWidth -- Use _G.game.baseWidth directly
    
    -- Determine position based on player number
    local modalX, keyPrefix
    if playerNum == 1 then
        modalX = 0  -- Pinned to left edge
        keyPrefix = {"Q", "W", "E", "QW", "QE", "WE", "QWE"}
    else
        modalX = screenWidth - 400  -- Pinned to right edge
        keyPrefix = {"I", "O", "P", "IO", "IP", "OP", "IOP"}
    end
    
    -- Define the key combinations and their corresponding keyNames
    local keyMappings = {
        {index = 1, keyName = "1"}, -- Q or I
        {index = 2, keyName = "2"}, -- W or O
        {index = 3, keyName = "3"}, -- E or P
        {index = 4, keyName = "12"}, -- QW or IO
        {index = 5, keyName = "13"}, -- QE or IP
        {index = 6, keyName = "23"}, -- WE or OP
        {index = 7, keyName = "123"} -- QWE or IOP
    }
    
    -- Count spells to calculate modal height dynamically
    local spellCount = 0
    for _, mapping in ipairs(keyMappings) do
        if wizard.spellbook[mapping.keyName] then
            spellCount = spellCount + 1
        end
    end
    
    -- Calculate modal height based on fixed components plus variable spell entries
    -- Components: title(30) + controls(120) + heading(25) + spellEntries(45 each) + no extra padding
    -- We end the component right after the last entry, letting the standard spacing between entries provide the visual margin
    local modalHeight = 175 + (spellCount * 45)
    
    -- Modal background - fully opaque to properly obscure what's behind it
    love.graphics.setColor(0.1, 0.1, 0.2, 1.0)  -- Fully opaque
    love.graphics.rectangle("fill", modalX, 50, 400, modalHeight)
    love.graphics.setColor(0.4, 0.4, 0.6, 1.0)  -- Fully opaque border
    love.graphics.rectangle("line", modalX, 50, 400, modalHeight)
    
    -- Modal title - simplified to just wizard name
    love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.9)
    love.graphics.rectangle("fill", modalX, 50, 400, 30)
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(wizard.name, modalX + 190, 60)
    
    -- Close button with appropriate hotkey instead of X
    local closeKey = (playerNum == 1) and "B" or "M"
    love.graphics.setColor(0.3, 0.3, 0.5, 0.8)
    love.graphics.rectangle("fill", modalX + 370, 50, 30, 30)
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(closeKey, modalX + 380, 60)
    
    -- Controls help section at the top of the modal
    love.graphics.setColor(0.2, 0.2, 0.4, 0.8)
    love.graphics.rectangle("fill", modalX + 10, 90, 380, 100)
    love.graphics.setColor(1, 1, 1, 0.9)
    
    if playerNum == 1 then
        love.graphics.print("Controls:", modalX + 20, 95)
        love.graphics.print("QWE: Key different spell inputs", modalX + 30, 115)
        love.graphics.print("F: Cast the currently keyed spell", modalX + 30, 135)
        love.graphics.print("G: Free all active spells and return mana", modalX + 30, 155)
        love.graphics.print("B: Toggle spellbook visibility", modalX + 30, 175)
    else
        love.graphics.print("Controls:", modalX + 20, 95)
        love.graphics.print("IOP: Key different spell inputs", modalX + 30, 115)
        love.graphics.print("J: Cast the currently keyed spell", modalX + 30, 135)
        love.graphics.print("H: Free all active spells and return mana", modalX + 30, 155)
        love.graphics.print("M: Toggle spellbook visibility", modalX + 30, 175)
    end
    
    -- Spells section
    local y = 200
    
    -- Spells heading
    love.graphics.setColor(1, 1, 0.7, 0.9)
    love.graphics.rectangle("fill", modalX + 10, y, 380, 25)
    love.graphics.setColor(0.2, 0.2, 0.4, 0.9)
    love.graphics.print("Spellbook", modalX + 170, y + 5)
    y = y + 30
    
    -- Track which spell entry is currently being hovered over (via keys)
    local activeSpellIndex = nil
    local keyCombo = ""
    
    -- Check which exact keys are being held down
    if playerNum == 1 then
        if love.keyboard.isDown("q") then keyCombo = keyCombo .. "1" end
        if love.keyboard.isDown("w") then keyCombo = keyCombo .. "2" end
        if love.keyboard.isDown("e") then keyCombo = keyCombo .. "3" end
    else
        if love.keyboard.isDown("i") then keyCombo = keyCombo .. "1" end
        if love.keyboard.isDown("o") then keyCombo = keyCombo .. "2" end
        if love.keyboard.isDown("p") then keyCombo = keyCombo .. "3" end
    end
    
    -- Store information about each spell entry for later use
    local spellEntries = {}
    
    -- Display all spells in a single unified list
    for i, mapping in ipairs(keyMappings) do
        local spell = wizard.spellbook[mapping.keyName]
        if spell then
            -- Check if this is the currently keyed spell
            local isCurrentSpell = wizard.currentKeyedSpell and wizard.currentKeyedSpell.name == spell.name
            
            -- Check if this exact key combo is being held
            local isExactMatch = (mapping.keyName == keyCombo)
            if isExactMatch then
                activeSpellIndex = i
            end
            
            -- Use a different background color to highlight the currently keyed spell
            if isCurrentSpell then
                -- Glowing highlight effect for the active spell
                -- Draw multiple layers with decreasing alpha for a glow effect
                for i = 3, 1, -1 do
                    local alpha = 0.15 * (4-i) / 3
                    local padding = i * 2
                    love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, alpha)
                    love.graphics.rectangle("fill", 
                        modalX + 10 - padding, 
                        y - padding, 
                        380 + padding*2, 
                        40 + padding*2, 
                        5, 5)
                end
                
                -- Brighter inner background for current spell
                love.graphics.setColor(0.25, 0.25, 0.35, 0.9)
            else
                -- Standard background for other spells
                love.graphics.setColor(0.2, 0.2, 0.3, 0.7)
            end
            
            -- Draw the spell entry background
            love.graphics.rectangle("fill", modalX + 10, y, 380, 40)
            
            -- Add a subtle border for the currently keyed spell
            if isCurrentSpell then
                love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.7)
                love.graphics.rectangle("line", modalX + 10, y, 380, 40)
            end
            
            -- Draw spell name with brighter color if it's the current spell
            if isCurrentSpell then
                love.graphics.setColor(1, 1, 0.8, 1.0)  -- Brighter color for active spell
            else
                love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.9)
            end
            love.graphics.print(keyPrefix[mapping.index] .. ": " .. spell.name, modalX + 20, y + 5)
            
            -- Draw spell details with appropriate color
            if isCurrentSpell then
                love.graphics.setColor(0.9, 0.9, 0.9, 1.0)  -- Brighter text for active spell
            else
                love.graphics.setColor(0.8, 0.8, 0.8, 0.8)
            end
            
            -- Convert cast time to "x" characters instead of numbers
            local castTimeVisual = string.rep("x", spell.castTime)

            -- Determine cost, evaluating getCost if present
            local costTable = spell.cost
            local isDynamic = false
            if spell.getCost and type(spell.getCost) == "function" then
                local ok, result = pcall(spell.getCost, wizard, opponentWizard)
                if ok and type(result) == "table" then
                    costTable = result
                    isDynamic = true
                else
                    print("ERROR evaluating getCost for " .. spell.name .. ": " .. tostring(result))
                end
            end

            local costText = formatCost(costTable)
            if isDynamic then
                costText = costText .. "*"
            end

            love.graphics.print("Cost: " .. costText .. "   Cast Time: " .. castTimeVisual, modalX + 30, y + 25)
            
            -- Store the spell entry information for later use (for description popup)
            table.insert(spellEntries, {
                spell = spell,
                y = y,
                isExactMatch = isExactMatch,
                isCurrentSpell = isCurrentSpell
            })
            
            y = y + 45  -- Restore original spacing between spell entries
        end
    end
    
    -- Draw description popup for the active spell (if any)
    if activeSpellIndex and spellEntries[activeSpellIndex] then
        local activeEntry = spellEntries[activeSpellIndex]
        local activeSpell = activeEntry.spell
        
        if activeSpell.description then
            -- Draw a popup box above the spell entry
            local popupWidth = 360
            local popupHeight = 50  -- Height for description text
            local popupX = modalX + 20  -- Align within the spellbook modal
            local popupY = activeEntry.y - popupHeight - 10  -- Position above the spell entry
            
            -- Draw popup background
            love.graphics.setColor(0.15, 0.15, 0.25, 0.95)  -- Darker background for contrast
            love.graphics.rectangle("fill", popupX, popupY, popupWidth, popupHeight, 5, 5)
            
            -- Add a subtle border with the wizard's color
            love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.7)
            love.graphics.rectangle("line", popupX, popupY, popupWidth, popupHeight, 5, 5)
            
            -- Add a connecting triangle in the same color
            love.graphics.polygon("fill", 
                popupX + popupWidth/2 - 8, popupY + popupHeight,  -- Left point
                popupX + popupWidth/2 + 8, popupY + popupHeight,  -- Right point
                popupX + popupWidth/2, popupY + popupHeight + 8   -- Bottom point
            )
            
            -- Draw the description text
            love.graphics.setColor(1, 1, 1, 0.9)
            love.graphics.printf(activeSpell.description, popupX + 10, popupY + 15, popupWidth - 20, "center")
        end
    end
end

return UI```

## ./vfx.lua
```lua
-- VFX.lua
-- Visual effects module for spell animations and combat effects

local VFX = {
    -- Tables to hold effect type updaters and drawers
    updaters = {},
    drawers = {}
}
VFX.__index = VFX

-- Import dependencies
local Pool = require("core.Pool")
local Constants = require("core.Constants")
local AssetCache = require("core.AssetCache")
local ParticleManager = require("vfx.ParticleManager")
local initializeParticlesModule = require("vfx.initializeParticles")

-- Table to store active effects
VFX.activeEffects = {}

-- Helper function to lazily load assets on demand
local function getAssetInternal(assetId)
    -- Check if asset path exists
    local path = VFX.assetPaths[assetId]
    if not path then 
        print("[VFX] Warning: No path defined for asset: " .. tostring(assetId))
        return nil 
    end
    
    -- Initialize assets table if it doesn't exist
    VFX.assets = VFX.assets or {}
    
    -- Check if already loaded (simple cache within VFX module)
    if VFX.assets[assetId] then 
        return VFX.assets[assetId] 
    end
    
    -- Special handling for runes array
    if assetId == "runes" then
        -- Check if runes are already loaded
        if VFX.assets.runes and #VFX.assets.runes > 0 then
            return VFX.assets.runes
        end
        
        -- Initialize runes array if needed
        VFX.assets.runes = VFX.assets.runes or {}
        
        -- If array exists but is empty, load runes
        if #VFX.assets.runes == 0 then
            for i, runePath in ipairs(path) do
                print("[VFX] Loading rune asset on demand: rune" .. i)
                local runeImg = AssetCache.getImage(runePath)
                if runeImg then
                    table.insert(VFX.assets.runes, runeImg)
                else
                    print("[VFX] Warning: Failed to load rune asset: " .. runePath)
                end
            end
        end
        
        -- Log if runes were loaded successfully
        if #VFX.assets.runes > 0 then
            print("[VFX] Successfully loaded " .. #VFX.assets.runes .. " rune assets")
        else 
            print("[VFX] Warning: No rune assets were loaded!")
        end
        
        return VFX.assets.runes
    end
    
    -- Load on demand using AssetCache
    print("[VFX] Lazily loading asset: " .. assetId)
    VFX.assets[assetId] = AssetCache.getImage(path)
    return VFX.assets[assetId]
end

-- Initialize the VFX system
function VFX.init()
    -- Store a reference to the global game object for use in effects
    VFX.gameState = _G.game -- Access the global game variable
    
    -- Define asset paths (but don't load them yet - lazy loading)
    VFX.assetPaths = {
        -- Fire effects
        fireParticle = "assets/sprites/fire-particle.png",
        fireGlow = "assets/sprites/fire-glow.png",
        
        -- Force effects
        forceWave = "assets/sprites/force-wave.png",
        
        -- Moon effects
        moonGlow = "assets/sprites/moon-glow.png",
        
        -- Generic effects
        sparkle = "assets/sprites/sparkle.png",
        impactRing = "assets/sprites/impact-ring.png",
        
        -- Bolt effects
        boltFrames = {
            "assets/sprites/bolt/bolt1.png",
            "assets/sprites/bolt/bolt2.png",
            "assets/sprites/bolt/bolt3.png"
        },
        
        -- Orb effects
        orbFrames = {
            "assets/sprites/orb/orb1.png",
            "assets/sprites/orb/orb2.png",
            "assets/sprites/orb/orb3.png",
            "assets/sprites/orb/orb4.png",
            "assets/sprites/orb/orb5.png"
        },
        
        -- Warp effects
        warpFrames = {
            "assets/sprites/warp/warp1.png",
            "assets/sprites/warp/warp2.png",
            "assets/sprites/warp/warp3.png"
        },

        -- Zap effects
        zapFrames = {
            "assets/sprites/zap/zap1.png",
            "assets/sprites/zap/zap2.png",
            "assets/sprites/zap/zap3.png"
        },

        -- Pixel primitive
        pixel = "assets/sprites/1px.png",

        -- Twinkle assets
        twinkle1 = "assets/sprites/3px-twinkle1.png",
        twinkle2 = "assets/sprites/3px-twinkle2.png",
        -- Rune assets for Ward shields (paths only)
        runes = {}
    }
    
    -- Define rune paths
    for i = 1, 9 do
        table.insert(VFX.assetPaths.runes, string.format("assets/sprites/runes/rune%d.png", i))
    end
    
    -- Initialize empty assets table (will be filled on demand)
    VFX.assets = {}
    
    -- Public function to get assets - expose the internal getAsset function
    VFX.getAsset = getAssetInternal
    
    -- Initialize particle pools
    Pool.create("vfx_particle", 100, function() return {} end, VFX.resetParticle)
    
    -- Preload critical assets immediately
    -- This ensures essential effects like ward shields work even on first use
    print("[VFX] Eagerly preloading critical assets...")
    
    -- Preload rune assets for ward shields
    VFX.assets.runes = {}
    for i, runePath in ipairs(VFX.assetPaths.runes) do
        print("[VFX] Preloading essential asset: rune" .. i)
        local runeImg = AssetCache.getImage(runePath)
        if runeImg then
            table.insert(VFX.assets.runes, runeImg)
        else
            print("[VFX] Warning: Failed to preload rune asset: " .. runePath)
        end
    end
    
    -- Preload sparkle asset (used in many effects)
    print("[VFX] Preloading essential asset: sparkle")
    VFX.assets.sparkle = AssetCache.getImage(VFX.assetPaths.sparkle)
    
    -- Preload bolt frames for the bolt effects
    print("[VFX] Preloading bolt frame assets")
    VFX.assets.boltFrames = {}
    for i, boltPath in ipairs(VFX.assetPaths.boltFrames) do
        print("[VFX] Preloading bolt frame " .. i)
        local boltImg = AssetCache.getImage(boltPath)
        if boltImg then
            table.insert(VFX.assets.boltFrames, boltImg)
        else
            print("[VFX] Warning: Failed to preload bolt frame asset: " .. boltPath)
        end
    end
    
    -- Preload orb frames for the orb effects
    print("[VFX] Preloading orb frame assets")
    VFX.assets.orbFrames = {}
    for i, orbPath in ipairs(VFX.assetPaths.orbFrames) do
        print("[VFX] Preloading orb frame " .. i)
        local orbImg = AssetCache.getImage(orbPath)
        if orbImg then
            table.insert(VFX.assets.orbFrames, orbImg)
        else
            print("[VFX] Warning: Failed to preload orb frame asset: " .. orbPath)
        end
    end
    
    -- Preload warp frames for the warp effects
    print("[VFX] Preloading warp frame assets")
    VFX.assets.warpFrames = {}
    for i, warpPath in ipairs(VFX.assetPaths.warpFrames) do
        print("[VFX] Preloading warp frame " .. i)
        local warpImg = AssetCache.getImage(warpPath)
        if warpImg then
            table.insert(VFX.assets.warpFrames, warpImg)
        else
            print("[VFX] Warning: Failed to preload warp frame asset: " .. warpPath)
        end
    end

    -- Preload zap frames for the zap effects
    print("[VFX] Preloading zap frame assets")
    VFX.assets.zapFrames = {}
    for i, zapPath in ipairs(VFX.assetPaths.zapFrames) do
        print("[VFX] Preloading zap frame " .. i)
        local zapImg = AssetCache.getImage(zapPath)
        if zapImg then
            table.insert(VFX.assets.zapFrames, zapImg)
        else
            print("[VFX] Warning: Failed to preload zap frame asset: " .. zapPath)
        end
    end
    
    -- Effect definitions keyed by effect name
    VFX.effects = {
        -- Base templates for the rules-driven VFX system
        proj_base = {
            type = "proj_base",
            duration = 1.0,
            particleCount = 30,           -- Increased from 20 for richer visuals
            startScale = 0.5,
            endScale = 0.8,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            trailLength = 15,             -- Slightly longer trail
            impactSize = 1.2,
            sound = nil,                  -- No default sound
            coreDensity = 0.6,            -- Controls density of center particles (0-1)
            trailDensity = 0.4,           -- Controls density of trail particles (0-1)
            turbulence = 0.5,             -- Random motion factor (0-1)
            arcHeight = 60,               -- Base arc height for trajectories
            particleLifespan = 0.6,       -- How long individual particles last (as fraction of total duration)
            leadingIntensity = 1.5        -- Brightness multiplier for the leading edge
        },

        bolt_base = {
            type = "bolt_base",  -- Template name as type
            duration = 1.0,               -- Slower to showcase enhanced particle effects
            particleCount = 20,           -- Fewer particles since we're using sprites
            startScale = 0.4,
            endScale = 0.7,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            trailLength = 18,             -- Longer trail for lightning-like effect
            impactSize = 1.3,             -- Slightly larger impact
            sound = nil,                  -- No default sound
            coreDensity = 0.3,            -- Less dense core, since we're using sprites
            trailDensity = 0.4,           -- Less dense trail, since we're using sprites
            turbulence = 0.8,             -- More random motion for lightning effect
            arcHeight = 0,                -- Zero arc height for straight-line trajectory
            straightLine = true,          -- New: Flag for straight-line movement
            particleLifespan = 0.5,       -- Shorter particle lifespan for quick flashes
            leadingIntensity = 1.8,       -- Brighter leading edge
            flickerRate = 12,             -- Rate at which particles flicker (Hz)
            flickerIntensity = 0.3,       -- Intensity of the flicker effect (0-1)
            useSprites = true,            -- Flag to indicate this effect uses sprite frames
            spriteFrameRate = 15,         -- Frames per second for sprite animation
            spriteRotationOffset = 0.78,  -- Radians to rotate the sprite by default (≈45 degrees)
            spriteScale = 0.85,           -- Base scale factor for the sprite
            spriteTint = true,            -- Whether to apply color tinting to sprites
            useSourcePosition = true,     -- Track source (caster) position
            useTargetPosition = true,     -- Track target position
            criticalAssets = {"boltFrames"} -- Mark bolt frames as critical assets to preload
        },

        zap_base = {
            type = "zap_base",
            duration = 0.6,
            color = Constants.Color.GRAY,
            segmentLength = 20,
            useSourcePosition = true,
            useTargetPosition = true,
            criticalAssets = {"zapFrames"}
        },

        orb_base = {
            type = "orb_base",  -- Template name as type
            duration = 1.8,               -- Significantly slower than bolt for dramatic arc
            particleCount = 35,           -- More particles for richer trail effect
            startScale = 0.6,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 65,                  -- Radius for particle effects and impact
            trailLength = 25,             -- Longer trail for graceful arc
            impactSize = 1.5,             -- Larger impact than bolt
            sound = nil,                  -- No default sound
            coreDensity = 0.5,            -- Balanced particle density
            trailDensity = 0.6,           -- Dense trail for visible arc path
            turbulence = 0.3,             -- Less turbulence for smoother flight
            arcHeight = 120,              -- High arc for lobbed trajectory
            straightLine = false,         -- Uses curved arc path
            particleLifespan = 0.8,       -- Longer particle lifespan for persistent trail
            leadingIntensity = 1.4,       -- Moderate leading edge intensity
            flickerRate = 8,              -- Slower flicker for mystical effect
            flickerIntensity = 0.2,       -- Subtle flicker
            useSprites = true,            -- Flag to indicate this effect uses sprite frames
            spriteFrameRate = 8,          -- Slower frame rate for floating effect
            spriteRotationOffset = 0,     -- No rotation offset for orbs
            spriteScale = 1.0,            -- Larger scale than bolts
            spriteTint = true,            -- Whether to apply color tinting to sprites
            useSourcePosition = true,     -- Track source (caster) position
            useTargetPosition = true,     -- Track target position
            useCurvedPath = true,         -- Enable curved path explicitly
            criticalAssets = {"orbFrames"} -- Mark orb frames as critical assets to preload
        },

        warp_base = {
            type = "warp_base",           -- Template name as type
            duration = 1.0,                -- Standard duration
            particleCount = 25,            -- Particles for additional effects
            startScale = 0.5,
            endScale = 1.0,
            color = Constants.Color.GRAY, -- Default color, will be overridden
            radius = 80,                   -- Radius for particle effects
            impactSize = 1.5,              -- Slightly larger impact
            sound = nil,                   -- No default sound
            pulseRate = 6.0,               -- Rate of pulsing effect
            useSprites = true,             -- Flag to indicate this effect uses sprite frames
            spriteFrameRate = 10,          -- Frames per second for sprite animation
            spriteScale = 1.0,             -- Base scale factor for the sprite
            spriteTint = true,             -- Whether to apply color tinting to sprites
            rotateSprite = true,           -- Whether to rotate the sprite
            rotationSpeed = 1.2,           -- Rotation speed in radians per second
            drawAtTarget = true,           -- Draw directly at target position
            usePulse = true,               -- Use pulsing effect
            pulseAmount = 0.2,             -- Amount of pulse (scale variation)
            glowIntensity = 0.7,           -- Intensity of the glow effect
            particleDensity = 0.6,         -- How dense the particles should be
            useTargetPosition = true,      -- Track the target's position
            criticalAssets = {"warpFrames"} -- Mark warp frames as critical assets to preload
        },

        beam_base = {
            type = "beam_base",           -- Template name as type
            duration = 1.2,
            particleCount = 25,
            beamWidth = 30,
            startScale = 0.3,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            pulseRate = 3,
            sound = nil,
            useSourcePosition = true,     -- Track source (caster) position
            useTargetPosition = true      -- Track target position
        },

        blast_base = {
            type = "blast_base",          -- Template name as type
            duration = 1.3,               -- Even longer duration for more dramatic impact
            particleCount = 95,           -- More particles for density and impact
            startScale = 0.45,            -- Larger starting scale
            endScale = 1.35,              -- Larger end scale for dramatic growth
            color = Constants.Color.GRAY, -- Default color, will be overridden
            coneAngle = 45,               -- Narrower cone angle (45° instead of 70°)
            coneLength = 320,             -- Much longer range for dramatic reach
            waveCount = 5,                -- More waves for increased visual impact
            waveSpeed = 350,              -- Faster wave propagation
            nearRangeIntensity = 2.2,     -- Stronger intensity multiplier at NEAR range
            matchedElevationIntensity = 1.7, -- Stronger multiplier for matched elevation
            useSourcePosition = true,     -- Track source (caster) position
            motionStyle = Constants.MotionStyle.DIRECTIONAL, -- Directional movement for particles
            waveCrest = true,             -- Enable wave crest visual effect
            waveCrestSize = 2.2,          -- Even larger wave crests
            turbulence = 0.35,            -- Slightly reduced turbulence for more focused beam
            leadingEdgeGlow = true,       -- Add bright leading edge to waves
            particleSizeVariance = 0.6,   -- Greater size variance for particles
            wavePersistence = 0.9,        -- How long waves remain visible (new parameter)
            trailingGlowStrength = 0.8,   -- Strength of glow trail behind waves (new parameter)
            sound = nil,                  -- No default sound
            intensityFalloff = 0.65,      -- Control how quickly intensity drops with distance
            focusedCore = true            -- Concentrate particles in center of cone (new parameter)
        },

        zone_base = {
            type = "zone_base",           -- Template name as type
            duration = 1.0,
            particleCount = 30,
            startScale = 0.4,
            endScale = 1.0,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 80,
            pulseRate = 3,
            sound = nil
        },

        util_base = {
            type = "util_base",           -- Template name as type
            duration = 0.8,
            particleCount = 15,
            startScale = 0.3,
            endScale = 0.7,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 60,
            pulseRate = 4,
            sound = nil
        },

        surge_base = {
            type = "surge_base",          -- Template name as type
            duration = 1.5,                -- Longer duration for buff visual
            particleCount = 90,            -- Extra particles for dramatic burst
            startScale = 1.0,              -- Pixel-sized primitives
            endScale = 0.2,               -- Fade to tiny specks
            color = Constants.Color.YELLOW_HERO,   -- Default color, will be overridden
            height = 200,                  -- Higher fountain effect
            spread = 45,                   -- Narrower spread for more focused fountain
            riseFactor = 1.4,              -- How quickly particles rise (new parameter)
            gravity = 180,                 -- Gravity effect for natural arc (new parameter)
            centerGlow = true,             -- Create glowing core at caster (new parameter)
            centerGlowSize = 50,           -- Size of the center glow
            centerGlowIntensity = 1.3,     -- Intensity of center glow
            spiralMotion = true,           -- Add spiral motion to particles (new parameter)
            spiralTightness = 2.5,         -- How tight the spiral is (new parameter)
            particleSizeVariance = 0.6,    -- Varied particle sizes
            riseAcceleration = 1.2,        -- Particles accelerate as they rise (new parameter)
            bloomEffect = true,            -- Add bloom/glow to particles (new parameter)
            bloomIntensity = 0.8,          -- Intensity of bloom effect (new parameter)
            sparkleChance = 0.4,           -- Chance for sparkle effect on particles (new parameter)
            useSprites = false,            -- Use primitive pixel sprites
            spriteFrameRate = 8,           -- Frame rate for sprite animation
            pulsateParticles = true,       -- Pulsate particle size (new parameter)
            sound = "surge",               -- Sound effect
            criticalAssets = {"pixel", "twinkle1", "twinkle2"} -- Required assets
        },

        wave_base = {
            type = "wave_base",          -- Template name as type
            duration = 1.2,
            particleCount = 120,
            startScale = 0.5,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            trailLength = 20,
            impactSize = 1.4,
            coreDensity = 0.4,
            trailDensity = 0.6,
            turbulence = 0.75,
            arcHeight = 40,
            particleLifespan = 0.7,
            leadingIntensity = 1.6,
            useSprites = false,
            criticalAssets = {"pixel", "twinkle1", "twinkle2"}
        },

        conjure_base = {
            type = "conjure_base",        -- Template name as type
            duration = 0.8,
            particleCount = 35,
            startScale = 0.3,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden by VisualResolver
            radius = 70,
            height = 120,
            pulseRate = 3,
            sound = nil,
            defaultParticleAsset = "sparkle"
        },

        impact_base = {
            type = "impact_base",         -- Template name as type
            duration = 0.5,
            particleCount = 20,
            startScale = 0.6,
            endScale = 0.3,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 40,
            sound = nil
        },

        remote_base = {
            type = "remote_base",         -- Template name as type
            duration = 0.7,
            particleCount = 35,
            startScale = 0.2,
            endScale = 1.0,              -- Larger ending scale for a flash effect
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 60,                 -- Larger radius than impact
            pulseRate = 2,               -- Add pulse for dynamic flash effect
            intensityMultiplier = 1.8,   -- Brighter than normal effects
            useTargetPosition = true,    -- Always use target position, not source
            trackTargetOffsets = true,   -- Track target's current position including offsets
            sound = nil
        },

        shield_hit_base = {
            type = "shield_hit_base",     -- Template name as type
            duration = 0.8,  -- Slightly longer impact duration
            particleCount = 30, -- More particles
            startScale = 0.5,
            endScale = 1.3,  -- Larger end scale
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 70,     -- Increased radius
            sound = "shield", -- Use shield sound
            criticalAssets = {"impactRing", "sparkle"} -- Assets needed for shield hit
        },
        
        -- Existing effects
        -- General impact effect (used for many spell interactions)
        impact = {
            type = "impact",              -- Effect name as type
            duration = 0.5,  -- Half second by default
            particleCount = 15,
            startScale = 0.8,
            endScale = 0.2,
            color = Constants.Color.GRAY,
            radius = 30,
            sound = nil  -- No default sound
        },

        meteor = {
            type = "meteor",              -- Effect name as type
            duration = 1.4,
            particleCount = 45,
            startScale = 0.6,
            endScale = 1.2,
            color = Constants.Color.RED_HERO,  -- Crimson red for meteor
            radius = 90,         -- Impact explosion radius
            height = 300,        -- Height from which meteor falls
            spread = 20,         -- Spread of the meteor cluster
            fireTrail = true,    -- Enable fire trail for particles
            impactExplosion = true, -- Create explosion effect on impact
            sound = "meteor_impact",
            defaultParticleAsset = "fireParticle"
        },

        force_blast = {
            type = "force_blast",         -- Effect name as type
            duration = 1.0,
            particleCount = 30,
            startScale = 0.4,
            endScale = 1.5,
            color = Constants.Color.YELLOW_HERO,
            radius = 90,
            sound = "force_wind"
        },

        free_mana = {
            type = "free_mana",           -- Effect name as type
            duration = 1.2,
            particleCount = 40,
            startScale = 0.4,
            endScale = 0.8,
            color = Constants.Color.WHITE,
            radius = 100,
            pulseRate = 4,
            sound = "release"
        },

        shield = {
            type = "shield",              -- Effect name as type
            duration = 1.0,
            particleCount = 25,
            startScale = 0.5,
            endScale = 1.2,
            color = Constants.Color.BLUE_HERO,
            radius = 60,
            pulseRate = 3,
            sound = "shield",
            criticalAssets = {"sparkle", "runes", "impactRing"}, -- Assets needed for shields
            shieldType = nil -- Will be set at runtime based on the spell
        },

        -- Emberlift spell effects
        emberlift = {
            type = "emberlift",           -- Effect name as type
            duration = 1.2,
            particleCount = 60,            -- More particles for richer effect
            startScale = 0.3,              -- Larger starting scale
            endScale = 0.08,               -- Smaller end scale for fade-out
            color = Constants.Color.RED_HERO,
            height = 160,                  -- Height for fountain effect
            spread = 45,                   -- Spread for the fountain
            riseFactor = 1.4,              -- How quickly particles rise
            gravity = 180,                 -- Gravity effect for natural arc
            centerGlow = true,             -- Create glowing core at caster
            centerGlowSize = 50,           -- Size of the center glow
            centerGlowIntensity = 1.3,     -- Intensity of center glow
            spiralMotion = true,           -- Add spiral motion to particles
            spiralTightness = 2.5,         -- How tight the spiral is
            particleSizeVariance = 0.6,    -- Varied particle sizes
            riseAcceleration = 1.2,        -- Particles accelerate as they rise
            bloomEffect = true,            -- Add bloom/glow to particles
            bloomIntensity = 0.8,          -- Intensity of bloom effect
            sparkleChance = 0.4,           -- Chance for sparkle effect on particles
            useSprites = true,             -- Use sprite images
            spriteFrameRate = 8,           -- Frame rate for sprite animation
            pulsateParticles = true,       -- Pulsate particle size
            sound = "surge",
            criticalAssets = {"sparkle", "fireParticle"}
        },

        range_change = {
            type = "range_change",         -- Effect name as type
            duration = 1.1,
            particleCount = 50,
            startScale = 0.3,
            endScale = 0.7,
            color = Constants.Color.YELLOW_HERO,
            height = 120,
            spread = 60,
            riseFactor = 1.2,
            gravity = 150,
            centerGlow = true,
            centerGlowSize = 40,
            spiralMotion = true,
            spiralTightness = 2.0,
            particleSizeVariance = 0.5,
            useSprites = true,
            spriteFrameRate = 8,
            sound = "range_shift"
        },

        -- Note: conjurefire will fall through to use the default conjure_base template
    }
    
    -- TODO: Initialize sound effects
    
    -- Create effect pool - each effect is a container object
    Pool.create("vfx_effect", 10, function() return { particles = {} } end, VFX.resetEffect)

    -- Run the diagnostic to ensure the particle pool is healthy
    VFX.runParticlePoolDiagnostic()

    -- Return the VFX table itself
    return VFX
end

-- Reset function for particle objects
function VFX.resetParticle(particle)
    -- Clear all fields
    for k, _ in pairs(particle) do
        particle[k] = nil
    end
    return particle
end

-- Update particle based on motion style
function VFX.updateParticle(particle, effect, dt, particleProgress)
    local Constants = require("core.Constants")
    
    -- If no motion style specified, use default behavior
    local motionStyle = particle.motion or Constants.MotionStyle.RADIAL
    
    -- Time since particle became active
    particle.startTime = (particle.startTime or 0) + dt
    local time = particle.startTime
    
    -- Get base position
    local baseX = particle.baseX or effect.sourceX
    local baseY = particle.baseY or effect.sourceY
    
    -- Apply motion based on style
    if motionStyle == Constants.MotionStyle.RADIAL then
        -- Standard radial outward motion (default)
        -- This behavior is already handled in most effect update functions
        -- Just update existing motion with time factor
        
    elseif motionStyle == Constants.MotionStyle.SWIRL then
        -- Tangential swirl using sine/cosine
        -- Start with the existing direction, then add rotational motion
        local angle = particle.angle or math.atan2(particle.targetY - baseY, particle.targetX - baseX)
        local baseDistance = math.sqrt((particle.targetX - baseX)^2 + (particle.targetY - baseY)^2)
        local distance = baseDistance * particleProgress
        local swirlFactor = 2.0 -- Controls the swirl tightness
        local rotationSpeed = 4.0 -- Controls how fast particles orbit
        
        -- Orbit around the path while moving outward
        local swirlAngle = angle + math.sin(time * rotationSpeed) * swirlFactor
        particle.x = baseX + math.cos(swirlAngle) * distance
        particle.y = baseY + math.sin(swirlAngle) * distance
        
    elseif motionStyle == Constants.MotionStyle.HEX then
        -- Approximated hex grid movement using snapped angles
        -- Move along hex angles (0, 60, 120, 180, 240, 300 degrees)
        local baseAngle = particle.angle or 0
        local hexAngle = math.floor(baseAngle / (math.pi/3)) * (math.pi/3)
        local jitterAmount = 0.2 * math.sin(time * 5) -- Small jitter
        local speed = particle.speed or 100 -- Default speed if not set
        local distance = speed * particleProgress
        
        particle.x = baseX + math.cos(hexAngle + jitterAmount) * distance
        particle.y = baseY + math.sin(hexAngle + jitterAmount) * distance
        
    elseif motionStyle == Constants.MotionStyle.STATIC then
        -- Minimal movement with subtle breathing effect
        local breatheFactor = 0.1 * math.sin(time * 3)
        
        -- Slight offset from original position
        local offsetX = (particle.targetX - baseX) * 0.2 * particleProgress
        local offsetY = (particle.targetY - baseY) * 0.2 * particleProgress
        
        -- Apply breathing effect
        particle.x = baseX + offsetX + math.cos(particle.angle or 0) * breatheFactor
        particle.y = baseY + offsetY + math.sin(particle.angle or 0) * breatheFactor
        
    elseif motionStyle == Constants.MotionStyle.RISE then
        -- Particles float upward
        local speed = particle.speed or 100 -- Default speed if not set
        local horizontalSpeed = speed * 0.3
        local verticalSpeed = speed
        
        particle.x = baseX + math.cos(particle.angle or 0) * horizontalSpeed * particleProgress
        particle.y = baseY - verticalSpeed * particleProgress -- Subtract to move up
        
    elseif motionStyle == Constants.MotionStyle.FALL then
        -- Particles fall downward
        local speed = particle.speed or 100 -- Default speed if not set
        local horizontalSpeed = speed * 0.3
        local verticalSpeed = speed
        local gravity = 100 -- Acceleration factor
        
        particle.x = baseX + math.cos(particle.angle or 0) * horizontalSpeed * particleProgress
        particle.y = baseY + (verticalSpeed * particleProgress + 0.5 * gravity * particleProgress * particleProgress)
        
    elseif motionStyle == Constants.MotionStyle.PULSE then
        -- Particles pulse outward and inward
        local pulseDistance = math.sin(time * 4) * 0.5 + 0.5 -- 0 to 1 pulsing
        local targetDistance = math.sqrt((particle.targetX - baseX)^2 + (particle.targetY - baseY)^2)
        local distance = targetDistance * pulseDistance * particleProgress
        
        particle.x = baseX + math.cos(particle.angle or 0) * distance
        particle.y = baseY + math.sin(particle.angle or 0) * distance
        
        -- Also pulse alpha
        particle.alpha = 0.4 + pulseDistance * 0.6
        
    elseif motionStyle == Constants.MotionStyle.RIPPLE then
        -- Wave-like ripple effect
        local angle = particle.angle or math.atan2(particle.targetY - baseY, particle.targetX - baseX)
        local baseDistance = math.sqrt((particle.targetX - baseX)^2 + (particle.targetY - baseY)^2)
        local distance = baseDistance * particleProgress
        
        -- Add wave effect perpendicular to the radial direction
        local waveAmplitude = 10 * math.sin(distance * 0.1 + time * 5)
        local perpX = -math.sin(angle) * waveAmplitude
        local perpY = math.cos(angle) * waveAmplitude
        
        particle.x = baseX + math.cos(angle) * distance + perpX
        particle.y = baseY + math.sin(angle) * distance + perpY
        
    elseif motionStyle == Constants.MotionStyle.DIRECTIONAL then
        -- Directional movement along a specific path
        -- This simply follows the default trajectory but with less randomness
        local dirX = (particle.targetX or baseX + 100) - baseX
        local dirY = (particle.targetY or baseY) - baseY
        local length = math.sqrt(dirX^2 + dirY^2)
        
        if length > 0 then
            dirX = dirX / length
            dirY = dirY / length
            
            -- Move with consistent speed
            local speed = particle.speed or 100 -- Default speed if not set
            particle.x = baseX + dirX * speed * particleProgress * time
            particle.y = baseY + dirY * speed * particleProgress * time
        end
    end
    
    -- Handle special visual effects for certain motion styles
    if motionStyle == Constants.MotionStyle.PULSE then
        -- Special scaling for pulse motion
        local pulseScale = 0.8 + 0.4 * math.sin(time * 4)
        particle.scale = (effect.startScale + (effect.endScale - effect.startScale) * particleProgress) * pulseScale
    end
end

-- Reset function for effect objects
function VFX.resetEffect(effect)
    -- Only release particles if effect has particles field
    if effect.particles then
        -- Use ParticleManager to safely release all particles
        ParticleManager.releaseAllParticles(effect.particles)
    end

    -- Clear all fields except particles
    effect.name = nil
    effect.type = nil
    effect.sourceX = nil
    effect.sourceY = nil
    effect.targetX = nil
    effect.targetY = nil
    effect.duration = nil
    effect.timer = nil
    effect.progress = nil
    effect.isComplete = nil
    effect.particleCount = nil
    effect.startScale = nil
    effect.endScale = nil
    effect.color = nil
    effect.trailPoints = nil
    effect.sound = nil
    effect.radius = nil
    effect.beamWidth = nil
    effect.height = nil
    effect.pulseRate = nil
    effect.trailLength = nil
    effect.impactSize = nil
    effect.spreadRadius = nil
    effect.options = nil
    effect.coreDensity = nil
    effect.trailDensity = nil
    effect.turbulence = nil
    effect.arcHeight = nil
    effect.particleLifespan = nil
    effect.leadingIntensity = nil
    effect.flickerRate = nil
    effect.flickerIntensity = nil
    effect.useSprites = nil
    effect.spriteFrameRate = nil
    effect.spriteRotationOffset = nil
    effect.spriteScale = nil
    effect.spriteTint = nil
    effect.straightLine = nil
    effect.rotateSprite = nil
    effect.rotationSpeed = nil
    effect.drawAtTarget = nil
    effect.usePulse = nil
    effect.pulseAmount = nil
    effect.glowIntensity = nil
    effect.particleDensity = nil
    effect.beamProgress = nil
    effect.beamLength = nil
    effect.beamAngle = nil
    effect.impactCreated = nil
    effect.manaPoolX = nil
    effect.manaPoolY = nil
    effect.sourceGlow = nil
    effect.poolGlow = nil
    effect.motion = nil
    effect.rangeBand = nil
    effect.elevation = nil
    effect.addons = nil
    effect.spread = nil
    effect.visualProgress = nil
    effect.blockTimerStarted = nil
    effect.blockTimer = nil
    effect.blockInfo = nil
    effect.blockLogged = nil
    effect.impactParticlesCreated = nil

    -- Reset particles array but don't delete it
    effect.particles = {}

    return effect
end

-- Helper function to ensure all effect parameters are valid
function VFX.sanitizeEffectParameters(effectName, sourceX, sourceY, targetX, targetY, options)
    -- Sanitize effect name
    if not effectName or effectName == "" then
        effectName = "impact_base" -- Safe default
        print("[VFX] Warning: Missing effect name, using impact_base as fallback")
    end
    
    -- Sanitize coordinates
    sourceX = sourceX or 0
    sourceY = sourceY or 0
    targetX = targetX or sourceX
    targetY = targetY or sourceY
    
    -- Sanitize options
    options = options or {}
    
    -- Ensure critical fields are present
    options.duration = options.duration or 0.5
    options.scale = options.scale or 1.0
    options.particleCount = options.particleCount or 10
    
    -- For blocked projectiles
    if options.blockInfo then
        options.blockPoint = options.blockPoint or 0.75
    end
    
    -- Always set default color if missing
    if not options.color then
        options.color = {1.0, 1.0, 1.0, 1.0} -- White fallback
    end
    
    -- Return sanitized values
    return effectName, sourceX, sourceY, targetX, targetY, options
end

-- Create a new effect instance
function VFX.createEffect(effectName, sourceX, sourceY, targetX, targetY, options)
    -- Sanitize all parameters to prevent nil errors
    effectName, sourceX, sourceY, targetX, targetY, options = 
        VFX.sanitizeEffectParameters(effectName, sourceX, sourceY, targetX, targetY, options)
    local Constants = require("core.Constants")
    
    -- Enhanced debugging for VFX-R5 implementation
    print("\n====== VFX CREATION CALL ======")
    print("[VFX] CALL STACK: " .. debug.traceback())
    print("[VFX] effectName: " .. tostring(effectName))
    print("[VFX] sourceX: " .. tostring(sourceX) .. " sourceY: " .. tostring(sourceY))
    if targetX and targetY then
        print("[VFX] targetX: " .. tostring(targetX) .. " targetY: " .. tostring(targetY))
    end
    if options then
        print("[VFX] Options:")
        for k, v in pairs(options) do
            if type(v) == "table" then
                print("  " .. k .. ": [table]")
            else
                print("  " .. k .. ": " .. tostring(v))
            end
        end
    end
    print("================================\n")
    
    -- Handle both string and Constants.VFXType format
    local effectNameStr
    
    -- Validate and normalize effectName 
    if type(effectName) ~= "string" then
        print("Error in VFX.createEffect: Effect name must be a string or Constants.VFXType value, got: " .. tostring(effectName))
        -- Fall back to a default effect
        effectNameStr = Constants.VFXType.IMPACT
    else
        effectNameStr = effectName
    end
    
    -- Regular debug output
    print("[VFX] Creating effect: " .. effectNameStr)
    print("[VFX] sourceX: " .. sourceX .. " sourceY: " .. sourceY)
    if targetX and targetY then
        print("[VFX] targetX: " .. targetX .. " targetY: " .. targetY)
    end
    
    -- Process options
    local opts = options or {}
    
    -- Process options.addons if provided (for future work)
    if opts.addons and #opts.addons > 0 then
        for _, addon in ipairs(opts.addons) do
            print("[VFX] TODO addon: " .. tostring(addon))
            -- In future work, we would create or modify effects based on addons
            -- Example: Apply a fire overlay to a projectile, add a sparkle effect, etc.
        end
    end
    
    -- Try to get the effect template first to check for critical assets
    local template = VFX.effects[effectNameStr:lower()]
    if template then
        -- Template exists, check for critical assets
        if template.criticalAssets then
            for _, assetId in ipairs(template.criticalAssets) do
                -- Try to get the asset, will trigger loading if not available
                local asset = VFX.getAsset(assetId)
                if not asset or (assetId == "runes" and #asset == 0) then
                    -- Asset failed to load, try emergency loading
                    print("[VFX] Critical asset missing: " .. assetId .. ", attempting emergency load")
                    
                    -- Emergency loading of critical asset
                    if assetId == "runes" and VFX.assetPaths and VFX.assetPaths.runes then
                        print("[VFX] Emergency loading of rune assets")
                        local AssetCache = require("core.AssetCache")
                        VFX.assets.runes = VFX.assets.runes or {}
                        for i, runePath in ipairs(VFX.assetPaths.runes) do
                            local runeImg = AssetCache.getImage(runePath)
                            if runeImg then
                                table.insert(VFX.assets.runes, runeImg)
                            end
                        end
                    elseif VFX.assetPaths and VFX.assetPaths[assetId] then
                        print("[VFX] Emergency loading of asset: " .. assetId)
                        local AssetCache = require("core.AssetCache")
                        VFX.assets[assetId] = AssetCache.getImage(VFX.assetPaths[assetId])
                    end
                end
            end
        end
    else
        -- Backward compatibility for effects without templates that may need runes
        -- (e.g., mistveil, effects with "ward" in the name)
        if effectNameStr:lower():find(Constants.ShieldType.WARD) or effectNameStr:lower() == "mistveil" then
            -- Ensure runes are loaded for ward-related effects
            local runeAssets = VFX.getAsset("runes")
            if not runeAssets or #runeAssets == 0 then
                print("[VFX] Warning: Ward effect requested but rune assets not available.")
                -- Force-load runes
                if VFX.assetPaths and VFX.assetPaths.runes then
                    local AssetCache = require("core.AssetCache")
                    VFX.assets.runes = {}
                    for i, runePath in ipairs(VFX.assetPaths.runes) do
                        print("[VFX] Emergency loading of rune asset: " .. i)
                        local runeImg = AssetCache.getImage(runePath)
                        if runeImg then
                            table.insert(VFX.assets.runes, runeImg)
                        end
                    end
                end
            end
        end
    end
    
    -- Get or reuse effect template - use :lower() safely now that we've verified it's a string
    if not template then -- Only if we didn't already get it above
        template = VFX.effects[effectNameStr:lower()]
        if not template then
            print("Warning: Effect not found: " .. effectNameStr)
            -- Fall back to impact effect if available
            template = VFX.effects[Constants.VFXType.IMPACT]
            if not template then
                return nil -- Give up if no fallback is available
            end
            print("[VFX] Falling back to '" .. Constants.VFXType.IMPACT .. "' effect")
        end
    end
    
    -- Create a new effect instance from pool
    local effect = Pool.acquire("vfx_effect")
    effect.name = effectName
    effect.type = template.type
    effect.sourceX = sourceX
    effect.sourceY = sourceY
    effect.targetX = targetX or sourceX
    effect.targetY = targetY or sourceY
    
    -- Store source and target entities for position tracking if provided in options
    if options and options.sourceEntity then
        effect.sourceEntity = options.sourceEntity
        
        -- Initialize with source position including offsets if available
        if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
            effect.sourceX = effect.sourceEntity.x + effect.sourceEntity.currentXOffset
            effect.sourceY = effect.sourceEntity.y + effect.sourceEntity.currentYOffset
        end
    end
    
    if options and options.targetEntity then
        effect.targetEntity = options.targetEntity
        
        -- Initialize with target position including offsets if available
        if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
            effect.targetX = effect.targetEntity.x + effect.targetEntity.currentXOffset
            effect.targetY = effect.targetEntity.y + effect.targetEntity.currentYOffset
        end
    end
    
    -- Flag for effects that should use target's actual position including offsets
    effect.trackTargetOffsets = (options and options.trackTargetOffsets) or (template and template.trackTargetOffsets) or false
    
    -- Flag for effects that should use source position tracking
    effect.useSourcePosition = (options and options.useSourcePosition) or (template and template.useSourcePosition) or false
    
    -- Flag for effects that should use target position tracking
    effect.useTargetPosition = (options and options.useTargetPosition) or (template and template.useTargetPosition) or false
    
    -- Timing
    -- Prioritize duration from options (EventRunner), then template, then fallback.
    if options and options.duration then
        effect.duration = options.duration
    elseif template.duration then
        effect.duration = template.duration
    else
        effect.duration = 0.5 -- Absolute fallback if no duration anywhere
        print("[VFX] Warning: Effect " .. effectNameStr .. " has no duration in options or template. Defaulting to 0.5s.")
    end
    effect.timer = 0
    effect.progress = 0
    effect.isComplete = false
    
    -- Visual properties (copied from template)
    effect.particleCount = template.particleCount
    effect.startScale = template.startScale
    effect.endScale = template.endScale
    effect.color = {template.color[1], template.color[2], template.color[3], template.color[4]}
    
    -- Store shield block information if provided (for projectile block visuals)
    if options and options.blockInfo then
        print("[VFX] Effect has blockInfo - will show shield block visuals")
        effect.blockInfo = options.blockInfo
        effect.options = effect.options or {}
        effect.options.blockPoint = options.blockPoint or 0.75 -- Default to 75% of the way
        effect.options.shieldType = options.blockInfo.blockType or (options.shieldType or "ward")
        
        -- Enhanced debugging for shield block effects
        print(string.format("[VFX] Created blocked effect '%s' with blockPoint=%.2f and shieldType=%s", 
            effectName, effect.options.blockPoint, effect.options.shieldType or "unknown"))
    elseif options and options.blockPoint then
        -- Fallback for cases where blockPoint is provided without blockInfo
        print("[VFX] Effect has blockPoint but no blockInfo - creating minimal blockInfo")
        effect.options = effect.options or {}
        effect.options.blockPoint = options.blockPoint
        effect.options.shieldType = options.shieldType or "ward"
        effect.blockInfo = {
            blockable = true,
            blockType = options.shieldType or "ward",
            blockPoint = options.blockPoint
        }
        
        -- Enhanced debugging for fallback shield block effects
        print(string.format("[VFX] Created fallback blocked effect '%s' with blockPoint=%.2f", 
            effectName, effect.options.blockPoint))
    elseif options and options.tags and options.tags.SHIELD_BLOCKED then
        -- Ultra fallback for SHIELD_BLOCKED tag without proper blockInfo
        print("[VFX] Effect has SHIELD_BLOCKED tag but no blockInfo or blockPoint - creating default blockInfo")
        effect.options = effect.options or {}
        effect.options.blockPoint = 0.75
        effect.options.shieldType = options.shieldType or "ward"
        effect.blockInfo = {
            blockable = true,
            blockType = options.shieldType or "ward",
            blockPoint = 0.75
        }
        
        -- Enhanced debugging for ultra fallback shield block effects
        print(string.format("[VFX] Created ultra fallback blocked effect '%s' with default blockPoint=0.75", 
            effectName))
    end
    
    -- Apply options modifiers
    if opts.color then
        -- Override color with the provided color
        effect.color = {opts.color[1], opts.color[2], opts.color[3], opts.color[4] or 1.0}
    end
    
    if opts.scale then
        -- Apply scale factor to particle counts, sizes, radii, etc.
        local scaleFactor = opts.scale
        if effect.particleCount then
            effect.particleCount = math.floor(effect.particleCount * scaleFactor)
        end
        if effect.startScale then
            effect.startScale = effect.startScale * scaleFactor
        end
        if effect.endScale then
            effect.endScale = effect.endScale * scaleFactor
        end
        if effect.radius then effect.radius = effect.radius * scaleFactor end
        if effect.beamWidth then effect.beamWidth = effect.beamWidth * scaleFactor end
        if effect.height then effect.height = effect.height * scaleFactor end
        if effect.spread then effect.spread = effect.spread * scaleFactor end
    end
    
    -- Store motion style and positional info
    effect.motion = opts.motion
    effect.rangeBand = opts.rangeBand
    effect.elevation = opts.elevation
    effect.addons = opts.addons
    
    -- Effect specific properties
    effect.particles = {}
    effect.trailPoints = {}
    
    -- Sound
    effect.sound = template.sound
    
    -- Additional properties based on effect type
    effect.radius = template.radius
    effect.beamWidth = template.beamWidth
    effect.height = template.height
    effect.pulseRate = template.pulseRate
    effect.trailLength = template.trailLength
    effect.impactSize = template.impactSize
    effect.spreadRadius = template.spreadRadius
    effect.spread = template.spread
    effect.coreDensity = template.coreDensity
    effect.trailDensity = template.trailDensity
    effect.turbulence = template.turbulence
    effect.arcHeight = template.arcHeight
    effect.particleLifespan = template.particleLifespan
    effect.leadingIntensity = template.leadingIntensity
    effect.flickerRate = template.flickerRate
    effect.flickerIntensity = template.flickerIntensity
    effect.useSprites = template.useSprites
    effect.spriteFrameRate = template.spriteFrameRate
    effect.spriteRotationOffset = template.spriteRotationOffset
    effect.spriteScale = template.spriteScale
    effect.spriteTint = template.spriteTint
    effect.straightLine = template.straightLine
    effect.rotateSprite = template.rotateSprite
    effect.rotationSpeed = template.rotationSpeed
    effect.drawAtTarget = template.drawAtTarget
    effect.usePulse = template.usePulse
    effect.pulseAmount = template.pulseAmount
    effect.glowIntensity = template.glowIntensity
    effect.particleDensity = template.particleDensity
    
    -- Optional overrides
    effect.options = options or {}
    
    -- Initialize particles based on effect type
    VFX.initializeParticles(effect)
    
    -- Play sound effect if available
    if effect.sound and VFX.sounds and VFX.sounds[effect.sound] then
        -- Will play sound when implemented
    end
    
    -- Add to active effects list
    table.insert(VFX.activeEffects, effect)
    
    return effect
end

-- Initialize particles based on effect type
-- Helper function to ensure particle has all required properties
function VFX.ensureParticleDefaults(particle)
    -- Safety defaults for mandatory properties
    particle.delay = particle.delay or 0
    particle.active = particle.active or false
    particle.startTime = particle.startTime or 0
    particle.scale = particle.scale or 1.0
    particle.alpha = particle.alpha or 1.0
    particle.rotation = particle.rotation or 0
    particle.isCore = particle.isCore or false
    return particle
end

function VFX.initializeParticles(effect)
    return initializeParticlesModule(effect)
end
-- Update all active effects
function VFX.update(dt)
    local i = 1
    
    -- Safety check
    if not VFX.activeEffects then 
        VFX.activeEffects = {}
        return
    end
    
    while i <= #VFX.activeEffects do
        local effect = VFX.activeEffects[i]
        
        -- Skip invalid effects
        if not effect then
            table.remove(VFX.activeEffects, i)
            goto next_effect
        end
        
        -- Update effect timer
        -- Make sure we have valid values
        effect.timer = effect.timer or 0
        effect.duration = effect.duration or 0.5
        
        -- Update timer
        effect.timer = effect.timer + dt
        
        -- Update positions based on tracked entities
        -- First check source position updates
        if effect.useSourcePosition and effect.sourceEntity then
            -- Check for wizard-specific position offsets
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                -- Update source position with offsets
                effect.sourceX = effect.sourceEntity.x + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceEntity.y + effect.sourceEntity.currentYOffset
            end
        end
        
        -- Then check target position updates
        if effect.useTargetPosition and effect.targetEntity then
            -- Check for wizard-specific position offsets
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                -- Update target position with offsets
                effect.targetX = effect.targetEntity.x + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetEntity.y + effect.targetEntity.currentYOffset
            end
        end
        
        -- Only calculate progress if duration is valid
        if effect.duration > 0 then
            effect.progress = math.min(effect.timer / effect.duration, 1.0)
        else
            effect.progress = effect.timer -- Fallback when duration is 0
            print("[VFX] Warning: Effect has invalid duration: " .. tostring(effect.duration))
        end
        
        -- Handle shield block effects with improved safeguards
        local isBlocked = effect.options and effect.options.blockPoint

        -- Mark effect as blocked if necessary
        if isBlocked and not effect.isBlocked then
            effect.isBlocked = true
            print("[VFX] Setting effect.isBlocked = true for projectile")
        end

        -- Debug to verify blocked effect tracking
        if isBlocked and effect.timer == dt then  -- First update frame
            print(string.format("[VFX] Tracking blocked effect '%s' with blockPoint=%.2f",
                effect.name or "unknown", effect.options.blockPoint))
        end
        
        if isBlocked then
            -- Ensure these fields exist to prevent runtime errors
            if not effect.type then effect.type = effect.name or "projectile" end
            if not effect.options then effect.options = {} end
            if not effect.options.blockPoint then effect.options.blockPoint = 0.75 end
            
            -- NEW: Instead of immediately setting progress to blockPoint, use a visual progress tracker
            -- This allows the projectile to follow a natural trajectory
            if not effect.visualProgress then
                -- Initialize visualProgress at the beginning (first frame)
                effect.visualProgress = 0
                print("[VFX] Initializing blocked projectile trajectory")
            end
            
            -- Update visualProgress for smooth animation - speed up slightly for gameplay feel
            effect.visualProgress = effect.visualProgress + dt * (1/effect.duration) * 1.2
            
            -- Clamp visualProgress at the block point
            effect.visualProgress = math.min(effect.visualProgress, effect.options.blockPoint)
            
            -- Determine if effect should be blocked - check if visualProgress reached blockPoint
            local shouldStartBlock = not effect.blockTimerStarted and effect.visualProgress >= effect.options.blockPoint - 0.01
            
            -- Start the block effect when we reach the block point
            if shouldStartBlock then
                -- Mark the start of block timing
                effect.blockTimerStarted = true
                effect.blockTimer = 0
                
                -- Lock progress at block point to show projectile stopping
                effect.visualProgress = effect.options.blockPoint
                
                -- Enhanced debugging
                print(string.format("[VFX] Effect '%s' blocked at %.2f, starting shield impact sequence", 
                    effect.name or "unknown", effect.options.blockPoint))
                
                -- Create shield impact effect
                -- Trigger shield impact visuals for projectile-type effects
                -- Accept both generic projectile templates (proj_base/bolt_base)
                if not effect.impactParticlesCreated and
                   (effect.type == "proj_base" or effect.type == "bolt_base" or effect.type == "orb_base" or
                    effect.type == "projectile") then
                    effect.impactParticlesCreated = true
                    
                    -- Calculate impact position 
                    local progress = effect.options.blockPoint
                    local impactX = effect.sourceX + (effect.targetX - effect.sourceX) * progress
                    local impactY = effect.sourceY + (effect.targetY - effect.sourceY) * progress
                    
                    -- Create a separate shield hit effect
                    print(string.format("[VFX] Creating shield hit effect at (%.1f, %.1f)", impactX, impactY))
                    
                    -- Determine shield color based on shield type
                    local shieldColor = {1.0, 1.0, 0.3, 0.7}  -- Default yellow
                    if effect.options.shieldType == "ward" then
                        shieldColor = {0.3, 0.3, 1.0, 0.7}  -- Blue for wards 
                    elseif effect.options.shieldType == "field" then
                        shieldColor = {0.3, 1.0, 0.3, 0.7}  -- Green for fields
                    end
                    
                    -- Make the impact more dramatically visible to the player
                    -- Use impact_base or a fallback effect
                    local impactEffect = "impact_base"
                    
                    -- Impact flash effect
                    local flashParams = {
                        duration = 0.3,
                        scale = (effect.startScale or 1.0) * 1.5,
                        color = {shieldColor[1], shieldColor[2], shieldColor[3], 0.9},
                        particleCount = 1
                    }
                    VFX.createEffect(impactEffect, impactX, impactY, impactX, impactY, flashParams)
                    
                    -- Particle burst effect 
                    local burstParams = {
                        duration = 0.8,
                        scale = (effect.startScale or 1.0) * 1.2,
                        color = shieldColor,
                        particleCount = 30
                    }
                    VFX.createEffect(impactEffect, impactX, impactY, impactX, impactY, burstParams)
                    
                    -- No need to add particles to current effect
                    print("[VFX] Created shield impact effects")

                    -- Clean up the projectile immediately after impact
                    ParticleManager.releaseAllParticles(effect.particles or {})
                    effect.particles = {}
                    effect.blockTimerStarted = nil
                    effect.progress = 1.0
                    
                    -- Trigger screen shake at the exact moment of shield impact
                    print("[VFX] Attempting to trigger screen shake for shield block")
                    
                    -- Get the game state reference from the effect options if available
                    local gameState = nil
                    
                    -- First try to use the directly passed gameState if available
                    if effect.options and effect.options.gameState then
                        print("[VFX] Found gameState directly in options")
                        gameState = effect.options.gameState
                    -- Next try through sourceEntity
                    elseif effect.options and effect.options.sourceEntity and effect.options.sourceEntity.gameState then
                        print("[VFX] Found gameState through sourceEntity")
                        gameState = effect.options.sourceEntity.gameState
                    -- Next try through targetEntity
                    elseif effect.options and effect.options.targetEntity and effect.options.targetEntity.gameState then
                        print("[VFX] Found gameState through targetEntity")
                        gameState = effect.options.targetEntity.gameState
                    -- Finally try the global game object
                    else
                        -- Try to find it through the global game object
                        print("[VFX] No entity references found, looking for global game object")
                        if _G.game then
                            print("[VFX] Found global game object via _G.game")
                            gameState = _G.game
                        elseif game then -- Try directly referencing the global variable 
                            print("[VFX] Found global game object via direct access")
                            gameState = game
                        -- As a last resort, use the VFX module's stored reference
                        elseif VFX.gameState then
                            print("[VFX] Using VFX.gameState reference")
                            gameState = VFX.gameState
                        end
                    end
                    
                    -- Check if we have game state and trigger methods
                    if gameState then
                        print("[VFX] GameState found. Has triggerShake: " .. tostring(gameState.triggerShake ~= nil))
                    else
                        print("[VFX] No gameState found for triggering shake!")
                    end
                    
                    -- Determine impact amount for shake intensity (from effect or default)
                    local amount = effect.options.amount or 10
                    local intensity = math.min(4, 2 + (amount / 20))
                    local shakeDuration = 0.2
                    
                    -- Trigger shake if we have access to the game state
                    if gameState and gameState.triggerShake then
                        -- Trigger a light shake for shield blocks via gameState
                        print(string.format("[VFX] About to call gameState.triggerShake(%.2f, %.2f)", shakeDuration, intensity))
                        gameState.triggerShake(shakeDuration, intensity)
                        print(string.format("[VFX] Shield block impact! Triggered light shake (%.2f, %.2f) at blockPoint=%.2f", 
                            shakeDuration, intensity, effect.options.blockPoint or 0))
                    elseif VFX.triggerShake then
                        -- Use the VFX module's direct function reference
                        print(string.format("[VFX] About to call VFX.triggerShake(%.2f, %.2f)", shakeDuration, intensity))
                        VFX.triggerShake(shakeDuration, intensity)
                        print(string.format("[VFX] Shield block impact! Triggered light shake via VFX.triggerShake"))
                    else
                        -- Last resort: Try to use the global function directly
                        if _G.triggerShake then
                            print(string.format("[VFX] About to call global triggerShake(%.2f, %.2f)", shakeDuration, intensity))
                            _G.triggerShake(shakeDuration, intensity)
                            print("[VFX] Called global triggerShake function")
                        else
                            print("[VFX] Could not trigger shake - no valid triggerShake function found")
                        end
                    end
                end
            end
            
            -- Once block is triggered, increment a block timer
            if effect.blockTimerStarted then
                effect.blockTimer = effect.blockTimer + dt
                -- Keep the effect alive until the block timer elapses
                if effect.blockTimer > 1.2 then
                    -- After the hold period, mark the effect complete
                    effect.progress = 1.0
                    print(string.format("[VFX] Blocked effect '%s' cleanup - forcing completion", effect.name or "unknown"))
                else
                    -- Lock both visual and logical progress at the block point so the effect isn't removed early
                    effect.visualProgress = effect.options.blockPoint
                    effect.progress = math.min(effect.progress, effect.options.blockPoint)
                end
            end
        end
        
        -- Update target position if tracking offsets and we have a target entity
        if effect.trackTargetOffsets and effect.targetEntity then
            -- Include wizard offsets in target position
            local targetWizard = effect.targetEntity
            if targetWizard and targetWizard.x and targetWizard.y then
                local xOffset = targetWizard.currentXOffset or 0
                local yOffset = targetWizard.currentYOffset or 0
                
                -- Update the effect's target position to follow the wizard
                effect.targetX = targetWizard.x + xOffset
                effect.targetY = targetWizard.y + yOffset
            end
        end
        
        -- Update effect based on type using the dispatcher
        local effectType = effect.type
        local updater = VFX.updaters[effectType]
        if updater then
            -- Add safety pcall to prevent crashes
            local success, err = pcall(function()
                updater(effect, dt)
            end)

            if not success then
                print(string.format("[VFX] Error updating effect type '%s': %s", tostring(effectType), tostring(err)))
            end
        else
            -- Fallback or warning for unhandled types
            print("[VFX] Warning: No updater found for VFX type: " .. tostring(effectType))
        end
        
        -- Remove effect if complete
        if effect.progress >= 1.0 then
            -- Execute onComplete callback if it exists
            if effect.options and effect.options.onComplete then
                print("[VFX] Executing onComplete callback for effect: " .. (effect.name or "unnamed"))
                local success, err = pcall(function()
                    effect.options.onComplete(effect)
                end)
                
                if not success then
                    print("[VFX] Error in onComplete callback: " .. tostring(err))
                end
            end
            
            -- Release the effect and its particles back to their pools
            local removedEffect = table.remove(VFX.activeEffects, i)
            Pool.release("vfx_effect", removedEffect)
        else
            i = i + 1
        end
        
        ::next_effect::
        -- Continue label for the loop
    end
end

-- Draw all active effects
function VFX.draw()
    for _, effect in ipairs(VFX.activeEffects) do
        local effectType = effect.type
        local drawer = VFX.drawers[effectType]
        if drawer then
            -- Preserve current graphics state so individual effect draw calls
            -- cannot permanently modify color or blend mode
            local prevR, prevG, prevB, prevA = love.graphics.getColor()
            local prevBlendSrc, prevBlendDst = love.graphics.getBlendMode()

            -- Add safety pcall to prevent crashes
            local success, err = pcall(function()
                drawer(effect)
            end)

            -- Restore graphics state
            love.graphics.setColor(prevR, prevG, prevB, prevA)
            love.graphics.setBlendMode(prevBlendSrc, prevBlendDst)

            if not success then
                print(string.format("[VFX] Error drawing effect type '%s': %s", tostring(effectType), tostring(err)))
            end
        else
            -- Fallback or warning for unhandled types
            print("[VFX] Warning: No drawer found for VFX type: " .. tostring(effectType))
        end
    end
end
-- Helper function for HSV to RGB conversion (for volatile conjuring rainbow effect)
function HSVtoRGB(h, s, v)
    local r, g, b
    
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    
    i = i % 6
    
    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end
    
    return r, g, b
end

-- Show Pool stats in debug mode
function VFX.showPoolStats()
    print("\n=== VFX POOLS STATS ===")
    print(string.format("Active Effects: %d", #VFX.activeEffects))
    print(string.format("Particle Pool Size: %d (Available: %d, Active: %d)",
        Pool.size("vfx_particle"), Pool.available("vfx_particle"), Pool.activeCount("vfx_particle")))
    print(string.format("Effect Pool Size: %d (Available: %d, Active: %d)",
        Pool.size("vfx_effect"), Pool.available("vfx_effect"), Pool.activeCount("vfx_effect")))

    -- Check for potential issues
    local particlePoolActiveCount = Pool.activeCount("vfx_particle")
    local activeParticlesCount = 0

    -- Count actual particles in active effects
    for _, effect in ipairs(VFX.activeEffects) do
        if effect.particles then
            activeParticlesCount = activeParticlesCount + #effect.particles
        end
    end

    -- Report if there's a mismatch
    if particlePoolActiveCount > activeParticlesCount then
        print(string.format("WARNING: Pool reports %d active particles but only %d found in effects",
            particlePoolActiveCount, activeParticlesCount))
        print("This suggests particles are not being properly released back to the pool")
    elseif particlePoolActiveCount < activeParticlesCount then
        print(string.format("WARNING: Found %d particles in effects but pool only reports %d active",
            activeParticlesCount, particlePoolActiveCount))
        print("This suggests particles are being created without using Pool.acquire")
    end

    -- Check particle creation and usage rate
    local creates = Pool.stats.creates["vfx_particle"] or 0
    local acquires = Pool.stats.acquires["vfx_particle"] or 0

    if creates > 0 and acquires > 0 then
        local reuseRate = (acquires - creates) / acquires * 100
        print(string.format("Particle Reuse Rate: %.1f%% (Lower is worse)", reuseRate))

        if reuseRate < 50 then
            print("WARNING: Low particle reuse rate suggests pool is too small or particles aren't being released properly")
        end
    end
end

-- Create an effect with async callback support
-- Currently just a stub - in the future, this could use coroutines or callbacks for complex effects
function VFX.createEffectAsync(effectName, sourceX, sourceY, targetX, targetY, options)
    -- Create the effect normally
    local effect = VFX.createEffect(effectName, sourceX, sourceY, targetX, targetY, options)
    
    -- Return a "promise-like" table with callback support
    return {
        effect = effect,  -- Store a reference to the actual effect
        
        -- Method to register a callback for when the effect completes
        onComplete = function(callback)
            print("[VFX] Async VFX callback registered (stub)")
            -- In a full implementation, this would store the callback and call it 
            -- when the effect completes (tracked via effect.progress reaching 1.0)
            return effect
        end
    }
end

-- Diagnostic function to run on game startup to detect and fix particle pool issues
function VFX.runParticlePoolDiagnostic()
    print("\n=== VFX PARTICLE POOL DIAGNOSTIC ===")
    local stats = ParticleManager.getStats()
    print(string.format("Particle Pool: %d total (%d active, %d available)",
        stats.poolSize, stats.active, stats.available))

    -- Check for active particles that aren't in use
    if stats.active > 0 and #VFX.activeEffects == 0 then
        print("WARNING: Pool reports active particles but no active effects exist")
        print("This suggests particles weren't released properly in a previous session")

        -- Force reset the pool
        print("Resetting particle pool to fix the issue...")
        Pool.clear("vfx_particle")

        -- Recreate with initial size
        Pool.create("vfx_particle", 100, function() return {} end, VFX.resetParticle)

        print("Pool reset complete")
    end

    -- Test particle acquisition and release
    print("Testing particle acquisition and release...")
    local testParticle = ParticleManager.createParticle()
    if testParticle then
        print("Successfully acquired test particle from pool")
        if ParticleManager.releaseParticle(testParticle) then
            print("Successfully released test particle back to pool")
        else
            print("ERROR: Failed to release test particle")
        end
    else
        print("ERROR: Failed to acquire test particle from pool")
    end

    print("Diagnostic complete!")
end

-- Import effect modules
local ProjectileEffect = require("vfx.effects.projectile")
local ImpactEffect = require("vfx.effects.impact")
local BeamEffect = require("vfx.effects.beam")
local ConeEffect = require("vfx.effects.cone")
local AuraEffect = require("vfx.effects.aura")
local ConjureEffect = require("vfx.effects.conjure")
local SurgeEffect = require("vfx.effects.surge")
local RemoteEffect = require("vfx.effects.remote")
local MeteorEffect = require("vfx.effects.meteor")
local ZapEffect = require("vfx.effects.zap")

-- Initialize the updaters table with update functions
-- Map each template name/type to the appropriate handler
VFX.updaters["proj_base"] = ProjectileEffect.update  -- Generic projectile template
VFX.updaters["bolt_base"] = ProjectileEffect.update  -- Bolt uses projectile logic
VFX.updaters["orb_base"] = ProjectileEffect.update   -- Orb uses projectile logic
VFX.updaters["zap_base"] = ZapEffect.update        -- Zap lightning effect
VFX.updaters["impact_base"] = ImpactEffect.update    -- Impact effect template
VFX.updaters["beam_base"] = BeamEffect.update        -- Beam effect template
VFX.updaters["blast_base"] = ConeEffect.update       -- Blast uses cone logic
VFX.updaters["zone_base"] = AuraEffect.update        -- Zone uses aura logic
VFX.updaters["util_base"] = AuraEffect.update        -- Utility uses aura logic
VFX.updaters["surge_base"] = SurgeEffect.update      -- Surge fountain template
VFX.updaters["wave_base"] = ProjectileEffect.update  -- Flowing wave uses projectile logic
VFX.updaters["conjure_base"] = ConjureEffect.update  -- Conjuration template
VFX.updaters["remote_base"] = RemoteEffect.update    -- Remote effect template
VFX.updaters["warp_base"] = RemoteEffect.update      -- Warp uses remote logic
VFX.updaters["shield_hit_base"] = ImpactEffect.update -- Shield hit template

-- Specific effect templates
VFX.updaters["meteor"] = MeteorEffect.update         -- Meteor effect
VFX.updaters["impact"] = ImpactEffect.update         -- Generic impact
VFX.updaters["force_blast"] = ImpactEffect.update    -- Force blast uses impact logic
VFX.updaters["free_mana"] = AuraEffect.update        -- Free mana uses aura logic
VFX.updaters["shield"] = AuraEffect.update           -- Shield uses aura logic
VFX.updaters["emberlift"] = SurgeEffect.update       -- Emberlift uses surge logic
VFX.updaters["range_change"] = SurgeEffect.update    -- Range change uses surge logic

-- Add backward compatibility for critical legacy code paths
-- These keys will be removed in a future update
VFX.updaters[Constants.AttackType.PROJECTILE] = ProjectileEffect.update

-- Initialize the drawers table with draw functions
VFX.drawers["proj_base"] = ProjectileEffect.draw    -- Generic projectile template
VFX.drawers["bolt_base"] = ProjectileEffect.draw    -- Bolt uses projectile logic
VFX.drawers["orb_base"] = ProjectileEffect.draw     -- Orb uses projectile logic
VFX.drawers["zap_base"] = ZapEffect.draw          -- Zap lightning effect
VFX.drawers["impact_base"] = ImpactEffect.draw      -- Impact effect template
VFX.drawers["beam_base"] = BeamEffect.draw          -- Beam effect template
VFX.drawers["blast_base"] = ConeEffect.draw         -- Blast uses cone logic
VFX.drawers["zone_base"] = AuraEffect.draw          -- Zone uses aura logic
VFX.drawers["util_base"] = AuraEffect.draw          -- Utility uses aura logic
VFX.drawers["surge_base"] = SurgeEffect.draw        -- Surge fountain template
VFX.drawers["wave_base"] = ProjectileEffect.draw    -- Flowing wave uses projectile logic
VFX.drawers["conjure_base"] = ConjureEffect.draw    -- Conjuration template
VFX.drawers["remote_base"] = RemoteEffect.draw      -- Remote effect template
VFX.drawers["warp_base"] = RemoteEffect.draw        -- Warp uses remote logic
VFX.drawers["shield_hit_base"] = ImpactEffect.draw  -- Shield hit template

-- Specific effect templates
VFX.drawers["meteor"] = MeteorEffect.draw           -- Meteor effect
VFX.drawers["impact"] = ImpactEffect.draw           -- Generic impact
VFX.drawers["force_blast"] = ImpactEffect.draw      -- Force blast uses impact logic
VFX.drawers["free_mana"] = AuraEffect.draw          -- Free mana uses aura logic
VFX.drawers["shield"] = AuraEffect.draw             -- Shield uses aura logic
VFX.drawers["emberlift"] = SurgeEffect.draw         -- Emberlift uses surge logic
VFX.drawers["range_change"] = SurgeEffect.draw      -- Range change uses surge logic

-- Add backward compatibility for critical legacy code paths
-- These keys will be removed in a future update
VFX.drawers[Constants.AttackType.PROJECTILE] = ProjectileEffect.draw

return VFX```

## ./vfx/ParticleManager.lua
```lua
-- ParticleManager.lua
-- Centralized system for managing VFX particles using the Pool system

local Pool = require("core.Pool")
local Constants = require("core.Constants")
local ParticleManager = {}

-- Create a new particle from the pool
function ParticleManager.createParticle()
    local particle = Pool.acquire("vfx_particle")
    -- Initialize with default values to avoid nil errors
    particle.x = 0
    particle.y = 0
    particle.scale = 1.0
    particle.alpha = 1.0
    particle.rotation = 0
    particle.active = false
    
    return particle
end

-- Release a particle back to the pool
function ParticleManager.releaseParticle(particle)
    if not particle then return false end
    return Pool.release("vfx_particle", particle)
end

-- Safe clean up function for particles in an effect
function ParticleManager.cleanupEffectParticles(particles, condition)
    local i = 1
    local removedCount = 0
    
    while i <= #particles do
        local particle = particles[i]
        
        -- Check if this particle should be removed based on the provided condition function
        if condition(particle) then
            -- Release the particle back to the pool
            ParticleManager.releaseParticle(particle)
            table.remove(particles, i)
            removedCount = removedCount + 1
        else
            i = i + 1
        end
    end
    
    return removedCount
end

-- Release all particles in an array
function ParticleManager.releaseAllParticles(particles)
    -- Go backward through the array to avoid index issues during removal
    for i = #particles, 1, -1 do
        local particle = particles[i]
        if particle then
            ParticleManager.releaseParticle(particle)
        end
        particles[i] = nil
    end
end

-- Clone particle data (copy from one particle to another)
function ParticleManager.cloneParticleData(sourceParticle, targetParticle)
    -- Copy all fields
    for k, v in pairs(sourceParticle) do
        targetParticle[k] = v
    end
    return targetParticle
end

-- Create a meteor particle
function ParticleManager.createMeteorParticle(effect, offsetX, offsetY)
    local particle = ParticleManager.createParticle()
    
    -- Set meteor-specific properties
    particle.type = "meteor"
    particle.offsetX = offsetX
    particle.offsetY = offsetY
    particle.startX = effect.targetX + offsetX  -- Start above the target
    particle.startY = effect.targetY - effect.height + offsetY
    particle.endX = effect.targetX + offsetX * 0.3  -- End at target with reduced offset
    particle.endY = effect.targetY + offsetY * 0.1
    particle.x = particle.startX
    particle.y = particle.startY
    particle.rotation = math.random() * math.pi * 2
    particle.rotationSpeed = (math.random() - 0.5) * 4
    particle.baseScale = 0.3 + math.random() * 0.3
    particle.scale = 0.3 + math.random() * 0.3
    particle.alpha = 1.0
    particle.timeCreated = effect.timer or 0
    particle.lifespan = (effect.duration or 1.4) * (0.7 + math.random() * 0.6)
    particle.assetId = "fireParticle"
    particle.color = effect.color
    
    return particle
end

-- Create a meteor trail particle
function ParticleManager.createMeteorTrailParticle(effect, parentParticle)
    local particle = ParticleManager.createParticle()
    
    -- Set trail-specific properties
    particle.type = "trail"
    particle.x = parentParticle.x + math.random(-5, 5)
    particle.y = parentParticle.y + math.random(-5, 5)
    particle.scale = parentParticle.scale * 0.6
    particle.baseScale = parentParticle.scale * 0.6
    particle.alpha = 0.7
    particle.baseAlpha = 0.7
    particle.timeCreated = effect.timer
    particle.lifespan = 0.2 + math.random() * 0.2
    particle.assetId = "fireParticle"
    particle.color = effect.color
    
    return particle
end

-- Create a meteor impact particle
function ParticleManager.createMeteorImpactParticle(effect, angle)
    local particle = ParticleManager.createParticle()

    -- Set impact-specific properties
    particle.type = "impact"
    particle.angle = angle
    particle.x = effect.targetX
    particle.y = effect.targetY
    particle.maxDist = 40 + math.random() * 20
    particle.scale = 0.3 + math.random() * 0.2
    particle.baseScale = 0.3 + math.random() * 0.2
    particle.alpha = 0.7
    particle.baseAlpha = 0.7
    particle.timeCreated = effect.timer
    particle.lifespan = 0.4 + math.random() * 0.2
    particle.assetId = "sparkle"
    particle.color = effect.color

    return particle
end

-- Create a projectile trail particle
function ParticleManager.createProjectileTrailParticle(effect, headX, headY)
    local particle = ParticleManager.createParticle()

    -- Set trail-specific properties
    particle.x = headX
    particle.y = headY
    particle.xVel = math.random(-30, 30)
    particle.yVel = math.random(-30, 30)
    particle.size = math.random(5, 15) * (effect.size or 1.0)
    particle.alpha = math.random() * 0.5 + 0.5
    particle.life = 0
    particle.maxLife = math.random() * 0.3 + 0.1
    particle.color = effect.color or {1, 1, 1}

    return particle
end

-- Create an impact particle
function ParticleManager.createImpactParticle(effect, angle, delay)
    local particle = ParticleManager.createParticle()

    -- Set impact-specific properties
    particle.baseX = effect.targetX
    particle.baseY = effect.targetY
    particle.x = effect.targetX
    particle.y = effect.targetY
    particle.angle = angle
    particle.delay = delay or 0
    particle.active = false
    particle.animType = "expand"
    particle.maxDist = effect.radius * (0.5 + math.random() * 0.5)
    particle.baseScale = 0.5 + math.random() * 0.5
    particle.scale = particle.baseScale
    particle.alpha = 1.0

    return particle
end

-- Create an aura particle
function ParticleManager.createAuraParticle(effect, angle, orbitId)
    local particle = ParticleManager.createParticle()

    -- Set aura-specific properties
    local distance = effect.radius * (0.6 + math.random() * 0.4)
    local orbitalSpeed = 0.5 + math.random() * 1.5

    particle.angle = angle
    particle.distance = distance
    particle.orbitalSpeed = orbitalSpeed
    particle.scale = effect.startScale
    particle.baseScale = effect.startScale
    particle.alpha = 0 -- Start invisible and fade in
    particle.baseAlpha = 1.0
    particle.rotation = 0
    particle.delay = (angle / (2 * math.pi)) * 0.5
    particle.active = false
    particle.orbitId = orbitId or math.random(1, effect.orbitCount or 2)
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY

    return particle
end

-- Create a beam particle
function ParticleManager.createBeamParticle(effect, position, offset)
    local particle = ParticleManager.createParticle()

    -- Set beam-specific properties
    particle.position = position -- 0 to 1 along beam
    particle.offset = offset -- Perpendicular to beam
    particle.scale = effect.startScale * (0.7 + math.random() * 0.6)
    particle.alpha = 0.8
    particle.rotation = math.random() * math.pi * 2
    particle.delay = math.random() * 0.3
    particle.active = false

    return particle
end

-- Create a cone particle
function ParticleManager.createConeParticle(effect, angle, distance, isWaveParticle, waveIndex)
    local particle = ParticleManager.createParticle()

    -- Common properties
    particle.angle = angle
    particle.rotation = angle -- Align rotation with direction
    particle.delay = math.random() * 0.3 -- Staggered start
    particle.active = false
    particle.motion = effect.motionStyle or Constants.MotionStyle.DIRECTIONAL
    particle.intensityMultiplier = 1.0

    -- Set position at source
    particle.x = effect.sourceX
    particle.y = effect.sourceY

    -- Additional properties for motion
    particle.startTime = 0
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY

    -- Wave-specific properties
    if isWaveParticle then
        particle.isWave = true
        particle.waveIndex = waveIndex
        particle.waveTime = waveIndex / (effect.waveCount or 3) -- Staggered wave timing

        -- Calculate wave speed and distance based on wave index
        local speedMultiplier = 1.0 + (waveIndex - 1) * 0.15
        particle.distance = (effect.coneLength or 320) * 0.95 -- Waves extend almost to max distance
        particle.speed = (effect.waveSpeed or 350) * speedMultiplier
        particle.scale = effect.startScale * (1.5 + waveIndex * 0.1)
        particle.alpha = 0.9

        -- Special effects
        if effect.wavePersistence then
            particle.persistenceFactor = effect.wavePersistence
        end

        if effect.trailingGlowStrength then
            particle.trailGlow = effect.trailingGlowStrength
        end
    else
        -- Regular fill particles
        particle.distance = distance
        particle.speed = math.random(100, 250)

        -- Size variance
        local sizeVariance = effect.particleSizeVariance or 0.6
        particle.scale = effect.startScale * (0.7 + math.random() * sizeVariance)
        particle.alpha = 0.6 + math.random() * 0.4
        particle.isWave = false
    end

    -- Target destination for the particle
    particle.targetX = effect.sourceX + math.cos(angle) * particle.distance
    particle.targetY = effect.sourceY + math.sin(angle) * particle.distance

    return particle
end

-- Create a remote effect particle
function ParticleManager.createRemoteParticle(effect, angle, distance, speed)
    local particle = ParticleManager.createParticle()

    -- Calculate center position
    local centerX = effect.targetX
    local centerY = effect.targetY

    -- Set remote-specific properties
    particle.x = centerX
    particle.y = centerY
    particle.targetX = centerX + math.cos(angle) * distance
    particle.targetY = centerY + math.sin(angle) * distance
    particle.speed = speed
    particle.scale = effect.startScale * (0.5 + math.random() * 0.5) -- Varied scales
    particle.alpha = 0.7 + math.random() * 0.3 -- Slightly varied alpha
    particle.rotation = angle
    particle.delay = math.random() * 0.4
    particle.active = false
    particle.motion = effect.motion
    particle.angle = angle
    particle.distance = distance

    return particle
end

-- Create a conjure particle
function ParticleManager.createConjureParticle(effect, startX, startY, dirX, dirY, speed, delay)
    local particle = ParticleManager.createParticle()

    -- Set conjure-specific properties
    particle.x = startX
    particle.y = startY
    particle.speedX = dirX * speed
    particle.speedY = dirY * speed
    particle.scale = effect.startScale
    particle.alpha = 0 -- Start transparent and fade in
    particle.rotation = math.random() * math.pi * 2
    particle.rotSpeed = math.random(-3, 3)
    particle.delay = delay
    particle.active = false
    particle.finalPulse = false
    particle.finalPulseTime = 0

    return particle
end

-- Create a surge particle
function ParticleManager.createSurgeParticle(effect)
    local particle = ParticleManager.createParticle()

    -- Get effect properties
    local particleSizeVariance = effect.particleSizeVariance or 0.6
    local useSprites = effect.useSprites

    -- Start at the source position
    particle.x = effect.sourceX
    particle.y = effect.sourceY

    -- Parameters for helix motion
    particle.baseRadius = 6 + math.random() * 8
    particle.startAngle = math.random() * math.pi * 2
    particle.spinSpeed = 3 + math.random() * 2
    particle.verticalSpeed = (effect.height or 160) / (effect.duration or 1)

    -- Visual properties with variance
    local sizeVariance = 1.0 + (math.random() * 2 - 1) * particleSizeVariance
    particle.scale = effect.startScale * sizeVariance
    particle.baseScale = particle.scale -- Store for pulsation

    particle.alpha = 0.9 + math.random() * 0.1
    particle.rotation = math.random() * math.pi * 2
    particle.rotationSpeed = math.random(-4, 4) -- Random rotation speed

    -- Assign primitive sprite type for rendering
    local spriteOptions = {"pixel", "twinkle1", "twinkle2"}
    particle.spriteType = spriteOptions[math.random(#spriteOptions)]

    -- Staggered appearance
    particle.delay = math.random() * 0.4
    particle.active = false

    -- Add sprite animation if enabled
    if useSprites then
        particle.useSprite = true
        particle.frameIndex = 1
        particle.frameTimer = 0
        particle.frameRate = effect.spriteFrameRate or 8
    end

    -- Special properties based on effect template settings
    if effect.spiralMotion then
        particle.spiral = true
        particle.spiralFrequency = 5 + math.random() * 3
        particle.spiralAmplitude = 10 + math.random() * 20
        particle.spiralPhase = math.random() * math.pi * 2
        particle.spiralTightness = effect.spiralTightness or 2.5
    end

    if effect.pulsateParticles and math.random() < 0.7 then
        particle.pulsate = true
        particle.pulseRate = 3 + math.random() * 5
        particle.pulseAmount = 0.2 + math.random() * 0.3
    end

    -- Chance for special sparkle particles
    if effect.sparkleChance and math.random() < effect.sparkleChance then
        particle.sparkle = true
        particle.sparkleIntensity = 0.7 + math.random() * 0.3
    end

    -- Add bloom glow effect
    if effect.bloomEffect then
        particle.bloom = true
        particle.bloomIntensity = (effect.bloomIntensity or 0.8) * (0.7 + math.random() * 0.6)
    end

    return particle
end

-- Create a projectile core particle
function ParticleManager.createProjectileCoreParticle(effect, baseAngle, turbulence)
    local particle = ParticleManager.createParticle()

    -- Random position near the projectile core
    local spreadFactor = 4 * turbulence
    local offsetX = math.random(-spreadFactor, spreadFactor)
    local offsetY = math.random(-spreadFactor, spreadFactor)

    -- Set initial state
    particle.x = effect.sourceX + offsetX
    particle.y = effect.sourceY + offsetY
    particle.scale = effect.startScale * (0.9 + math.random() * 0.5) -- Slightly larger scales
    particle.alpha = 1.0
    particle.rotation = math.random() * math.pi * 2

    -- Create leading-edge cluster with minimal delay
    particle.delay = math.random() * 0.05
    particle.active = false
    particle.isCore = true -- Mark as core particle for special rendering
    particle.motion = effect.motion -- Store motion style

    -- Motion properties
    particle.startTime = 0
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY
    particle.targetX = effect.targetX
    particle.targetY = effect.targetY

    -- Add less randomness to motion for more focused projectile
    local angleVar = (math.random() - 0.5) * 0.2 * turbulence
    particle.angle = baseAngle + angleVar
    particle.speed = math.random(200, 260) -- Significantly faster speeds

    -- Life cycle control
    particle.lifespan = (effect.particleLifespan or 0.6) * effect.duration
    particle.timeOffset = math.random() * 0.1
    particle.turbulence = turbulence

    return particle
end

-- Create a projectile trail particle (using core system, not the same as createProjectileTrailParticle)
function ParticleManager.createProjectileFullTrailParticle(effect, baseAngle, turbulence, trailIndex, trailCount)
    local particle = ParticleManager.createParticle()

    -- Trail particles start closer to the core
    local spreadRadius = 6 * (effect.trailDensity or 0.4) * turbulence -- Tighter spread
    local spreadAngle = math.random() * math.pi * 2
    local spreadDist = math.random() * spreadRadius

    -- Set initial state - more directional alignment
    particle.x = effect.sourceX + math.cos(spreadAngle) * spreadDist
    particle.y = effect.sourceY + math.sin(spreadAngle) * spreadDist
    particle.scale = effect.startScale * (0.7 + math.random() * 0.2) -- Slightly smaller
    particle.alpha = 0.7 -- Lower alpha for less visibility
    particle.rotation = math.random() * math.pi * 2

    -- Much shorter staggered delay for trail particles
    particle.delay = (trailIndex / trailCount) * 0.15 -- Cut delay in half for faster response
    particle.active = false
    particle.isCore = false -- Mark as trail particle
    particle.motion = effect.motion

    -- Motion properties
    particle.startTime = 0
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY
    particle.targetX = effect.targetX
    particle.targetY = effect.targetY

    -- Reduce trail spread angle for more directional appearance
    local angleVar = (math.random() - 0.5) * 0.3 * turbulence -- Half the angle variance
    particle.angle = baseAngle + angleVar
    particle.speed = math.random(150, 200) -- Faster than before, closer to core speed

    -- Trail particles have shorter lifespans for smoother fade
    particle.lifespan = (effect.particleLifespan or 0.6) * effect.duration * 0.8
    particle.timeOffset = math.random() * 0.2
    particle.turbulence = turbulence

    -- Which segment of the trail this particle belongs to
    particle.trailSegment = math.random()

    return particle
end

-- Get particle stats
function ParticleManager.getStats()
    return {
        poolSize = Pool.size("vfx_particle"),
        available = Pool.available("vfx_particle"),
        active = Pool.activeCount("vfx_particle")
    }
end

-- Print particle stats to console
function ParticleManager.printStats()
    local stats = ParticleManager.getStats()
    print(string.format("[PARTICLE MANAGER] Pool: %d total (%d active, %d available)", 
        stats.poolSize, stats.active, stats.available))
end

return ParticleManager
```

## ./vfx/effects/aura.lua
```lua
-- aura.lua
-- Aura VFX module for handling aura/circle effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for aura effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for aura effects
local function updateAura(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.radius = effect.radius or 50 -- Default radius
    effect.pulseRate = effect.pulseRate or 5 -- Default pulse rate
    effect.angularSpeed = effect.angularSpeed or 1.5 -- Default angular speed
    effect.orbitCount = effect.orbitCount or 2 -- Default orbit count
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update orbital particles
    for i, particle in ipairs(effect.particles) do
        -- Skip invalid particles
        if not particle then
            goto next_particle
        end
        
        -- Initialize particle properties if missing
        particle.delay = particle.delay or 0
        particle.active = particle.active or false
        particle.angle = particle.angle or 0
        particle.radius = particle.radius or effect.radius
        particle.orbitId = particle.orbitId or 1
        
        -- Check if particle should be active based on delay
        if effect.timer > particle.delay then
            particle.active = true
        end
        
        if particle.active then
            -- Calculate particle progress
            local particleProgress = math.min((effect.timer - particle.delay) / (effect.duration - particle.delay), 1.0)
            
            -- Update orbital position
            particle.angle = particle.angle + dt * (effect.angularSpeed or 1.5)
            
            -- Different orbits have different radii and move in opposite directions
            local orbitRadius = effect.radius * (0.8 + 0.4 * (particle.orbitId / (effect.orbitCount or 2)))
            
            -- Alternate direction for different orbits
            if particle.orbitId % 2 == 0 then
                particle.angle = particle.angle - dt * (effect.angularSpeed or 1.5) * 2
            end
            
            -- Update particle position
            particle.x = effect.sourceX + math.cos(particle.angle) * orbitRadius
            particle.y = effect.sourceY + math.sin(particle.angle) * orbitRadius
            
            -- Calculate fade based on progress
            -- Start visible, peak at 50%, then fade out
            local fadeProgress = 1.0 - math.abs(particleProgress - 0.5) * 2
            particle.alpha = fadeProgress * (particle.baseAlpha or 1.0)
            
            -- Pulse size
            local pulse = math.sin(effect.timer * (effect.pulseRate or 5) + particle.angle) * 0.3 + 0.7
            particle.scale = (particle.baseScale or 0.3) * pulse
        end
        
        ::next_particle::
    end
end

-- Draw function for aura effects
local function drawAura(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default position
    effect.sourceY = effect.sourceY or 0 -- Default position
    effect.radius = effect.radius or 50 -- Default radius
    effect.pulseRate = effect.pulseRate or 5 -- Default pulse rate
    
    local particleImage = getAssetInternal("sparkle")
    
    -- Draw base aura circle
    local pulseAmount = math.sin(effect.timer * effect.pulseRate) * 0.2
    local baseAlpha = 0.3 * (1 - (math.abs(effect.progress - 0.5) * 2)^2) -- Peak at middle of effect
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], baseAlpha)
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, effect.radius * (1 + pulseAmount))
    love.graphics.setColor(effect.color[1] * 1.3, effect.color[2] * 1.3, effect.color[3] * 1.3, baseAlpha * 1.5)
    love.graphics.circle("line", effect.sourceX, effect.sourceY, effect.radius * (1 + pulseAmount))
    
    -- Draw particles with additive blending for brighter core
    local prevMode = {love.graphics.getBlendMode()}
    love.graphics.setBlendMode("add")
    
    -- Draw central glow
    local centerGlowSize = effect.radius * 0.4
    local centerPulse = math.sin(effect.timer * effect.pulseRate * 1.5) * 0.2 + 0.8
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], baseAlpha * 1.2)
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * centerPulse)
    
    -- Draw bright center
    love.graphics.setColor(1, 1, 1, baseAlpha * 1.5)
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.3 * centerPulse)
    
    -- Restore blend mode
    love.graphics.setBlendMode(prevMode[1], prevMode[2])
    
    -- Draw individual particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        ::next_draw_particle::
    end
end

-- Initialize function for aura effects
local function initializeAura(effect)
    -- For aura effects, create particles that orbit the character using ParticleManager
    for i = 1, effect.particleCount do
        local angle = (i / effect.particleCount) * math.pi * 2
        local orbitId = math.ceil(i / (effect.particleCount / (effect.orbitCount or 2)))

        -- Create particle using specialized helper
        local particle = ParticleManager.createAuraParticle(effect, angle, orbitId)

        -- Add motion information
        particle.motion = effect.motion -- Store motion style on particle

        -- Add additional properties for special motion
        particle.startTime = 0

        -- Calculate distance and orbitalSpeed for legacy code compatibility
        local distance = particle.distance or (effect.radius * 0.8)
        local orbitalSpeed = particle.orbitalSpeed or 1.5

        particle.targetX = effect.sourceX + math.cos(angle) * distance
        particle.targetY = effect.sourceY + math.sin(angle) * distance
        particle.speed = orbitalSpeed * 30

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeAura,
    update = updateAura,
    draw = drawAura
}```

## ./vfx/effects/beam.lua
```lua
-- beam.lua
-- Beam VFX module for handling beam/laser effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for beam effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for beam effects
local function updateBeam(effect, dt)
    -- Initialize effect default values if not already set
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.beamWidth = effect.beamWidth or 15 -- Default beam width
    effect.sourceX = effect.sourceX or 0 -- Default source position
    effect.sourceY = effect.sourceY or 0 -- Default source position
    effect.targetX = effect.targetX or 400 -- Default target position
    effect.targetY = effect.targetY or 0 -- Default target position
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Enhanced beam update with shield block handling
    local Constants = require("core.Constants")

    -- Update beam properties based on current source and target positions
    -- This ensures the beam adjusts if the wizards move due to range/elevation changes
    effect.beamLength = math.sqrt((effect.targetX - effect.sourceX)^2 + (effect.targetY - effect.sourceY)^2)
    effect.beamAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)

    -- Determine which progress value to use (normal vs. visualProgress for blocked beams)
    local baseProgress = effect.visualProgress or effect.progress

    -- Apply pulsing effect
    effect.pulseTimer = (effect.pulseTimer or 0) + dt * 10
    effect.pulseFactor = 0.7 + 0.3 * math.sin(effect.pulseTimer)

    -- Handle beam progress for blocked beams
    local blockPoint = effect.blockPoint or 1.0

    -- Handle shield block specific effects
    if effect.isBlocked and not effect.impactEffectCreated and baseProgress >= blockPoint then
        -- Create shield impact effect
        effect.impactEffectCreated = true

        -- Calculate impact position
        local impactX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * blockPoint)
        local impactY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * blockPoint)

        print(string.format("[BEAM] Creating shield impact effect at (%.1f, %.1f)", impactX, impactY))

        -- Get the VFX module (should be loaded by now)
        if not VFX then VFX = require("vfx") end

        -- Determine shield color based on shield type
        local shieldColor = {1.0, 1.0, 0.3, 0.7}  -- Default yellow
        local shieldType = effect.blockType or (effect.options and effect.options.shieldType)
        if shieldType == "ward" then
            shieldColor = {0.3, 0.3, 1.0, 0.7}  -- Blue for wards
        elseif shieldType == "field" then
            shieldColor = {0.3, 1.0, 0.3, 0.7}  -- Green for fields
        end

        -- Create shield impact effect
        if VFX.createEffect then
            -- Impact flash effect
            local flashParams = {
                duration = 0.3,
                scale = (effect.startScale or 1.0) * 1.5,
                color = {shieldColor[1], shieldColor[2], shieldColor[3], 0.9},
                particleCount = 8
            }
            VFX.createEffect("impact_base", impactX, impactY, impactX, impactY, flashParams)

            -- Particle burst effect
            local burstParams = {
                duration = 0.8,
                scale = (effect.startScale or 1.0) * 1.2,
                color = shieldColor,
                particleCount = 30
            }
            VFX.createEffect("impact_base", impactX, impactY, impactX, impactY, burstParams)
        end

        -- Trigger screen shake for beam impact
        local gameState = nil

        -- Try to find the game state through various references
        if effect.options and effect.options.gameState then
            gameState = effect.options.gameState
        elseif effect.options and effect.options.sourceEntity and effect.options.sourceEntity.gameState then
            gameState = effect.options.sourceEntity.gameState
        elseif effect.options and effect.options.targetEntity and effect.options.targetEntity.gameState then
            gameState = effect.options.targetEntity.gameState
        elseif _G.game then
            gameState = _G.game
        elseif VFX.gameState then
            gameState = VFX.gameState
        end

        -- Determine impact amount for shake intensity
        local amount = effect.options and effect.options.amount or 12  -- Beams are powerful
        local intensity = math.min(5, 2.5 + (amount / 20))  -- Slightly more intense than projectiles
        local shakeDuration = 0.25  -- Longer duration for beam

        -- Trigger shake if we have access to game state
        if gameState and gameState.triggerShake then
            gameState.triggerShake(shakeDuration, intensity)
            print(string.format("[BEAM] Shield block impact! Triggered shake (%.2f, %.2f) at blockPoint=%.2f",
                shakeDuration, intensity, blockPoint))
        elseif VFX.triggerShake then
            VFX.triggerShake(shakeDuration, intensity)
        end
    end

    -- If beam is blocked, it should stop at the block point
    if effect.isBlocked and baseProgress > blockPoint then
        effect.beamProgress = blockPoint
    else
        effect.beamProgress = baseProgress
    end
    
    -- Update beam particles
    if effect.particles then
        -- Update existing particles
        local i = 1
        while i <= #effect.particles do
            local particle = effect.particles[i]
            
            -- Skip invalid particles
            if not particle then
                table.remove(effect.particles, i)
                goto next_particle
            end
            
            -- Initialize any missing particle properties
            particle.life = particle.life or 0
            particle.maxLife = particle.maxLife or 0.5
            particle.alpha = particle.alpha or 1.0
            particle.scale = particle.scale or 1.0
            particle.startScale = particle.startScale or particle.scale
            
            -- Update particle lifetime
            particle.life = particle.life + dt
            
            -- Remove expired particles
            if particle.life >= particle.maxLife then
                table.remove(effect.particles, i)
            else
                -- Update particle position and alpha
                local lifeProgress = particle.life / particle.maxLife
                
                -- Update alpha (fade out)
                particle.alpha = 1.0 - lifeProgress
                
                -- Update scale (grow slightly then shrink)
                particle.scale = particle.startScale * (1.0 + lifeProgress * 0.5 - lifeProgress * lifeProgress)
                
                -- Move to next particle
                i = i + 1
            end
            
            ::next_particle::
        end
        
        -- Add many new particles for dense swarm effect
        local particleRate = 3.0 -- Much higher rate for particle swarm
        
        -- Generate multiple particles per frame
        local particlesThisFrame = math.floor(particleRate)
        if math.random() < (particleRate - particlesThisFrame) then
            particlesThisFrame = particlesThisFrame + 1
        end
        
        for i = 1, particlesThisFrame do
            -- Add particles at source with variety
            local sourceParticle = {
                x = effect.sourceX + math.random(-8, 8),
                y = effect.sourceY + math.random(-8, 8),
                scale = math.random(1, 3),
                startScale = math.random(1, 3),
                alpha = 1.0,
                life = 0,
                maxLife = math.random() * 0.3 + 0.15,
                active = true,
                spriteType = ({"pixel", "twinkle1", "twinkle2"})[math.random(3)]
            }
            table.insert(effect.particles, sourceParticle)
            
            -- Add particles along the beam path
            if effect.beamProgress > 0.1 then
                local beamPos = math.random() * effect.beamProgress
                local beamX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * beamPos)
                local beamY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * beamPos)
                
                -- Perpendicular offset for beam width
                local perpAngle = effect.beamAngle + math.pi/2
                local perpOffset = (math.random() - 0.5) * effect.beamWidth
                
                local beamParticle = {
                    x = beamX + math.cos(perpAngle) * perpOffset,
                    y = beamY + math.sin(perpAngle) * perpOffset,
                    scale = math.random(1, 2),
                    startScale = math.random(1, 2),
                    alpha = 1.0,
                    life = 0,
                    maxLife = math.random() * 0.2 + 0.1,
                    active = true,
                    spriteType = ({"pixel", "twinkle1", "twinkle2"})[math.random(3)]
                }
                table.insert(effect.particles, beamParticle)
            end
            
            -- Add particles at impact point (if beam has traveled that far)
            if effect.beamProgress > 0.5 then
                local impactX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * effect.beamProgress)
                local impactY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * effect.beamProgress)
                
                local impactParticle = {
                    x = impactX + math.random(-12, 12),
                    y = impactY + math.random(-12, 12),
                    scale = math.random(2, 4),
                    startScale = math.random(2, 4),
                    alpha = 1.0,
                    life = 0,
                    maxLife = math.random() * 0.25 + 0.15,
                    active = true,
                    spriteType = ({"pixel", "twinkle1", "twinkle2"})[math.random(3)]
                }
                table.insert(effect.particles, impactParticle)
            end
        end
    end
end

-- Draw function for beam effects
local function drawBeam(effect)
    -- Preserve the current line width and blend mode so we can restore them after drawing
    local prevLineWidth = love.graphics.getLineWidth()
    local prevBlendMode = {love.graphics.getBlendMode()}
    
    -- Make sure essential properties exist
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default position
    effect.sourceY = effect.sourceY or 0 -- Default position
    effect.beamLength = effect.beamLength or 400 -- Default length
    effect.beamAngle = effect.beamAngle or 0 -- Default angle
    effect.beamProgress = effect.beamProgress or effect.progress or 1.0 -- Default progress
    effect.beamWidth = effect.beamWidth or 15 -- Default width
    effect.pulseFactor = effect.pulseFactor or 1.0 -- Default pulse
    
    local particleImage = getAssetInternal("sparkle")
    local onePxImage = getAssetInternal("pixel")
    local twinkle1Image = getAssetInternal("twinkle1")
    local twinkle2Image = getAssetInternal("twinkle2")
    
    -- Use current beam properties (which have been updated in updateBeam)
    local beamLength = effect.beamLength * effect.beamProgress
    
    -- Draw particle-based beam core instead of line shapes
    local beamEndX = effect.sourceX + math.cos(effect.beamAngle) * beamLength
    local beamEndY = effect.sourceY + math.sin(effect.beamAngle) * beamLength
    
    -- Calculate beam width with pulse
    local pulseValue = effect.pulseFactor or 1.0
    local beamWidth = (effect.beamWidth or 15) * pulseValue
    
    -- Draw beam using dense particle chains
    local particlesAlongBeam = math.floor(beamLength / 3) -- One particle every 3 pixels
    
    for i = 0, particlesAlongBeam do
        local t = i / math.max(1, particlesAlongBeam)
        local coreX = effect.sourceX + (beamEndX - effect.sourceX) * t
        local coreY = effect.sourceY + (beamEndY - effect.sourceY) * t
        
        -- Perpendicular angle for beam width spread
        local perpAngle = effect.beamAngle + math.pi/2
        
        -- Draw outer glow particles
        local outerParticles = math.floor(beamWidth / 4)
        for j = 1, outerParticles do
            local offset = (j / outerParticles - 0.5) * beamWidth * 1.5
            local px = coreX + math.cos(perpAngle) * offset
            local py = coreY + math.sin(perpAngle) * offset
            
            love.graphics.setColor(
                effect.color[1] * 0.4, 
                effect.color[2] * 0.4, 
                effect.color[3] * 0.4, 
                0.3 * (1 - math.abs(offset) / (beamWidth * 0.75))
            )
            
            local sprite = onePxImage or twinkle1Image
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1.5 + math.random() * 0.5, 1.5 + math.random() * 0.5,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Save current blend mode and set to additive for core
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw inner core particles with additive blending
        local innerParticles = math.floor(beamWidth / 6)
        for j = 1, innerParticles do
            local offset = (j / innerParticles - 0.5) * beamWidth * 0.7
            local px = coreX + math.cos(perpAngle) * offset
            local py = coreY + math.sin(perpAngle) * offset
            
            love.graphics.setColor(
                math.min(1.0, effect.color[1] * 1.3), 
                math.min(1.0, effect.color[2] * 1.3), 
                math.min(1.0, effect.color[3] * 1.3), 
                0.7 * (1 - math.abs(offset) / (beamWidth * 0.35))
            )
            
            local sprite = (j % 2 == 0) and twinkle1Image or twinkle2Image
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1.2 + math.random() * 0.3, 1.2 + math.random() * 0.3,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Draw brightest center particles
        local centerParticles = math.floor(beamWidth / 10) + 1
        for j = 1, centerParticles do
            local offset = (j / centerParticles - 0.5) * beamWidth * 0.3
            local px = coreX + math.cos(perpAngle) * offset
            local py = coreY + math.sin(perpAngle) * offset
            
            love.graphics.setColor(1, 1, 1, 0.9 * (1 - math.abs(offset) / (beamWidth * 0.15)))
            
            local sprite = twinkle2Image or onePxImage
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1 + math.random() * 0.2, 1 + math.random() * 0.2,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw source glow using particle swarm
    local sourceParticleCount = 15
    local sourceRadius = beamWidth * 0.7
    
    for i = 1, sourceParticleCount do
        local angle = (i / sourceParticleCount) * math.pi * 2 + love.timer.getTime() * 3
        local radius = sourceRadius * (0.4 + math.random() * 0.6)
        local px = effect.sourceX + math.cos(angle) * radius
        local py = effect.sourceY + math.sin(angle) * radius
        
        love.graphics.setColor(
            effect.color[1], 
            effect.color[2], 
            effect.color[3], 
            (0.5 + math.random() * 0.3) * pulseValue
        )
        
        local sprite = (i % 3 == 0) and twinkle1Image or ((i % 3 == 1) and onePxImage or twinkle2Image)
        if sprite then
            love.graphics.draw(
                sprite, px, py, 0,
                1 + math.random() * 0.5, 1 + math.random() * 0.5,
                sprite:getWidth()/2, sprite:getHeight()/2
            )
        end
    end
    
    -- Draw impact glow using particle swarm
    local impactParticleCount = 18
    local impactRadius = beamWidth * 0.9
    
    for i = 1, impactParticleCount do
        local angle = (i / impactParticleCount) * math.pi * 2 + love.timer.getTime() * 4
        local radius = impactRadius * (0.3 + math.random() * 0.7)
        local px = beamEndX + math.cos(angle) * radius
        local py = beamEndY + math.sin(angle) * radius
        
        love.graphics.setColor(
            effect.color[1], 
            effect.color[2], 
            effect.color[3], 
            (0.6 + math.random() * 0.4) * pulseValue
        )
        
        local sprite = (i % 3 == 0) and twinkle2Image or ((i % 3 == 1) and twinkle1Image or onePxImage)
        if sprite then
            love.graphics.draw(
                sprite, px, py, 0,
                1.2 + math.random() * 0.8, 1.2 + math.random() * 0.8,
                sprite:getWidth()/2, sprite:getHeight()/2
            )
        end
    end
    
    -- Draw particles using primitive sprites
    if effect.particles then
        for _, particle in ipairs(effect.particles) do
            -- Skip invalid or inactive particles
            if not particle or not particle.active then
                goto next_draw_particle
            end
            
            -- Ensure required properties exist
            particle.alpha = particle.alpha or 1.0
            particle.scale = particle.scale or 1.0
            particle.x = particle.x or effect.sourceX
            particle.y = particle.y or effect.sourceY
            
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.9)
            
            -- Choose sprite based on particle type
            local sprite = nil
            if particle.spriteType == "pixel" and onePxImage then
                sprite = onePxImage
            elseif particle.spriteType == "twinkle1" and twinkle1Image then
                sprite = twinkle1Image
            elseif particle.spriteType == "twinkle2" and twinkle2Image then
                sprite = twinkle2Image
            else
                -- Fallback to any available primitive
                sprite = onePxImage or twinkle1Image or twinkle2Image or particleImage
            end
            
            if sprite then
                love.graphics.draw(
                    sprite,
                    particle.x, particle.y,
                    0,
                    particle.scale / 3, particle.scale / 3,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            else
                -- Final fallback
                love.graphics.circle("fill", particle.x, particle.y, particle.scale)
            end
            
            ::next_draw_particle::
        end
    end
    
    -- Draw blocked impact flash if beam hit a shield
    if effect.isBlocked and effect.blockPoint and effect.progress > effect.blockPoint then
        -- Calculate impact point
        local blockX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * effect.blockPoint)
        local blockY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * effect.blockPoint)

        -- Calculate impact flash size and alpha
        local impactProgress = (effect.progress - effect.blockPoint) / (1 - effect.blockPoint)
        local flashSize = 40 * (1.0 - impactProgress) * effect.pulseFactor
        local flashAlpha = 0.7 * (1.0 - impactProgress)

        -- Set to additive blending for bright flash
        love.graphics.setBlendMode("add")

        -- Draw impact flash using particle swarm
        local flashParticleCount = math.floor(flashSize / 3)
        for i = 1, flashParticleCount do
            local angle = (i / flashParticleCount) * math.pi * 2
            local radius = flashSize * (0.2 + math.random() * 0.8)
            local px = blockX + math.cos(angle) * radius
            local py = blockY + math.sin(angle) * radius
            
            love.graphics.setColor(1, 1, 1, flashAlpha * (0.6 + math.random() * 0.4))
            
            local sprite = (i % 3 == 0) and twinkle1Image or ((i % 3 == 1) and onePxImage or twinkle2Image)
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    2 + math.random() * 2, 2 + math.random() * 2,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end

        -- Get shield color based on type for distinctive visuals
        local shieldR, shieldG, shieldB = 1.0, 1.0, 0.3 -- Default yellow
        local shieldType = effect.blockType or (effect.options and effect.options.shieldType)
        if shieldType == "ward" then
            shieldR, shieldG, shieldB = 0.3, 0.3, 1.0 -- Blue for wards
        elseif shieldType == "field" then
            shieldR, shieldG, shieldB = 0.3, 1.0, 0.3 -- Green for fields
        end

        -- Draw colored shield impact ring
        love.graphics.setColor(shieldR, shieldG, shieldB, flashAlpha * 0.9)
        local ringSize = flashSize * 1.2
        local ringWidth = 3
        love.graphics.setLineWidth(ringWidth)
        love.graphics.circle("line", blockX, blockY, ringSize)

        -- Draw radial beams emanating from impact point
        local beamCount = 8
        for i = 1, beamCount do
            local angle = (i / beamCount) * math.pi * 2 + (effect.progress * 3)
            local rayLength = ringSize * (0.8 + 0.4 * math.sin(impactProgress * math.pi * 6))
            local x2 = blockX + math.cos(angle) * rayLength
            local y2 = blockY + math.sin(angle) * rayLength

            love.graphics.setLineWidth(ringWidth * 0.6)
            love.graphics.line(blockX, blockY, x2, y2)
        end

        -- Draw shield specific effects if applicable
        if shieldType and (shieldType == "ward" or shieldType == "barrier") then
            -- Shield-specific visualization
            local runeImages = getAssetInternal("runes")
            if runeImages and #runeImages > 0 then
                -- Get a deterministic rune index
                local runeIndex
                if effect.id then
                    runeIndex = (effect.id % #runeImages) + 1
                else
                    -- Calculate a stable index from the positions
                    local posHash = math.floor(effect.sourceX + effect.sourceY + effect.targetX + effect.targetY)
                    runeIndex = (posHash % #runeImages) + 1
                end
                local runeImage = runeImages[runeIndex]

                -- Draw the rune with rotation and pulsing
                local runeSize = 0.5 * (1 + 0.3 * math.sin(impactProgress * math.pi * 4))
                local runeAlpha = flashAlpha * 0.9

                love.graphics.setColor(1, 1, 1, runeAlpha)

                if runeImage then
                    love.graphics.draw(
                        runeImage,
                        blockX, blockY,
                        impactProgress * math.pi * 2,
                        runeSize, runeSize,
                        runeImage:getWidth()/2, runeImage:getHeight()/2
                    )
                end
            end
        end

        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end

    -- Restore the previous line width, blend mode, and color to avoid affecting other draw calls
    love.graphics.setLineWidth(prevLineWidth)
    love.graphics.setBlendMode(prevBlendMode[1], prevBlendMode[2])
    love.graphics.setColor(1, 1, 1, 1)
end

-- Initialize function for beam effects
local function initializeBeam(effect)
    -- First create the main beam shape
    effect.beamProgress = 0
    effect.beamLength = math.sqrt((effect.targetX - effect.sourceX)^2 + (effect.targetY - effect.sourceY)^2)
    effect.beamAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)

    -- Check for block info and set block properties
    if effect.options and effect.options.blockPoint then
        print(string.format("[BEAM INIT] Detected block at point %.2f", effect.options.blockPoint))
        effect.isBlocked = true
        effect.blockPoint = effect.options.blockPoint
        effect.blockType = effect.options.shieldType or "ward"
    end

    -- Then add particles along the beam
    for i = 1, effect.particleCount do
        local position = math.random()
        local offset = math.random(-10, 10)

        -- Create particle using ParticleManager
        local particle = ParticleManager.createBeamParticle(effect, position, offset)

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeBeam,
    update = updateBeam,
    draw = drawBeam
}```

## ./vfx/effects/cone.lua
```lua
-- cone.lua
-- Cone VFX module for handling cone/blast effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for cone effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for cone effects
local function updateCone(effect, dt)
    -- Initialize effect default values if not already set
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.waveCount = effect.waveCount or 3 -- Default wave count
    effect.coneAngle = effect.coneAngle or 70 -- Default cone angle (degrees)
    effect.beamDist = effect.beamDist or 200 -- Default beam distance
    effect.waveCrestSize = effect.waveCrestSize or 1.0 -- Default wave crest size
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Calculate the base direction from source to target
    local dirX = effect.targetX - effect.sourceX
    local dirY = effect.targetY - effect.sourceY
    local baseAngle = math.atan2(dirY, dirX)
    
    -- Update wave timing
    local waveCount = effect.waveCount or 3
    for i = 1, waveCount do
        -- Calculate when this wave should start
        local waveStartTime = (i - 1) * effect.duration * 0.3 / waveCount
        
        -- Update wave progress
        if effect.timer >= waveStartTime then
            -- Calculate how far this wave has traveled
            local waveProgress = math.min(1.0, (effect.timer - waveStartTime) / (effect.duration * 0.8))
            
            -- Store wave progress for drawing
            effect.waves = effect.waves or {}
            effect.waves[i] = {
                progress = waveProgress,
                startTime = waveStartTime,
                crestDelay = i * 0.05, -- Slight delay for the wave crest visualization
                age = effect.timer - waveStartTime
            }
        end
    end
    
    -- Apply intensity multiplier based on range band
    -- This makes close-range cones more powerful (wider, more intense colors)
    if not effect.rangeFactorApplied then
        if effect.rangeBand == "CLOSE" then
            effect.coneAngle = effect.coneAngle * 1.2
            effect.waveCrestSize = effect.waveCrestSize * 1.3
            effect.currentIntensityMultiplier = 1.3
        elseif effect.rangeBand == "MID" then
            effect.coneAngle = effect.coneAngle * 1.1
            effect.waveCrestSize = effect.waveCrestSize * 1.15
            effect.currentIntensityMultiplier = 1.15
        elseif effect.rangeBand == "FAR" then
            -- Default, no change
            effect.currentIntensityMultiplier = 1.0
        else
            -- Default, no change
            effect.currentIntensityMultiplier = 1.0
        end
        
        effect.rangeFactorApplied = true
    end
    
    -- Add particles at cone edges and along the waves
    if math.random() < 0.3 then
        -- Calculate cone properties
        local coneAngleRad = (effect.coneAngle or 70) * math.pi / 180
        local beamDist = effect.beamDist or 200
        
        -- Spawn particles along current wave fronts
        if effect.waves then
            for i, wave in ipairs(effect.waves) do
                -- Only add particles if the wave has started but not fully dissipated
                if wave.progress > 0 and wave.progress < 0.9 then
                    -- Calculate wave position (distance from source)
                    local waveDist = beamDist * wave.progress
                    
                    -- Add particles along the wave front
                    local numParticles = math.random(1, 3)
                    for j = 1, numParticles do
                        -- Calculate random angle within the cone
                        local randomAngleOffset = (math.random() * 2 - 1) * coneAngleRad / 2
                        local particleAngle = baseAngle + randomAngleOffset
                        
                        -- Calculate position
                        local distanceVariation = math.random() * 10 - 5
                        local particleDist = waveDist + distanceVariation
                        local particleX = effect.sourceX + math.cos(particleAngle) * particleDist
                        local particleY = effect.sourceY + math.sin(particleAngle) * particleDist
                        
                        -- Create particle
                        local particle = {
                            x = particleX,
                            y = particleY,
                            angle = particleAngle,
                            scale = math.random(10, 30) / 100,
                            alpha = math.random() * 0.7 + 0.3,
                            life = 0,
                            maxLife = math.random() * 0.2 + 0.1,
                            active = true
                        }
                        
                        table.insert(effect.particles, particle)
                    end
                end
            end
        end
    end
    
    -- Update existing particles
    local i = 1
    while i <= #effect.particles do
        local particle = effect.particles[i]
        
        -- Skip invalid particles
        if not particle then
            table.remove(effect.particles, i)
            goto next_particle
        end
        
        -- Initialize any missing particle properties
        particle.life = particle.life or 0
        particle.maxLife = particle.maxLife or 0.3
        particle.alpha = particle.alpha or 1.0
        particle.scale = particle.scale or 0.2
        
        -- Update particle lifetime
        particle.life = particle.life + dt
        
        -- Remove expired particles
        if particle.life >= particle.maxLife then
            table.remove(effect.particles, i)
        else
            -- Update particle properties
            local lifeProgress = particle.life / particle.maxLife
            
            -- Fade out
            particle.alpha = (1.0 - lifeProgress) * particle.alpha
            
            -- Grow slightly then shrink
            particle.scale = particle.scale * (1.0 + lifeProgress * 0.3 - lifeProgress * lifeProgress * 0.6)
            
            -- Move to next particle
            i = i + 1
        end
        
        ::next_particle::
    end
end

-- Draw function for cone effects
local function drawCone(effect)
    -- Initialize effect default values if not already set
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.waves = effect.waves or {} -- Initialize waves array if nil
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.coneAngle = effect.coneAngle or 70 -- Default cone angle (degrees)
    effect.beamDist = effect.beamDist or 200 -- Default beam distance
    effect.currentIntensityMultiplier = effect.currentIntensityMultiplier or 1.0 -- Default intensity multiplier
    
    -- Get assets
    local particleImage = getAssetInternal("sparkle")
    local glowImage = getAssetInternal("fireGlow") -- For enhanced glow effects
    
    -- Get intensity multiplier for range-based effects
    local intensityMult = effect.currentIntensityMultiplier or 1.0
    
    -- Draw background glow for the entire cone area at the beginning
    if effect.progress < 0.5 then
        -- Calculate cone properties
        local coneAngleRad = (effect.coneAngle or 70) * math.pi / 180
        local baseAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)
        local beamDist = effect.beamDist or 200
        
        -- Calculate glow alpha based on progress
        local glowAlpha = 0.3 * (0.5 - effect.progress) / 0.5
        
        -- Draw ambient background glow for the cone area
        local trianglePoints = {}
        
        -- Start from source point
        table.insert(trianglePoints, effect.sourceX)
        table.insert(trianglePoints, effect.sourceY)
        
        -- Number of points to create a smooth cone edge
        local numPoints = 10
        for i = 0, numPoints do
            local angle = baseAngle - coneAngleRad/2 + i * (coneAngleRad / numPoints)
            local x = effect.sourceX + math.cos(angle) * beamDist
            local y = effect.sourceY + math.sin(angle) * beamDist
            table.insert(trianglePoints, x)
            table.insert(trianglePoints, y)
        end
        
        -- Draw cone glow background
        love.graphics.setColor(effect.color[1] * 0.5, effect.color[2] * 0.5, effect.color[3] * 0.5, glowAlpha)
        love.graphics.polygon("fill", trianglePoints)
    end
    
    -- Draw the wave bands
    if effect.waves then
        for i, wave in ipairs(effect.waves) do
            -- Only draw if wave has started
            if wave.progress > 0 then
                -- Calculate wave properties
                local waveFront = wave.progress
                local waveBack = math.max(0, waveFront - 0.2)
                local waveFade = math.min(1.0, (1.0 - wave.progress) * 2)
                
                -- Calculate cone properties
                local coneAngleRad = (effect.coneAngle or 70) * math.pi / 180
                local baseAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)
                local beamDist = effect.beamDist or 200
                
                -- Calculate color based on effect color
                local r = effect.color[1] * intensityMult
                local g = effect.color[2] * intensityMult
                local b = effect.color[3] * intensityMult
                local a = 0.7 * waveFade
                
                -- Draw the wave segments
                local segments = 10
                local prevX1, prevY1, prevX2, prevY2 = nil, nil, nil, nil
                
                for j = 0, segments do
                    -- Calculate angle for this segment
                    local segmentAngle = baseAngle - coneAngleRad/2 + j * (coneAngleRad / segments)
                    
                    -- Calculate front and back points of the wave
                    local x1 = effect.sourceX + math.cos(segmentAngle) * (beamDist * waveFront)
                    local y1 = effect.sourceY + math.sin(segmentAngle) * (beamDist * waveFront)
                    local x2 = effect.sourceX + math.cos(segmentAngle) * (beamDist * waveBack)
                    local y2 = effect.sourceY + math.sin(segmentAngle) * (beamDist * waveBack)
                    
                    -- Draw the wave segment if we have a previous point
                    if prevX1 ~= nil then
                        -- Draw the wave segment
                        love.graphics.setColor(r, g, b, a)
                        love.graphics.polygon("fill", x1, y1, prevX1, prevY1, prevX2, prevY2, x2, y2)
                    end
                    
                    -- Add extra glow points at wave crest with additive blending
                    if waveFront > 0.2 and j % 3 == 1 then
                        local glowSize = waveFront * (effect.waveCrestSize or 1.0) * 15
                        love.graphics.setColor(r, g, b, waveFront * 0.7)
                        
                        -- Save current blend mode and set to additive for the brightest elements
                        local prevMode = {love.graphics.getBlendMode()}
                        love.graphics.setBlendMode("add")
                        
                        love.graphics.circle("fill", (x1 + prevX1)/2, (y1 + prevY1)/2, glowSize * intensityMult)
                        
                        -- Restore previous blend mode
                        love.graphics.setBlendMode(prevMode[1], prevMode[2])
                    end
                    
                    -- Store current points as previous for next segment
                    prevX1, prevY1, prevX2, prevY2 = x1, y1, x2, y2
                end
            end
        end
    end
    
    -- Draw source glow (brighter at the beginning)
    local sourceGlowSize = 10 + 40 * (1.0 - effect.progress)
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.7 * (1.0 - effect.progress))
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, sourceGlowSize)
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 1.0
        particle.scale = particle.scale or 0.2
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw the particle
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.8)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        ::next_draw_particle::
    end
end

-- Initialize function for cone effects
local function initializeCone(effect)
    -- For conical blast effects
    -- Calculate the base direction from source to target
    local dirX = effect.targetX - effect.sourceX
    local dirY = effect.targetY - effect.sourceY
    local baseAngle = math.atan2(dirY, dirX)

    -- Convert cone angle from degrees to radians
    local coneAngleRad = (effect.coneAngle or 60) * math.pi / 180
    local halfConeAngle = coneAngleRad / 2

    -- Set up wave parameters
    local waveCount = effect.waveCount or 3

    -- Calculate effect properties based on range and elevation
    local intensityMultiplier = 1.0
    if effect.rangeBand == Constants.RangeState.NEAR and effect.nearRangeIntensity then
        intensityMultiplier = intensityMultiplier * effect.nearRangeIntensity
    end

    -- Create particles for the cone blast
    for i = 1, effect.particleCount do
        -- Determine if this particle is part of a wave or general cone fill
        local isWaveParticle = i <= math.floor(effect.particleCount * 0.45) -- 45% of particles for waves

        -- Random position within the cone but with focus toward center if focusedCore enabled
        local angleOffset

        if effect.focusedCore then
            -- Apply quadratic distribution to concentrate particles near center
            -- Use squared random value to cluster toward cone center
            local angleRand = math.random()
            -- Apply bias toward center (squared distribution pushes values toward 0)
            angleRand = (angleRand * 2 - 1) * (angleRand * 2 - 1) * (angleRand > 0.5 and 1 or -1)
            angleOffset = angleRand * halfConeAngle
        else
            -- Standard uniform distribution across cone
            angleOffset = (math.random() * 2 - 1) * halfConeAngle
        end

        local angle = baseAngle + angleOffset

        -- Distance based on position in the cone (closer to edge or center)
        local maxDistance = effect.coneLength or 320

        -- For longer cone, we want more particles toward the end
        local distanceRand
        if math.random() < 0.6 then
            -- 60% chance for farther particles
            distanceRand = math.random() * 0.5 + 0.5 -- 0.5 to 1.0
        else
            -- 40% chance for closer particles
            distanceRand = math.random() * 0.5 -- 0.0 to 0.5
        end

        local distance = maxDistance * distanceRand

        -- Create the particle using ParticleManager
        local waveIndex = 0
        if isWaveParticle and effect.waveCrest then
            waveIndex = math.floor(math.random() * waveCount) + 1
        end

        local particle = ParticleManager.createConeParticle(effect, angle, distance, isWaveParticle, waveIndex)

        -- For focused cone, make particles in the center brighter and larger
        if effect.focusedCore and not isWaveParticle then
            -- Calculate distance from center angle
            local angleDiff = math.abs(angle - baseAngle) / halfConeAngle -- 0 at center, 1 at edge
            -- Particles closer to center get enhancements
            if angleDiff < 0.4 then
                local centerBoost = (1.0 - angleDiff/0.4) * 0.5
                particle.scale = particle.scale * (1 + centerBoost)
                particle.alpha = particle.alpha * (1 + centerBoost * 0.5)
            end
        end

        -- Apply intensity multiplier
        particle.intensityMultiplier = intensityMultiplier

        table.insert(effect.particles, particle)
    end

    -- Flag to track which waves have started
    effect.waveStarted = {}
    for i = 1, waveCount do
        effect.waveStarted[i] = false
    end
end

-- Return the module
return {
    initialize = initializeCone,
    update = updateCone,
    draw = drawCone
}```

## ./vfx/effects/conjure.lua
```lua
-- conjure.lua
-- Conjure VFX module for handling conjuration/summoning effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for conjure effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for conjure effects
local function updateConjure(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.sourceGlow = effect.sourceGlow or 0 -- Default source glow
    effect.poolGlow = effect.poolGlow or 0 -- Default pool glow
    effect.pulseRate = effect.pulseRate or 5 -- Default pulse rate
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update particles rising toward mana pool
    for i, particle in ipairs(effect.particles) do
        -- Skip invalid particles
        if not particle then
            goto next_particle
        end
        
        -- Initialize particle properties if missing
        particle.delay = particle.delay or 0
        particle.active = particle.active or false
        particle.baseX = particle.baseX or effect.sourceX
        particle.baseY = particle.baseY or effect.sourceY
        particle.targetX = particle.targetX or effect.targetX
        particle.targetY = particle.targetY or effect.targetY
        
        -- Check if particle should be active based on delay
        if effect.timer > particle.delay then
            particle.active = true
        end
        
        if particle.active then
            -- Calculate particle progress
            local particleProgress = math.min((effect.timer - particle.delay) / (effect.duration - particle.delay), 1.0)
            
            -- Update position - moving from source to target (mana pool)
            local startX = particle.baseX
            local startY = particle.baseY
            local endX = particle.targetX
            local endY = particle.targetY
            
            -- For a more interesting path, add some curves
            local bezierT = particleProgress
            local invT = 1.0 - bezierT
            
            -- Calculate bezier curve with randomized control points
            if not particle.ctrlPoint1X then
                -- Midpoint distance between source and target
                local midX = (startX + endX) / 2
                local midY = (startY + endY) / 2
                local dist = math.sqrt((endX - startX)^2 + (endY - startY)^2)
                
                -- Add random offset for natural path variation
                local offsetX = (math.random() - 0.5) * dist * 0.5
                local offsetY = (math.random() - 0.5) * dist * 0.5
                
                -- Store the control points for this particle's path
                particle.ctrlPoint1X = midX + offsetX
                particle.ctrlPoint1Y = midY + offsetY
            end
            
            -- Calculate quadratic bezier curve position
            particle.x = invT * invT * startX + 2 * invT * bezierT * particle.ctrlPoint1X + bezierT * bezierT * endX
            particle.y = invT * invT * startY + 2 * invT * bezierT * particle.ctrlPoint1Y + bezierT * bezierT * endY
            
            -- Calculate fade alpha based on progress
            -- Full opacity in the middle of the journey
            local fadeProgress = math.abs(particleProgress - 0.5) * 2 -- 0 at middle, 1 at start/end
            particle.alpha = 1.0 - fadeProgress * 0.7
            
            -- Update size - grow then shrink
            local sizeFactor = 1.0 - fadeProgress * 0.5
            particle.scale = (particle.baseScale or 0.3) * sizeFactor
        end
        
        ::next_particle::
    end
    
    -- Update glow at source position (starts strong, then fades)
    local sourceGlowProgress = math.min(effect.progress * 2, 1.0) -- 0->1 over first half
    effect.sourceGlow = 1.0 - sourceGlowProgress -- Fade from 1->0
    
    -- Update glow at mana pool (grows as particles converge)
    local poolGlowProgress = math.max(0, effect.progress * 2 - 1.0) -- 0->1 over second half
    effect.poolGlow = poolGlowProgress -- Grow from 0->1
    
    -- Create final pulse particles at the end
    if effect.progress > 0.85 and not effect.finalPulseCreated then
        -- Create a burst of particles radiating outward from mana pool
        local burstCount = 12
        for i = 1, burstCount do
            local angle = (i-1) * (2 * math.pi / burstCount)
            local particle = {
                x = effect.targetX,
                y = effect.targetY,
                angle = angle,
                speed = 80 + math.random() * 50,
                baseScale = 0.3 + math.random() * 0.2,
                scale = 0.3 + math.random() * 0.2,
                alpha = 0.8,
                life = 0,
                maxLife = 0.3 + math.random() * 0.2,
                active = true,
                type = "burst"  -- Mark these as burst particles
            }
            table.insert(effect.particles, particle)
        end
        
        effect.finalPulseCreated = true
    end
    
    -- Update final pulse particles (they move outward)
    for _, particle in ipairs(effect.particles) do
        if particle.type == "burst" and particle.active then
            -- Update position based on angle and speed
            particle.x = particle.x + math.cos(particle.angle) * particle.speed * dt
            particle.y = particle.y + math.sin(particle.angle) * particle.speed * dt
            
            -- Update lifecycle
            particle.life = particle.life + dt
            particle.alpha = 1.0 - (particle.life / particle.maxLife)
            particle.scale = particle.baseScale * (1.0 - particle.life / particle.maxLife)
            
            -- Deactivate if expired
            if particle.life >= particle.maxLife then
                particle.active = false
            end
        end
    end
end

-- Draw function for conjure effects
local function drawConjure(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default source position
    effect.sourceY = effect.sourceY or 0 -- Default source position
    effect.targetX = effect.targetX or 0 -- Default target position
    effect.targetY = effect.targetY or 0 -- Default target position
    effect.sourceGlow = effect.sourceGlow or 0 -- Default source glow
    effect.poolGlow = effect.poolGlow or 0 -- Default pool glow
    effect.timer = effect.timer or 0 -- Default timer
    
    local particleImage = getAssetInternal("sparkle")
    local glowImage = getAssetInternal("fireGlow")  -- We'll use this for all conjure types
    
    -- Draw source glow if active with additive blending
    if effect.sourceGlow and effect.sourceGlow > 0 then
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], effect.sourceGlow * 0.6)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, 50 * effect.sourceGlow)
        
        -- Draw expanding rings from source (hint at conjuration happening)
        local ringCount = 3
        for i = 1, ringCount do
            local ringProgress = ((effect.timer * 1.5) % 1.0) + (i-1) / ringCount
            if ringProgress < 1.0 then
                local ringSize = 60 * ringProgress
                local ringAlpha = 0.5 * (1.0 - ringProgress) * effect.sourceGlow
                love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], ringAlpha)
                love.graphics.circle("line", effect.sourceX, effect.sourceY, ringSize)
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle with additive blending for brighter appearance
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.8)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        ::next_draw_particle::
    end
    
    -- Draw mana pool glow with additive blending (grows at the end of the effect)
    if effect.poolGlow and effect.poolGlow > 0 then
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Add some pulsing to the glow
        local pulseOffset = math.sin(effect.timer * 8) * 0.2
        local finalGlowScale = effect.poolGlow * (1.0 + pulseOffset)
        
        -- Draw outer glow
        love.graphics.setColor(effect.color[1] * 0.6, effect.color[2] * 0.6, effect.color[3] * 0.6, effect.poolGlow * 0.7)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 50 * finalGlowScale)
        
        -- Draw inner glow (brighter)
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], effect.poolGlow * 0.9)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 30 * finalGlowScale)
        
        -- Draw bright center
        love.graphics.setColor(1, 1, 1, effect.poolGlow * 0.95)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 15 * finalGlowScale)
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
end

-- Initialize function for conjure effects
local function initializeConjure(effect)
    -- For conjuration spells, create particles that rise from caster toward mana pool
    -- Set the mana pool position (typically at top center)
    effect.manaPoolX = effect.options and effect.options.manaPoolX or 400 -- Screen center X
    effect.manaPoolY = effect.options and effect.options.manaPoolY or 120 -- Near top of screen

    -- Ensure spreadRadius has a default value
    effect.spreadRadius = effect.spreadRadius or 40

    -- Calculate direction vector toward mana pool
    local dirX = effect.manaPoolX - effect.sourceX
    local dirY = effect.manaPoolY - effect.sourceY
    local len = math.sqrt(dirX * dirX + dirY * dirY)
    dirX = dirX / len
    dirY = dirY / len

    for i = 1, effect.particleCount do
        -- Create a spread of particles around the caster
        local spreadAngle = math.random() * math.pi * 2
        local spreadDist = math.random() * effect.spreadRadius
        local startX = effect.sourceX + math.cos(spreadAngle) * spreadDist
        local startY = effect.sourceY + math.sin(spreadAngle) * spreadDist

        -- Randomize particle properties
        local speed = math.random(80, 180)
        local delay = i / effect.particleCount * 0.7

        -- Add some variance to path
        local pathVariance = math.random(-20, 20)
        local pathDirX = dirX + pathVariance / 100
        local pathDirY = dirY + pathVariance / 100

        -- Create particle using ParticleManager
        local particle = ParticleManager.createConjureParticle(effect, startX, startY, pathDirX, pathDirY, speed, delay)

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeConjure,
    update = updateConjure,
    draw = drawConjure
}```

## ./vfx/effects/impact.lua
```lua
-- impact.lua
-- Impact VFX module for handling impact/explosion effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for impact effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for impact effects
local function updateImpact(effect, dt)
    -- Initialize effect default values if not already set
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.radius = effect.radius or 50 -- Default radius
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Create impact wave that expands outward
    -- For effects with useTargetPosition=true, ensure particles use target position
    local useTargetPosition = effect.useTargetPosition
    
    for i, particle in ipairs(effect.particles) do
        -- Check if particle should be active based on delay
        if effect.timer > particle.delay then
            particle.active = true
            
            -- Update particle base position to current target position for effects that track target
            if useTargetPosition then
                particle.baseX = effect.targetX
                particle.baseY = effect.targetY
            end
            
            -- Calculate particle progress
            local particleProgress = (effect.timer - particle.delay) / (effect.duration - particle.delay)
            particleProgress = math.min(particleProgress, 1.0)
            
            -- Update particle based on its specific animation type
            if particle.animType == "expand" then
                -- Expand outward from center
                local distProgress = particleProgress -- Distance progress
                local fadeProgress = particleProgress ^ 0.7 -- Fade progress (start faster)
                
                -- Calculate distance from center
                local angle = particle.angle
                local dist = particle.maxDist * distProgress
                
                -- Update position
                particle.x = particle.baseX + math.cos(angle) * dist
                particle.y = particle.baseY + math.sin(angle) * dist
                
                -- Update alpha (fade out)
                particle.alpha = (1.0 - fadeProgress)
                
                -- Update scale (grow slightly, then shrink)
                local scaleProgress = particleProgress
                particle.scale = particle.baseScale * (1.0 + scaleProgress * 0.5) * (1.0 - scaleProgress * 0.8)
            end
        end
    end
end

-- Draw function for impact effects
local function drawImpact(effect)
    -- Make sure essential properties exist
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.targetX = effect.targetX or 0 -- Default position
    effect.targetY = effect.targetY or 0 -- Default position
    effect.radius = effect.radius or 50 -- Default radius
    
    local particleImage = getAssetInternal("fireParticle")
    local impactImage = getAssetInternal("impactRing")
    
    -- Draw expanding ring
    local ringProgress = math.min(effect.progress * 1.5, 1.0) -- Ring expands faster than full effect
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], (1.0 - ringProgress)) -- Use base color, apply ring alpha
    local ringScale = effect.radius * 0.02 * ringProgress
    love.graphics.draw(
        impactImage,
        effect.targetX, effect.targetY,
        0,
        ringScale, ringScale,
        impactImage:getWidth()/2, impactImage:getHeight()/2
    )
    
    -- Draw central flash with additive blending for extra brightness
    if effect.progress < 0.3 then
        local flashIntensity = 1.0 - (effect.progress / 0.3)
        love.graphics.setColor(1, 1, 1, flashIntensity * 0.7)
        
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.circle("fill", effect.targetX, effect.targetY, 30 * flashIntensity)
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        if particle.active and particle.alpha > 0 then
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.7)
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        end
    end
end

-- Initialize function for impact effects
local function initializeImpact(effect)
    -- For impact effects, create a radial explosion using ParticleManager
    for i = 1, effect.particleCount do
        local angle = (i / effect.particleCount) * math.pi * 2
        local delay = math.random() * 0.2 -- Slight random delay

        -- Create particle using specialized helper
        local particle = ParticleManager.createImpactParticle(effect, angle, delay)

        -- Additional motion-related properties
        particle.motion = effect.motion -- Store motion style on particle

        -- Additional properties for special motion
        particle.startTime = 0
        particle.baseX = effect.targetX
        particle.baseY = effect.targetY
        particle.angle = angle

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeImpact,
    update = updateImpact,
    draw = drawImpact
}```

## ./vfx/effects/meteor.lua
```lua
-- meteor.lua
-- Meteor VFX module for handling falling meteor/comet effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for meteor effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for meteor effects - SIMPLIFIED IMPLEMENTATION
local function updateMeteor(effect, dt)
    print("[METEOR] Start of updateMeteor()")

    -- Initialize basic effect properties
    effect.particles = effect.particles or {}
    effect.color = effect.color or {1, 1, 1}
    effect.height = effect.height or 300
    effect.spread = effect.spread or 40

    -- Set delaysDamage flag to true - this tells the spell system to wait for impact
    -- This should be checked in the wizard's castSpell function
    effect.delaysDamage = true
    
    -- Debug output
    print(string.format("[METEOR] Effect: timer=%.2f, progress=%.2f, particles=%d, target=(%d,%d)",
                      effect.timer or 0, effect.progress or 0, #effect.particles, 
                      effect.targetX or 0, effect.targetY or 0))
    
    -- Create particles if none exist
    if #effect.particles == 0 and effect.targetX and effect.targetY then
        print("[METEOR] Creating new meteor particles")

        local particleCount = effect.particleCount or 8

        -- Increase spread to make meteors more visually distinct
        local spreadX = effect.spread * 2.5  -- Much wider X spread
        local spreadY = effect.spread * 0.5  -- Less Y spread for a more uniform height

        for i = 1, particleCount do
            -- Create meteor particle with wide horizontal distribution and less vertical variation
            local offsetX = (math.random() - 0.5) * spreadX
            local offsetY = (math.random() - 0.5) * spreadY
            
            -- Create meteor particle using ParticleManager
            local meteor = ParticleManager.createMeteorParticle(effect, offsetX, offsetY)
            
            -- Initialize position
            meteor.x = meteor.startX
            meteor.y = meteor.startY
            
            table.insert(effect.particles, meteor)
            print(string.format("[METEOR] Created particle #%d at (%.1f, %.1f)", i, meteor.x, meteor.y))
        end
    end
    
    -- Process particles
    local rawProgress = effect.progress or 0
    
    for i, particle in ipairs(effect.particles) do
        if particle.type == "meteor" then
            -- Calculate individual particle progress
            local particleTime = (effect.timer or 0) - (particle.timeCreated or 0)
            local particleProgress = math.min(particleTime / (particle.lifespan or 1.0), 1.0)
            
            -- Use raw effect progress to move
            local moveProgress = rawProgress
            
            -- Simple linear movement from start to end position
            particle.x = particle.startX + (particle.endX - particle.startX) * moveProgress
            particle.y = particle.startY + (particle.endY - particle.startY) * moveProgress
            
            -- Update rotation
            particle.rotation = particle.rotation + particle.rotationSpeed * dt
            
            -- Logging for first particle
            if i == 1 then
                print(string.format("[METEOR] Main particle: progress=%.2f, pos=(%.1f, %.1f)", 
                                 moveProgress, particle.x, particle.y))
            end
            
            -- Randomly create trail particles
            if math.random() < 0.1 and moveProgress > 0.1 and moveProgress < 0.9 then
                local Pool = require("core.Pool")
                -- Create trail particle using ParticleManager
                local trail = ParticleManager.createMeteorTrailParticle(effect, particle)
                table.insert(effect.particles, trail)
            end
        elseif particle.type == "trail" then
            -- Update trail particles
            local trailTime = (effect.timer or 0) - (particle.timeCreated or 0)
            local trailProgress = math.min(trailTime / (particle.lifespan or 0.3), 1.0)
            
            -- Fade out trail
            particle.alpha = (1.0 - trailProgress) * particle.baseAlpha
            
            -- Shrink trail
            particle.scale = particle.baseScale * (1.0 - trailProgress * 0.5)
        elseif particle.type == "impact" then
            -- Update impact particles
            local impactTime = (effect.timer or 0) - (particle.timeCreated or 0)
            local impactProgress = math.min(impactTime / (particle.lifespan or 0.5), 1.0)
            
            -- Radiate outward
            local dist = particle.maxDist * impactProgress
            particle.x = effect.targetX + math.cos(particle.angle) * dist
            particle.y = effect.targetY + math.sin(particle.angle) * dist
            
            -- Fade out
            if impactProgress < 0.2 then
                particle.alpha = impactProgress / 0.2 * particle.baseAlpha
            else
                particle.alpha = (1.0 - (impactProgress - 0.2) / 0.8) * particle.baseAlpha
            end
        end
    end
    
    -- Create impact particles at end of animation
    if effect.progress > 0.8 and effect.progress < 0.9 and not effect.impactCreated then
        print("[METEOR] Creating impact particles")

        -- Create impact effect
        local impactCount = 12
        for i = 1, impactCount do
            local angle = (i-1) * (2 * math.pi / impactCount)
            local Pool = require("core.Pool")
            -- Create impact particle using ParticleManager
            local impact = ParticleManager.createMeteorImpactParticle(effect, angle)
            table.insert(effect.particles, impact)
        end

        -- TRIGGER DAMAGE EVENT AT IMPACT (similar to projectile implementation)
        -- Execute the damage callback if it exists (this is how we delay the actual damage until impact)
        if effect.options and effect.options.onImpact then
            print("[METEOR] Triggering onImpact callback for delayed damage!")

            local success, err = pcall(function()
                effect.options.onImpact(effect)
            end)

            if not success then
                print("[METEOR] Error in onImpact callback: " .. tostring(err))
            end
        end

        -- Trigger screen shake and hit stop on impact
        local shakeDuration = 0.25
        local shakeIntensity = 6

        -- Try to trigger screen shake if available
        if VFX.triggerShake then
            VFX.triggerShake(shakeDuration, shakeIntensity)
            print("[METEOR] Triggered screen shake")
        end

        -- Try to trigger hit stop if available
        if VFX.triggerHitstop then
            VFX.triggerHitstop(0.08)  -- Brief hitstop for impact feel
            print("[METEOR] Triggered hit stop")
        end

        effect.impactCreated = true
    end
    
    -- Clean up expired particles using ParticleManager
    local removedCount = ParticleManager.cleanupEffectParticles(effect.particles, function(particle)
        return particle.type == "trail" and particle.alpha <= 0.05
    end)

    if removedCount > 0 then
        print(string.format("[METEOR] Cleaned up %d expired particles", removedCount))
    end
    
    print(string.format("[METEOR] End of update: %d particles", #effect.particles))
end

-- Draw function for meteor effects
local function drawMeteor(effect)
    -- Set additive blending for the entire effect
    love.graphics.setBlendMode("add")
    
    -- Draw all active particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or invisible particles
        if not particle or particle.alpha <= 0.01 then
            goto next_draw_particle
        end
        
        -- Get the appropriate asset
        local asset = getAssetInternal(particle.assetId or "fireParticle")
        
        if asset then
            -- Get color
            local colorR, colorG, colorB = effect.color[1], effect.color[2], effect.color[3]
            if particle.color then
                colorR, colorG, colorB = particle.color[1], particle.color[2], particle.color[3]
            end
            
            -- Set color and alpha
            love.graphics.setColor(colorR, colorG, colorB, particle.alpha)
            
            -- Draw particle with rotation
            love.graphics.draw(
                asset,
                particle.x, particle.y,
                particle.rotation or 0,
                particle.scale, particle.scale,
                asset:getWidth()/2, asset:getHeight()/2
            )
            
            -- Draw glow for meteor particles
            if particle.type == "meteor" then
                -- Draw glow around meteor with additional color intensity
                love.graphics.setColor(colorR * 1.2, colorG * 1.2, colorB * 1.2, particle.alpha * 0.7)
                local glowAsset = getAssetInternal("fireGlow")
                
                if glowAsset then
                    love.graphics.draw(
                        glowAsset,
                        particle.x, particle.y,
                        0,
                        particle.scale * 2, particle.scale * 2,
                        glowAsset:getWidth()/2, glowAsset:getHeight()/2
                    )
                end
            end
        else
            -- Fallback if asset is missing
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha)
            love.graphics.circle("fill", particle.x, particle.y, (particle.scale or 1) * 20)
        end
        
        ::next_draw_particle::
    end
    
    -- Reset blend mode
    love.graphics.setBlendMode("alpha")
end

-- Return the module
return {
    update = updateMeteor,
    draw = drawMeteor
}```

## ./vfx/effects/projectile.lua
```lua
-- projectile.lua
-- Projectile VFX module for handling spell projectiles

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for projectile effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for projectile effects
local function updateProjectile(effect, dt)
    -- Initialize effect default values if not already set
    effect.trailLength = effect.trailLength or 10 -- Default trail length
    effect.trailPoints = effect.trailPoints or {} -- Initialize trail points array if nil
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.size = effect.size or 1.0 -- Default size
    effect.arcHeight = effect.arcHeight or 60 -- Default arc height
    effect.frameDuration = effect.frameDuration or 0.1 -- Default frame duration
    effect.currentFrame = effect.currentFrame or 1 -- Default current frame
    effect.frameTimer = effect.frameTimer or 0 -- Default frame timer

    -- Always update visual progress from effect.progress on each frame
    -- This ensures visualProgress increases over time consistently

    -- Bug fix: visualProgress wasn't being set correctly for blocked projectiles
    if effect.isBlocked then
        -- For blocked effects, always update until it reaches the block point
        local blockPoint = (effect.options and effect.options.blockPoint) or 1.0

        if not effect.visualProgress or effect.visualProgress < effect.progress then
            effect.visualProgress = math.min(effect.progress, blockPoint)
            print("[PROJECTILE DEBUG] Updating visualProgress for blocked effect: " .. effect.visualProgress)
        end
    else
        -- For normal effects, always sync visualProgress with progress on each update
        effect.visualProgress = effect.progress
    end
    
    -- Ensure path-related properties are set
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.useCurvedPath = (effect.useCurvedPath ~= false) -- Default to true for bolt effects
    effect.useTrail = (effect.useTrail ~= false) -- Default to true
    
    if #effect.trailPoints == 0 then
        -- Initialize trail with source position
        for i = 1, effect.trailLength do
            table.insert(effect.trailPoints, {
                x = effect.sourceX, 
                y = effect.sourceY,
                alpha = i == 1 and 1.0 or (1.0 - (i-1)/effect.trailLength)
            })
        end
    end
    
    -- Get effect parameters with defaults
    local arcHeight = effect.arcHeight or 60
    
    -- Always use visualProgress for consistent animation
    -- This ensures the head position consistently updates with each frame
    local baseProgress = effect.visualProgress

    print(string.format("[PROJECTILE PROGRESS] isBlocked=%s, progress=%.2f, visualProgress=%.2f, baseProgress=%.2f",
        tostring(effect.isBlocked), effect.progress or 0, effect.visualProgress or 0, baseProgress))
    
    -- Calculate projectile position along the path
    local startX, startY = effect.sourceX, effect.sourceY
    local endX, endY = effect.targetX, effect.targetY
    
    -- For remote casting, override startX/Y to be the actual cast position
    if effect.useSourcePosition and effect.remoteSourceX and effect.remoteSourceY then
        startX = effect.remoteSourceX
        startY = effect.remoteSourceY
    end
    
    -- Special case for parabolic block
    local blockPoint = effect.blockPoint or 1.0
    
    -- Adjust the trajectory for blocked projectiles
    if effect.isBlocked and baseProgress > blockPoint then
        baseProgress = blockPoint
    end
    
    -- Calculate the current position of the projectile head
    local head = { 
        x = startX, 
        y = startY 
    }
    
    -- Ensure we're using a valid progress value
    -- Crucial: If baseProgress is nil, use effect.progress directly
    -- This ensures we always have a value that increases over time
    if baseProgress == nil then
        baseProgress = effect.progress or 0
        print("[PROJECTILE WARNING] baseProgress was nil, using effect.progress = " .. baseProgress)
    end

    -- Now calculate the position along the path
    if effect.useCurvedPath then
        -- Use a parabolic path
        head.x = startX + (endX - startX) * baseProgress
        head.y = startY + (endY - startY) * baseProgress
        
        -- Apply parabolic arc
        -- Calculate a parabola that starts at source, ends at target, and peaks at height
        local arcProgress = baseProgress
        
        if effect.isBlocked and blockPoint < 1.0 then
            -- The arc should complete over the shorter range to the block point
            arcProgress = baseProgress / blockPoint
        end
        
        -- Standard parabola: 4 * h * x * (1-x) where h is height and x is [0,1] progress
        local arcFactor = 4 * arcHeight * arcProgress * (1 - arcProgress)
        
        -- Apply the vertical offset
        head.y = head.y - arcFactor
    else
        -- Use a straight-line path
        head.x = startX + (endX - startX) * baseProgress
        head.y = startY + (endY - startY) * baseProgress
    end
    
    -- For source tracking, update the source position if needed
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
        end
    end
    
    -- For target tracking, update the target position if needed
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
        end
    end
    
    -- Update trail points (shifting all points to make room for the new head)
    -- Bug fix: Ensure head position is actually different before updating trail
    -- This prevents the trail from being stuck at the same point
    local shouldUpdateTrail = true

    if #effect.trailPoints > 0 then
        -- Check if the head has actually moved from the last position
        local lastHeadX = effect.trailPoints[1] and effect.trailPoints[1].x
        local lastHeadY = effect.trailPoints[1] and effect.trailPoints[1].y

        -- Only create a new trail point if the head has moved at least a small distance
        -- or if this is the first update
        local minDistance = 1.0 -- Minimum distance to consider movement significant
        if lastHeadX and lastHeadY then
            local dx = head.x - lastHeadX
            local dy = head.y - lastHeadY
            local distanceMoved = math.sqrt(dx*dx + dy*dy)
            shouldUpdateTrail = (distanceMoved >= minDistance)

            if not shouldUpdateTrail then
                print(string.format("[PROJECTILE DEBUG] Head position hasn't changed significantly: dist=%.2f < %.2f",
                    distanceMoved, minDistance))
            end
        end

        if shouldUpdateTrail then
            -- For trail with length n, we want to preserve n points
            -- Remove the last point
            table.remove(effect.trailPoints)

            -- Insert the new head position at the beginning
            table.insert(effect.trailPoints, 1, {
                x = head.x,
                y = head.y,
                alpha = 1.0
            })

            -- Update alpha values for the trail
            for i = 2, #effect.trailPoints do
                effect.trailPoints[i].alpha = 1.0 - (i-1)/effect.trailLength
            end

            print(string.format("[PROJECTILE DEBUG] Updated trail with new head position: (%.1f, %.1f)", head.x, head.y))
        end
    else
        -- If there are no trail points yet, initialize with current head position
        for i = 1, effect.trailLength do
            table.insert(effect.trailPoints, {
                x = head.x,
                y = head.y,
                alpha = i == 1 and 1.0 or (1.0 - (i-1)/effect.trailLength)
            })
        end
        print("[PROJECTILE DEBUG] Initialized trail with starting position")
    end
    
    -- Update particles for the projectile trail
    if effect.particles then
        -- Add many new particles at the current head position for dense swarm effect
        local particleRate = effect.particleRate or 15.0 -- Massive rate for spectacular particle swarm
        
        -- Generate multiple particles per frame for dense effect
        local particlesThisFrame = math.floor(particleRate)
        if math.random() < (particleRate - particlesThisFrame) then
            particlesThisFrame = particlesThisFrame + 1
        end
        
        for i = 1, particlesThisFrame do
            -- Create different types of particles using primitive assets
            local particle = ParticleManager.createProjectileTrailParticle(effect, head.x, head.y)
            
            -- Assign primitive sprite types for variety
            local spriteType = math.random(3)
            if spriteType == 1 then
                particle.spriteType = "pixel"
                particle.size = math.random(1, 3)
            elseif spriteType == 2 then
                particle.spriteType = "twinkle1"
                particle.size = math.random(2, 4)
            else
                particle.spriteType = "twinkle2"
                particle.size = math.random(2, 4)
            end
            
            -- Add some randomness to position for swarm effect
            particle.x = particle.x + (math.random() - 0.5) * 8
            particle.y = particle.y + (math.random() - 0.5) * 8
            
            -- Add the particle to the effect
            table.insert(effect.particles, particle)
        end
        
        -- Update existing particles
        local i = 1
        while i <= #effect.particles do
            local particle = effect.particles[i]
            
            -- Skip invalid particles
            if not particle then
                table.remove(effect.particles, i)
                goto next_particle
            end
            
            -- Ensure particle has all needed properties
            particle.x = particle.x or head.x
            particle.y = particle.y or head.y
            particle.xVel = particle.xVel or 0
            particle.yVel = particle.yVel or 0
            particle.life = particle.life or 0
            particle.maxLife = particle.maxLife or 0.5
            
            -- Update particle physics
            particle.x = particle.x + particle.xVel * dt
            particle.y = particle.y + particle.yVel * dt
            particle.life = particle.life + dt
            
            -- Calculate fade based on life
            particle.alpha = 1.0 - (particle.life / particle.maxLife)
            
            -- Remove dead particles
            if particle.life >= particle.maxLife then
                -- Release particle back to pool
                ParticleManager.releaseParticle(particle)
                table.remove(effect.particles, i)
            else
                i = i + 1
            end
            
            ::next_particle::
        end
    end
    
    -- Update sprite animation frame (if using sprites)
    if effect.useSprites then
        effect.frameTimer = effect.frameTimer + dt
        if effect.frameTimer >= effect.frameDuration then
            effect.frameTimer = 0
            effect.currentFrame = effect.currentFrame + 1
            
            -- Determine max frames based on effect type
            local maxFrames = 3  -- Default for bolt
            if effect.type == "orb_base" then
                maxFrames = 5
            end
            
            if effect.currentFrame > maxFrames then
                effect.currentFrame = 1
            end
        end
    end
    
    -- Write the head position to the effect for drawing
    -- Critical bugfix: Force head position update even if trail wasn't updated
    -- This ensures the head always reflects the current progress
    effect.headX = head.x
    effect.headY = head.y

    -- Debug logging - track position updates
    print(string.format("[PROJECTILE DEBUG] Updated head position: (%.1f, %.1f) at progress=%.2f",
        head.x, head.y, baseProgress))
end

-- Draw function for projectile effects
local function drawProjectile(effect)
    -- Make sure essential properties exist
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.size = effect.size or 1.0 -- Default size
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.trailPoints = effect.trailPoints or {} -- Initialize trail points array if nil
    effect.currentFrame = effect.currentFrame or 1 -- Default current frame
    effect.useCurvedPath = (effect.useCurvedPath ~= false) -- Default to true for bolt effects
    effect.useTrail = (effect.useTrail ~= false) -- Default to true
    
    -- Debug info for drawing
    print(string.format("[PROJECTILE DRAW] Effect: %s, Timer: %.2f, Progress: %.2f", 
        effect.name or "unnamed", effect.timer or 0, effect.progress or 0))
    print(string.format("[PROJECTILE DRAW] Head Position: (%.0f, %.0f), Source: (%.0f, %.0f), Target: (%.0f, %.0f)", 
        effect.headX or 0, effect.headY or 0, 
        effect.sourceX or 0, effect.sourceY or 0,
        effect.targetX or 0, effect.targetY or 0))
    
    -- Ensure the head position exists
    if not effect.headX or not effect.headY then
        -- If no head position, calculate it based on progress
        local progress = effect.isBlocked and effect.visualProgress or effect.progress or 0
        effect.headX = effect.sourceX + (effect.targetX - effect.sourceX) * progress
        effect.headY = effect.sourceY + (effect.targetY - effect.sourceY) * progress
        
        print(string.format("[PROJECTILE DRAW] Recalculated head position to (%.0f, %.0f) with progress %.2f", 
            effect.headX, effect.headY, progress))
    end
    
    -- Get assets including new primitive sprites
    local particleImage = getAssetInternal("fireParticle")
    local glowImage = getAssetInternal("fireGlow")
    local impactImage = getAssetInternal("impactRing")
    local onePxImage = getAssetInternal("pixel")
    local twinkle1Image = getAssetInternal("twinkle1")
    local twinkle2Image = getAssetInternal("twinkle2")
    
    -- Get sprite frames if needed
    local spriteFrames = nil
    if effect.useSprites then
        if effect.type == "orb_base" then
            spriteFrames = getAssetInternal("orbFrames")
        else
            spriteFrames = getAssetInternal("boltFrames")
        end
    end
    
    -- Calculate the actual trajectory angle for aimed shots
    -- This will be used for sprite rotation if it's a bolt
    local trajectoryAngle = nil
    if effect.useSourcePosition and effect.useTargetPosition then
        -- Calculate direction vector from current source to target
        local dirX = effect.targetX - effect.sourceX
        local dirY = effect.targetY - effect.sourceY
        
        -- Calculate the angle
        trajectoryAngle = math.atan2(dirY, dirX)
    end
    
    -- Get the head position (calculated in update)
    local head = {
        x = effect.headX or effect.sourceX,
        y = effect.headY or effect.sourceY
    }
    
    -- If we have a trail, draw it using particle swarms instead of large sprites
    if effect.useTrail and #effect.trailPoints > 1 then
        -- Draw trail using swarms of tiny particles at each point
        for i = #effect.trailPoints, 1, -1 do
            local point = effect.trailPoints[i]
            local trailIntensity = (1 - (i-1)/#effect.trailPoints)
            local trailAlpha = point.alpha * 0.6
            local particleCount = math.floor(trailIntensity * 50) -- Massive particle count for spectacular trail
            
            -- Draw swarm of tiny particles at each trail point
            local color = effect.color or {1, 1, 1}
            
            for p = 1, particleCount do
                -- Random offset for particle swarm
                local offsetX = (math.random() - 0.5) * trailIntensity * 15
                local offsetY = (math.random() - 0.5) * trailIntensity * 15
                
                -- Choose random primitive sprite
                local spriteChoice = math.random(3)
                local sprite, scale
                
                if spriteChoice == 1 and onePxImage then
                    sprite = onePxImage
                    scale = math.random(1, 2)
                elseif spriteChoice == 2 and twinkle1Image then
                    sprite = twinkle1Image
                    scale = math.random(0.8, 1.5)
                else
                    sprite = twinkle2Image or onePxImage
                    scale = math.random(0.8, 1.5)
                end
                
                if sprite then
                    love.graphics.setColor(
                        color[1], 
                        color[2], 
                        color[3], 
                        trailAlpha * (0.4 + math.random() * 0.6)
                    )
                    
                    love.graphics.draw(
                        sprite,
                        point.x + offsetX, point.y + offsetY,
                        0,
                        scale, scale,
                        sprite:getWidth()/2, sprite:getHeight()/2
                    )
                end
            end
        end
    end
    
    -- Draw the particles using primitive sprites
    if effect.particles then
        for _, particle in ipairs(effect.particles) do
            -- Skip invalid particles
            if not particle then
                goto next_draw_particle
            end
            
            local particleColor = particle.color or effect.color or {1, 1, 1}
            love.graphics.setColor(
                particleColor[1],
                particleColor[2],
                particleColor[3],
                (particle.alpha or 0.5) * 0.8
            )
            
            -- Choose sprite based on particle type
            local sprite = nil
            local scale = (particle.size or 3) / 3
            
            if particle.spriteType == "pixel" and onePxImage then
                sprite = onePxImage
            elseif particle.spriteType == "twinkle1" and twinkle1Image then
                sprite = twinkle1Image
            elseif particle.spriteType == "twinkle2" and twinkle2Image then
                sprite = twinkle2Image
            else
                -- Fallback to any available primitive
                sprite = onePxImage or twinkle1Image or twinkle2Image or particleImage
            end
            
            -- Draw particle with primitive sprite
            if sprite then
                love.graphics.draw(
                    sprite,
                    particle.x, particle.y,
                    0,
                    scale, scale,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            else
                -- Final fallback to a circle
                love.graphics.circle("fill", particle.x, particle.y, particle.size or 3)
            end
            
            ::next_draw_particle::
        end
    end
    
    -- Draw the projectile head
    local leadingIntensity = 1.3 -- Make the leading edge brighter
    
    -- Draw sprite-based projectile (like lightning bolt or orb)
    if effect.useSprites and spriteFrames then
        -- Use projectile sprites
        local frame = spriteFrames[effect.currentFrame]
        local scale = effect.size * 2
        
        -- Handle rotation based on effect type
        local rotation = 0
        if effect.type == "orb_base" then
            -- Orbs don't rotate with trajectory, but can have gentle spinning
            rotation = (effect.spriteRotationOffset or 0) + (love.timer.getTime() * 0.5)
        else
            -- Bolts rotate based on trajectory
            rotation = trajectoryAngle or 0
        end
        
        love.graphics.setColor(
            effect.color[1], 
            effect.color[2], 
            effect.color[3], 
            0.9
        )
        
        love.graphics.draw(
            frame, 
            head.x, head.y,
            rotation,
            scale, scale,
            frame:getWidth()/2, frame:getHeight()/2
        )
    else
        -- Draw particle-based projectile using swarms of tiny primitives
        
        -- Draw outer glow using massive swarm of tiny particles
        local color = effect.color or {1, 1, 1}
        local outerRadius = (effect.size or 1.0) * 25
        local outerParticleCount = 80
        
        for i = 1, outerParticleCount do
            local angle = (i / outerParticleCount) * math.pi * 2
            local radius = outerRadius * (0.6 + math.random() * 0.4)
            local px = head.x + math.cos(angle) * radius
            local py = head.y + math.sin(angle) * radius
            
            love.graphics.setColor(
                color[1] * 0.6, 
                color[2] * 0.6, 
                color[3] * 0.6, 
                0.3 * (0.5 + math.random() * 0.5)
            )
            
            local sprite = (i % 2 == 0) and onePxImage or twinkle1Image
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1 + math.random(), 1 + math.random(),
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Inner glow using massive swarm of tiny particles with additive blending
        local innerRadius = (effect.size or 1.0) * 12
        local innerParticleCount = 65
        
        -- Save current blend mode and set to additive for brightness
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        for i = 1, innerParticleCount do
            local angle = (i / innerParticleCount) * math.pi * 2 + love.timer.getTime() * 2
            local radius = innerRadius * (0.3 + math.random() * 0.7)
            local px = head.x + math.cos(angle) * radius
            local py = head.y + math.sin(angle) * radius
            
            love.graphics.setColor(
                math.min(1.0, color[1] * leadingIntensity), 
                math.min(1.0, color[2] * leadingIntensity), 
                math.min(1.0, color[3] * leadingIntensity), 
                0.6 * (0.4 + math.random() * 0.6)
            )
            
            local sprite = (i % 3 == 0) and twinkle2Image or ((i % 3 == 1) and twinkle1Image or onePxImage)
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    0.8 + math.random() * 0.6, 0.8 + math.random() * 0.6,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        -- Add electrical corona effect using primitive particles
        local coronaRadius = (effect.size or 1.0) * 35
        local coronaParticleCount = 45
        local time = love.timer.getTime()
        
        -- Save current blend mode and set to additive for electrical effect
        local prevMode2 = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        for i = 1, coronaParticleCount do
            local angle = (i / coronaParticleCount) * math.pi * 2 + time * 3
            local pulseRadius = coronaRadius * (0.8 + 0.3 * math.sin(time * 5 + i))
            local px = head.x + math.cos(angle) * pulseRadius
            local py = head.y + math.sin(angle) * pulseRadius
            
            -- Flickering alpha for electrical effect
            local flickerAlpha = 0.15 + 0.1 * math.sin(time * 8 + i * 0.5)
            
            love.graphics.setColor(
                color[1] * 0.8, 
                color[2] * 0.9, 
                color[3] * 1.0, 
                flickerAlpha
            )
            
            -- Use tiny 1px sprites for electrical sparks
            if onePxImage then
                love.graphics.draw(
                    onePxImage, px, py, 0,
                    1 + math.random() * 0.5, 1 + math.random() * 0.5,
                    onePxImage:getWidth()/2, onePxImage:getHeight()/2
                )
            end
        end
        
        -- Add sparkle layer using twinkle sprites
        local sparkleRadius = (effect.size or 1.0) * 40
        local sparkleCount = 30
        
        for i = 1, sparkleCount do
            local angle = (i / sparkleCount) * math.pi * 2 + time * -1.5
            local radius = sparkleRadius * (0.6 + 0.4 * math.random())
            local px = head.x + math.cos(angle) * radius
            local py = head.y + math.sin(angle) * radius
            
            -- Twinkling effect
            local twinklePhase = math.sin(time * 4 + i * 1.2)
            local twinkleAlpha = math.max(0, 0.2 + 0.3 * twinklePhase)
            
            love.graphics.setColor(
                color[1], 
                color[2], 
                color[3], 
                twinkleAlpha
            )
            
            local sprite = (i % 2 == 0) and twinkle1Image or twinkle2Image
            if sprite then
                local scale = 0.8 + 0.4 * math.abs(twinklePhase)
                love.graphics.draw(
                    sprite, px, py, 0,
                    scale, scale,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode2[1], prevMode2[2])
        
        -- Core (solid center)
        love.graphics.setColor(1, 1, 1, 0.9)
        local coreScale = (effect.size or 1.0) * 0.5
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                head.x, head.y,
                0,
                coreScale, coreScale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback
            love.graphics.circle("fill", head.x, head.y, coreScale * 10)
        end
    end
    
    -- Draw block impact if projectile was blocked
    if effect.isBlocked and effect.blockPoint and effect.progress > effect.blockPoint then
        -- Calculate the impact position at the block point
        local blockX = effect.sourceX + (effect.targetX - effect.sourceX) * effect.blockPoint
        local blockY = effect.sourceY + (effect.targetY - effect.sourceY) * effect.blockPoint
        
        -- If using curved path, apply the arc height
        if effect.useCurvedPath then
            -- Apply parabolic arc at block point
            local arcFactor = 4 * (effect.arcHeight or 60) * effect.blockPoint * (1 - effect.blockPoint)
            blockY = blockY - arcFactor
        end
        
        -- Draw impact flash
        local impactProgress = (effect.progress - effect.blockPoint) / (1 - effect.blockPoint)
        local impactSize = 20 * (1 - impactProgress) * effect.size
        local impactAlpha = 0.7 * (1 - impactProgress)
        
        if impactAlpha > 0 then
            love.graphics.setColor(1, 1, 1, impactAlpha)
            
            -- Save current blend mode and set to additive for the brightest elements
            local prevMode = {love.graphics.getBlendMode()}
            love.graphics.setBlendMode("add")
            
            if impactImage then
                love.graphics.draw(
                    impactImage,
                    blockX, blockY,
                    0,
                    impactSize/10, impactSize/10,
                    impactImage:getWidth()/2, impactImage:getHeight()/2
                )
            else
                -- Fallback
                love.graphics.circle("fill", blockX, blockY, impactSize)
            end
            
            -- Draw shield runes if this was blocked by a shield
            local shieldType = effect.blockType or effect.options.shieldType
            if shieldType and (shieldType == "ward" or shieldType == "barrier") then
                -- Shield-specific visualization
                local runeImages = getAssetInternal("runes")
                if runeImages and #runeImages > 0 then
                    -- Get a deterministic or random rune
                    local runeIndex
                    if effect.id then
                        runeIndex = (effect.id % #runeImages) + 1
                    else
                        -- Calculate a stable index from the positions
                        local posHash = math.floor(effect.sourceX + effect.sourceY + effect.targetX + effect.targetY)
                        runeIndex = (posHash % #runeImages) + 1
                    end
                    local runeImage = runeImages[runeIndex]
                    
                    -- Draw the rune
                    local runeSize = 0.5 * impactSize * (1 + 0.5 * math.sin(impactProgress * math.pi * 4))
                    local runeAlpha = impactAlpha * 0.8
                    love.graphics.setColor(1, 1, 1, runeAlpha)
                    
                    if runeImage then
                        love.graphics.draw(
                            runeImage,
                            blockX, blockY,
                            math.pi * 2 * impactProgress,
                            runeSize, runeSize,
                            runeImage:getWidth()/2, runeImage:getHeight()/2
                        )
                    end
                end
            end
            
            -- Restore previous blend mode
            love.graphics.setBlendMode(prevMode[1], prevMode[2])
        end
    end
end

-- Initialize function for projectile effects
local function initializeProjectile(effect)
    -- Calculate base trajectory properties
    local dirX = effect.targetX - effect.sourceX
    local dirY = effect.targetY - effect.sourceY
    local distance = math.sqrt(dirX*dirX + dirY*dirY)
    local baseAngle = math.atan2(dirY, dirX)

    -- Check for block info and set block properties
    if effect.options and effect.options.blockPoint then
        print(string.format("[PROJECTILE INIT] Detected block at point %.2f", effect.options.blockPoint))
        effect.isBlocked = true
        effect.blockPoint = effect.options.blockPoint
        effect.blockType = effect.options.shieldType or "ward"
    end

    -- Get turbulence factor or use default
    local turbulence = effect.turbulence or 0.5
    local coreDensity = effect.coreDensity or 0.6
    local trailDensity = effect.trailDensity or 0.4

    -- Core particles (at the leading edge of the projectile)
    local coreCount = math.floor(effect.particleCount * coreDensity)
    local trailCount = effect.particleCount - coreCount

    -- Create core/leading particles using ParticleManager
    for i = 1, coreCount do
        local particle = ParticleManager.createProjectileCoreParticle(effect, baseAngle, turbulence)

        -- Apply motion style variations
        if effect.motion == Constants.MotionStyle.SWIRL then
            particle.swirlRadius = math.random(5, 15)
            particle.swirlSpeed = math.random(3, 8)
        elseif effect.motion == Constants.MotionStyle.PULSE then
            particle.pulseFreq = math.random(3, 7)
            particle.pulseAmplitude = 0.2 + math.random() * 0.3
        end

        table.insert(effect.particles, particle)
    end

    -- Create trail particles using ParticleManager
    for i = 1, trailCount do
        local particle = ParticleManager.createProjectileFullTrailParticle(effect, baseAngle, turbulence, i, trailCount)
        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeProjectile,
    update = updateProjectile,
    draw = drawProjectile
}```

## ./vfx/effects/remote.lua
```lua
-- remote.lua
-- Remote VFX module for handling teleport/warp effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for remote effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for remote effects
local function updateRemote(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    effect.useSprites = effect.useSprites or false -- Default for sprite usage
    effect.frameTimer = effect.frameTimer or 0 -- Animation timer
    effect.currentFrame = effect.currentFrame or 1 -- Current animation frame
    effect.frameDuration = effect.frameDuration or 0.1 -- Duration between frames
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Update particles for the warp/remote effect
    for i, particle in ipairs(effect.particles) do
        -- Skip invalid particles
        if not particle then
            goto next_particle
        end
        
        -- Initialize particle properties if missing
        particle.delay = particle.delay or 0
        particle.active = particle.active or false
        
        -- Activate particles based on delay
        if effect.timer > particle.delay then
            particle.active = true
        end
        
        if particle.active then
            -- Calculate particle progress
            local particleProgress = math.min((effect.timer - particle.delay) / (effect.duration - particle.delay), 1.0)
            
            -- Update particle position based on type
            if particle.type == "source" then
                -- Source particles expand outward
                local dist = particle.maxDist * particleProgress
                particle.x = effect.sourceX + math.cos(particle.angle) * dist
                particle.y = effect.sourceY + math.sin(particle.angle) * dist
                
                -- Fade out as they expand
                particle.alpha = 1.0 - particleProgress
            elseif particle.type == "target" then
                -- Target particles converge inward
                local dist = particle.maxDist * (1.0 - particleProgress)
                particle.x = effect.targetX + math.cos(particle.angle) * dist
                particle.y = effect.targetY + math.sin(particle.angle) * dist
                
                -- Fade in as they converge
                particle.alpha = particleProgress
            end
            
            -- Update particle scale
            local scaleFactor = 1.0 - math.abs(particleProgress - 0.5) * 0.6
            particle.scale = (particle.baseScale or 0.3) * scaleFactor
        end
        
        ::next_particle::
    end
    
    -- Update sprite animation for warp effect
    if effect.useSprites then
        effect.frameTimer = effect.frameTimer + dt
        if effect.frameTimer >= effect.frameDuration then
            effect.frameTimer = 0
            effect.currentFrame = effect.currentFrame + 1
            if effect.currentFrame > 3 then
                effect.currentFrame = 1
            end
        end
    end
end

-- Draw function for remote effects
local function drawRemote(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default source position
    effect.sourceY = effect.sourceY or 0 -- Default source position
    effect.targetX = effect.targetX or 0 -- Default target position
    effect.targetY = effect.targetY or 0 -- Default target position
    effect.progress = effect.progress or 0 -- Default progress
    effect.useSprites = effect.useSprites or false -- Default for sprite usage
    effect.currentFrame = effect.currentFrame or 1 -- Current animation frame
    
    local particleImage = getAssetInternal("sparkle")
    local glowImage = getAssetInternal("fireGlow")
    local impactImage = getAssetInternal("impactRing")
    
    -- Get warp frames if needed
    local warpFrames = nil
    if effect.useSprites then
        warpFrames = getAssetInternal("warpFrames")
    end
    
    -- Draw effects at source position
    if effect.progress < 0.6 then
        -- Fade out as effect progresses
        local sourceAlpha = 1.0 - (effect.progress / 0.6)
        
        -- Draw glow effect at source with additive blending
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw expanding ring for warp-out effect
        local ringSize = 30 + effect.progress * 60
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.5 * sourceAlpha)
        love.graphics.circle("line", effect.sourceX, effect.sourceY, ringSize)
        
        -- Draw bright glow core
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.8 * sourceAlpha)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, 25 * (1.0 - effect.progress/0.6))
        
        -- Draw inner bright center
        love.graphics.setColor(1, 1, 1, 0.9 * sourceAlpha)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, 10 * (1.0 - effect.progress/0.6))
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        -- Draw sprite-based warp effect if enabled
        if effect.useSprites and warpFrames then
            local frame = warpFrames[effect.currentFrame]
            local scale = 1.0 * (1.0 - effect.progress/0.6)
            
            -- Draw the warp sprite
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], sourceAlpha)
            love.graphics.draw(
                frame,
                effect.sourceX, effect.sourceY,
                0,
                scale, scale,
                frame:getWidth()/2, frame:getHeight()/2
            )
        end
    end
    
    -- Draw effects at target position
    if effect.progress > 0.4 then
        -- Fade in at target position
        local targetAlpha = math.min(1.0, (effect.progress - 0.4) / 0.6)
        
        -- Draw glow effect at target with additive blending
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw converging ring for warp-in effect
        local ringSize = 90 - (effect.progress - 0.4) * 60
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.5 * targetAlpha)
        love.graphics.circle("line", effect.targetX, effect.targetY, ringSize)
        
        -- Draw bright glow core
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.8 * targetAlpha)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 25 * ((effect.progress - 0.4)/0.6))
        
        -- Draw inner bright center
        love.graphics.setColor(1, 1, 1, 0.9 * targetAlpha)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 10 * ((effect.progress - 0.4)/0.6))
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        -- Draw sprite-based warp effect if enabled
        if effect.useSprites and warpFrames then
            local frame = warpFrames[effect.currentFrame]
            local scale = 1.0 * ((effect.progress - 0.4)/0.6)
            
            -- Draw the warp sprite
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], targetAlpha)
            love.graphics.draw(
                frame,
                effect.targetX, effect.targetY,
                0,
                scale, scale,
                frame:getWidth()/2, frame:getHeight()/2
            )
        end
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle with additive blending for brighter effect
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.7)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        ::next_draw_particle::
    end
end

-- Initialize function for remote effects
local function initializeRemote(effect)
    -- For remote effects like warp, create particles at the target location
    -- Set flags for position tracking
    effect.useTargetPosition = true  -- This tells the system to use the current target position

    -- Make sure to use the initial position with offsets if available
    local centerX = effect.targetX
    local centerY = effect.targetY

    -- Initialize with offset if the target entity has position offsets
    if effect.targetEntity and effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
        centerX = effect.targetEntity.x + effect.targetEntity.currentXOffset
        centerY = effect.targetEntity.y + effect.targetEntity.currentYOffset

        -- Update effect's target position to include offsets
        effect.targetX = centerX
        effect.targetY = centerY

        print(string.format("[VFX] Initializing warp at (%d, %d) with offsets (%d, %d)",
            centerX, centerY, effect.targetEntity.currentXOffset, effect.targetEntity.currentYOffset))
    end

    local radius = effect.radius or 60

    -- Calculate how many particles to create based on density
    local particlesToCreate = effect.particleCount
    if effect.particleDensity then
        particlesToCreate = math.floor(effect.particleCount * effect.particleDensity)
    end

    for i = 1, particlesToCreate do
        -- Create particles in a circular pattern around the target
        local angle = (i / particlesToCreate) * math.pi * 2
        -- Random distance from center
        local distance = math.random(10, radius)
        -- Random speed for movement
        local speed = math.random(10, 70)

        -- Create particle using ParticleManager
        local particle = ParticleManager.createRemoteParticle(effect, angle, distance, speed)

        table.insert(effect.particles, particle)
    end

    -- Initialize sprite rotation angle if needed
    if effect.rotateSprite then
        effect.spriteAngle = 0
    end
end

-- Return the module
return {
    initialize = initializeRemote,
    update = updateRemote,
    draw = drawRemote
}```

## ./vfx/effects/surge.lua
```lua
-- surge.lua
-- Surge VFX module for handling fountain/burst effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for surge effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for surge effects
local function updateSurge(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.centerGlow = (effect.centerGlow ~= false) -- Default to true
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update center glow animation
    if effect.centerGlow then
        effect.centerParticleTimer = (effect.centerParticleTimer or 0) + dt
    end
    
    -- Rising helix motion around the caster
    for _, particle in ipairs(effect.particles) do
        if not particle then
            goto next_particle
        end

        particle.delay = particle.delay or 0
        particle.active = particle.active or false

        if effect.timer > particle.delay then
            particle.active = true
        end

        if particle.active then
            local age = effect.timer - particle.delay
            local progress = math.min(age / effect.duration, 1.0)

            local angle = (particle.startAngle or 0) + (particle.spinSpeed or 4) * age
            local radius = (particle.baseRadius or 8) + progress * (particle.spiralAmplitude or 20)
            local rise = progress * (effect.height or 160)

            particle.x = effect.sourceX + math.cos(angle) * radius
            particle.y = effect.sourceY - rise + math.sin(angle) * radius * 0.1

            -- Alpha fades in then out
            local alphaPeak = 0.3
            local alphaValue
            if progress < alphaPeak then
                alphaValue = progress / alphaPeak
            else
                alphaValue = 1.0 - ((progress - alphaPeak) / (1.0 - alphaPeak))
            end
            particle.alpha = alphaValue * (particle.baseAlpha or 1.0)

            local sizeCurve = 1.0 + math.sin(progress * math.pi) * 0.5
            particle.scale = (particle.baseScale or 0.3) * sizeCurve
        end

        ::next_particle::
    end
    
    -- Update center glow pulsing if enabled
    if effect.centerGlow then
        local pulseSpeed = 5
        effect.centerGlowPulse = 0.7 + 0.3 * math.sin(effect.centerParticleTimer * pulseSpeed)
    end
end

-- Draw function for surge effects
local function drawSurge(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default position
    effect.sourceY = effect.sourceY or 0 -- Default position
    effect.progress = effect.progress or 0 -- Default progress
    effect.centerGlow = (effect.centerGlow ~= false) -- Default to true
    effect.centerGlowPulse = effect.centerGlowPulse or 1.0 -- Default pulse value
    
    local particleImage = getAssetInternal("sparkle")
    local onePxImage = getAssetInternal("pixel")
    local twinkle1Image = getAssetInternal("twinkle1")
    local twinkle2Image = getAssetInternal("twinkle2")
    
    -- Draw expanding ground effect ring at source
    if effect.progress < 0.7 then
        local ringProgress = effect.progress / 0.7
        local ringSize = 30 + ringProgress * 40 -- Grows from 30 to 70 pixels
        local ringAlpha = 0.5 * (1 - ringProgress)
        
        love.graphics.setColor(effect.color[1] * 0.8, effect.color[2] * 0.8, effect.color[3] * 0.8, ringAlpha)
        love.graphics.circle("line", effect.sourceX, effect.sourceY, ringSize)
    end
    
    -- Draw center glow effect with additive blending
    if effect.centerGlow then
        -- Calculate glow size based on progress
        -- Stronger at the start, then fades
        local glowProgress = math.max(0, 1.0 - effect.progress * 1.5)
        local centerGlowSize = 30 * glowProgress
        
        -- Calculate pulsing and intensity
        local glowPulse = effect.centerGlowPulse or 1.0
        local glowIntensity = 1.0 + 0.5 * glowPulse
        local glowAlpha = 0.7 * glowProgress
        
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw outer glow layers with additive blending
        love.graphics.setColor(effect.color[1] * 0.5, effect.color[2] * 0.5, effect.color[3] * 0.5, glowAlpha * 0.4)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 1.2 * glowPulse)
        
        -- Middle glow layer
        love.graphics.setColor(effect.color[1] * 0.8, effect.color[2] * 0.8, effect.color[3] * 0.8, glowAlpha * 0.6)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.8 * glowPulse)
        
        -- Bright core
        love.graphics.setColor(effect.color[1] * glowIntensity, effect.color[2] * glowIntensity, 
                              effect.color[3] * glowIntensity, glowAlpha * 0.8)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.5 * glowPulse)
        
        -- White inner core
        love.graphics.setColor(1, 1, 1, glowAlpha * 0.9 * glowPulse)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.2 * glowPulse)
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle with additive blending for extra brightness
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.7)
        
        -- Choose sprite based on assigned type
        local sprite
        if particle.spriteType == "pixel" then
            sprite = onePxImage
        elseif particle.spriteType == "twinkle1" then
            sprite = twinkle1Image
        elseif particle.spriteType == "twinkle2" then
            sprite = twinkle2Image
        else
            sprite = particleImage
        end

        if sprite then
            love.graphics.draw(
                sprite,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                sprite:getWidth()/2, sprite:getHeight()/2
            )
        else
            -- Fallback if image missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 3)
        end
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        ::next_draw_particle::
    end
end

-- Initialize function for surge effects
local function initializeSurge(effect)
    -- Pre-load center particle
    effect.centerParticleTimer = 0

    -- Create particles with varied properties using ParticleManager
    for i = 1, effect.particleCount do
        local particle = ParticleManager.createSurgeParticle(effect)
        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeSurge,
    update = updateSurge,
    draw = drawSurge
}
```

## ./vfx/effects/zap.lua
```lua
-- zap.lua
-- Simple lightning zap effect drawing tiled sprites between source and target

local VFX

local function getAssetInternal(assetId)
    if not VFX then
        VFX = require("vfx")
    end
    return VFX.getAsset(assetId)
end

local function initializeZap(effect)
    effect.timer = 0
end

local function updateZap(effect, dt)
    -- ensure defaults
    effect.useSourcePosition = (effect.useSourcePosition ~= false)
    effect.useTargetPosition = (effect.useTargetPosition ~= false)
    effect.followSourceEntity = (effect.followSourceEntity ~= false)
    effect.followTargetEntity = (effect.followTargetEntity ~= false)
    effect.color = effect.color or {1,1,1}
    effect.segmentLength = effect.segmentLength or 20

    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
        end
    end
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
        end
    end

    local dx = (effect.targetX or 0) - (effect.sourceX or 0)
    local dy = (effect.targetY or 0) - (effect.sourceY or 0)
    effect.angle = math.atan2(dy, dx)
    effect.length = math.sqrt(dx*dx + dy*dy)
    effect.headX = (effect.sourceX or 0) + dx * (effect.progress or 0)
    effect.headY = (effect.sourceY or 0) + dy * (effect.progress or 0)
end

local function drawZap(effect)
    local frames = getAssetInternal("zapFrames")
    if not frames or #frames < 3 then return end
    local seg1, seg2, terminus = frames[1], frames[2], frames[3]

    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 1)

    local segLen = effect.segmentLength or seg1:getWidth()
    local drawn = 0
    local maxLen = math.min(effect.length, effect.length * (effect.progress or 0))

    while drawn + segLen < maxLen do
        local img = (math.floor(drawn/segLen) % 2 == 0) and seg1 or seg2
        local x = effect.sourceX + math.cos(effect.angle) * drawn
        local y = effect.sourceY + math.sin(effect.angle) * drawn
        love.graphics.draw(img, x, y, effect.angle, 1, 1, 0, img:getHeight()/2)
        drawn = drawn + segLen
    end

    -- draw terminus at head
    love.graphics.draw(terminus, effect.headX, effect.headY, effect.angle, 1, 1,
        terminus:getWidth()/2, terminus:getHeight()/2)
end

return {
    initialize = initializeZap,
    update = updateZap,
    draw = drawZap
}
```

## ./vfx/init.lua
```lua
-- Base VFX module that acts as the entrypoint
local VFX = require("vfx.lua") -- Relative path to vfx.lua in the game's root directory

-- Expose the module with its public interface
return VFX```

## ./vfx/initializeParticles.lua
```lua
-- initializeParticles.lua
-- Centralized function for initializing particles for each effect type

-- Import dependencies
local Constants = require("core.Constants")

-- Initialize particles function
local function initializeParticles(effect)
    -- Import the appropriate effect module
    local effectModule

    -- Extract the base effect type for loading the proper module
    local effectType = effect.type

    -- Map template names directly to module paths
    local typeToModuleMap = {
        -- Base templates
        ["proj_base"] = "projectile",
        ["bolt_base"] = "projectile",
        ["orb_base"] = "projectile",
        ["zap_base"] = "zap",
        ["impact_base"] = "impact",
        ["beam_base"] = "beam",
        ["blast_base"] = "cone",
        ["zone_base"] = "aura",
        ["util_base"] = "aura",
        ["surge_base"] = "surge",
        ["wave_base"] = "projectile",
        ["conjure_base"] = "conjure",
        ["remote_base"] = "remote",
        ["warp_base"] = "remote",
        ["shield_hit_base"] = "impact",

        -- Specific effect templates
        ["meteor"] = "meteor",
        ["impact"] = "impact",
        ["force_blast"] = "impact",
        ["free_mana"] = "aura",
        ["shield"] = "aura",
        ["emberlift"] = "surge",
        ["range_change"] = "surge",

        -- Critical backward compatibility (to be removed in future)
        [Constants.AttackType.PROJECTILE] = "projectile"
    }

    local moduleName = typeToModuleMap[effectType]

    -- If type isn't in our map, attempt a direct match with module name
    if not moduleName then
        -- Try using type as direct module name
        if effectType and (effectType == "projectile" or
                         effectType == "impact" or
                         effectType == "beam" or
                         effectType == "cone" or
                         effectType == "aura" or
                         effectType == "remote" or
                         effectType == "meteor" or
                         effectType == "surge" or
                         effectType == "conjure") then
            moduleName = effectType
            print(string.format("[VFX] Using effect.type '%s' directly as module name", effectType))
        else
            -- Last fallback to avoid crashes - default to impact effect
            print(string.format("[VFX] Warning: Unknown effect type: '%s' - falling back to impact", tostring(effectType)))
            moduleName = "impact"
        end
    end

    -- Load the module based on name
    effectModule = require("vfx.effects." .. moduleName)

    -- Call the module's initialize function if it exists
    if effectModule and effectModule.initialize then
        effectModule.initialize(effect)
    else
        print("[VFX] Warning: No initialize function found for effect type: " .. tostring(effectType))
    end
end

-- Return the function
return initializeParticles```

## ./wizard.lua
```lua
-- Wizard class

local Wizard = {}
Wizard.__index = Wizard

-- Load required modules
local Constants = require("core.Constants")
local SpellsModule = require("spells")
local Spells = SpellsModule.spells
local ShieldSystem = require("systems.ShieldSystem")
local WizardVisuals = require("systems.WizardVisuals")
local TokenManager = require("systems.TokenManager")
local UnlockSystem = require("systems.UnlockSystem")

-- We'll use game.compiledSpells instead of a local compiled spells table

-- Get a compiled spell by ID, compile on demand if not already compiled
local function getCompiledSpell(spellId, wizard)
    -- Make sure we have a game reference
    if not wizard or not wizard.gameState then
        print("Error: No wizard or gameState to get compiled spell")
        return nil
    end
    
    local gameState = wizard.gameState
    
    -- Try to get from game's compiled spells
    if gameState.compiledSpells and gameState.compiledSpells[spellId] then
        return gameState.compiledSpells[spellId]
    end
    
    -- If not found, try to compile on demand
    if Spells[spellId] and gameState.spellCompiler and gameState.keywords then
        -- Make sure compiledSpells exists
        if not gameState.compiledSpells then
            gameState.compiledSpells = {}
        end
        
        -- Compile the spell and store it
        gameState.compiledSpells[spellId] = gameState.spellCompiler.compileSpell(
            Spells[spellId], 
            gameState.keywords
        )
        print("Compiled spell on demand: " .. spellId)
        return gameState.compiledSpells[spellId]
    else
        print("Error: Could not compile spell with ID: " .. spellId)
        return nil
    end
end

function Wizard.new(name, x, y, color, spellbook)
    local self = setmetatable({}, Wizard)
    
    self.name = name
    self.x = x
    self.y = y
    self.color = color  -- RGB table
    
    -- Wizard state
    self.health = 100
    self.elevation = Constants.ElevationState.GROUNDED  -- GROUNDED or AERIAL
    self.elevationTimer = 0      -- Timer for temporary elevation changes
    
    -- Position animation state
    self.positionAnimation = {
        active = false,
        startX = 0,
        startY = 0, 
        targetX = 0,
        targetY = 0,
        progress = 0,
        duration = 0.3 -- 300ms animation by default
    }
    
    -- Status effects
    self.statusEffects = {
        [Constants.StatusType.BURN] = {
            active = false,
            duration = 0,
            tickDamage = 0,
            tickInterval = 1.0,
            elapsed = 0,         -- Time since last tick
            totalTime = 0        -- Total time effect has been active
        },
        [Constants.StatusType.STUN] = {
            active = false,
            duration = 0,
            elapsed = 0,
            totalTime = 0
        }
    }
    
    -- Visual effects
    self.blockVFX = {
        active = false,
        timer = 0,
        x = 0,
        y = 0
    }
    
    -- Hit flash effect
    self.hitFlashTimer = 0

    -- Cast frame animation properties
    self.castFrameSprite = nil
    self.castFrameTimer = 0
    self.castFrameDuration = 0.25 -- Show cast frame for 0.25 seconds

    -- Idle animation properties
    self.idleAnimationFrames = {}
    self.currentIdleFrame = 1
    self.idleFrameTimer = 0
    self.idleFrameDuration = 0.15 -- seconds per frame
    -- Positional animation sets (per range/elevation combo)
    self.positionalAnimations = {}
    self.lastPositionalKey = nil

    -- Spell cast notification (temporary until proper VFX)
    self.spellCastNotification = nil
    
    -- Spell keying system
    self.activeKeys = {
        [1] = false,
        [2] = false,
        [3] = false
    }
    self.currentKeyedSpell = nil
    
    -- Spell loadout provided by character data
    self.spellbook = spellbook or {}
    
    -- Create 3 spell slots for this wizard
    self.spellSlots = {}
    for i = 1, 3 do
        self.spellSlots[i] = {
            active = false,
            progress = 0,
            castTime = 0,
            spell = nil,
            spellType = nil,
            tokens = {},
            isShield = false,
            defenseType = nil,
            blocksAttackTypes = nil,
            reflect = false,
            frozen = false,
            freezeTimer = 0,
            castTimeModifier = 0, -- Additional time from freeze effects
            willBecomeShield = false,
            wasAlreadyCast = false -- Track if the spell has already been cast
        }
    end
    
    -- Load sprite with fallback
    local spritePath = "assets/sprites/" .. string.lower(name) .. ".png"
    local success, result = pcall(function()
        return love.graphics.newImage(spritePath)
    end)

    if success then
        self.sprite = result
        print("Loaded wizard sprite: " .. spritePath)
    else
        -- Fallback to default wizard sprite
        print("Warning: Could not load sprite " .. spritePath .. ". Using default wizard.png instead.")
        self.sprite = love.graphics.newImage("assets/sprites/wizard.png")
    end

    -- Load cast frame sprite with fallback
    local castFramePath = "assets/sprites/" .. string.lower(name) .. "-cast.png"
    local castSuccess, castResult = pcall(function()
        return love.graphics.newImage(castFramePath)
    end)

    if castSuccess then
        self.castFrameSprite = castResult
        print("Loaded wizard cast frame: " .. castFramePath)
    else
        -- No fallback for cast frame, just leave it nil
        print("Warning: Could not load cast frame " .. castFramePath .. ". Cast animation will be disabled.")
    end

    -- Load default idle animation frames (used as fallback for positional sets)
    if name == "Ashgar" then
        local AssetCache = require("core.AssetCache")
        for i = 1, 7 do
            local framePath = "assets/sprites/" .. string.lower(name) .. "-idle-" .. i .. ".png"
            local frameImg = AssetCache.getImage(framePath)
            if frameImg then
                table.insert(self.idleAnimationFrames, frameImg)
            else
                print("Warning: Could not load Ashgar idle frame: " .. framePath)
                table.insert(self.idleAnimationFrames, self.sprite)
            end
        end
        if #self.idleAnimationFrames == 0 then
            print("Warning: Ashgar has no idle animation frames loaded, using static sprite.")
            table.insert(self.idleAnimationFrames, self.sprite)
        end
    else
        table.insert(self.idleAnimationFrames, self.sprite)
    end

    -- Load positional animation sets (idle + cast for range/elevation combos)
    self:loadPositionalAnimations()

    self.scale = 1.0
    
    -- Keep references
    self.gameState = _G.game  -- Reference to global game state
    self.manaPool = self.gameState.manaPool
    
    -- Track UI offsets
    self.currentXOffset = 0
    self.currentYOffset = 0
    
    -- Flags for trap triggering and spell expiry
    self.justCastSpellThisFrame = false
    self.justConjuredMana = false
    
    return self
end

function Wizard:update(dt)
    -- Reset flags at the beginning of each frame
    self.justCastSpellThisFrame = false
    self.justConjuredMana = false

    -- Update hit flash timer
    if self.hitFlashTimer > 0 then
        self.hitFlashTimer = math.max(0, self.hitFlashTimer - dt)
    end

    -- Update cast frame timer
    if self.castFrameTimer > 0 then
        self.castFrameTimer = math.max(0, self.castFrameTimer - dt)
    end

    -- Update idle animation timer and frame based on positional state
    local posKey = self:getPositionalKey()

    if posKey ~= self.lastPositionalKey then
        self.currentIdleFrame = 1
        self.idleFrameTimer = 0
        self.lastPositionalKey = posKey
    end

    local idleFrames = self:getIdleFramesForKey(posKey)

    if self.castFrameTimer <= 0 then
        self.idleFrameTimer = self.idleFrameTimer + dt
        if self.idleFrameTimer >= self.idleFrameDuration then
            self.idleFrameTimer = self.idleFrameTimer - self.idleFrameDuration
            self.currentIdleFrame = self.currentIdleFrame + 1
            if self.currentIdleFrame > #idleFrames then
                self.currentIdleFrame = 1
            end
        end
    else
        self.currentIdleFrame = 1
        self.idleFrameTimer = 0
    end
    
    -- Update position animation
    if self.positionAnimation.active then
        self.positionAnimation.progress = self.positionAnimation.progress + dt / self.positionAnimation.duration
        
        -- Check if animation is complete
        if self.positionAnimation.progress >= 1.0 then
            self.positionAnimation.active = false
            self.positionAnimation.progress = 1.0
            self.currentXOffset = self.positionAnimation.targetX
            self.currentYOffset = self.positionAnimation.targetY
        end
    end
    
    -- Update stun status effect
    if self.statusEffects[Constants.StatusType.STUN] and self.statusEffects[Constants.StatusType.STUN].active then
        local stun = self.statusEffects[Constants.StatusType.STUN]
        stun.totalTime = stun.totalTime + dt
        if stun.duration > 0 and stun.totalTime >= stun.duration then
            stun.active = false
            stun.totalTime = stun.duration
            print(self.name .. " is no longer stunned")
        end
    end
    
    -- Update elevation effects (NEW LOGIC)
    if self.elevationEffects then
        for elevationType, effectData in pairs(self.elevationEffects) do
            effectData.duration = effectData.duration - dt
            
            if effectData.duration <= 0 then
                -- Execute the expiration action (e.g., set elevation back to GROUNDED)
                if effectData.expireAction then
                    effectData.expireAction()
                end
                
                -- Remove the effect from the table
                self.elevationEffects[elevationType] = nil
                
                -- Create landing VFX if we just returned to GROUNDED
                if self.elevation == Constants.ElevationState.GROUNDED then
                    if self.gameState and self.gameState.vfx then
                        local Constants = require("core.Constants")
                        self.gameState.vfx.createEffect(Constants.VFXType.IMPACT, self.x, self.y + 30, nil, nil, {
                            duration = 0.5,
                            color = {0.7, 0.7, 0.7, 0.8},
                            particleCount = 8,
                            radius = 20
                        })
                    end
                end
            end
        end
    end
    
    -- Update shield visuals using ShieldSystem
    ShieldSystem.updateShieldVisuals(self, dt)
    
    -- Update status effects generically
    if self.statusEffects then
        for effectType, effectData in pairs(self.statusEffects) do
            if effectData.active then
                -- Increment total time the effect has been active
                effectData.totalTime = effectData.totalTime + dt
                
                -- Check for expiration
                if effectData.duration > 0 then -- Only expire effects with explicit duration
                    if effectData.totalTime >= effectData.duration then
                        -- Reset the effect
                        effectData.active = false
                        effectData.elapsed = 0
                        effectData.totalTime = 0
                        print(string.format("%s's %s effect expired", self.name, effectType))
                    end
                end
                
                -- If this is a burn effect, handle damage ticks
                if effectType == Constants.StatusType.BURN and effectData.active then
                    effectData.elapsed = effectData.elapsed + dt
                    if effectData.elapsed >= effectData.tickInterval then
                        -- Apply burn damage
                        self.health = math.max(0, self.health - effectData.tickDamage)
                        
                        -- Set hit flash timer for DoT visual feedback
                        self.hitFlashTimer = 0.125 -- 125ms flash duration
                        
                        print(string.format("%s took %d burn damage (health: %d)", 
                            self.name, effectData.tickDamage, self.health))
                        
                        -- Create burn damage effect
                        if self.gameState and self.gameState.vfx then
                            self.gameState.vfx.createEffect(Constants.VFXType.IMPACT, self.x, self.y, nil, nil, {
                                duration = 0.3,
                                color = {1.0, 0.2, 0.0, 0.6},
                                particleCount = 10,
                                radius = 25
                            })
                        end
                        
                        -- Reset tick interval timer but keep total duration timer
                        effectData.elapsed = 0
                        
                        -- Check for defeat
                        if self.health <= 0 then
                            print(self.name .. " was defeated by burn damage!")
                            if self.gameState then
                                self.gameState.gameOver = true
                                self.gameState.winner = self.name == "Ashgar" and "Selene" or "Ashgar"
                                
                                -- Create defeat effect
                                if self.gameState.vfx then
                                    self.gameState.vfx.createEffect(Constants.VFXType.IMPACT, self.x, self.y, nil, nil, {
                                        duration = 1.0,
                                        color = {1.0, 0.0, 0.0, 0.8},
                                        particleCount = 30,
                                        radius = 80
                                    })
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Update block effect
    if self.blockVFX.active then
        self.blockVFX.timer = self.blockVFX.timer - dt
        if self.blockVFX.timer <= 0 then
            self.blockVFX.active = false
        end
    end
    
    -- Update cast notification
    if self.spellCastNotification then
        self.spellCastNotification.timer = self.spellCastNotification.timer - dt
        if self.spellCastNotification.timer <= 0 then
            self.spellCastNotification = nil
        end
    end
    
    -- Update spell slots
    for i, slot in ipairs(self.spellSlots) do
        if slot.active then
            if slot.isShield then
                -- Shields remain active and don't progress further
                -- But we still need to update token orbits, which happens below
            else
                -- For frozen spells, don't increment progress but accumulate castTimeModifier
                if slot.frozen then
                    -- Track the total freeze time as castTimeModifier
                    slot.castTimeModifier = (slot.castTimeModifier or 0) + dt
                    
                    -- Decrease freeze timer
                    slot.freezeTimer = slot.freezeTimer - dt
                    if slot.freezeTimer <= 0 then
                        slot.frozen = false
                        print(string.format("%s's spell in slot %d is no longer frozen after %.2f seconds (%.4f castTimeModifier)", 
                            self.name, i, slot.castTimeModifier, slot.castTimeModifier))
                    end
                else
                    -- Normal progress update for unfrozen spells
                    slot.progress = slot.progress + dt
                    
                    -- Shield state is now managed directly in the castSpell function
                    -- and tokens remain as CHANNELED until the shield is activated
                    
                    -- ONLY check for spell completion when NOT frozen
                    if slot.progress >= slot.castTime and not slot.wasAlreadyCast then
                        -- Mark this slot as already cast to prevent repeated casting
                        slot.wasAlreadyCast = true
                        
                        -- Cast the spell
                        self:castSpell(i)
                        
                        -- Debug message to confirm we're setting the flag
                        print(string.format("[DEBUG] Marked slot %d as already cast to prevent repetition", i))
                        
                        -- For non-shield spells, we return tokens and reset the slot
                        -- For shield spells, castSpell will handle setting up the shield 
                        -- UNLESS the spell is a sustained spell like a trap
                        
                        -- Check for both shield and sustained spells (traps, etc.)
                        if not slot.isShield and not slot.sustainedId then
                            -- Start return animation for tokens
                            if #slot.tokens > 0 then
                                for _, tokenData in ipairs(slot.tokens) do
                                    -- Request return animation directly on the token
                                    if tokenData.token and tokenData.token.requestReturnAnimation then
                                        tokenData.token:requestReturnAnimation()
                                    else
                                        -- Fallback to legacy method if token doesn't have the method
                                        self.manaPool:returnToken(tokenData.index)
                                    end
                                end
                                
                                -- Clear token list (tokens still exist in the mana pool)
                                slot.tokens = {}
                            end
                            
                            -- Reset slot using unified method only if it's not a sustained spell
                            self:resetSpellSlot(i)
                        end
                    end
                end
            end
        end
    end

    -- Update visual particles for spell slot arcs
    WizardVisuals.updateArcParticles(self, dt)
end

function Wizard:draw()
    -- Use WizardVisuals module for drawing
    WizardVisuals.drawWizard(self)
end

-- Helper function to draw an ellipse (delegated to WizardVisuals)
function Wizard:drawEllipse(x, y, radiusX, radiusY, mode)
    return WizardVisuals.drawEllipse(x, y, radiusX, radiusY, mode)
end

-- Helper function to draw an elliptical arc (delegated to WizardVisuals)
function Wizard:drawEllipticalArc(x, y, radiusX, radiusY, startAngle, endAngle, segments)
    return WizardVisuals.drawEllipticalArc(x, y, radiusX, radiusY, startAngle, endAngle, segments)
end

-- Draw status effects with durations using horizontal bars (delegated to WizardVisuals)
function Wizard:drawStatusEffects()
    return WizardVisuals.drawStatusEffects(self)
end

function Wizard:drawSpellSlots()
    -- Delegate to WizardVisuals module
    return WizardVisuals.drawSpellSlots(self)
end

-- Handle key press and update currently keyed spell
function Wizard:keySpell(keyIndex, isPressed)
    -- Check if wizard is stunned
    local stun = self.statusEffects[Constants.StatusType.STUN]
    if stun and stun.active and isPressed then
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        print(self.name .. " tried to key a spell but is stunned for " .. string.format("%.1f", remaining) .. " more seconds")
        return false
    end
    
    -- Update key state
    self.activeKeys[keyIndex] = isPressed
    
    -- Determine current key combination
    local keyCombo = ""
    for i = 1, 3 do
        if self.activeKeys[i] then
            keyCombo = keyCombo .. i
        end
    end
    
    -- Update currently keyed spell based on combination
    if keyCombo == "" then
        self.currentKeyedSpell = nil
    else
        self.currentKeyedSpell = self.spellbook[keyCombo]
        
        -- Log the currently keyed spell
        if self.currentKeyedSpell then
            print(self.name .. " keyed " .. self.currentKeyedSpell.name .. " (" .. keyCombo .. ")")
            
            -- Debug: verify spell definition is complete
            if not self.currentKeyedSpell.cost then
                print("WARNING: Spell '" .. self.currentKeyedSpell.name .. "' has no cost defined!")
            end
        else
            print(self.name .. " has no spell for key combination: " .. keyCombo)
        end
    end
    
    return true
end

-- Cast the currently keyed spell
function Wizard:castKeyedSpell()
    -- Check if wizard is stunned
    local stun = self.statusEffects[Constants.StatusType.STUN]
    if stun and stun.active then
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        print(self.name .. " tried to cast a spell but is stunned for " .. string.format("%.1f", remaining) .. " more seconds")
        return false
    end
    
    -- Check if a spell is keyed
    if not self.currentKeyedSpell then
        print(self.name .. " tried to cast, but no spell is keyed")
        return false
    end
    
    -- Queue the spell
    return self:queueSpell(self.currentKeyedSpell)
end

-- Format mana cost for display
function Wizard:formatCost(cost)
    if not cost then return "nil" end
    
    -- If cost is not a table, return as string
    if type(cost) ~= "table" then
        return tostring(cost)
    end
    
    -- Format cost components
    local costStrings = {}
    for _, component in ipairs(cost) do
        if type(component) == "table" and component.type then
            table.insert(costStrings, component.amount .. " " .. component.type)
        else
            table.insert(costStrings, tostring(component))
        end
    end
    
    return table.concat(costStrings, ", ")
end

function Wizard:queueSpell(spell)
    -- Check if wizard is stunned
    local stun = self.statusEffects[Constants.StatusType.STUN]
    if stun and stun.active then
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        print(self.name .. " tried to queue a spell but is stunned for " .. string.format("%.1f", remaining) .. " more seconds")
        return false
    end
    
    -- Validate the spell
    if not spell then
        print("No spell provided to queue")
        return false
    end
    
    -- Get the compiled spell if available
    local spellToUse = spell
    if spell.id and not spell.executeAll then
        -- This is an original spell definition, not a compiled one - get the compiled version
        local compiledSpell = getCompiledSpell(spell.id, self)
        if compiledSpell then
            spellToUse = compiledSpell
            print("Using compiled spell for queue: " .. spellToUse.id)
        else
            print("Warning: Using original spell definition - could not get compiled version of " .. spell.id)
        end
    end
    
    -- Find the innermost available spell slot
    for i = 1, #self.spellSlots do
        if not self.spellSlots[i].active then
            -- Determine cost source (static table or dynamic function)
            local costSource = spellToUse.getCost or spellToUse.cost

            -- Check if we can pay the mana cost from the pool
            local tokenReservations = self:canPayManaCost(costSource)
            
            if tokenReservations then
                local tokens = {}
                
                -- Check if we need tokens (empty cost doesn't need tokens)
                if #tokenReservations == 0 then
                    -- Free spell - no tokens needed
                    print("[TOKEN MANAGER] Free spell (no mana cost)")
                else
                    -- Resolve actual cost table now if using dynamic cost
                    local actualCost = type(costSource) == "function" and costSource(self, nil) or costSource

                    -- Use TokenManager to acquire and position tokens for the spell
                    local success, acquiredTokens = TokenManager.acquireTokensForSpell(self, i, actualCost)
                    
                    -- If TokenManager succeeded, use those tokens
                    if success and acquiredTokens then
                        tokens = acquiredTokens
                    else
                        -- TokenManager failed, fallback to legacy method
                        print("[TokenManager] Failed to acquire tokens, using legacy method")
                        
                        -- Move each token from mana pool to spell slot with animation
                        for _, reservation in ipairs(tokenReservations) do
                            local token = self.manaPool.tokens[reservation.index]
                            
                            -- Mark the token as being channeled using state machine if available
                            if token.setState then
                                token:setState(Constants.TokenStatus.CHANNELED)
                            else
                                token.state = Constants.TokenState.CHANNELED
                            end
                            
                            -- Store original position for animation
                            token.startX = token.x
                            token.startY = token.y
                            
                            -- Calculate target position in the spell slot based on 3D positioning
                            -- These must match values in drawSpellSlots
                            local slotYOffsets = {30, 0, -30}  -- legs, midsection, head
                            local horizontalRadii = {80, 70, 60}
                            local verticalRadii = {20, 25, 30}
                            
                            local targetX = self.x
                            local targetY = self.y + slotYOffsets[i]  -- Vertical offset based on slot
                            
                            -- Animation data
                            token.targetX = targetX
                            token.targetY = targetY
                            token.animTime = 0
                            token.animDuration = 0.5 -- Half second animation
                            token.slotIndex = i
                            token.tokenIndex = #tokens + 1 -- Position in the slot
                            token.spellSlot = i
                            token.wizardOwner = self
                            
                            -- 3D perspective data
                            token.radiusX = horizontalRadii[i]
                            token.radiusY = verticalRadii[i]
                            
                            table.insert(tokens, {token = token, index = reservation.index})
                        end
                    end
                end
                
                -- Store the tokens and cost in the spell slot
                self.spellSlots[i].tokens = tokens
                self.spellSlots[i].cost = type(costSource) == "function" and costSource(self, nil) or costSource
                
                -- Successfully paid the cost, queue the spell
                self.spellSlots[i].active = true
                self.spellSlots[i].progress = 0
                self.spellSlots[i].spellType = spellToUse.name
                
                -- Calculate base cast time (handling dynamic function)
                local baseCastTime
                if spellToUse.getCastTime and type(spellToUse.getCastTime) == "function" then
                    baseCastTime = spellToUse.getCastTime(self)
                    print(self.name .. " is using dynamic base cast time: " .. baseCastTime .. "s")
                else
                    baseCastTime = spellToUse.castTime
                end

                -- Check for and apply Slow status effect
                local finalCastTime = baseCastTime
                if self.statusEffects and self.statusEffects[Constants.StatusType.SLOW] and self.statusEffects[Constants.StatusType.SLOW].active then
                    local slowEffect = self.statusEffects[Constants.StatusType.SLOW]
                    local targetSlot = slowEffect.targetSlot -- Slot the slow effect targets (nil for any)
                    local queueingSlot = i -- Slot we are currently queueing into

                    -- Check if the slow effect applies to this specific slot or any slot
                    if targetSlot == nil or targetSlot == 0 or targetSlot == queueingSlot then
                        local slowMagnitude = slowEffect.magnitude or 0
                        finalCastTime = baseCastTime + slowMagnitude
                        print(string.format("[STATUS] Slow effect applied! Base cast: %.1fs, Slowed cast: %.1fs (Slot %s)",
                            baseCastTime, finalCastTime, tostring(targetSlot or "Any")))
                        
                        -- Consume the slow effect
                        slowEffect.active = false
                        slowEffect.magnitude = nil
                        slowEffect.targetSlot = nil 
                        -- Keep duration timer running so it eventually clears from statusEffects table if update loop doesn't
                    end
                end
                
                -- Store the final cast time (potentially modified by slow)
                self.spellSlots[i].castTime = finalCastTime
                
                self.spellSlots[i].spell = spellToUse
                
                -- Check if this is a shield spell and mark it accordingly
                if spellToUse.isShield or (spellToUse.keywords and spellToUse.keywords.block) then
                    print("SHIELD SPELL DETECTED during queue: " .. spellToUse.name)
                    -- Flag that this will become a shield when cast
                    self.spellSlots[i].willBecomeShield = true
                    
                    -- Prepare tokens for shield status using TokenManager
                    TokenManager.prepareTokensForShield(tokens)
                    
                    -- DO NOT mark tokens as SHIELDING yet - let them orbit normally during casting
                    -- Only mark them as SHIELDING after the spell is fully cast
                    
                    -- Mark this in the compiled spell if not already marked
                    if not spellToUse.isShield then
                        spellToUse.isShield = true
                    end
                end
                
                -- Set attackType if present in the new schema
                if spellToUse.attackType then
                    self.spellSlots[i].attackType = spellToUse.attackType
                end
                
                print(self.name .. " queued " .. spellToUse.name .. " in slot " .. i .. " (cast time: " .. spellToUse.castTime .. "s)")
                return true
            else
                -- Couldn't pay the cost
                print(self.name .. " tried to queue " .. spellToUse.name .. " but couldn't pay the mana cost")
                return false
            end
        end
    end
    
    -- No available slots
    print(self.name .. " tried to queue " .. spellToUse.name .. " but all slots are full")
    return false
end

-- This is a stub that delegates to the ShieldSystem module
local function createShield(wizard, spellSlot, shieldParams)
    return ShieldSystem.createShield(wizard, spellSlot, shieldParams)
end

-- Add createShield method to Wizard for compatibility
function Wizard:createShield(spellSlot, shieldParams)
    return ShieldSystem.createShield(self, spellSlot, shieldParams)
end

-- Free all active spells and return their mana to the pool
function Wizard:freeAllSpells()
    print(self.name .. " is freeing all active spells")
    
    -- Iterate through all spell slots
    for i, slot in ipairs(self.spellSlots) do
        if slot.active then
            -- Return tokens to the mana pool using TokenManager
            if #slot.tokens > 0 then
                -- Use TokenManager to return all tokens to pool
                TokenManager.returnTokensToPool(slot.tokens)
                
                -- Clear token list (tokens still exist in the mana pool)
                slot.tokens = {}
            end
            
            -- Reset all slot properties using unified method
            self:resetSpellSlot(i)
            
            print("Freed spell in slot " .. i)
        end
    end
    
    -- Create visual effect for all spells being canceled
    if self.gameState and self.gameState.vfx then
        self.gameState.vfx.createEffect(Constants.VFXType.FREE_MANA, self.x, self.y, nil, nil)
    end
    
    -- Reset active key inputs
    for i = 1, 3 do
        self.activeKeys[i] = false
    end
    
    -- Clear keyed spell
    self.currentKeyedSpell = nil
    
    return true
end

-- Helper function to check if mana cost can be paid without actually taking the tokens
-- This is a wrapper around TokenManager functionality for backward compatibility
-- Helper function to check if mana cost can be paid without actually taking the tokens
-- Accepts either a cost table or a getCost function
function Wizard:canPayManaCost(costOrGetCostFn, target)
    local cost = costOrGetCostFn

    if type(costOrGetCostFn) == "function" then
        cost = costOrGetCostFn(self, target)
    end

    local tokenReservations = {}
    local reservedIndices = {} -- Track which token indices are already reserved
    
    -- Handle cost being nil or not a table
    if not cost then
        return {}
    end
    
    -- Check if cost is a valid table we can iterate through
    if type(cost) ~= "table" then
        print("Cost is not a table, it's a " .. type(cost))
        return nil
    end
    
    -- Early exit if cost is empty
    if #cost == 0 then 
        return {} 
    end
    
    -- Convert legacy cost format to standardized manaCost object
    local standardizedCost = {}
    
    -- Process each cost component
    for i, component in ipairs(cost) do
        if type(component) == "table" and component.type and component.amount then
            -- New schema: {type="fire", amount=2}
            local tokenType = component.type
            standardizedCost[tokenType] = (standardizedCost[tokenType] or 0) + component.amount
        elseif type(component) == "string" then
            -- Old schema: "fire", "water", "any", etc.
            standardizedCost[component] = (standardizedCost[component] or 0) + 1
        elseif type(component) == "number" then
            -- Old schema numeric: 1, 2, 3 means ANY token of that count
            -- Use "any" for consistency with string "any"
            standardizedCost[Constants.TokenType.ANY] = (standardizedCost[Constants.TokenType.ANY] or 0) + component
        else
            -- Unknown cost component format
            print("Unknown cost component format: " .. type(component))
            return nil
        end
    end
    
    -- Using our local function to maintain backward compatibility
    local function reserveToken(tokenType, amount)
        -- Find matching tokens in the mana pool
        
        local count = 0
        
        -- Special case for "any" token type
        if tokenType == Constants.TokenType.ANY or tokenType == "ANY" then
            -- Go through all tokens in the mana pool
            for i, token in ipairs(self.manaPool.tokens) do
                -- Skip already reserved tokens
                if not reservedIndices[i] and token.state == Constants.TokenState.FREE then
                    -- Any free token will work
                    count = count + 1
                    
                    -- Add to reservations
                    table.insert(tokenReservations, {index = i, token = token})
                    reservedIndices[i] = true
                    
                    -- Check if we've found enough
                    if count >= amount then
                        break
                    end
                end
            end
        else
            -- Normal token type or nil (for random)
            -- Go through all tokens in the mana pool
            for i, token in ipairs(self.manaPool.tokens) do
                -- Skip already reserved tokens
                if not reservedIndices[i] then
                    -- Match either by specific type or any type if no type specified
                    if (tokenType == nil and token.state == Constants.TokenState.FREE) or (token.type == tokenType and token.state == Constants.TokenState.FREE) then
                        -- This token matches our requirements
                        count = count + 1
                        
                        -- Add to reservations
                        table.insert(tokenReservations, {index = i, token = token})
                        reservedIndices[i] = true
                        
                        -- Check if we've found enough
                        if count >= amount then
                            break
                        end
                    end
                end
            end
        end
        
        -- Check if we found enough tokens
        return count >= amount
    end
    
    -- Check each token type in the standardized cost
    for tokenType, amount in pairs(standardizedCost) do
        if tokenType == Constants.TokenType.RANDOM or tokenType == Constants.TokenType.ANY or tokenType == "ANY" then
            -- Random/any token type (any token will do)
            local success = reserveToken(tokenType, amount)
            if not success then
                print("Cannot find " .. amount .. " tokens of any type")
                return nil
            end
        else
            -- Specific token type
            local success = reserveToken(tokenType, amount)
            if not success then
                print("Cannot find enough " .. tokenType .. " tokens (need " .. amount .. ")")
                return nil
            end
        end
    end
    
    -- If we get here, all components were successfully reserved
    return tokenReservations
end

function Wizard:castSpell(spellSlot)
    local slot = self.spellSlots[spellSlot]
    if not slot or not slot.active or not slot.spell then return end
    
    -- Set the flag to indicate a spell was cast this frame (for trap triggers)
    self.justCastSpellThisFrame = true

    print(self.name .. " cast " .. slot.spellType .. " from slot " .. spellSlot)

    -- Activate cast frame animation if sprite is available
    if self.castFrameSprite then
        self.castFrameTimer = self.castFrameDuration
    end
    
    -- Create a temporary visual notification for spell casting
    self.spellCastNotification = {
        text = self.name .. " cast " .. slot.spellType,
        timer = 2.0,  -- Show for 2 seconds
        x = self.x,
        y = self.y + 70, -- Moved below the wizard instead of above
        color = {self.color[1]/255, self.color[2]/255, self.color[3]/255, 1.0}
    }
    
    -- Get target (the other wizard)
    local target = nil
    for _, wizard in ipairs(self.gameState.wizards) do
        if wizard ~= self then
            target = wizard
            break
        end
    end
    
    if not target then return end
    
    -- Get the spell (either compiled or original)
    local spellToUse = slot.spell
    
    -- Convert to compiled spell if needed
    if spellToUse.id and not spellToUse.executeAll then
        -- This is an original spell, not a compiled one - get the compiled version
        local compiledSpell = getCompiledSpell(spellToUse.id, self)
        if compiledSpell then
            spellToUse = compiledSpell
            -- Store the compiled spell back in the slot for future use
            slot.spell = compiledSpell
            print("Using compiled spell: " .. spellToUse.id)
        else
            print("Warning: Falling back to original spell - could not get compiled version of " .. spellToUse.id)
        end
    end

    -- Check for character unlocks based on this spell
    UnlockSystem.checkSpellUnlock(spellToUse, self)
    
    -- Get attack type for shield checking
    local attackType = spellToUse.attackType or Constants.AttackType.PROJECTILE
    
    -- Check if the spell can be blocked by any of the target's shields
    -- This now happens BEFORE spell execution per ticket PROG-20
    local blockInfo = ShieldSystem.checkShieldBlock(spellToUse, attackType, target, self)
    
    -- Handle shield block effects
    if blockInfo.blockable then
        print(string.format("[SHIELD BLOCK] %s's %s was blocked by %s's %s shield!", 
            self.name, spellToUse.name, target.name, blockInfo.blockType or "unknown"))
        
        -- Set a standard blockPoint for visual effect (75% of the way from caster to target)
        blockInfo.blockPoint = 0.75
        
        -- Use the ShieldSystem to handle token consumption for the shield
        ShieldSystem.handleShieldBlock(target, blockInfo.blockingSlot, spellToUse)
        
        -- Create a partial results table with initialResults
        local blockedResults = { blockInfo = blockInfo }
        
        -- Execute the spell, but convert the DAMAGE events to BLOCKED_DAMAGE
        -- This will show visuals but prevent actual damage application
        effect = spellToUse.executeAll(self, target, blockedResults, spellSlot)
        
        -- Set blocked flag in the effect results
        effect.blocked = true
        effect.blockType = blockInfo.blockType
        effect.blockingSlot = blockInfo.blockingSlot
        
        -- Return tokens from our spell slot
        if #slot.tokens > 0 then
            -- Use TokenManager to return tokens to pool
            TokenManager.returnTokensToPool(slot.tokens)
            -- Clear token list after requesting return animations
            slot.tokens = {}
        end
        
        -- Reset our slot using unified method
        self:resetSpellSlot(spellSlot)
        
        -- Return the effect
        return effect
    end
    
    -- Now execute the spell
    
    -- For tracking if the spell is a shield spell
    local isShieldSpell = false
    if slot.willBecomeShield or spellToUse.isShield then
        isShieldSpell = true
    end
    
    -- Handle spell execution based on type
    local effect = nil
    local shouldSustain = false  -- Initialize outside if-block so it's available throughout the function
    
    -- Execute the spell using compiled spell format
    print("Executing spell: " .. spellToUse.id)
    
    -- Execute the spell with blockInfo if the spell is blocked
    local initialResults = blockInfo.blockable and { blockInfo = blockInfo } or {}
    effect = spellToUse.executeAll(self, target, initialResults, spellSlot)
    
    -- After execution, check if the spell was blocked (results should have blocked=true)
    if effect.blocked then
        print(string.format("[SHIELD] %s's %s was fully blocked by shield!", 
            self.name, spellToUse.name))
    end
    
    -- Check if this is a sustained spell (from sustain keyword)
    shouldSustain = effect.isSustained or false
    print("DEBUG: effect.isSustained = " .. tostring(effect.isSustained) .. ", shouldSustain = " .. tostring(shouldSustain))
    
    -- If no valid effect was returned, create an empty one
    if not effect then
        print("WARNING: Spell " .. spellToUse.id .. " didn't return any effect")
        effect = {}
    end
    
    -- Shield spell creation - check if the effect has shield params
    if effect.isShield and not effect.blocked and not slot.isShield then
        if effect.shieldParams then
            -- Create a shield in this spell slot using ShieldSystem
            print("Creating shield in spell slot " .. spellSlot)
            
            -- Explicitly mark as sustained (shields are a type of sustained spell)
            effect.isSustained = true
            shouldSustain = true
            
            -- Mark this slot as already cast to prevent repeated casting
            slot.wasAlreadyCast = true
            
            local shieldResult = ShieldSystem.createShield(self, spellSlot, effect.shieldParams)
            
            -- Register shield with SustainedSpellManager (shields are a type of sustained spell)
            if shieldResult.shieldCreated and self.gameState and self.gameState.sustainedSpellManager then
                -- Mark the effect as sustained for shields too
                effect.isSustained = true
                shouldSustain = true  -- Make sure shouldSustain is set for shields as well
                
                -- Make sure the shield params are set in the proper field expected by SustainedSpellManager
                effect.shieldParams = effect.shieldParams or {}
                effect.isShield = true
                
                local sustainedId = self.gameState.sustainedSpellManager.addSustainedSpell(
                    self,        -- wizard who cast the spell
                    spellSlot,   -- slot index where the shield is
                    effect       -- effect table from executeAll with shield params
                )
                
                -- Store the sustained spell ID in the slot for reference
                slot.sustainedId = sustainedId
                
                print(string.format("[SUSTAINED] Registered shield in slot %d with ID: %s", 
                    spellSlot, tostring(sustainedId)))
            end
            
            -- Apply any elevation change specified by the shield
            if shieldResult.shieldCreated and effect.shieldParams.setElevation then
                self.elevation = effect.shieldParams.setElevation
                if effect.shieldParams.elevationDuration and effect.shieldParams.setElevation == Constants.ElevationState.AERIAL then
                    self.elevationTimer = effect.shieldParams.elevationDuration
                end
                print(self.name .. " moved to " .. self.elevation .. " elevation by shield spell")
            end
        else
            print("ERROR: Shield spell missing shieldParams")
        end
    end
    
    -- For shields, skip the rest of the processing (shields are a specific kind of sustained spell)
    if effect.isShield or slot.isShield then
        -- Debug log - make it clear to use sustain instead in new code, but shields keep working
        if effect.isSustained and effect.isShield then
            print("[SUSTAINED] Note: Spell " .. spellToUse.id .. " has both isShield and isSustained flags - shields are already sustained")
        end
        return effect
    end
    
    if not isShieldSpell and not slot.isShield and not effect.isShield then
        -- Only reset slot and return tokens if this isn't a sustained spell
        if not shouldSustain then
            -- Start return animation for tokens
            if #slot.tokens > 0 then
                -- Check if any tokens are marked as SHIELDING using TokenManager
                local hasShieldingTokens = false
                for _, tokenData in ipairs(slot.tokens) do
                    if tokenData.token and TokenManager.validateTokenState(tokenData.token, Constants.TokenStatus.SHIELDING) then
                        hasShieldingTokens = true
                        break
                    end
                end
                
                -- Handle blocked spells - should always return tokens
                if effect and effect.blocked then
                    print("Returning tokens for blocked spell")
                    TokenManager.returnTokensToPool(slot.tokens)
                    slot.tokens = {}
                elseif not hasShieldingTokens then
                    -- Normal case: Safe to return tokens if not shielding
                    TokenManager.returnTokensToPool(slot.tokens)
                    
                    -- Clear token list (tokens still exist in the mana pool)
                    slot.tokens = {}
                else
                    print("Found SHIELDING tokens, preventing token return")
                end
            end
            
            -- Reset slot only if it's not a shield
            self:resetSpellSlot(spellSlot)
        else
            -- This is a sustained spell - keep slot active and tokens in place
            print(string.format("[SUSTAINED] %s's spell in slot %d is being sustained", self.name, spellSlot))
            
            -- Keep the slot as active with full progress
            slot.active = true
            slot.progress = slot.castTime -- Mark as fully cast
            slot.wasAlreadyCast = true -- Keep the flag set to prevent repeated casting
            
            -- Register with the SustainedSpellManager
            if self.gameState and self.gameState.sustainedSpellManager then
                local sustainedId = self.gameState.sustainedSpellManager.addSustainedSpell(
                    self,        -- wizard who cast the spell
                    spellSlot,   -- slot index where the spell is
                    effect       -- effect table from executeAll (contains trapTrigger, trapEffect, etc.)
                )
                
                -- Store the sustained spell ID in the slot for reference
                slot.sustainedId = sustainedId
                
                print(string.format("[SUSTAINED] Registered spell in slot %d with ID: %s", 
                    spellSlot, tostring(sustainedId)))
            else
                print("[SUSTAINED ERROR] Could not register sustained spell - gameState or sustainedSpellManager missing")
            end
        end
    else
        -- For shield spells, the slot remains active and tokens remain in orbit
        -- Make sure slot is marked as a shield
        slot.isShield = true
        
        -- Use TokenManager to mark tokens as SHIELDING
        TokenManager.markTokensAsShielding(slot.tokens)
    end
end

-- Reset a spell slot to its default state
-- This function can be used to clear a slot when a spell is cast, canceled, or a shield is destroyed
function Wizard:resetSpellSlot(slotIndex)
    local slot = self.spellSlots[slotIndex]
    if not slot then return end
    
    -- Debug message when slot reset happens
    print(string.format("[DEBUG] resetSpellSlot called for %s slot %d", self.name, slotIndex))
    
    -- Remove from SustainedSpellManager if it's a sustained spell
    if slot.sustainedId and self.gameState and self.gameState.sustainedSpellManager then
        self.gameState.sustainedSpellManager.removeSustainedSpell(slot.sustainedId)
        print(string.format("[SUSTAINED] Removed spell in slot %d with ID: %s during slot reset", 
            slotIndex, tostring(slot.sustainedId)))
        slot.sustainedId = nil
    end

    -- Reset the basic slot properties
    slot.active = false
    slot.spell = nil
    slot.spellType = nil
    slot.castTime = 0
    slot.castProgress = 0
    slot.progress = 0 -- Used in many places instead of castProgress
    slot.wasAlreadyCast = false -- Reset the flag that tracks if the spell was already cast
    
    -- Reset shield-specific properties
    slot.isShield = false
    slot.willBecomeShield = false
    slot.defenseType = nil
    slot.blocksAttackTypes = nil
    slot.blockTypes = nil
    slot.reflect = nil
    slot.shieldStrength = 0
    
    -- Reset spell status properties
    slot.frozen = false
    slot.freezeTimer = 0
    slot.castTimeModifier = 0 -- Renamed from frozenTimeAccrued
    
    -- Reset zone-specific properties
    slot.zoneAnchored = nil
    slot.anchorRange = nil
    slot.anchorElevation = nil
    slot.anchorRequireAll = nil
    slot.affectsBothRanges = nil
    
    -- Reset spell properties
    slot.attackType = nil
    
    -- Clear token references *after* animations have been requested
    slot.tokens = {}
end

-- Add method to check for spell fizzle/shield collapse when a token is removed
-- This is a wrapper around TokenManager.checkFizzleCondition
function Wizard:checkFizzleOnTokenRemoval(slotIndex, removedTokenObject)
    return TokenManager.checkFizzleCondition(self, slotIndex, removedTokenObject)
end

-- Handle the effects of a spell being blocked by a shield in a specific slot
-- This is now a wrapper method that delegates to ShieldSystem
function Wizard:handleShieldBlock(slotIndex, incomingSpell)
    print("[WIZARD DEBUG] handleShieldBlock called for " .. self.name .. " slot " .. slotIndex)
    
    -- Debug the shield slot to check for onBlock
    if self.spellSlots and self.spellSlots[slotIndex] then
        local slot = self.spellSlots[slotIndex]
        if slot.onBlock then
            print("[WIZARD DEBUG] onBlock handler found in shield slot")
        else
            print("[WIZARD DEBUG] No onBlock handler found in shield slot")
        end
    else
        print("[WIZARD DEBUG] Invalid slot index: " .. tostring(slotIndex))
    end
    
    return ShieldSystem.handleShieldBlock(self, slotIndex, incomingSpell)
end

-- Determine the current positional key string for animation lookup
function Wizard:getPositionalKey()
    local range = self.gameState and self.gameState.rangeState or Constants.RangeState.FAR
    local elevation = self.elevation or Constants.ElevationState.GROUNDED
    return string.lower(range .. "-" .. elevation)
end

-- Retrieve idle frames for a given positional key
function Wizard:getIdleFramesForKey(key)
    if self.positionalAnimations[key] and self.positionalAnimations[key].idle then
        return self.positionalAnimations[key].idle
    end
    return self.idleAnimationFrames
end

-- Retrieve cast frame for a given positional key
function Wizard:getCastFrameForKey(key)
    if self.positionalAnimations[key] then
        return self.positionalAnimations[key].cast or self.castFrameSprite
    end
    return self.castFrameSprite
end

-- Load positional animation assets for all range/elevation combinations
function Wizard:loadPositionalAnimations()
    local AssetCache = require("core.AssetCache")
    for _, range in pairs(Constants.RangeState) do
        for _, elevation in pairs(Constants.ElevationState) do
            local key = string.lower(range .. "-" .. elevation)
            local dir = string.format("assets/sprites/%s-%s-%s", string.lower(self.name), string.lower(range), string.lower(elevation))
            local anim = { idle = {}, cast = nil }

            if love.filesystem.getInfo(dir, "directory") then
                local files = love.filesystem.getDirectoryItems(dir)
                table.sort(files)
                for _, file in ipairs(files) do
                    if file:match("%.png$") then
                        local path = dir .. "/" .. file
                        if file:lower():find("cast") then
                            anim.cast = AssetCache.getImage(path)
                        else
                            local img = AssetCache.getImage(path)
                            if img then table.insert(anim.idle, img) end
                        end
                    end
                end
            end

            if #anim.idle == 0 then
                anim.idle = self.idleAnimationFrames
            end
            if not anim.cast then
                anim.cast = self.castFrameSprite
            end

            self.positionalAnimations[key] = anim
        end
    end
end

return Wizard
```

# Documentation

## docs/AddingVisualTemplates.md
# Adding Visual Templates

This guide walks through the **end-to-end** workflow for adding a new VFX "template" (a _base_ effect definition) and making it available everywhere (runtime, constants, resolver and tests).

---
## 1  Create/extend the template in `vfx.lua`
1.  Open `vfx.lua` and locate the `VFX.effects` table near the top.
2.  Add a new entry, e.g.
   ```lua
   myeffect_base = {
       type          = "myEffectType",  -- projectile / beam / surge / etc.
       duration      = 1.0,
       particleCount = 30,
       startScale    = 0.4,
       endScale      = 0.8,
       color         = Constants.Color.SMOKE,
       -- any extra fields that the effect's logic needs
   }
   ```
3.  If you introduce **new per-template fields** (e.g. `spread`, `height`, `defaultParticleAsset`):
   • Copy them into the effect instance in `VFX.createEffect` (`effect.spread = template.spread`).  
   • Clear them in `VFX.resetEffect` (`effect.spread = nil`).

---
## 2  Add particle initialisation
Inside `VFX.initializeParticles(effect)` insert a new `elseif effect.type == "myEffectType" then ...` branch that **creates particles** and stores them in `effect.particles`.

---
## 3  Add per-frame logic
1.  Implement `VFX.updateMyEffect(effect, dt)` to animate particles and update per-effect state.
2.  Call it from the main dispatcher in `VFX.update`:
   ```lua
   elseif effect.type == "myEffectType" then
       VFX.updateMyEffect(effect, dt)
   ```

---
## 4  Add rendering
1.  Implement `VFX.drawMyEffect(effect)`.
2.  Dispatch it from `VFX.draw` just like the update step.

---
## 5  Expose a constant for the template
Add an identifier in `core/Constants.lua` so other systems can reference it:
```lua
Constants.VFXType.MY_EFFECT_BASE = "myeffect_base"
```

---
## 6  Hook into **VisualResolver** (optional but typical)
1.  Decide how the game should pick the template (by `visualShape`, `attackType`, tags, etc.).
2.  Update `systems/VisualResolver.lua` mapping tables, e.g.:
   ```lua
   TEMPLATE_BY_SHAPE["myShape"] = Constants.VFXType.MY_EFFECT_BASE
   ```

---
## 7  Assets & sounds (if any)
• Add asset paths in `VFX.assetPaths`.  
• If the effect **must** be shown instantly (e.g. shields) preload the asset in `VFX.init()`.  
• Otherwise it will be lazily loaded on first use.

---
## 8  Testing checklist
☑  The game starts with no Lua errors.  
☑  `VisualResolver.test()` prints the expected base template for a crafted event.  
☑  In-game the effect animates, updates and fades out correctly.  
☑  Pool statistics (`VFX.showPoolStats()`) do not leak particles.

---
## 9  Troubleshooting
| Symptom | Common cause |
|---------|--------------|
| Nil-field error inside update/draw | Forgot to copy the field from template in `createEffect()` |
| Effect visible but never removed | Didn't mark `effect.progress` to `1` or forgot `isComplete` flag |
| No visual appears | Asset path typo or `initializeParticles` created **zero** particles |

---
Happy effect hacking! 🎆 

## docs/Bugs.md
* Zone spells not blocked by Barriers - found with Eruption vs. Wrap in Moonlight

## docs/ProgrammingIdeaBoard.md
## Purpose
This is a hybrid to-do list and bluesky whiteboard, organized by task type.

## Visualization/Gamefeel
### Tie Mana Pool orbits to mana token type
* MOON moves in sine wave shaped orbit, FIRE moves in ellipse, etc.

### Better visual language for spell slots and cast progress
* ?? on whole thing...current vibes are serviceable
* DONE - Experiment with no explicitly drawn static orbit, only draw as cast bar
* Experiment with transparent lines or particles flowing between mana tokens in slot. Strengthen with cast progress?

### Unique "idle" animations for each stance
* DONE - Stretch: unique "cast" animations for each stance
  
### Tween frames for range/position changes
* DONE
### Establish visual language for Ninefold Path
* Two colors per element, "core" and "aura"?

### FX on taking damage
* DONE - Hitstop - exclude DoT (burn, etc. Minimum threshold?)
  * Implementation scales with DMG value - consistent rule that makes DoTs feel right.
* Flashing effect for DoT (for everything maybe?)
  * DONE, for everything

### Consistent-fy visual language for shield types: ward vs. barrier
* Barrier is a partly-transparent "screen" that extends up and down from the spell slot
* Ward is a set of floating runes that orbits in-line wit the spell slot

### SFX
* Whole thing needs to be built
* Stubbed alongside VFX, should be similar and a bit simpler
* handle overlapping sounds somehow

## Rules Engine
### Update mana types to canonical Ninefold Path
  * DONE
* Material: FIRE, WATER, SALT
* Celestial: SUN, MOON, STAR
* Transcendental: SOURCE, MIND, VOID
* Update all spells to use definitions

### Unify Shield spells with new "Trap" type/keyword set under a "sustained spell" umbrella
* DONE

### Support "Field" spell type/keyword as an additional type of ongoing effect/"sustained spell"

### Better consistent rules for Burn stacking rather than quasi-overlapping shared timer thing. Use in Brightwulf design.

## docs/VFX_Audit_Report.md
# Spells VFX Audit Report

This report shows the current VFX setup for each spell and recommendations for improvement.

| Spell Name | Element | Attack Type | Current VFX | Using VFX Keyword | Generates EFFECT Events | Recommended VFX | Status |
|------------|---------|-------------|-------------|-------------------|------------------------|-----------------|--------|
| Adaptive Surge | fire | projectile | adaptive_surge | No | Yes | adaptive_surge | ✅ Correct |
| Arcane Reversal | fire | remote | arcane_reversal | No | Yes | arcane_reversal | ✅ Correct |
| Battle Shield | fire | utility | battle_shield | No | Yes | battle_shield | ✅ Correct |
| Blast Wave | fire | zone | blastwave | No | Yes | blastwave | ✅ Correct |
| Blazing Ascent | fire | zone | blazing_ascent | No | Yes | blazing_ascent | ✅ Correct |
| Combust Mana | fire | utility | combust_lock | No | Yes | combust_lock | ✅ Correct |
| Conjure Fire | fire | utility | fire_conjure | No | Yes | fire_conjure | ✅ Correct |
| Conjure Moonlight | moon | utility | moon_conjure | No | Yes | moon_conjure | ✅ Correct |
| Conjure Nothing | void | utility | void_conjure | No | Yes | void_conjure | ✅ Correct |
| Conjure Salt | salt | utility | force_conjure | No | Yes | force_conjure | ✅ Correct |
| Conjure Stars | star | utility | star_conjure | No | Yes | star_conjure | ✅ Correct |
| Cosmic Rift | fire | zone | cosmic_rift | No | Yes | cosmic_rift | ✅ Correct |
| Drag From the Sky | moon | zone | None | Yes | Yes | gravity_pin_ground | ✅ Correct |
| Emberlift | sun | utility | ember_lift | No | Yes | ember_lift | ✅ Correct |
| Enhanced Mirror Shield | fire | utility | enhanced_mirror_shield | No | Yes | enhanced_mirror_shield | ✅ Correct |
| Firebolt | fire | projectile | None | Yes | Yes | firebolt | ✅ Correct |
| Force Blast | fire | remote | force_blast | No | Yes | force_blast | ✅ Correct |
| Full Moon Beam | moon | projectile | moon_beam | No | Yes | moon_beam | ✅ Correct |
| Gravity Trap | moon | utility | gravity_trap_set | No | Yes | gravity_trap_set | ✅ Correct |
| Infinite Procession | moon | utility | infinite_procession | No | Yes | infinite_procession | ✅ Correct |
| Lunar Disjunction | moon | projectile | lunardisjunction | No | Yes | lunardisjunction | ✅ Correct |
| Lunar Tides | fire | zone | lunar_tide | No | Yes | lunar_tide | ✅ Correct |
| Meteor Dive | sun | zone | None | Yes | Yes | meteor | ✅ Correct |
| Mirror Shield | fire | utility | mirror_shield | No | Yes | mirror_shield | ✅ Correct |
| Molten Ash | fire | zone | lava_eruption | No | Yes | lava_eruption | ✅ Correct |
| Moon Dance | moon | remote | None | No | No | fullmoonbeam | ❌ Missing VFX |
| Moon Ward | fire | utility | moon_ward | No | Yes | moon_ward | ✅ Correct |
| Nature Field | fire | utility | nature_field | No | Yes | nature_field | ✅ Correct |
| Nova Conjuring | sun | utility | nova_conjure | No | Yes | nova_conjure | ✅ Correct |
| Shield Breaker | fire | projectile | force_blast | No | Yes | force_blast | ✅ Correct |
| Storm Meld | fire | utility | storm_meld | No | Yes | storm_meld | ✅ Correct |
| Sun Block | fire | utility | force_barrier | No | Yes | force_barrier | ✅ Correct |
| Test Shield | fire | utility | force_barrier | No | Yes | force_barrier | ✅ Correct |
| Tidal Force | water | remote | tidal_force | No | Yes | tidal_force | ✅ Correct |
| Total Eclipse | moon | utility | eclipse_burst | No | Yes | eclipse_burst | ✅ Correct |
| Wings of Moonlight | moon | utility | None | Yes | Yes | mistveil | ✅ Correct |
| Witch Conjuring | moon | utility | witch_conjure | No | Yes | witch_conjure | ✅ Correct |

## Summary Statistics

- **Total Spells:** 37
- **Correctly Implemented:** 36 (97.3%)
- **Needs VFX Keyword:** 0 (0.0%)
- **Missing VFX:** 1 (2.7%)

## Implementation Recommendations

1. **Replace top-level VFX properties with VFX keywords:**
   ```lua
   -- Before:
   vfx = "firebolt",

   -- After:
   keywords = {
       -- other keywords...
       vfx = { effect = Constants.VFXType.FIREBOLT, target = Constants.TargetType.ENEMY }
   },
   ```

2. **Add VFX keywords to spells missing visual effects:**
   - Use Constants.VFXType for standard effect names
   - Match the effect type to the spell's element and attack pattern
   - Consider spell's role when selecting the visual effect

3. **Run the automated fix tool:**
   ```bash
   lua tools/fix_vfx_events.lua
   ```

4. **Test with the VFX events test:**
   ```bash
   lua tools/test_vfx_events.lua
   ```

## docs/VerticalSliceMustHaves.md
Polished spell templates:
* DONE BOLT
* DONE BEAM
* WARP
* BLAST
* METEOR
* FOUNTAIN

Polished mechanical templates:
* WARD
* BARRIER
* TRAP

SFX:
* Figure this out!

Character animation:
* Absolute bare minimum: 2-frame idles
* Ideally: 4-frame idles _per position_.
* DONE 1-frame Cast per-position
* DONE Flash/shake on-hit
* DONE Screenshake on big hit (Meteor Dive, charged Full Moon Beam)
* 

## docs/Visual_Language.md
# Visual Language Reference

This document defines the visual language for the Manastorm game, mapping game concepts to visual elements to ensure consistency across the game.

## Overview

The visual language is organized by:

1. **Element**: The magical element (Fire, Moon, etc.)
2. **Concept**: The game mechanic (Damage, Heal, Shield, etc.)
3. **Target**: Who/what the effect targets (Self, Enemy, Pool)
4. **VFX Name**: The corresponding `Constants.VFXType` value
5. **Particle Sprite**: The asset used by the VFX system
6. **Core Color**: The base color used for the effect (from `Constants.Color`)

## Visual Language Map

| Element | Concept | Target | VFX Name | Particle Sprite | Core Color | Notes |
|---------|---------|--------|----------|----------------|------------|-------|
| **Fire** | Damage | Enemy | `FIREBOLT` | fireParticle | CRIMSON | Fast, direct projectile |
| Fire | Area Damage | Enemy | `METEOR` | fireParticle | OCHRE | Impact-focused with larger radius |
| Fire | Elevation | Self | `EMBERLIFT` | fireParticle | ORANGE | Vertical rising particles |
| Fire | Conjure | Pool | `CONJUREFIRE` | fireParticle | ORANGE | Particles converge on mana pool |
| **Water** | Damage | Enemy | `TIDAL_FORCE` | sparkle | OCEAN | Flowing, wave-like projectile |
| Water | Ground | Enemy | `TIDAL_FORCE_GROUND` | impactRing | OCEAN | Downward pressing impact |
| Water | Shield | Self | `SHIELD` | impactRing | OCEAN | Barrier-type with liquid appearance |
| **Moon** | Damage | Enemy | `LUNARDISJUNCTION` | sparkle | PINK | Elegant, arcing projectile |
| Moon | Disable | Enemy | `DISJOINT_CANCEL` | impactRing | PINK | Disruptive, sparkling impact |
| Moon | Conjure | Pool | `CONJUREMOONLIGHT` | moonGlow | SKY | Soft, glowing particles to pool |
| Moon | Shield | Self | `SHIELD` | runeAssets | SKY | Ward-type with runic symbols |
| Moon | Field | Area | `MISTVEIL` | sparkle | SKY | Diffuse, fog-like effect |
| **Sun** | Damage | Enemy | `METEOR` | fireParticle | ORANGE | Falling impact from above |
| Sun | Shield | Self | `SHIELD` | impactRing | ORANGE | Barrier-type with bright rings |
| Sun | Conjure | Pool | `NOVA_CONJURE` | sparkle | ORANGE | Bright, star-like particles |
| **Star** | Damage | Enemy | `STAR_CONJURE` | sparkle | YELLOW | Small, bright flashes |
| **Salt** | Control | Enemy | `TOKEN_LOCK` | impactRing | SAND | Crystalline, binding appearance |
| **Force** | Push | Enemy | `FORCE_BLAST` | forceWave | YELLOW | Wave-like, rippling effect |
| Force | Elevate | Enemy | `FORCE_BLAST_UP` | forceWave | YELLOW | Upward-moving force waves |
| Force | Conjure | Pool | `FORCE_CONJURE` | sparkle | YELLOW | Dynamic, energetic particles |
| **Life** | Heal | Self | `FREE_MANA` | sparkle | LIME | Gentle, pulsing aura |
| **Mind** | Control | Enemy | `SPELL_FREEZE` | sparkle | PINK | Twisting, distorting effect |
| **Void** | Consume | Enemy | `TOKEN_CONSUME` | sparkle | BONE | Draining, empty appearance |
| **Generic** | Impact | Any | `IMPACT` | impactRing | SMOKE | Basic impact when no specific VFX |
| Generic | Range Change | Both | `RANGE_CHANGE` | sparkle | SMOKE | Quick positional indicator |
| Generic | Acceleration | Slot | `SPELL_ACCELERATE` | sparkle | LIME | Speed-up animation |
| Generic | Cancel | Slot | `SPELL_CANCEL` | impactRing | CRIMSON | Spell interruption effect |
| Generic | Echo | Slot | `SPELL_ECHO` | sparkle | BONE | Spell replication effect |

## Shield Visual Language

Shields have distinct visual characteristics based on their type:

| Shield Type | Visual Style | Color | Asset | Description |
|-------------|--------------|-------|-------|-------------|
| `barrier` | Solid, physical | ORANGE (Sun) | impactRing | Concentric rings that expand outward, solid appearance |
| `ward` | Magical, runic | SKY (Moon) | runeAssets | Runic symbols that rotate around the wizard, ethereal glow |
| `field` | Energy, force | YELLOW (Force) | forceWave | Wave-like energy that pulses outward, semi-transparent |

## Element Color Reference

For consistency, these are the primary colors associated with each element:

- Fire: CRIMSON/ORANGE
- Water: OCEAN
- Salt: SAND
- Sun: ORANGE (brighter than Fire)
- Moon: SKY/PINK
- Star: YELLOW
- Life: LIME
- Mind: PINK
- Void: BONE
- Force: YELLOW
- Generic: SMOKE

## Implementation Checklist

When implementing visual effects for a new spell:

1. Identify which element the spell belongs to
2. Determine the primary concept (what game mechanic it represents)
3. Choose the appropriate target type
4. Select the matching VFX from the table above
5. Use the color values in the spell's visual implementation
6. Consider combining multiple VFX types for complex spells

## Particle System Usage

The particle system has several main effect types that produce different visual patterns:

- `projectile`: Moves from source to target with trailing particles
- `impact`: Creates a radial burst of particles from a central point
- `aura`: Generates particles orbiting around a central point
- `beam`: Creates a solid beam with particle effects along its length
- `conjure`: Creates particles that rise toward the mana pool

## docs/combat_events.md
# Manastorm Combat Event System

This document defines the event schema for the Manastorm combat system. Events are generated by the spell compiler and processed by the EventRunner to apply state changes to the game.

## Event Structure

All events follow a common structure:

```lua
{
  type = "EVENT_TYPE",  -- Required: string identifying the event type
  source = "caster",    -- Required: entity that generated the event ("caster" or "target")
  target = "enemy",     -- Required: entity that receives the effect ("self", "enemy", "both", or specific slot)
  
  -- Additional fields specific to the event type
  ...
}
```

## Core Event Types

### Damage Events

```lua
{
  type = "DAMAGE",
  source = "caster",
  target = "enemy",
  amount = 10,
  damageType = "fire"  -- Optional: type of damage (fire, ice, force, etc.)
}
```

### Status Effect Events

```lua
{
  type = "APPLY_STATUS",
  source = "caster",
  target = "enemy",
  statusType = "burn",
  duration = 3.0,
  tickDamage = 2,      -- For DoT effects
  tickInterval = 1.0,  -- For DoT effects
  -- Additional status-specific parameters
}
```

### Elevation Events

```lua
{
  type = "SET_ELEVATION",
  source = "caster",
  target = "self",    -- or "enemy" for forced elevation changes
  elevation = "AERIAL",
  duration = 5.0      -- Optional: duration of the effect (nil = permanent)
}
```

### Range Events

```lua
{
  type = "SET_RANGE",
  source = "caster",
  target = "both",    -- Range changes always affect both wizards
  position = "NEAR"
}
```

### Force Position Events

```lua
{
  type = "FORCE_POSITION",
  source = "caster",
  target = "enemy",   -- Force enemy to move to caster's range
}
```

## Resource and Token Events

### Conjure Token Events

```lua
{
  type = "CONJURE_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "fire", -- Type of token to create
  amount = 1          -- Number of tokens to create
}
```

### Dissipate Token Events

```lua
{
  type = "DISSIPATE_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "any",  -- Type of token to remove, "any" for any type
  amount = 1          -- Number of tokens to remove
}
```

### Token Shift Events

```lua
{
  type = "SHIFT_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "fire", -- Type to transform tokens into
  amount = 1          -- Number of tokens to transform
}
```

### Lock Token Events

```lua
{
  type = "LOCK_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  duration = 5.0,     -- Duration of the lock
  amount = 1,         -- Number of tokens to lock
  tokenType = "any"   -- Optional: specific type to lock
}
```

## Spell Timing Events

### Delay Events

```lua
{
  type = "DELAY_SPELL",
  source = "caster",
  target = "enemy_slot", -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,         -- Specific slot to target (nil = random active slot)
  amount = 1.0           -- Amount to delay by in seconds
}
```

### Accelerate Events

```lua
{
  type = "ACCELERATE_SPELL",
  source = "caster",
  target = "self_slot",   -- Can specify exact slot number (1-3) or "current"
  slotIndex = 2,          -- Specific slot to target (nil = current slot)
  amount = 1.0            -- Amount to accelerate by in seconds
}
```

### Cancel Spell Events

```lua
{
  type = "CANCEL_SPELL",
  source = "caster",
  target = "enemy_slot",  -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,          -- Specific slot to target (nil = random active slot)
  returnMana = true       -- Whether to return mana to the pool (true = dispel, false = disjoint)
}
```

### Freeze Spell Events

```lua
{
  type = "FREEZE_SPELL",
  source = "caster",
  target = "enemy_slot",  -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,          -- Specific slot to target (nil = random active slot)
  duration = 2.0          -- Duration of the freeze effect
}
```

## Defense Events

### Create Shield Events

```lua
{
  type = "CREATE_SHIELD",
  source = "caster",
  target = "self_slot",   -- Always targets a slot of the caster
  slotIndex = 1,          -- Slot where the shield is created
  defenseType = "barrier", -- Type of shield
  blocksAttackTypes = {"projectile", "zone"}, -- Attack types this shield blocks
  reflect = false         -- Whether the shield reflects damage
}
```

### Reflect Events

```lua
{
  type = "REFLECT",
  source = "caster",
  target = "self",
  duration = 3.0          -- Duration of the reflect effect
}
```

## Special Events

### Echo Events

```lua
{
  type = "ECHO",
  source = "caster",
  target = "self_slot",   -- Always targets a slot of the caster
  slotIndex = 1,          -- Slot to echo
  delay = 2.0             -- Delay before echo triggers
}
```

### Zone Anchor Events

```lua
{
  type = "ZONE_ANCHOR",
  source = "caster",
  target = "self",
  anchorRange = "NEAR",    -- Range state to anchor to (or "ANY")
  anchorElevation = "AERIAL", -- Elevation to anchor to (or "ANY")
  requireAll = true       -- Whether all conditions must be met
}
```

### Zone Multi Events

```lua
{
  type = "ZONE_MULTI",
  source = "caster",
  target = "self"
}
```

## Event Processing Order

Events are processed in the following order to ensure consistent game state:

1. **State Setting Events**: Elevation, Range, Zone anchors
2. **Resource Events**: Conjure, Dissipate, Shift, Lock 
3. **Spell Timeline Events**: Delay, Accelerate, Cancel, Freeze
4. **Defense Events**: Create Shield, Reflect
5. **Status Effect Events**: Apply DoTs and other effects
6. **Damage Events**: Direct damage
7. **Special Effect Events**: Echo, Zone Multi

## Integration with Existing Systems

The EventRunner module is responsible for processing events and applying their effects to the game state. It will:

1. Receive events from the spell compiler
2. Sort them according to the processing order
3. Apply each event to the game state
4. Handle any visual effects triggered by events
5. Return a summary of applied effects for UI updates

## Design Principles

1. **Separation of Concerns**: Events describe what happens, the runner decides how it happens
2. **Deterministic Execution**: The same events always produce the same game state changes
3. **Testability**: Events can be serialized and replayed for testing
4. **Extensibility**: New event types can be added without changing the core system
5. **Backward Compatibility**: The event system supports all existing keyword behaviors

## Examples

### Example: Fireball Spell Events

```lua
-- Events generated by a Fireball spell
{
  {
    type = "DAMAGE",
    source = "caster",
    target = "enemy",
    amount = 10,
    damageType = "fire"
  },
  {
    type = "APPLY_STATUS",
    source = "caster",
    target = "enemy",
    statusType = "burn",
    duration = 3.0,
    tickDamage = 2,
    tickInterval = 1.0
  }
}
```

### Example: Shield Spell Events

```lua
-- Events generated by a Barrier Shield spell
{
  {
    type = "CREATE_SHIELD",
    source = "caster",
    target = "self_slot",
    slotIndex = 1,
    defenseType = "barrier",
    blocksAttackTypes = {"projectile", "zone"},
    reflect = false
  }
}
```

## Future Extensions

Possible future extensions to the event system:

1. **Event Logging**: Recording all events for replay and analysis
2. **Deterministic Replay**: Replaying a sequence of events to recreate a game state
3. **Network Synchronization**: Using events for multiplayer synchronization
4. **AI Decision-Making**: AI can analyze possible events to make decisions
5. **Event Modifications**: Allowing special effects to modify events before processing

## docs/constants.md
# Constants Reference

This document provides a reference for the Constants module in Manastorm.

## Overview

The Constants module (`core/Constants.lua`) provides centralized string constants used throughout the game, replacing string literals with structured reference tables. This approach offers several benefits:

- **Reduced typos**: References are checked at compile time
- **Better IDE support**: Autocomplete suggestions for constants
- **Centralized documentation**: All constants defined in one place
- **Easier refactoring**: Change a value in one place instead of throughout the codebase

## Usage

```lua
-- Import the module
local Constants = require("core.Constants")

-- Use constants in code
if wizard.elevation == Constants.ElevationState.AERIAL then
    -- Do something with aerial wizards
end

-- Use in tables
local spell = {
    attackType = Constants.AttackType.PROJECTILE,
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FORCE}
}
```

## Available Constants

### Token Types

```lua
Constants.TokenType.FIRE    -- "fire"
Constants.TokenType.FORCE   -- "force"
Constants.TokenType.MOON    -- "moon"
Constants.TokenType.NATURE  -- "nature"
Constants.TokenType.STAR    -- "star"
Constants.TokenType.RANDOM  -- "random" (special: used in spell costs)
Constants.TokenType.ANY     -- "any" (special: used in keywords)
```

### Token States

```lua
Constants.TokenState.FREE       -- "FREE"
Constants.TokenState.CHANNELED  -- "CHANNELED"
Constants.TokenState.SHIELDING  -- "SHIELDING"
Constants.TokenState.LOCKED     -- "LOCKED"
Constants.TokenState.DESTROYED  -- "DESTROYED"
```

### Range States

```lua
Constants.RangeState.NEAR  -- "NEAR"
Constants.RangeState.FAR   -- "FAR"
```

### Elevation States

```lua
Constants.ElevationState.GROUNDED  -- "GROUNDED"
Constants.ElevationState.AERIAL    -- "AERIAL"
```

### Shield Types

```lua
Constants.ShieldType.BARRIER  -- "barrier"
Constants.ShieldType.WARD     -- "ward"
Constants.ShieldType.FIELD    -- "field"
```

### Attack Types

```lua
Constants.AttackType.PROJECTILE  -- "projectile"
Constants.AttackType.REMOTE      -- "remote"
Constants.AttackType.ZONE        -- "zone"
Constants.AttackType.UTILITY     -- "utility"
```

### Target Types

```lua
Constants.TargetType.SELF        -- "SELF"
Constants.TargetType.ENEMY       -- "ENEMY"
Constants.TargetType.SLOT_SELF   -- "SLOT_SELF"
Constants.TargetType.SLOT_ENEMY  -- "SLOT_ENEMY"
Constants.TargetType.POOL_SELF   -- "POOL_SELF"
Constants.TargetType.POOL_ENEMY  -- "POOL_ENEMY"
Constants.TargetType.CASTER      -- "caster"
Constants.TargetType.TARGET      -- "target"
```

### Damage Types

```lua
Constants.DamageType.FIRE     -- "fire"
Constants.DamageType.FORCE    -- "force"
Constants.DamageType.MOON     -- "moon"
Constants.DamageType.NATURE   -- "nature"
Constants.DamageType.STAR     -- "star"
Constants.DamageType.GENERIC  -- "generic"
Constants.DamageType.MIXED    -- "mixed"
```

### Player Sides

```lua
Constants.PlayerSide.PLAYER    -- "PLAYER"
Constants.PlayerSide.OPPONENT  -- "OPPONENT"
Constants.PlayerSide.NEUTRAL   -- "NEUTRAL"
```

### Status Types

```lua
Constants.StatusType.BURN    -- "burn"
Constants.StatusType.SLOW    -- "slow"
Constants.StatusType.STUN    -- "stun"
Constants.StatusType.REFLECT -- "reflect"
```

## Helper Functions

The Constants module also provides helper functions:

### `Constants.poolSide(side)`

Converts a side (SELF/ENEMY) to its POOL_ equivalent.

```lua
Constants.poolSide(Constants.TargetType.SELF)  -- Returns Constants.TargetType.POOL_SELF
```

### `Constants.slotSide(side)`

Converts a side (SELF/ENEMY) to its SLOT_ equivalent.

```lua
Constants.slotSide(Constants.TargetType.ENEMY)  -- Returns Constants.TargetType.SLOT_ENEMY
```

### Collection Functions

- `Constants.getAllTokenTypes()` - Returns a table with all token types
- `Constants.getAllShieldTypes()` - Returns a table with all shield types
- `Constants.getAllAttackTypes()` - Returns a table with all attack types

## CI Checking

We've implemented a CI check to prevent new string literals from being added. Run the check script:

```
lua tools/check_magic_strings.lua
```

This will scan the codebase for string literals that should be using Constants instead.

## docs/manapool.md
# ManaPool Module (`manapool.lua`)

## Overview

The `manapool.lua` module manages the central shared pool of mana tokens that wizards use to cast spells. It handles the creation, storage, update (movement, state changes), and drawing of these tokens. It also defines the core state machine logic for individual tokens.

## Key Components

### 1. ManaPool Object

*   **Role:** Represents the central mana pool area.
*   **State:**
    *   `x`, `y`: Center position of the pool.
    *   `tokens`: Array table holding references to all active token objects currently managed by the pool (regardless of their state: FREE, CHANNELED, etc.).
    *   `valences`: Defines multiple elliptical orbital paths (rings) within the pool area for `FREE` tokens, each with different radii and base speeds.
    *   `valenceJumpChance`: Probability for `FREE` tokens to switch valences.
    *   `lockOverlay`: Loaded image for drawing on `LOCKED` tokens.
*   **Core Methods:**
    *   `ManaPool.new(x, y)`: Constructor. Initializes state, defines valences, loads assets, ensures the "token" object pool exists.
    *   `ManaPool:addToken(tokenType, imagePath)`: Creates a new token. Acquires a recycled object from the pool, adds `TokenMethods`, initializes state (`FREE`), sets orbital parameters, loads image, and adds it to `self.tokens`.
    *   `ManaPool:update(dt)`: Per-frame update loop. Iterates through `self.tokens` and updates each based on its `status`:
        *   `FREE`: Manages orbital motion, valence jumps, and smooth transitions.
        *   `CHANNELED`/`SHIELDING`: Updates animation towards the wizard along a Bezier path (position is handled by `Wizard` once animation completes).
        *   `RETURNING`: Updates animation back to the pool center along a Bezier path, triggers `animationCallback` (`finalizeReturn`) on completion.
        *   `DISSOLVING`: Updates animation timer, triggers `animationCallback` (`finalizeDestruction`) on completion.
        *   `LOCKED`: Updates timer, unlocks to `FREE` when timer expires, applies constrained movement.
    *   `ManaPool:draw()`: Draws all active tokens. Z-sorts for layering. Applies state-dependent visuals (glows, trails, color tints, overlays).
    *   `ManaPool:clear()`: Releases all tokens back to the object pool and clears `self.tokens`.
    *   `ManaPool:findFreeToken(tokenType)`: Helper to find a `FREE` token of a specific type *without* changing its state.
    *   `ManaPool:getToken(tokenType)`: Legacy/fallback (?) function to find a `FREE` token and set its state to `CHANNELED`.
    *   `ManaPool:returnToken(tokenIndex)`: Legacy/fallback function called if a token lacks `requestReturnAnimation`. Wraps the call if possible, otherwise handles return logic directly.
    *   `ManaPool.resetToken(token)`: Static function used by the object pool (`core.Pool`) to completely reset a token object's fields when it's released.

### 2. Token Objects & State Machine (`TokenMethods`)

*   **Object Pooling:** Tokens are managed using `core.Pool` for performance. Objects are acquired via `Pool.acquire("token")` and returned via `Pool.release("token", token)` (triggered by `finalizeDestruction` or `ManaPool:clear`).
*   **State (`token.status`):** Managed using `Constants.TokenStatus` values:
    *   `FREE`: Idle in the mana pool, orbiting.
    *   `CHANNELED`: Reserved/moving towards a wizard's spell slot.
    *   `SHIELDING`: Part of an active shield, orbiting the wizard (position managed by Wizard module).
    *   `LOCKED`: Unusable, timer counts down until returned to `FREE`.
    *   `RETURNING`: Animating back towards the mana pool center.
    *   `DISSOLVING`: Animating destruction.
    *   `POOLED`: Inactive, object released back to the pool.
*   **Core Methods (`TokenMethods` table, applied to token objects):**
    *   `token:setState(newStatus)`: Validates and applies state changes, maintains legacy `token.state` sync.
    *   `token:requestReturnAnimation()`: Preferred method to initiate return. Sets state to `RETURNING`, sets up animation parameters and `finalizeReturn` callback.
    *   `token:requestDestructionAnimation()`: Initiates destruction. Sets state to `DISSOLVING`, sets up animation parameters and `finalizeDestruction` callback, triggers VFX.
    *   `token:finalizeReturn()`: Callback after return animation. Sets state to `FREE`, clears wizard references, initializes orbital parameters within the pool.
    *   `token:finalizeDestruction()`: Callback after destruction animation. Sets state to `POOLED`, removes token from `manaPool.tokens`, releases object back to `core.Pool`.
*   **Other Token Properties:** `type`, `image`, `x`, `y`, `scale`, `rotAngle`, `orbitAngle`, `orbitSpeed`, animation timers/flags, references (`manaPool`, `gameState`, `wizardOwner`, `spellSlot`), etc.

### 3. Visuals

*   The pool itself is visually defined only by the orbiting `FREE` tokens.
*   Tokens have complex drawing logic based on state:
    *   Colored glows (type-specific).
    *   Pulsation.
    *   Z-ordering for depth.
    *   Color tints (`LOCKED`, `SHIELDING`).
    *   Shield type icons drawn inside `SHIELDING` tokens.
    *   Trails for `RETURNING` tokens.
    *   Fade-out/scale effects for `DISSOLVING` tokens.
    *   Lock overlay and timer for `LOCKED` tokens.

### 4. Potential Cleanup Areas

*   The `ManaPool:getToken` method seems less robust than the reservation system used in `Wizard` and might be a candidate for removal or refactoring.
*   The Bezier curve calculations used for animating tokens (`CHANNELED`/`SHIELDING`, `RETURNING`) are duplicated between the `update` function and the `draw` function (for trails). This could be consolidated into a helper function.

## Dependencies

*   `core.Constants`
*   `core.AssetCache`
*   `core.Pool`
*   Global `game` state (optional, via `self.gameState` reference, primarily for VFX access) 

## docs/shield_hooks.md
# Shield On-Block Hooks

This document describes the on-block hook system for shield spells, which allows custom effects to be triggered when a shield successfully blocks an incoming spell.

## Overview

Shields can now define an `onBlock` callback function that is invoked whenever the shield successfully blocks an attack. This callback can emit events that are processed by the EventRunner, allowing for a wide variety of dynamic effects.

## onBlock Callback Signature

The `onBlock` callback has the following signature:

```lua
function onBlock(defender, attacker, slotIndex, blockInfo)
    -- Return an array of events to process
    return events
end
```

### Parameters

- `defender`: The wizard who owns the shield (shield caster)
- `attacker`: The wizard who cast the spell being blocked (may be nil)
- `slotIndex`: The spell slot index where the shield is active
- `blockInfo`: A table with contextual information about the block:
  - `blockType`: The type of shield (barrier, ward, field)

### Return Value

The callback should return an array of events to be processed by the EventRunner. Each event should follow the standard event structure defined in the EventRunner system.

## Examples

### Simple Elevation on Block

```lua
onBlock = function(defender, attacker, slotIndex, blockInfo)
    return {{
        type = "SET_ELEVATION",
        source = "caster",
        target = "self",
        elevation = "AERIAL",
        duration = 4.0
    }}
end
```

### Counter Damage

```lua
onBlock = function(defender, attacker, slotIndex, blockInfo)
    if not attacker then return {} end
    
    return {{
        type = "DAMAGE",
        source = "caster",
        target = "enemy",
        amount = 10,
        damageType = "fire"
    }}
end
```

### Multiple Effects

```lua
onBlock = function(defender, attacker, slotIndex, blockInfo)
    local events = {}
    
    -- Deal counter damage
    table.insert(events, {
        type = "DAMAGE",
        source = "caster",
        target = "enemy",
        amount = 8,
        damageType = "fire"
    })
    
    -- Accelerate next spell
    table.insert(events, {
        type = "ACCELERATE_SPELL",
        source = "caster",
        target = "self_slot",
        slotIndex = 0,
        amount = 2.0
    })
    
    return events
end
```

## Creating Custom Shield Spells

To create a shield spell with an on-block hook:

1. Define a normal spell with the `block` keyword
2. Add an `onBlock` function to the block keyword parameters
3. Return an array of events from the `onBlock` function

The events will be processed through the EventRunner system, maintaining compatibility with all existing game systems.

## docs/spellcasting.md
# Manastorm Spell System

## Overview

The spell system in Manastorm is designed to be modular and data-driven, allowing for complex spell effects to be defined by combining simpler, reusable components. It revolves around four key files, which can be thought of using a kitchen metaphor:

1.  **`keywords.lua`**: The **Ingredients** - Defines atomic game actions.
2.  **`spells.lua`**: The **Recipes** - Combines ingredients (keywords) into specific spells.
3.  **`spellCompiler.lua`**: The **Chef** - Prepares the recipes for execution.
4.  **`systems/EventRunner.lua`**: The **Waiter** - Delivers the effects of the prepared spell to the game state.

This system is transitioning towards a pure event-based architecture, where spell effects generate descriptive events that are then processed centrally, ensuring consistent application order and state management.

## Core Components

### 1. `keywords.lua` - The Ingredients

*   **Purpose:** Defines the fundamental "verbs" or atomic actions that spells can perform. Each keyword represents a specific game mechanic (e.g., dealing damage, applying a status effect, changing position, manipulating tokens).
*   **Structure:** A large Lua table (`Keywords`) where each key is a keyword name (e.g., `damage`, `elevate`, `conjure`, `block`). The value is a table containing:
    *   `behavior`: A sub-table describing the keyword's effect conceptually (e.g., `dealsDamage = true`, `targetType = Constants.TargetType.ENEMY`, `category = "DAMAGE"`). This acts as metadata and helps define default parameters.
    *   `execute`: A function implementing the keyword's logic. **Crucially, this function should ideally generate events rather than directly modify game state.** It takes `caster`, `target`, `params`, `results` (for legacy compatibility), and an `events` table as arguments. It should add event tables (e.g., `{ type = "DAMAGE", ... }`) to the `events` list.
*   **Event-Based Shift:** Comments emphasize that new keywords should generate events processed by the `EventRunner`. Older keywords might still directly modify the `results` table for backward compatibility.

### 2. `spells.lua` - The Recipes

*   **Purpose:** Defines the concrete spells available by combining keywords (`ingredients`) with specific parameters. Acts as a database of spell definitions.
*   **Structure:** A large Lua table (`Spells`) where each key is a unique spell ID (e.g., `firebolt`). The value is a table adhering to a schema:
    *   **Basic Info:** `id`, `name`, `description`.
    *   **Mechanics:** `attackType` (`projectile`, `remote`, `zone`, `utility`), `castTime`, `cost` (array of token types like `Constants.TokenType.FIRE`). If a `getCost` function is provided it will be used at runtime instead of the static table.
    *   **`keywords`:** **The core.** A table mapping keyword names (from `keywords.lua`) to parameter tables (e.g., `damage = { amount = 10 }`, `elevate = { duration = 5.0 }`). Parameters can be static values or functions.

    The optional `getCost(caster, target)` function allows a spell's mana cost to change based on game state. It should return a table of token types just like the static `cost` field. `getCost` is evaluated each time the spell is queued or affordability is checked.

    **Example:** A spell that gets cheaper as the caster's health drops might be implemented as:

    ```lua
    getCost = function(caster)
        local fireCost = 3
        if caster.health < 75 then fireCost = 2 end
        if caster.health < 40 then fireCost = 1 end
        if caster.health < 20 then fireCost = 0 end
        local t = {}
        for i = 1, fireCost do
            t[i] = Constants.TokenType.FIRE
        end
        return t
    end
    ```
*   **Optional:** `vfx`, `sfx`, `getCastTime` (dynamic cast time function), `getCost` (dynamic mana cost), `onBlock`/`onMiss`/`onSuccess` (legacy callbacks).
*   **Validation:** Includes a `validateSpell` function called at load time to ensure schema adherence and add defaults, printing warnings for issues.

### 3. `spellCompiler.lua` - The Chef

*   **Purpose:** Takes a raw spell definition (`recipe`) from `spells.lua` and "compiles" it into an optimized, executable object, ready to be used in the game.
*   **Compilation (`compileSpell` function):**
    *   Creates a `compiledSpell` table, copying basic properties.
    *   Iterates through the `spellDef.keywords`.
    *   For each keyword, finds the corresponding definition in `keywords.lua`.
    *   Merges default keyword `behavior` with spell-specific `params` into `compiledSpell.behavior[keyword]`.
    *   Binds the `keywords.lua` `execute` function to `compiledSpell.behavior[keyword].execute`.
*   **Execution (`executeAll` method):**
    *   Adds an `executeAll` method to the `compiledSpell` object.
    *   Called by `Wizard:castSpell` when a spell finishes casting.
    *   Iterates through all behaviors defined in `compiledSpell.behavior`.
    *   Calls the bound `execute` function for each keyword, passing context (`caster`, `target`) and an **empty `events` table**.
    *   Keywords populate the `events` table.
    *   Calls `EventRunner.processEvents(events, ...)` to handle the generated events.
    *   Returns a `results` table (combining legacy results and the `EventRunner` summary).
*   **Configuration:** Includes toggles (`setUseEventSystem`, `setDebugEvents`) for debugging and controlling the execution path.

### 4. `systems/EventRunner.lua` - The Waiter

*   **Purpose:** Takes the list of raw events generated by `compiledSpell.executeAll` and applies their effects to the actual game state in a controlled, ordered manner.
*   **Structure:**
    *   `PROCESSING_PRIORITY`: Defines the order for processing different event types (e.g., state changes before damage).
    *   `EVENT_HANDLERS`: A table mapping event type strings (e.g., `"DAMAGE"`, `"APPLY_STATUS"`) to handler functions.
    *   `resolveTarget`: Helper to find the target game object(s) based on event data (e.g., `"self"`, `"enemy"`, `"enemy_slot"`).
*   **Processing Flow (`processEvents` function):**
    *   Receives the `events` list, `caster`, `target`, `spellSlot`.
    *   Sorts events based on `PROCESSING_PRIORITY`.
    *   Iterates through sorted events.
    *   Looks up the appropriate handler in `EVENT_HANDLERS` using `event.type`.
    *   Calls the handler function (`handleEvent`).
    *   **Handlers modify state:** The specific handler function (e.g., `EVENT_HANDLERS.DAMAGE`) uses `resolveTarget` and then directly modifies game state (e.g., `targetEntity.health -= event.amount`) or calls appropriate object methods (e.g., `wizard:resetSpellSlot`, `manaPool:addToken`). Handlers also trigger VFX.
    *   Returns a summary of processed events and effects.

## Interaction Flow Example (Firebolt)

1.  **Definition (`spells.lua`):** Defines `Spells.firebolt` using the `damage` keyword from `keywords.lua` with params `{ amount = 10, type = "fire" }`.
2.  **Compilation (`spellCompiler.lua`):** At game load, `compileSpell` processes `Spells.firebolt`, creating `compiledSpell` linking the `damage` keyword logic and params.
3.  **Casting (`wizard.lua`):** Player casts Firebolt; `Wizard:castSpell` calls `compiledSpell.executeAll`.
4.  **Execution & Event Generation (`spellCompiler.lua` -> `keywords.lua`):** `executeAll` calls the `damage` keyword's `execute` function, passing an `events` table. `damage.execute` adds `{ type="DAMAGE", target="enemy", amount=10, damageType="fire" }` to the `events` table.
5.  **Event Processing (`spellCompiler.lua` -> `EventRunner.lua`):** `executeAll` calls `EventRunner.processEvents` with the `events` list.
6.  **State Modification (`EventRunner.lua`):** `processEvents` sorts events, finds the `DAMAGE` handler, resolves the target to the enemy wizard, and executes `target.health = target.health - 10`. Triggers VFX.
7.  **Result:** Enemy health updated. `processEvents` returns summary. `executeAll` returns results to `castSpell`.

---

This modular system allows defining complex spell effects by combining simple, reusable keywords. The event-based execution ensures effects are applied consistently and in the correct order, making the system easier to manage and extend.

## docs/status_effects.md
# Status Effects

This document lists the built-in status effects available in the game and their expected behavior. All status types are defined in `core/Constants.lua` under `Constants.StatusType`.

## Available Statuses

| Status | Description |
|--------|-------------|
| `BURN` | Deals periodic damage over time. Damage ticks use `tickDamage` at intervals defined by `tickInterval` for the duration of the effect. |
| `SLOW` | Increases the cast time of the next spell by `magnitude` seconds. Can optionally target a specific slot. Consumed after affecting a cast or when the duration expires. |
| `STUN` | Prevents the affected wizard from keying or casting spells for the duration. |
| `REFLECT` | Causes the wizard to reflect incoming spells while active. |

## Usage

Status effects are applied through `APPLY_STATUS` events emitted by keywords or spell logic. Event handlers store the effect data on the target wizard in the `statusEffects` table.

```lua
-- Example APPLY_STATUS event
{
    type = "APPLY_STATUS",
    source = "caster",
    target = "enemy",
    statusType = Constants.StatusType.BURN,
    duration = 3.0,
    tickDamage = 2,
    tickInterval = 1.0
}
```

The `EventRunner` module processes these events and manages status state each frame.

## docs/token_lifecycle.md
# Mana Token Lifecycle State Machine

## Overview
This document describes the token lifecycle system in Manastorm, which handles the transition of mana tokens between various states, from creation to destruction.

## Implementation Status

The token lifecycle system is implemented in the following files:
- `core/Constants.lua` - Defines the TokenStatus enum
- `manapool.lua` - Implements the token methods and updates the mana pool update loop to drive animations
- Future tickets will update all token acquisition and return points to use the new methods

## States

```
+-------+    channeling    +------------+    shield creation    +-----------+
| FREE  |----------------->| CHANNELED  |-------------------->  | SHIELDING |
+-------+                  +------------+                       +-----------+
   ^                           |    |                               |
   |                           |    |                               |
   |                           |    v                               |
   |      animation            |  +------------+                    |
   |<-----------------+--------+  | DISSOLVING |                    |
   |      complete    |           +------------+                    |
   |                  |                 |                           |
   |                  |                 v                           |
   |                  |          +------------+                     |
   |                  +----------| RETURNING  |<--------------------+
   |                             +------------+
   |                                    |
   |                                    v
   |                             +------------+
   +-----------------------------+   POOLED   |
                                 +------------+
```

### State Descriptions

- **FREE**: Token is available in the mana pool for use
- **CHANNELED**: Token is being used for an active spell or ability
- **SHIELDING**: Token is specifically being used as part of a shield
- **RETURNING**: Token is animating back to the mana pool (temporary transition state)
- **DISSOLVING**: Token is being destroyed and will be released back to object pool (temporary transition state)
- **POOLED**: Token is fully released to the object pool and no longer exists in game

## Token Methods

Each token has the following state machine methods:

### setState(newStatus)
- Validates and changes the token's state
- Logs the state transition for debugging
- Maintains backward compatibility with legacy token.state

### requestReturnAnimation()
- Initiates the process of returning a token to the pool
- Validates that token is in CHANNELED or SHIELDING state
- Sets animation parameters and schedules the finalizeReturn callback

### requestDestructionAnimation()
- Initiates the process of dissolving/destroying a token
- Sets animation parameters and schedules the finalizeDestruction callback
- Creates visual effects for the dissolution

### finalizeReturn()
- Called when return animation completes
- Positions the token appropriately in the mana pool
- Resets token properties for its FREE state

### finalizeDestruction()
- Called when dissolve animation completes
- Removes token from the tokens list
- Releases token to the object pool (POOLED state)

## Usage

### Acquiring a Token
```lua
local token, index = manaPool:getToken(tokenType)
-- token.status is now CHANNELED
```

### Returning a Token to Pool
```lua
token:requestReturnAnimation()
-- Animation will play, then token.status will become FREE
```

### Destroying a Token
```lua
token:requestDestructionAnimation()
-- Animation will play, then token will be released to pool
```

### Canceling a Spell with Disjoint (Event-based)
```lua
-- In keywords.lua, the disjoint keyword creates a CANCEL_SPELL event
table.insert(events, {
    type = "CANCEL_SPELL",
    source = "caster",
    target = "enemy_slot", -- Use string that EventRunner understands
    slotIndex = targetSlotIndex,
    returnMana = false -- Key difference for disjoint
})

-- The EventRunner handles the CANCEL_SPELL event and destroys tokens
for _, tokenData in ipairs(slot.tokens) do
    if tokenData.token then
        tokenData.token:requestDestructionAnimation()
    end
end

-- Then it resets the slot without manipulating token states
wizard:resetSpellSlot(slotIndex)
```

## Benefits

1. Encapsulation: Token manages its own lifecycle
2. Clear states: Each token's state is well-defined
3. Animation/Logic Separation: Animation logic is clearly separated from state transition logic
4. Safety: Invalid state transitions are prevented and logged
5. Unified approach: All token handling follows the same pattern
6. Event System Integration: Token lifecycle integrates with the game's event system

## Event System Integration

The token lifecycle system integrates with the event-driven architecture:

1. **CANCEL_SPELL Events**: Handle spell cancellation
   - With `returnMana = true`: Tokens are returned to the pool (dispel)
   - With `returnMana = false`: Tokens are destroyed (disjoint)

2. **Direct vs. Event-Driven Manipulation**:
   - Old approach: Set `token.state = "DESTROYED"` directly
   - New approach: Generate events that call appropriate token methods
   
3. **Decoupled Spell Slot Reset**:
   - `resetSpellSlot` no longer manipulates token states directly
   - All slot resets across the codebase use a centralized method
   - Token animations are requested first, then slot references are cleared later 
   - Clean separation between token state management and slot reset
   - Unified handling of all slot properties (basic, shield, zone, etc.)

## Animation System

The ManaPool:update method now drives token animations based on their status:

- For tokens with status == RETURNING:
  - Updates their return animation progress (moving towards pool center)
  - When animation completes, calls token.animationCallback() which triggers finalizeReturn()

- For tokens with status == DISSOLVING:
  - Updates their dissolve animation progress (scaling/fading)
  - When animation completes, calls token.animationCallback() which triggers finalizeDestruction()

- For each status (FREE, CHANNELED, SHIELDING, LOCKED):
  - Updates positions based on appropriate behavior (orbiting, spell slot, wobbling, etc.)

This separation of concerns ensures that:
1. Animations are consistent and predictable
2. Token state transitions only happen at well-defined points
3. The ManaPool update method is more maintainable, focusing on animation driving rather than state management

## docs/vfxTodo.md
# Spell "Visual Shapes" for Demo
1. Affect Mana Pool (Utility)
2. Barrier (Utility)
3. Wings (Utility)
4. Surge (Utility)
5. Eclipse (Utility)
6. Bolt (Projectile)
7. Beam (Projectile)
8. Zap (Projectile)
9. Orb (Projectile)
10. Blast (Zone)
11. Ground Burst (Zone)
12. Meteor (Zone)
13. Warp (Remote)

## docs/visualShape.md
# visualShape Property in Spell Definitions

## Overview

The `visualShape` property is an optional field in spell definitions that allows overriding the default visual template selection based on attackType. This property gives greater control over the visual representation of spells without requiring custom VFX definitions for every spell variant.

## Purpose

In Manastorm's visual system:

1. By default, the `VisualResolver` selects a base visual template based on a spell's `attackType`:
   - `PROJECTILE` → `proj_base`
   - `REMOTE` → `remote_base`
   - `ZONE` → `zone_base`
   - `UTILITY` → `util_base`

2. The `visualShape` property allows overriding this default mapping to select a more appropriate template.

## Example Use Case

Consider a spell like `Full Moon Beam` which has `attackType = REMOTE` but should visually appear as a beam:

```lua
MoonSpells.fullmoonbeam = {
    id = "fullmoonbeam",
    name = "Full Moon Beam",
    affinity = Constants.TokenType.MOON,
    description = "Channels moonlight into a beam",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "beam",  -- Override to use beam template instead of remote template
    -- other properties...
}
```

Without the `visualShape` property, this spell would use the `remote_base` template (which might be an explosion effect). By setting `visualShape = "beam"`, it will use the `beam_base` template instead.

## Supported Values

The `visualShape` property supports the following values:

- `"beam"` - A sustained beam effect (uses `beam_base` template)
- `"bolt"` or `"orb"` - Projectile effects (use `proj_base` template)
- `"zap"` - Lightning bolt effect (uses `zap_base` template)
- `"blast"` or `"groundBurst"` - Area effects (use `zone_base` template)
- `"warp"`, `"surge"`, or `"affectManaPool"` - Utility effects (use `util_base` template)
- `"wings"` or `"mirror"` - Shield/barrier effects (use `shield_overlay` template)
- `"eclipse"` - Special effect (uses a specialized template)

## Implementation Details

1. The spell definition includes a `visualShape` property.
2. This property is carried through to the compiled spell.
3. When the spell is cast, the VisualResolver checks for this property in the event.
4. If found, it overrides the template selection logic to use the specified template instead of the default based on attackType.

## Benefits

- Maintains the benefit of the rules-driven VFX system while allowing visual customization
- Allows spells with the same attackType to have different visual styles
- Reduces the need for custom VFX definitions for every spell
- Separates the gameplay behavior (attackType) from visual representation (visualShape)

## Relationship with Other VFX Properties

The `visualShape` property works alongside other VFX-related properties:

- `vfx`: Directly specifies a VFX template (highest priority, bypasses VisualResolver)
- `visualShape`: Overrides the base template selection in VisualResolver
- `attackType`: Default method for determining base template (lowest priority)

## Example Implementation Flow

1. Spell definition includes `visualShape = "beam"`
2. Spell is cast, generates a DAMAGE event
3. DAMAGE handler creates an EFFECT event with the same visualShape
4. VisualResolver receives the event with visualShape property
5. VisualResolver maps "beam" to beam_base template
6. VFX is rendered using the beam_base template with appropriate colors and modifiers based on spell affinity

## docs/wizard.md
# Wizard Module (`wizard.lua`)

## Overview

The `wizard.lua` module defines the "class" for the player characters in Manastorm. It encapsulates the state, capabilities, and core logic for each wizard participating in the duel. This includes handling health, position, status effects, spellcasting (keying, channeling, casting, shielding), input interpretation (via delegation), updates, and drawing.

## Key Components

### 1. State Variables

Each `Wizard` instance maintains a comprehensive set of state variables:

*   **Identity & Position:** `name`, `x`, `y`, `color`.
*   **Combat:** `health`.
    * `statusEffects[Constants.StatusType.STUN]`: Tracks stun duration.
*   **Positioning:**
    *   `elevation`: String ("GROUNDED" or "AERIAL").
    *   `elevationTimer`: Duration for temporary AERIAL state.
    *   `currentXOffset`, `currentYOffset`: Calculated visual offsets based on game range state (`NEAR`/`FAR`) and elevation, used for drawing.
*   **Status Effects:** `statusEffects` table (e.g., `statusEffects.burn` tracks active state, duration, tick damage, timers).
*   **Spellcasting State:**
    *   `spellbook`: Table mapping key combinations ("1", "12", "123") to specific spell definitions from `SpellsModule`. Unique per wizard name ("Ashgar", "Selene").
    *   `activeKeys`: Table tracking pressed state of spell keys [1], [2], [3].
    *   `currentKeyedSpell`: Reference to the spell definition matching `activeKeys`.
    *   `spellSlots`: Array of 3 tables, each representing a casting/shield slot. Tracks:
        *   `active`: Boolean indicating if the slot is in use.
        *   `progress`: Current casting time elapsed.
        *   `castTime`: Total time required to cast the spell (can be dynamic).
        *   `spell`: Reference to the compiled spell object.
        *   `spellType`: Name of the spell.
        *   `tokens`: Array table holding references to mana tokens ({token=..., index=...}) currently channeled or part of a shield in this slot.
        *   `isShield`: Boolean indicating if the slot holds an active shield.
        *   `defenseType`: String ("barrier", "ward", "field") for shield type.
        *   `blocksAttackTypes`: Table mapping attack types this shield blocks.
        *   `reflect`: Boolean indicating if the shield reflects damage.
        *   `frozen`: Boolean indicating if the spell cast is paused (e.g., by Eclipse Echo).
        *   `freezeTimer`: Remaining duration for the frozen state.
*   **Visuals:** `sprite` (loaded image), `scale`, `blockVFX` (timer/state for block visuals).
*   **References:** `manaPool` (instance of ManaPool), `gameState` (reference to the global `game` table in `main.lua`).

### 2. Core Methods

*   **`Wizard.new(name, x, y, color, spellbook)`:** Constructor. Initializes all state variables, loads sprite, and assigns the provided `spellbook`.
*   **`Wizard:update(dt)`:** Per-frame update logic. Manages timers (stun, elevation, status effects), applies burn damage ticks, updates shield token orbits, increments spell casting `progress`. Calls `castSpell` upon completion.
*   **`Wizard:draw()`:** Main drawing function. Draws the wizard sprite (applying offsets/effects), elevation visuals, status bars (`drawStatusEffects`), and spell slots (`drawSpellSlots`).
*   **`Wizard:drawSpellSlots()`:** Visualizes casting/shields. Draws elliptical orbits, progress arcs (colored by state: casting, shield, frozen), shield type names, and orbiting mana tokens (with Z-ordering for depth).
*   **`Wizard:keySpell(keyIndex, isPressed)`:** Updates `activeKeys` and `currentKeyedSpell` based on player input.
*   **`Wizard:castKeyedSpell()`:** Entry point for casting. Checks stun state, validates `currentKeyedSpell`, and calls `queueSpell`.
*   **`Wizard:queueSpell(spell)`:** Initiates spell casting.
    *   Finds an available `spellSlot`.
    *   Checks mana availability using `canPayManaCost`.
        *   If the spell defines `getCost`, that function is called with `caster` and `target` to determine the token list.
    *   If affordable, acquires token references from `manaPool` via reservations.
    *   Sets token state to `CHANNELED`.
    *   Sets up animation parameters for tokens (Bezier curve towards wizard).
    *   Activates the `spellSlot`, storing spell info and cast time.
    *   Flags slot if it `willBecomeShield`.
*   **`Wizard:castSpell(spellSlot)`:** Executes the spell effect when casting completes.
    *   Performs preemptive shield check on the target (`checkShieldBlock`).
    *   If blocked: calls `target:handleShieldBlock`, returns caster's tokens, resets caster's slot (`resetSpellSlot`).
    *   If not blocked: Executes spell logic via `spell.executeAll` (compiled) or legacy system.
    *   Interprets returned `effect` table:
        *   Shield Spells: Calls local `createShield` helper, potentially applies elevation, leaves slot active with tokens (`isShield=true`).
        *   Normal Spells: Applies damage (`target.health`), status effects (burn, stun), position changes (range, elevation), mana manipulation (lock, delay) based on `effect` table. Returns caster's tokens (`requestReturnAnimation`/`manaPool:returnToken`), resets caster's slot (`resetSpellSlot`).
*   **`Wizard:handleShieldBlock(slotIndex, blockedSpell)`:** (Called on the target wizard). Consumes tokens from the specified shield slot based on `blockedSpell.shieldBreaker`, returns consumed tokens, and calls `resetSpellSlot` if the shield breaks (runs out of tokens).
*   **`Wizard:resetSpellSlot(slotIndex)`:** Utility function to reset all properties of a spell slot to default/inactive state and clear its token list. Used after normal casts, cancellations, or shield breaks.
*   **`Wizard:canPayManaCost(costOrFn[, target])`:** Checks if a mana cost can be paid without consuming tokens. `costOrFn` may be a static table or the `getCost` function from a spell definition. The function returns a reservation detail table or `nil` if the cost can't currently be met.
*   **`Wizard:freeAllSpells()`:** Cancels all active spells/shields, returns their tokens, and resets the corresponding slots.

### 3. Token Interaction

The Wizard module interacts heavily with the `ManaPool` and individual token objects:

*   Uses `canPayManaCost` to check availability.
*   Reserves tokens during `queueSpell`.
*   Sets token state to `CHANNELED`.
*   Manages token position updates *while they are animating towards or orbiting the wizard*.
*   Initiates token return via `token:requestReturnAnimation()` (preferred) or `manaPool:returnToken()` (fallback).
*   Shields maintain references to their tokens; `handleShieldBlock` removes tokens from the target's shield slot and initiates their return.

### 4. Potential Cleanup Areas

*   Consider factoring to smaller modules.

## Dependencies

*   `core.Constants`
*   `core.AssetCache`
*   `spells` (SpellsModule)
*   `manapool` (via `self.manaPool` reference)
*   Global `game` state (via `self.gameState` reference) for accessing `vfx`, `wizards` list, `rangeState`.
*   Local `getCompiledSpell` helper (defined within `wizard.lua`)
*   Local `checkShieldBlock` helper (defined within `wizard.lua`)
*   Local `createShield` helper (defined within `wizard.lua`) 

## ./AGENTS.md
Prime for development on _Manastorm_, a strategic action game of magical dueling, using the following docs as your primary entry points:

* CrashCourse.md
* DevelopmentGuidelines.md

You will want to explore the "docs" folder and the relevant Lua code related to some specific bug or feature request once you have gotten your bearing with the above documents. You can assume the content of the "Tickets" folder to have already been completed unless directed there explicitly for tasks.

## ./ComprehensiveDesignDocument.md
Game Title: Manastorm (working title)

Genre: Tactical Wizard Dueling / Real-Time Strategic Battler

Target Platforms: PC (initial), with possible future expansion to consoles

Core Pitch:

A high-stakes, low-input real-time dueling game where two spellcasters 
clash in arcane combat by channeling mana from a shared pool to queue 
spells into orbiting "spell slots." Strategy emerges from a shared 
resource economy, strict limitations on casting tempo, and deep 
interactions between positional states and spell types. Think Street 
Fighter meets Magic: The Gathering, filtered through an occult operating 
system.

Core Gameplay Loop:

Spell Selection Phase (Pre-battle)

Each player drafts a small set of spells from a shared pool.

These spells define their available actions for the match.

OR

Character Select Phase (Pre-battle)

Each player selects a character with a unique spellbook from a fighting-game style roster.

Combat Phase (Real-Time)

Players queue spells from their loadout (max 3 at a time).

Each spell channels mana from a shared pool and takes time to resolve.

Spells resolve in real-time after a fixed cast duration.

Cast spells release mana back into the shared pool, ramping intensity.

Positioning states (NEAR/FAR, GROUNDED/AERIAL) alter spell legality and 
effects.

Players win by reducing the opponent’s health to zero.

Key Systems & Concepts:

1. Spell Queue & Spell Slots

Each player has 3 spell slots.

Spells are queued into slots using hotkeys (Q/W/E or similar).

Each slot is visually represented as an orbit ring around the player 
character.

Channeled mana tokens orbit in these rings.

2. Mana Pool System

A shared pool of mana tokens floats in the center of the screen.

Tokens are temporarily removed when used to queue a spell.

Upon spell resolution, tokens return to the pool.

Tokens have types (e.g. FIRE, VOID, WATER), which interact with spell 
costs and effects.

The mana pool escalates tension by becoming more dynamic and volatile as 
spells resolve.

3. Token States

FREE: Available in the pool.

CHANNELED: Orbiting a caster while a spell is charging.

LOCKED: Temporarily unavailable due to enemy effects.

DESTROYED: Rare, removed from match entirely.

4. Positional States

Each player exists in binary positioning states:

Range: NEAR / FAR

Elevation: GROUNDED / AERIAL

Many spells can only be cast or take effect under certain conditions.

Players can be moved between states via spell effects.

5. Cast Feedback (Diegetic UI)

Each spell slot shows its cast time progression via a glowing arc rotating 
around the orbit.

Players can visually read how close a spell is to resolving.

No abstract bars; all feedback is embedded in the arena.

6. Spellbook System

Players have access to a limited loadout of spells during combat.

A separate spellbook UI (toggleable) shows full names, descriptions, and 
mechanics.

Core battlefield UI remains minimal to prioritize visual clarity and 
strategic deduction.

Visual & Presentation Goals

Combat is side-view, 2D.

Wizards are expressive but minimal sprites.

Mana tokens are vibrant, animated symbols.

All key mechanics are visible in-world (tokens, cast arcs, positioning 
shifts).

No HUD overload; world itself communicates state.

Design Pillars

Tactical Clarity: All decisions have observable consequences.

Strategic Literacy: Experienced players gain advantage by reading visual 
patterns.

Diegetic Information: The battlefield tells the story; minimal overlays.

Shared Economy, Shared Risk: Players operate in a closed loop that fuels 
both offense and defense.

Example Spells (Shortlist)

Ashgar the Emberfist:

Firebolt: Quick ranged hit, more damage at FAR.

Meteor Dive: Aerial finisher, hits GROUNDED enemies.

Combust Lock: Locks opponent mana token, punishes overqueueing.

Selene of the Veil:

Mist Veil: Projectile block, grants AERIAL.

Gravity Pin: Traps AERIAL enemies.

Eclipse Echo: Delays central queued spell.

Target Experience

Matches last 2–5 minutes.

Constant mental engagement without twitchy inputs.

Read-your-opponent mind games and counterplay at the forefront.

Replayable duels with high skill ceiling and unique matchups.

This document will evolve, but this version represents the intended 
holistic vision of the gameplay experience, tone, and structure of 
Manastorm.

## ./CrashCourse.md
Manastorm Crash Course: Welcome to the Ninefold Circle!
Purpose: To quickly bring new contributors up to speed on the overall architecture and key systems of Manastorm.
Target Audience: Developers new to the Manastorm codebase.
1. Introduction: What is Manastorm?
Manastorm is a real-time tactical wizard dueling game. Two spellcasters face off, drawing mana from a shared central pool to queue and cast spells. The core gameplay revolves around:
Shared Resource Economy: Both players draw from the same mana pool.
Casting Tempo: Spells take time to charge, creating windows of opportunity and vulnerability.
Positional Strategy: NEAR/FAR range and GROUNDED/AERIAL elevation states significantly impact spell legality and effects.
Diegetic UI: Game information is primarily conveyed through in-world visual cues rather than traditional HUD elements.
(Refer to ComprehensiveDesignDocument.md for the full vision.)
2. Core Architectural Pillars
The game is built around several key interconnected systems:
Game Loop & State (main.lua):
Manages the main game states (MENU, CHARACTER_SELECT, BATTLE, GAME_OVER, BATTLE_ATTRACT, etc.).
Handles love.load(), love.update(), love.draw(), and input routing via core/Input.lua.
The global game table holds references to major game objects and state (wizards, mana pool, VFX system, etc.).
Wizards (wizard.lua):
The primary actors in the game. Each wizard has health, spell slots, a spellbook, and manages their current state (elevation, status effects).
Spellcasting: Wizards don't cast spells instantly. They:
Key Spells: Players press key combinations (e.g., Q, W, E or Q+W) to select a spell from their spellbook.
Queue Spells: If a slot is available and mana cost can be paid, the spell is queued into an orbiting spell slot. Mana tokens are acquired from the ManaPool and animated towards the wizard.
Channeling: The spell "charges" in the slot, visually represented by a progress arc.
Resolution: Once charged, Wizard:castSpell() is called.
(See docs/wizard.md for more details.)
Mana Pool (manapool.lua):
A shared, central pool of mana tokens.
Tokens have types (Constants.TokenType) and states (Constants.TokenStatus - FREE, CHANNELED, SHIELDING, RETURNING, DISSOLVING, POOLED).
Manages token animations (orbiting in the pool, moving to/from wizards).
Employs object pooling (core/Pool.lua) for token objects to reduce garbage collection.
(See docs/manapool.md and docs/token_lifecycle.md for more details.)
Spell System (The "Triune Spell Engine"):
keywords.lua (Ingredients): Defines atomic game actions (e.g., damage, elevate, conjure). Each keyword has a behavior (metadata) and an execute function.
Crucially, keyword execute functions generate events describing state changes, rather than directly modifying game state.
spells/ directory (Recipes): Spell definitions are organized by element (e.g., spells/elements/fire.lua). Each spell is a table combining keywords with specific parameters (e.g., damage = { amount = 10, type = "fire" }).
spellCompiler.lua (Chef): Takes raw spell definitions and "compiles" them into executable objects. It merges keyword behaviors and binds their execute functions. The compiled spell's executeAll() method is called by Wizard:castSpell().
(See docs/spellcasting.md and docs/keywords.lua [generated] for more details.)
Event System (systems/EventRunner.lua):
The Core of Gameplay Logic Application. After compiledSpell.executeAll() generates a list of events, the EventRunner processes them.
Events have a type, source, target, and event-specific data.
The EventRunner sorts events by PROCESSING_PRIORITY and calls specific handler functions from EventRunner.EVENT_HANDLERS for each event type.
It is these handlers within EventRunner that actually modify the game state (e.g., wizard health, token states, VFX triggers).
(See docs/combat_events.md for the event schema.)
Visual Effects (VFX) System (vfx.lua & systems/VisualResolver.lua):
Rule-Driven: Most VFX are not manually specified per spell. Instead, the VisualResolver inspects metadata within EFFECT events (like affinity, attackType, visualShape, manaCost, tags) to pick a base VFX template and its parameters (color, scale, motion).
vfx.lua contains base effect templates (e.g., proj_base, beam_base) and the logic to update and draw active visual effects. It also uses object pooling for effects and particles.
Specific named effects (like meteor) exist for more unique visuals.
(See docs/Visual_Language.md, docs/AddingVisualTemplates.md, and VFX-RulesBasedRefactor-GamePlan.md.)
AI System (ai/):
OpponentAI.lua: Provides the core FSM (Idle, Attack, Defend, etc.) and Perception-Decision-Action loop.
PersonalityBase.lua: Defines an interface for character-specific AI behavior.
ai/personalities/: Contains specific AI logic for different wizards (e.g., SelenePersonality.lua). Personalities suggest spells and can influence state transitions.
The AI interacts with its wizard object via the same API as a human player would (e.g., wizard:queueSpell()), not by simulating key presses.
Core Utilities (core/):
Constants.lua: Centralized string constants. Crucial for avoiding magic strings.
AssetCache.lua: Prevents duplicate loading of images and sounds.
Pool.lua: Generic object pooling system.
Input.lua: Unified input routing. Uses an action-based scheme defined in
  `Constants.ControlAction`. Keyboard and gamepad bindings are loaded from
  Settings.lua and can be changed at runtime.
Settings.lua: Handles persistent game settings.
assetPreloader.lua: Manages preloading of assets.
3. Key Interactions & Data Flow
Player Input (core/Input.lua) -> Wizard (wizard.lua):
Keys pressed are routed to wizard:keySpell() to select a spell, then wizard:castKeyedSpell() calls wizard:queueSpell().
Spell Queuing (wizard.lua):
wizard:canPayManaCost() checks ManaPool.
TokenManager.acquireTokensForSpell() moves tokens from ManaPool to wizard.spellSlots[i].tokens (state: CHANNELED).
Spell slot becomes active; casting progress begins.
Spell Resolution (wizard.lua -> spellCompiler.lua -> keywords.lua):
When slot.progress >= slot.castTime, wizard:castSpell() is called.
compiledSpell.executeAll() (from spellCompiler) iterates through the spell's keywords.
Each keyword's execute() function is called, adding descriptive events to a list.
Event Processing (spellCompiler.lua -> systems/EventRunner.lua):
executeAll() passes the generated event list to EventRunner.processEvents().
EventRunner sorts events and calls the appropriate handler for each.
State Mutation & VFX Triggering (systems/EventRunner.lua):
Event handlers modify game state (e.g., targetWizard.health -= event.amount).
For visual changes, handlers often generate an EFFECT event.
The EFFECT event handler calls VisualResolver.pick(event) to determine the baseEffectName and vfxOpts.
Then, VFX.createEffect(baseEffectName, ..., vfxOpts) is called to create the visual.
Visual Rendering (vfx.lua, systems/WizardVisuals.lua):
VFX.update() and VFX.draw() manage active visual effects.
WizardVisuals.drawWizard() handles drawing the wizard sprite, spell slots, and status effects.
4. Current Development Focus
"Game Juice": Enhancing visual and audio feedback to make gameplay feel more impactful and satisfying.
Content Creation: Adding new spells, characters, and potentially AI personalities.
Balancing: Tweaking spell costs, cast times, and effects.
5. Getting Started
Read the Docs: Start with ComprehensiveDesignDocument.md, README.md, then dive into system-specific docs relevant to your task (e.g., spellcasting.md, VFX-RulesBasedRefactor-GamePlan.md).
Trace a Spell: Pick a simple spell (e.g., Firebolt). Trace its definition in spells/elements/fire.lua, its keywords in keywords.lua, how spellCompiler.lua prepares it, how wizard.lua casts it, how EventRunner.lua processes the resulting events, and how vfx.lua (via VisualResolver.lua) displays it.
Look at Tickets: The Tickets/ directory shows recent work and priorities, which can give context to code changes.

## ./DevelopmentGuidelines.md
Manastorm Development Guidelines
Purpose: To establish conventions and best practices for coding new features and refactoring existing systems in Manastorm, ensuring consistency and maintainability.
I. General Principles
Modularity:
Keep systems decoupled. Favor communication through well-defined interfaces or events.
New major functionalities should generally reside in their own modules within appropriate directories (e.g., systems/, ai/, core/).
Avoid "god objects"; delegate responsibilities to specialized modules.
Data-Driven Design:
Prefer defining game entities (spells, character stats, AI behaviors) in Lua tables rather than hardcoding logic. This is evident in spells/, keywords.lua, and ai/personalities/.
This makes balancing and content creation easier.
Event-Driven Architecture (for Gameplay Logic):
Primary Rule: Changes to game state (wizard health, token status, positions, status effects) resulting from spell effects must be processed through the EventRunner.
Keywords and spell logic should generate descriptive events, not directly mutate state.
Refer to docs/combat_events.md for the event schema.
Use EventRunner.queueVisual() (or generate an EFFECT event) for triggering VFX from game systems outside direct spell casts (e.g., token destruction animations).
Use Constants (core/Constants.lua):
Strictly avoid magic strings for anything that represents a defined game state, type, or category (e.g., "fire", "AERIAL", "projectile").
Always use Constants.TokenType.FIRE, Constants.ElevationState.AERIAL, Constants.AttackType.PROJECTILE, etc.
Add new constants to core/Constants.lua as needed, following existing naming conventions.
Run tools/check_magic_strings.lua periodically or as a pre-commit hook.
Readability & Clarity:
Write clear, self-documenting code where possible.
Use meaningful variable and function names.
Add comments to explain complex logic or non-obvious decisions.
Performance Considerations:
Object Pooling: For frequently created/destroyed objects (mana tokens, VFX particles, VFX effect containers), use the core/Pool.lua system. Ensure resetFn thoroughly clears all object fields.
Asset Caching: All image and sound loading must go through core/AssetCache.lua to prevent duplicate loads.
Avoid heavy computations in love.update() or love.draw() where possible. Profile if performance issues arise.
II. Specific System Guidelines
Adding New Spells:
Define the spell in the appropriate spells/elements/your_element.lua file.
Adhere to the schema in spells/schema.lua (id, name, affinity, description, attackType, castTime, cost, keywords, visualShape (optional)).
Compose spell effects using existing keywords from keywords.lua. If new mechanics are needed, define new keywords first.
Spell visualShape and affinity will primarily drive visuals via VisualResolver. Only use the vfx keyword with effectOverride for truly unique cinematic effects.
Update characterData.lua if the spell is part of a default spellbook or the character's general spell list for the Compendium.
Add to game.unlockedSpells in main.lua if it's unlockable.
Modifying or Adding Keywords (keywords.lua):
Event Generation: The execute function must add events to the passed-in events table. It should not directly modify caster, target, or gameState.
Parameters: Keyword parameters defined in spells.lua can be static values or functions (resolved by keywords.lua.resolve()).
Dynamic Costs: Spells may include a `getCost(caster, target)` function which returns a token cost table at runtime. Use this for mechanics like health-scaled or target-dependent costs.
Metadata: Keep the behavior table updated with descriptive flags, targetType, and category.
VFX: Keywords generally should not trigger VFX directly. Instead, the events they generate (e.g., DAMAGE, SET_ELEVATION) will be picked up by EventRunner, which then uses VisualResolver for VFX. If a keyword has a unique, inherent visual distinct from its gameplay event (rare), it can generate a specific EFFECT event.
Documentation: Update docs/keywords.lua (or ensure it's auto-generated) if adding or significantly changing a keyword.
Visual Effects (VFX - vfx.lua, systems/VisualResolver.lua):
Rule-Driven First: Strive to have visuals determined by VisualResolver based on event metadata (affinity, attackType, visualShape, manaCost, tags).
Base Templates: Add to or modify base templates in VFX.effects (e.g., proj_base, beam_base) to handle parameters like color, scale, and motion style.
Motion Styles: Utilize Constants.MotionStyle and implement the corresponding logic in VFX.updateParticle.
Constants.VFXType: Add new base template names or unique override effect names to Constants.VFXType.
Asset Handling: Add asset paths to VFX.assetPaths. Critical assets needed immediately should be preloaded in VFX.init(); others will be lazy-loaded via getAssetInternal.
(Refer to docs/AddingVisualTemplates.md and VFX-RulesBasedRefactor-GamePlan.md.)
AI Personalities (ai/personalities/):
Create new personality files that implement the interface defined in ai/PersonalityBase.lua.
Personality modules are responsible for spell selection logic for a specific character.
Keep the core OpponentAI.lua generic; character-specific logic belongs in personality modules.
AI actions should use wizard:queueSpell(), not simulate input.
Input Handling:
  The game uses an action-based input layer. All actions are defined in
  `Constants.ControlAction`. Default bindings for keyboard and gamepad live in
  `core/Settings.lua` and can be rebound at runtime through the Settings menu.
UI (ui.lua, main.lua draw functions):
Strive for diegetic UI where possible (information integrated into the game world).
Keep UI drawing logic separate from game state update logic.
For complex UI elements, consider dedicated update/draw functions within ui.lua.
State Management & Game Logic:
EventRunner is King: Gameplay state changes resulting from spell effects must go through the EventRunner.
Wizard Object: Owns its immediate state (health, slots, current keyed spell, position).
_G.game Table: Holds global game state and references to major systems. Use judiciously.
main.lua: Orchestrates system updates and drawing based on game.currentState.
Asset Handling:
core/AssetCache.lua: All static file-based assets (images, sounds) must be loaded via AssetCache.getImage() or AssetCache.getSound().
core/assetPreloader.lua: Add paths for new assets to assetManifest to ensure they are preloaded at game start, preventing hitches. For VFX assets, also add paths to VFX.assetPaths in vfx.lua for lazy loading fallback/management.
III. Coding Conventions
Naming:
Modules / "Classes": PascalCase (e.g., OpponentAI, VisualResolver).
Functions / Methods: camelCase (e.g., requestReturnAnimation, canPayManaCost).
Local Variables: camelCase.
Constants: ALL_CAPS_SNAKE_CASE (e.g., Constants.TokenType.FIRE).
Private module functions (not intended for export): prefix with _ (e.g., _privateHelperFunction).
Comments:
Use LuaDoc-style comments for public functions/methods in modules (--- Description \n -- @param name type \n -- @return type).
Add inline comments for complex or non-obvious logic.
Use TODO:, FIXME:, NOTE: prefixes for actionable comments.
Error Handling & Logging:
Use pcall() for operations that might fail (e.g., file loading, external calls if any).
Use print("ERROR: ...") or print("WARNING: ...") for logging issues.
Leverage core/Log.lua (Log.debug(...)) for verbose development logs, which can be toggled.
Constants: Reiterate: No magic strings.
Global State:
Minimize direct modification of _G.game from modules other than main.lua. Systems should generally read from _G.game or have necessary parts passed to them.
Functions within modules should operate on self or passed-in parameters.
IV. Testing
Unit Tests (Informal): While a formal unit testing framework isn't in place, consider writing small, isolated test functions within modules or in tools/ to verify specific logic, especially for utility functions or complex algorithms.
V. Documentation
Update Existing Docs: If a change impacts a system described in docs/, update the relevant markdown file.
New Systems: Create new markdown documents in docs/ for significant new systems or architectural patterns.
Code Comments: Keep docblocks and inline comments current.

## ./README.md
# Manastorm

A tactical wizard dueling game built with LÖVE (Love2D).

## Description

Manastorm is a real-time strategic battler where two spellcasters clash in arcane combat by channeling mana from a shared pool to queue spells into orbiting "spell slots." Strategy emerges from a shared resource economy, strict limitations on casting tempo, and deep interactions between positional states and spell types.

## Requirements

- [LÖVE](https://love2d.org/) 11.4 or later

## How to Run

1. Install LÖVE from [love2d.org](https://love2d.org/)
2. Clone this repository
3. Run the game:
   - On Windows: Drag the folder onto love.exe, or run `"C:\Program Files\LOVE\love.exe" path\to\Manastorm`
   - On macOS: Run `open -n -a love.app --args $(pwd)` from the Manastorm directory
   - On Linux: Run `love .` from the Manastorm directory

## Controls

Manastorm uses an **action-based** input layer. Each action is defined in
`Constants.ControlAction` and can be bound independently for keyboard or
gamepad via the Settings menu. The mappings below reflect the defaults shipped
with the game.

### Default Keyboard Mapping

**Player 1**

- Q / W / E: Spell slots 1–3
- F: Cast (also acts as menu confirm)
- G: Free spells (also acts as menu cancel)
- B: Toggle spellbook
- Arrow Keys: Menu navigation

**Player 2**

- I / O / P: Spell slots 1–3
- J: Cast
- H: Free spells
- M: Toggle spellbook

### Default Gamepad Mapping

Gamepad controls mirror the keyboard actions. Use the D-pad for spell slots and
menu navigation. The **A** button casts or confirms, **Y** frees or cancels, and
**B** toggles the spellbook. When a second gamepad is connected these mappings
apply to Player 2 as well.

### General
- ESC: Quit the game

## Unlocking Characters

Casting any Salt-affinity spell during a match unlocks the wizard **Silex** for
future character selection.

## Debug Logging

Verbose debug output can be toggled at runtime. Require the `core.Log` module and
call `Log.setVerbose(true)` to enable detailed logging. Set it to `false` (the
default) to silence development traces.

## Development Status

This is a late prototype with basic full engine functionality:
- Two opposing wizards with health bars
- Shared mana pool with floating tokens
- Three spell slots per wizard with visual feedback
- Simple spatial state representation (NEAR/FAR, GROUNDED/AERIAL)
- Data-driven VFX engine (actual visuals are still rough)
- Various spell types with unique mechanics: Attack, Utility, Shield, Trap (with various subtypes of each)
- Various spell keywords with rigorously defined mechanics.
- "Triune Spell Engine" custom DSL/data-driven format for defining spells in terms of keywords. Spells are "compiled" at runtime from keyword-based definitions which can be authored using any convenient tool.

## Next Steps

- Polish VFX and add SFX. Use consistent design language driven by TSE spell definitions.
- Add basic main menu, mode select, control customization.
- Add AI opponent (strategy design pattern).
- Add content. Lots of content. Lots and lots and lots of content.

## ./SFX_GATING_IMPLEMENTATION.md
# SFX Gating Implementation

## Overview
The SFX gating system prevents crashes when sound files are missing or corrupted during development. All sound-related operations are now conditional based on an `ENABLE_SFX` configuration flag.

## Changes Made

### 1. Settings Module (`core/Settings.lua`)
- Added `ENABLE_SFX = false` to the defaults configuration
- This disables SFX by default during development

### 2. VFX Module (`vfx.lua`)
- Added Settings import
- Added `VFX.isSFXEnabled()` helper function
- Modified sound loading to check `ENABLE_SFX` before attempting to load sounds
- Added error handling with `pcall` for sound loading
- Modified sound playing to check `ENABLE_SFX` before playing
- Added documentation comments

### 3. AssetCache Module (`core/AssetCache.lua`)
- Added Settings import
- Modified `getSound()` function to check `ENABLE_SFX` before loading
- Modified `preload()` function to skip sound loading when SFX is disabled
- Added appropriate logging messages

### 4. Main Module (`main.lua`)
- Modified sound play operation in slot highlighting to check `ENABLE_SFX`

## How to Enable SFX

### Method 1: Edit settings.lua
```lua
return {
    dummyFlag = false,
    gameSpeed = "FAST",
    ENABLE_SFX = true,  -- Enable SFX
    controls = {
        -- ... rest of settings
    }
}
```

### Method 2: Programmatically
```lua
local Settings = require("core.Settings")
Settings.set("ENABLE_SFX", true)
```

### Method 3: Check SFX Status
```lua
local VFX = require("vfx")
if VFX.isSFXEnabled() then
    -- SFX is enabled
else
    -- SFX is disabled
end
```

## Benefits

1. **Crash Prevention**: Game won't crash when sound files are missing
2. **Development Friendly**: Can develop without sound assets
3. **Configurable**: Easy to enable/disable via settings
4. **Graceful Degradation**: Visual effects work without sound
5. **Error Handling**: Proper error messages when sound loading fails

## Testing

The system has been tested to ensure:
- Game starts without crashes when SFX is disabled
- Sound loading is properly gated
- Sound playing is properly gated
- Settings can be changed at runtime
- Error handling works correctly

## Future Considerations

- When actual sound assets are created, set `ENABLE_SFX = true` in production
- Consider adding individual sound enable/disable flags for fine-grained control
- May want to add volume controls when SFX is enabled 

## ./manastorm_codebase_dump.md
# Manastorm Codebase Dump
Generated: Thu Jun 26 14:09:07 CDT 2025

# Source Code

## ./ai/OpponentAI.lua
```lua
-- ai/OpponentAI.lua
-- Basic AI opponent for Manastorm
-- Phase 2: Modular AI Architecture with Personality System

local Constants = require("core.Constants")
local ManaHelpers = require("systems.ManaHelpers")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the OpponentAI module
local OpponentAI = {}

-- AI States - Define as constants for clarity
OpponentAI.STATE = {
    IDLE = "IDLE",             -- Default state, focus on building mana resources
    ATTACK = "ATTACK",         -- Aggressive offense, prioritize damage spells
    DEFEND = "DEFEND",         -- Defensive posture, prioritize shields and healing
    COUNTER = "COUNTER",       -- Counter opponent's active spells
    ESCAPE = "ESCAPE",         -- Desperate state when very low health, try to survive
    POSITION = "POSITION"      -- Adjust position (elevation/range) for advantage
}

-- Constructor for OpponentAI
-- @param wizard - The wizard object this AI will control (typically game.wizards[2])
-- @param gameState - Reference to the game state (the global 'game' object)
-- @param personalityModule - The personality module to use for decision making
function OpponentAI.new(wizard, gameState, personalityModule)
    -- Create default personality if none provided
    personalityModule = personalityModule or PersonalityBase.new("Default")
    
    -- Create a new instance
    local ai = {
        -- Store references to game objects
        wizard = wizard,
        gameState = gameState,
        
        -- Store personality
        personality = personalityModule,
        
        -- Track the opposing wizard (player's wizard)
        playerWizard = nil,
        
        -- Track last perception time for throttling
        lastPerceptionTime = 0,
        perceptionInterval = 2, -- Update perception every 2 seconds
        
        -- Track last action time for throttling
        lastActionTime = 0,
        actionInterval = 1.0, -- Consider actions every 1.0 seconds
        
        -- Simple finite state machine
        currentState = OpponentAI.STATE.IDLE, -- Initial state
        lastState = nil,           -- Previous state for transition detection
        stateChangeTime = 0,       -- When the last state change occurred
        
        -- Current decision and action
        currentDecision = nil,
        
        -- Perceived game state (updated periodically)
        perception = {
            selfHealth = 0,
            opponentHealth = 0,
            rangeState = Constants.RangeState.FAR,
            ownElevation = Constants.ElevationState.GROUNDED,
            opponentElevation = Constants.ElevationState.GROUNDED,
            availableTokens = {}, -- Count of each token type
            activeSlots = 0, -- Number of spell slots currently in use
            spellSlots = {}, -- Detailed information about own spell slots
            opponentSpellSlots = {}, -- Information about opponent spell slots
        },
        
        -- Debug output options
        debug = {
            printPerception = true, -- Set to false to disable perception debug output
            perceptionPrintInterval = 2.0, -- How often to print perception details (seconds)
            lastPerceptionPrintTime = 0,
        }
    }
    
    -- Set the metatable to use the OpponentAI methods
    setmetatable(ai, {__index = OpponentAI})
    
    -- Find the opposing wizard (player's wizard)
    for i, w in ipairs(gameState.wizards) do
        if w ~= wizard then
            ai.playerWizard = w
            break
        end
    end
    
    return ai
end

-- Main update method - called from main.lua's love.update
-- @param dt - Delta time from the game loop
function OpponentAI:update(dt)
    -- Update perception (throttled)
    if love.timer.getTime() - self.lastPerceptionTime > self.perceptionInterval then
        self:perceive()
        self.lastPerceptionTime = love.timer.getTime()
        
        -- Debug output (throttled separately)
        if self.debug.printPerception and love.timer.getTime() - self.debug.lastPerceptionPrintTime > self.debug.perceptionPrintInterval then
            self:printPerceptionDebug()
            self.debug.lastPerceptionPrintTime = love.timer.getTime()
        end
    end
    
    -- Make decisions and act (throttled)
    if love.timer.getTime() - self.lastActionTime > self.actionInterval then
        -- Store previous state for transition detection
        self.lastState = self.currentState
        
        -- Make a decision based on current perception
        local decision = self:decide()
        self.currentDecision = decision
        
        -- If state changed, log it and record the time
        if self.currentState ~= self.lastState then
            print(string.format("[AI] State transition: %s -> %s", 
                self.lastState, self.currentState))
            self.stateChangeTime = love.timer.getTime()
            
            -- Print the decision that led to the state change
            if decision and decision.type then
                print(string.format("[AI] New Action: %s (reason: %s)", 
                    decision.type, decision.reason or "unknown"))
            end
        end
        
        -- Execute the decided action
        self:act(decision)
        
        self.lastActionTime = love.timer.getTime()
    end
end

-- Observe the current game state and update perception
function OpponentAI:perceive()
    local p = self.perception -- shorthand for readability
    
    -- Check if game state and wizards still exist (safety check)
    if not self.gameState or not self.wizard or not self.playerWizard then
        print("ERROR: AI missing critical game references")
        return
    end
    
    -- Basic game state perception
    p.rangeState = self.gameState.rangeState
    
    -- Self wizard perception
    p.selfHealth = self.wizard.health
    p.ownElevation = self.wizard.elevation
    
    -- Opponent wizard perception
    p.opponentHealth = self.playerWizard.health
    p.opponentElevation = self.playerWizard.elevation
    
    -- Mana pool token counts
    p.availableTokens = {}
    
    -- Track counts for all token types
    for _, tokenType in ipairs(Constants.getAllTokenTypes()) do
        p.availableTokens[tokenType] = ManaHelpers.count(tokenType, self.gameState.manaPool)
    end
    
    -- Count total free tokens
    p.totalFreeTokens = 0
    for _, count in pairs(p.availableTokens) do
        p.totalFreeTokens = p.totalFreeTokens + count
    end
    
    -- Spell slot perception (own)
    p.spellSlots = {}
    p.activeSlots = 0
    
    for i, slot in ipairs(self.wizard.spellSlots) do
        p.spellSlots[i] = {
            active = slot.active,
            progress = slot.progress,
            castTime = slot.castTime,
            isShield = slot.isShield or false,
            willBecomeShield = slot.willBecomeShield or false,
            spellType = slot.spellType,
            frozen = slot.frozen or false,
            attackType = slot.attackType,
            tokenCount = slot.tokens and #slot.tokens or 0
        }
        
        if slot.active then
            p.activeSlots = p.activeSlots + 1
        end
    end
    
    -- Spell slot perception (opponent)
    p.opponentSpellSlots = {}
    p.opponentActiveSlots = 0
    
    for i, slot in ipairs(self.playerWizard.spellSlots) do
        p.opponentSpellSlots[i] = {
            active = slot.active,
            progress = slot.progress,
            castTime = slot.castTime,
            isShield = slot.isShield or false,
            spellType = slot.spellType,
            tokenCount = slot.tokens and #slot.tokens or 0
        }
        
        if slot.active then
            p.opponentActiveSlots = p.opponentActiveSlots + 1
        end
    end
    
    -- Can pay for basic token costs? (for decision making)
    p.canPayForSingleToken = {}
    for _, tokenType in ipairs(Constants.getAllTokenTypes()) do
        local canPay = self.wizard:canPayManaCost({tokenType}) ~= nil
        p.canPayForSingleToken[tokenType] = canPay
    end
    
    -- Calculate key derived states for decision making
    p.opponentLowHealth = p.opponentHealth < 30
    p.selfLowHealth = p.selfHealth < 30
    p.selfCriticalHealth = p.selfHealth < 15
    
    -- Calculate health advantage (positive = AI has more health)
    p.healthAdvantage = p.selfHealth - p.opponentHealth
    
    -- Check if opponent has dangerous spell in progress
    p.opponentHasDangerousSpell = false
    for _, slot in ipairs(p.opponentSpellSlots) do
        if slot.active and not slot.isShield and slot.progress > 0 then
            -- Simple heuristic: consider any active spell with progress "dangerous"
            p.opponentHasDangerousSpell = true
            break
        end
    end
    
    -- Check if we have any shield active
    p.hasActiveShield = false
    for _, slot in ipairs(p.spellSlots) do
        if slot.active and slot.isShield then
            p.hasActiveShield = true
            break
        end
    end
    
    return p
end

-- Print debug information about current perception
function OpponentAI:printPerceptionDebug()
    local p = self.perception
    print("=== AI PERCEPTION ===")
    print(string.format("PERSONALITY: %s", self.personality.name))
    print(string.format("HEALTH: Self=%d, Opponent=%d", p.selfHealth, p.opponentHealth))
    print(string.format("RANGE: %s, ELEVATION: Self=%s, Opp=%s", 
        p.rangeState, p.ownElevation, p.opponentElevation))
    
    -- Token counts
    local tokenInfo = "TOKENS: "
    for tokenType, count in pairs(p.availableTokens) do
        if count > 0 then
            tokenInfo = tokenInfo .. tokenType .. "=" .. count .. " "
        end
    end
    print(tokenInfo)
    
    -- Spell slot info (self)
    print("SPELL SLOTS:")
    for i, slot in ipairs(p.spellSlots) do
        if slot.active then
            print(string.format("  [%d] %s - Progress: %.1f/%.1f %s%s", 
                i, slot.spellType or "Unknown", 
                slot.progress, slot.castTime,
                slot.isShield and "[SHIELD]" or "",
                slot.frozen and "[FROZEN]" or ""))
        end
    end
    
    -- Opponent spell slots
    print("OPPONENT SLOTS:")
    for i, slot in ipairs(p.opponentSpellSlots) do
        if slot.active then
            print(string.format("  [%d] %s - Progress: %.1f/%.1f %s", 
                i, slot.spellType or "Unknown", 
                slot.progress, slot.castTime,
                slot.isShield and "[SHIELD]" or ""))
        end
    end
    
    -- Current AI state
    print("AI STATE: " .. self.currentState)
    if self.currentDecision then
        print("CURRENT ACTION: " .. (self.currentDecision.type or "None"))
    end
    print("===================")
end

-- Decide what to do based on current perception
function OpponentAI:decide()
    local p = self.perception
    local spellbook = self.wizard.spellbook
    
    -- Check if personality wants to override state selection
    local suggestedState = self.personality:suggestState(self, p)
    if suggestedState then
        self.currentState = suggestedState
    else
        -- Basic state transition logic based on health and threat
        
        -- Critical health - go into escape mode
        if p.selfCriticalHealth then
            self.currentState = OpponentAI.STATE.ESCAPE
        
        -- Low health - prioritize defense
        elseif p.selfLowHealth and not p.hasActiveShield then
            self.currentState = OpponentAI.STATE.DEFEND
        
        -- Opponent has very low health - press the advantage
        elseif p.opponentLowHealth then
            self.currentState = OpponentAI.STATE.ATTACK
        
        -- Opponent is casting something - consider countering
        elseif p.opponentHasDangerousSpell and p.totalFreeTokens >= 2 then
            self.currentState = OpponentAI.STATE.COUNTER
        
        -- If health advantage is significant and we're not in low health, attack
        elseif p.healthAdvantage > 15 and not p.selfLowHealth then
            self.currentState = OpponentAI.STATE.ATTACK
        
        -- If we're at a health disadvantage, consider defense
        elseif p.healthAdvantage < -15 and not p.hasActiveShield then
            self.currentState = OpponentAI.STATE.DEFEND
        
        -- If no tokens or very few tokens are available, focus on gaining resources
        elseif p.totalFreeTokens <= 1 then
            self.currentState = OpponentAI.STATE.IDLE
        
        -- Default state when no specific criteria are met - slight aggression bias
        else
            -- Slightly biased toward attacking when nothing else is going on
            local randomChoice = math.random(1, 10)
            
            if randomChoice <= 6 then -- 60% chance of attack
                self.currentState = OpponentAI.STATE.ATTACK
            elseif randomChoice <= 9 then -- 30% chance of defense
                self.currentState = OpponentAI.STATE.DEFEND
            else -- 10% chance of resource gathering
                self.currentState = OpponentAI.STATE.IDLE
            end
        end
    end
    
    -- State->Action mapping
    local spell = nil
    local actionType = nil
    local reason = nil
    
    -- Based on the current state, decide what specific spell to cast
    if self.currentState == OpponentAI.STATE.ATTACK then
        -- Ask personality module for attack spell
        spell = self.personality:getAttackSpell(self, p, spellbook)
        reason = "Attack"
        actionType = "ATTACK_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.DEFEND then
        -- Ask personality module for defense spell
        spell = self.personality:getDefenseSpell(self, p, spellbook)
        reason = "Defense"
        actionType = "DEFEND_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.COUNTER then
        -- Ask personality module for counter spell
        spell = self.personality:getCounterSpell(self, p, spellbook)
        reason = "Counter"
        actionType = "COUNTER_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.ESCAPE then
        -- Emergency defense: shield, escape, or free all (last resort)
        if p.activeSlots > 0 and p.totalFreeTokens < 1 then
            -- No resources, free all spell slots
            return {
                type = "FREE_ALL",
                reason = "Critical health - free resources"
            }
        end
        
        -- Ask personality module for escape spell
        spell = self.personality:getEscapeSpell(self, p, spellbook)
        reason = "Escape"
        actionType = "ESCAPE_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.POSITION then
        -- Ask personality module for positioning spell
        spell = self.personality:getPositioningSpell(self, p, spellbook)
        reason = "Positioning"
        actionType = "POSITION_ACTION"
    
    elseif self.currentState == OpponentAI.STATE.IDLE then
        -- Ask personality module for conjure/resource spell
        spell = self.personality:getConjureSpell(self, p, spellbook)
        reason = "Generate resources"
        actionType = "CONJURE_ACTION"
    end
    
    -- If we found a specific spell and have a slot for it, cast it
    if spell and self:hasAvailableSpellSlot() then
        -- Evaluate dynamic cost if provided
        local costToEvaluate
        if spell.getCost then
            costToEvaluate = spell.getCost(self.wizard, self.playerWizard)
        else
            costToEvaluate = spell.cost
        end

        local canAfford = self.wizard:canPayManaCost(costToEvaluate)
        if canAfford then
            return {
                type = "CAST_SPELL",
                spell = spell,
                reason = reason
            }
        end
    end
    
    -- Return the general action if no specific spell was found or affordable
    return {
        type = actionType,
        reason = reason .. " (no specific spell found or affordable)"
    }
end

-- Execute the decided action
function OpponentAI:act(decision)
    -- Safety check
    if not decision or not decision.type then
        print("[AI] No valid decision to act on")
        return
    end
    
    -- Log the action
    print("[AI Action] " .. decision.type)
    
    -- For conciseness
    local wizard = self.wizard
    
    -- Execute based on action type
    if decision.type == "WAIT_ACTION" then
        -- Do nothing (idle)
        print("[AI] Waiting...")
        
    elseif decision.type == "FREE_ALL" then
        -- Cancel all active spells
        print("[AI] Freeing all spells")
        wizard:freeAllSpells()
        
    elseif decision.type == "CAST_SPELL" and decision.spell then
        -- Direct spell casting (specified by higher-level logic)
        print("[AI] Casting specific spell: " .. decision.spell.name)
        local success = wizard:queueSpell(decision.spell)
        if not success then
            print("[AI] Failed to cast " .. decision.spell.name)
        end
    
    -- Generic action types - try to get a spell from personality as fallback
    elseif decision.type == "ATTACK_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.ATTACK, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting attack spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable attack spell found")
        end
        
    elseif decision.type == "DEFEND_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.DEFEND, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting defense spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable defense spell found")
        end
        
    elseif decision.type == "COUNTER_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.COUNTER, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting counter spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable counter spell found")
        end
        
    elseif decision.type == "ESCAPE_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.ESCAPE, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting escape spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable escape spell found")
        end
        
    elseif decision.type == "POSITION_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.POSITION, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting positioning spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable positioning spell found")
        end
        
    elseif decision.type == "CONJURE_ACTION" then
        local spell = self.personality:getBestSpellForIntent(OpponentAI.STATE.IDLE, self, self.perception, self.wizard.spellbook)
        if spell and self:hasAvailableSpellSlot() and self.wizard:canPayManaCost(spell.cost) then
            print("[AI] Fallback casting conjure spell: " .. spell.name)
            self.wizard:queueSpell(spell)
        else
            print("[AI] No suitable conjure spell found")
        end
    
    else
        print("[AI] Unknown action type: " .. decision.type)
    end
end

-- Helper function to check if a spell slot is available
function OpponentAI:hasAvailableSpellSlot()
    for _, slot in ipairs(self.wizard.spellSlots) do
        if not slot.active then
            return true
        end
    end
    return false
end

return OpponentAI```

## ./ai/PersonalityBase.lua
```lua
-- ai/PersonalityBase.lua
-- Interface for wizard AI personalities in Manastorm
-- Defines the contract for how personality modules interact with the OpponentAI system

local PersonalityBase = {}

-- Constructor for personality modules
-- @param name - A string identifier for the personality
function PersonalityBase.new(name)
    local personality = {
        name = name or "Generic",
        description = "Base personality module - meant to be extended"
    }
    
    -- Set metatable to use PersonalityBase methods
    setmetatable(personality, {__index = PersonalityBase})
    
    return personality
end

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getAttackSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best defensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getDefenseSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best counter spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getCounterSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best escape spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getEscapeSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best conjuration spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getConjureSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get the best positioning spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getPositioningSpell(ai, perception, spellbook)
    -- Base implementation returns nil - should be overridden by derived personalities
    return nil
end

-- Get best spell for a given intent/state when no specific spell was found
-- @param state - The AI state (from OpponentAI.STATE)
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function PersonalityBase:getBestSpellForIntent(state, ai, perception, spellbook)
    -- This is a fallback method for when more specific methods don't find a suitable spell
    -- Each personality can implement custom fallback logic
    
    -- Base implementation tries to match the state to a specific spell getter
    if state == "ATTACK" then
        return self:getAttackSpell(ai, perception, spellbook)
    elseif state == "DEFEND" then
        return self:getDefenseSpell(ai, perception, spellbook)
    elseif state == "COUNTER" then
        return self:getCounterSpell(ai, perception, spellbook)
    elseif state == "ESCAPE" then
        return self:getEscapeSpell(ai, perception, spellbook)
    elseif state == "IDLE" then
        return self:getConjureSpell(ai, perception, spellbook)
    elseif state == "POSITION" then
        return self:getPositioningSpell(ai, perception, spellbook)
    end
    
    return nil
end

-- Can be used to provide character-specific customizations to FSM state selection
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @return - A string state name or nil to use default state selection logic
function PersonalityBase:suggestState(ai, perception)
    -- Base implementation returns nil, letting the core AI decide
    -- Derived personalities can override this to customize state selection
    return nil
end

return PersonalityBase```

## ./ai/personalities/AshgarPersonality.lua
```lua
-- ai/personalities/AshgarPersonality.lua
-- AI personality module for Ashgar the Emberfist

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the AshgarPersonality module
local AshgarPersonality = PersonalityBase.new("Ashgar the Emberfist")

-- Ashgar's Spellbook:
-- "1": Conjure Fire (Conjure)
-- "2": Nova Conjuring (Resource Management/Setup)
-- "3": Firebolt (Attack)
-- "12": Battle Shield (Defense)
-- "13": Blast Wave (Attack - Zone, good vs NEAR)
-- "23": Emberlift (Positioning/Utility, Conjure Fire)
-- "123": Meteor (Attack - Aerial Finisher, requires AERIAL setup)

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Meteor (powerful aerial finisher) - if both conditions are met:
    -- 1. AI is in AERIAL state
    -- 2. Opponent is in GROUNDED state
    if p.ownElevation == Constants.ElevationState.AERIAL and 
       p.opponentElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["123"]) -- Meteor
    end
    
    -- Blast Wave (good at NEAR range)
    if p.rangeState == Constants.RangeState.NEAR and 
       p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["13"]) -- Blast Wave
    end
    
    -- Firebolt (basic attack, better at FAR range)
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["3"]) -- Firebolt 
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best defensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Battle Shield is Ashgar's primary defense
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() and not p.hasActiveShield then
        table.insert(spellsToTry, spellbook["12"]) -- Battle Shield
    end
    
    -- Emberlift can be used to escape by changing elevation
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() and 
       p.ownElevation == Constants.ElevationState.GROUNDED then
        table.insert(spellsToTry, spellbook["23"]) -- Emberlift
    end
    
    -- If we don't have enough tokens for a shield
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        -- Try to gain tokens
        table.insert(spellsToTry, spellbook["1"]) -- Conjure Fire
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best counter spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getCounterSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Ashgar doesn't have direct counter spells like Selene's Eclipse,
    -- but he can use Blast Wave to disrupt opponents at NEAR range
    -- or Emberlift to change position
    
    if p.opponentHasDangerousSpell then
        -- If near, use Blast Wave as a counter
        if p.rangeState == Constants.RangeState.NEAR and p.totalFreeTokens >= 2 then
            table.insert(spellsToTry, spellbook["13"]) -- Blast Wave
        end
        
        -- Use Emberlift to change position and potentially disrupt
        if p.totalFreeTokens >= 2 and p.ownElevation == Constants.ElevationState.GROUNDED then
            table.insert(spellsToTry, spellbook["23"]) -- Emberlift
        end
        
        -- Simple attack may also work as disruption
        if p.totalFreeTokens >= 1 then
            table.insert(spellsToTry, spellbook["3"]) -- Firebolt
        end
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    -- If no counter spell is available, fall back to a defensive option
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Get the best escape spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getEscapeSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- When in critical health
    
    -- First priority: Battle Shield if not already shielded
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["12"]) -- Battle Shield
    end
    
    -- Second priority: Emberlift to change elevation (if grounded)
    if p.ownElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["23"]) -- Emberlift
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best conjuration spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getConjureSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Try to use Nova Conjuring for more advanced resource generation
    -- when we already have some tokens
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["2"]) -- Nova Conjuring
    end
    
    -- Basic conjuration spell - always useful
    if ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["1"]) -- Conjure Fire
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best positioning spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function AshgarPersonality:getPositioningSpell(ai, perception, spellbook)
    local p = perception
    
    -- Emberlift is Ashgar's primary positioning spell
    -- Use it when grounded to gain aerial advantage
    if p.ownElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local posSpell = spellbook["23"] -- Emberlift
        
        if posSpell and ai.wizard:canPayManaCost(posSpell.cost) then
            return posSpell
        end
    end
    
    return nil
end

-- Suggest custom state based on Ashgar's special capabilities
function AshgarPersonality:suggestState(ai, perception)
    local p = perception
    
    -- Consider positioning to setup an aerial meteor attack
    if not p.selfCriticalHealth and -- not in emergency
       p.ownElevation == Constants.ElevationState.GROUNDED and
       p.totalFreeTokens >= 2 and 
       ai:hasAvailableSpellSlot() then
        
        -- 20% chance to try positioning for a meteor setup when conditions are good
        if math.random(1, 5) == 1 then
            return ai.STATE.POSITION
        end
    end
    
    -- Let the core AI decide in other cases
    return nil
end

return AshgarPersonality```

## ./ai/personalities/BorrakPersonality.lua
```lua
-- ai/personalities/BorrakPersonality.lua
-- AI personality module for Borrak, the water warlock

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")
local ManaHelpers = require("systems.ManaHelpers")

-- Define the BorrakPersonality module
local BorrakPersonality = PersonalityBase.new("Borrak")

-- Utility to randomly choose a spell from a list that the wizard can afford
local function chooseRandomAffordable(ai, spells)
    -- shuffle order for randomness
    for i = #spells, 2, -1 do
        local j = math.random(i)
        spells[i], spells[j] = spells[j], spells[i]
    end

    for _, spell in ipairs(spells) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    return nil
end

-- Get the best offensive spell for the current situation
function BorrakPersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local options = {}

    if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(options, spellbook["123"]) -- Wave Crash
    end
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(options, spellbook["23"]) -- Maelstrom
        table.insert(options, spellbook["13"]) -- Brine Chain
        table.insert(options, spellbook["12"]) -- Tidal Force
    end
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(options, spellbook["2"]) -- Water Gun
    end

    return chooseRandomAffordable(ai, options)
end

-- Get the best defensive spell for the current situation
function BorrakPersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local shield = spellbook["3"] -- Riptide Guard
        if shield and ai.wizard:canPayManaCost(shield.cost) then
            return shield
        end
    end
    return nil
end

-- Counters simply fall back to defensive options
function BorrakPersonality:getCounterSpell(ai, perception, spellbook)
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Escape behavior is also to put up a shield
function BorrakPersonality:getEscapeSpell(ai, perception, spellbook)
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Conjure Water whenever possible
function BorrakPersonality:getConjureSpell(ai, perception, spellbook)
    if ai:hasAvailableSpellSlot() then
        local spell = spellbook["1"] -- Conjure Water
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    return nil
end

-- Borrak generally has no special positioning logic
function BorrakPersonality:getPositioningSpell(ai, perception, spellbook)
    return nil
end

-- Suggest AI state based on Borrak's strategy
function BorrakPersonality:suggestState(ai, perception)
    local p = perception
    local waterCount = p.availableTokens[Constants.TokenType.WATER] or 0

    -- Focus on conjuring until we have at least 3 Water tokens
    if waterCount < 3 then
        return ai.STATE.IDLE
    end

    -- Maintain a shield if we don't have one
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        return ai.STATE.DEFEND
    end

    -- Alternate between attacking and conjuring
    if math.random() < 0.5 then
        return ai.STATE.ATTACK
    else
        return ai.STATE.IDLE
    end
end

return BorrakPersonality
```

## ./ai/personalities/SelenePersonality.lua
```lua
-- ai/personalities/SelenePersonality.lua
-- AI personality module for Selene of the Veil

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the SelenePersonality module
local SelenePersonality = PersonalityBase.new("Selene of the Veil")

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- CORE STRATEGY: 
    -- 1. Save up for Full Moon Beam
    -- 2. Try to queue Full Moon Beam in the middle slot
    -- 3. Use Eclipse to boost its damage
    
    -- Track what spells we already have active
    local fullMoonBeamActive = false
    local eclipseActive = false
    local moonDanceActive = false
    local gravityTrapActive = false
    local fullMoonBeamSlot = nil
    
    for i, slot in ipairs(p.spellSlots) do
        if slot.active then
            if slot.spellType == "fullmoonbeam" then
                fullMoonBeamActive = true
                fullMoonBeamSlot = i
            elseif slot.spellType == "eclipse" then
                eclipseActive = true
            elseif slot.spellType == "moondance" then
                moonDanceActive = true
            elseif slot.spellType == "gravityTrap" then
                gravityTrapActive = true
            end
        end
    end
    
    -- Check if we have enough resources for Full Moon Beam
    if p.totalFreeTokens >= 4 and not fullMoonBeamActive and ai:hasAvailableSpellSlot() then
        -- We have enough tokens for Full Moon Beam, prioritize it
        local fullMoonBeam = spellbook["123"] -- Full Moon Beam
        if fullMoonBeam and ai.wizard:canPayManaCost(fullMoonBeam.cost) then
            -- We're specifically looking for this, so prioritize it highly
            return fullMoonBeam
        end
    end
    
    -- If we have Full Moon Beam active, follow up with Eclipse to enhance it
    if fullMoonBeamActive and not eclipseActive and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local eclipse = spellbook["13"] -- Eclipse
        if eclipse and ai.wizard:canPayManaCost(eclipse.cost) then
            return eclipse
        end
    end
    
    -- If opponent is aerial, consider Gravity Trap
    if p.opponentElevation == Constants.ElevationState.AERIAL and p.totalFreeTokens >= 2 and 
       not gravityTrapActive and ai:hasAvailableSpellSlot() then
        local gravityTrap = spellbook["23"] -- gravityTrap
        if gravityTrap and ai.wizard:canPayManaCost(gravityTrap.cost) then
            table.insert(spellsToTry, gravityTrap)
        end
    end
    
    -- If we have a shield up and < 3 tokens, consider Moon Dance for chip damage
    if p.hasActiveShield and p.totalFreeTokens >= 1 and p.totalFreeTokens < 3 and 
       not moonDanceActive and ai:hasAvailableSpellSlot() then
        local moonDance = spellbook["3"] -- moondance
        if moonDance and ai.wizard:canPayManaCost(moonDance.cost) then
            table.insert(spellsToTry, moonDance)
        end
    end
    
    -- If we have 3+ tokens but can't do Full Moon Beam for some reason, try Eclipse
    if not eclipseActive and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        local eclipse = spellbook["13"] -- eclipse
        if eclipse and ai.wizard:canPayManaCost(eclipse.cost) then
            table.insert(spellsToTry, eclipse)
        end
    end
    
    -- Return the first affordable spell from our priority list
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best defensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    -- ENHANCED STRATEGY: Prioritize defense more - try to keep a shield up at all times
    -- Put up a shield whenever we don't have one and can afford it, not just when low health
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() and not p.hasActiveShield then
        -- Try shield spell (wrapinmoonlight) - Selene's primary advantage
        table.insert(spellsToTry, spellbook["2"]) -- wrapinmoonlight
    end

    -- Secondary options if shield isn't possible
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        -- If health is starting to get low, consider evasive maneuvers
        if p.selfHealth < 75 and not p.hasActiveShield then
            table.insert(spellsToTry, spellbook["3"]) -- moondance (position change for evasion)
        end

        -- Building resources is also defensive when we need tokens for shield
        if p.totalFreeTokens < 2 then
            table.insert(spellsToTry, spellbook["1"]) -- conjuremoonlight
        end
    end

    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best counter spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getCounterSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- Check if there's something to counter and we have enough resources
    if p.opponentHasDangerousSpell and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        -- For Selene, try using eclipse or moondance
        table.insert(spellsToTry, spellbook["13"]) -- eclipse (freezes crown slot)
        table.insert(spellsToTry, spellbook["3"])  -- moondance (can disrupt by changing range)
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    -- If no counter spell is available, fall back to a defensive option
    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Get the best escape spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getEscapeSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}
    
    -- When in critical health, try shield, range change, or free all slots
    
    -- First priority: shields if not already shielded
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["2"]) -- wrapinmoonlight
    end
    
    -- Second priority: change range/position
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["3"]) -- moondance
    end
    
    -- Return the first affordable spell
    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end
    
    return nil
end

-- Get the best conjuration spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getConjureSpell(ai, perception, spellbook)
    local p = perception
    
    -- Try conjuration spell if a slot is available
    if ai:hasAvailableSpellSlot() then
        local conjureSpell = spellbook["1"] -- conjuremoonlight
        
        if conjureSpell and ai.wizard:canPayManaCost(conjureSpell.cost) then
            return conjureSpell
        end
    end
    
    return nil
end

-- Get the best positioning spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SelenePersonality:getPositioningSpell(ai, perception, spellbook)
    local p = perception
    
    -- If at NEAR range, prioritize Moon Dance to get back to FAR
    if p.rangeState == Constants.RangeState.NEAR then
        local moonDance = spellbook["3"] -- moondance
        if moonDance and ai.wizard:canPayManaCost(moonDance.cost) and ai:hasAvailableSpellSlot() then
            return moonDance
        end
    end
    
    -- Default behavior - try to use moondance to change range if needed
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        local posSpell = spellbook["3"] -- moondance
        
        if posSpell and ai.wizard:canPayManaCost(posSpell.cost) then
            return posSpell
        end
    end
    
    return nil
end

-- Override suggestState to provide Selene-specific state suggestions
function SelenePersonality:suggestState(ai, perception)
    local p = perception
    
    -- If at NEAR range, prioritize positioning to get back to FAR
    if p.rangeState == Constants.RangeState.NEAR and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        -- 80% chance to prioritize positioning when at NEAR range
        if math.random() < 0.5 then
            return ai.STATE.POSITION
        end
    end
    
    -- NEW CORE STRATEGY: Focus on resource accumulation for Full Moon Beam + Eclipse combo
    -- If we have a shield up and 3+ tokens, focus on attacking to try our combo
    if p.hasActiveShield and p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        -- With a shield up and enough tokens, we should try our combo
        return ai.STATE.ATTACK
    end
    
    -- If we have a lot of tokens, prioritize attacking to use them
    if p.totalFreeTokens >= 4 and ai:hasAvailableSpellSlot() then
        -- We have enough tokens for our most powerful spells
        return ai.STATE.ATTACK
    end
    
    -- ENHANCED STRATEGY: More proactive shield usage
    -- Prioritize defense if we don't have a shield and have enough resources
    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        -- 70% chance to prioritize defense when we don't have a shield (increased from 60%)
        if math.random() < 0.7 then
            return ai.STATE.DEFEND
        end
    end
    
    -- ENHANCED STRATEGY: Resource accumulation when we have a shield but not enough tokens
    -- If we have a shield but less than 3 tokens, focus on resource gathering
    if p.hasActiveShield and p.totalFreeTokens < 3 then
        -- 70% chance to focus on resource gathering when we have a shield but few tokens
        if math.random() < 0.7 then
            return ai.STATE.IDLE
        end
    end
    
    -- ENHANCED STRATEGY: Prioritize Counter when opponent is casting
    -- If opponent is casting and we have enough tokens, counter them
    if p.opponentHasDangerousSpell and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        -- 80% chance to try countering dangerous spells
        if math.random() < 0.8 then
            return ai.STATE.COUNTER
        end
    end
    
    -- Let the default AI logic handle other cases
    return nil
end

return SelenePersonality```

## ./ai/personalities/SilexPersonality.lua
```lua
-- ai/personalities/SilexPersonality.lua
-- AI personality module for Silex, the salt mage

local Constants = require("core.Constants")
local PersonalityBase = require("ai.PersonalityBase")

-- Define the SilexPersonality module
local SilexPersonality = PersonalityBase.new("Silex")

-- Get the best offensive spell for the current situation
-- @param ai - The OpponentAI instance
-- @param perception - The current perception data
-- @param spellbook - The wizard's spellbook
-- @return - A spell object or nil if no suitable spell found
function SilexPersonality:getAttackSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    -- Big area damage when we have plenty of tokens
    if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["123"]) -- Salt Storm
    end

    -- Use Shield Breaker to punish opponents hiding behind shields
    if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["23"]) -- Shield Breaker
    end

    -- Trap the opponent to maintain advantage
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["3"]) -- Imprison
    end

    -- Quick poke
    if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["2"]) -- Glitter Fang
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best defensive spell for the current situation
function SilexPersonality:getDefenseSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    -- Always try to keep a Salt Circle up
    if not p.hasActiveShield and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["12"]) -- Salt Circle
    end

    -- Add Stone Shield as backup protection
    if p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["13"]) -- Stone Shield
    end

    -- Build resources if we can't shield
    if p.totalFreeTokens == 0 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["1"]) -- Conjure Salt
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best counter spell for the current situation
function SilexPersonality:getCounterSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    if p.opponentHasDangerousSpell then
        -- Put up Salt Circle to ward off incoming spells
        if p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
            table.insert(spellsToTry, spellbook["12"]) -- Salt Circle
        end
        -- Try to break the spell with Shield Breaker
        if p.totalFreeTokens >= 3 and ai:hasAvailableSpellSlot() then
            table.insert(spellsToTry, spellbook["23"]) -- Shield Breaker
        end
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return self:getDefenseSpell(ai, perception, spellbook)
end

-- Get the best escape spell for the current situation
function SilexPersonality:getEscapeSpell(ai, perception, spellbook)
    local p = perception
    local spellsToTry = {}

    if not p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["13"]) -- Stone Shield
    end

    if not p.hasActiveShield and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        table.insert(spellsToTry, spellbook["12"]) -- Salt Circle
    end

    for _, spell in ipairs(spellsToTry) do
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Get the best conjuration spell for the current situation
function SilexPersonality:getConjureSpell(ai, perception, spellbook)
    print("Silex:getConjureSpell")
    if ai:hasAvailableSpellSlot() then
        local spell = spellbook["1"] -- Conjure Salt
        if spell and ai.wizard:canPayManaCost(spell.cost) then
            return spell
        end
    end

    return nil
end

-- Positioning is not a focus for Silex
function SilexPersonality:getPositioningSpell(ai, perception, spellbook)
    return nil
end

-- Suggest AI state based on Silex's strategy
function SilexPersonality:suggestState(ai, perception)
    local p = perception

    -- Prioritize keeping a shield up
    if not p.hasActiveShield and p.totalFreeTokens >= 1 and ai:hasAvailableSpellSlot() then
        return ai.STATE.DEFEND
    end

    -- If shielded and have resources, press the attack
    if p.hasActiveShield and p.totalFreeTokens >= 2 and ai:hasAvailableSpellSlot() then
        return ai.STATE.ATTACK
    end

    -- Build resources when low
    if p.totalFreeTokens == 0 and ai:hasAvailableSpellSlot() then
        return ai.STATE.IDLE
    end

    return nil
end

return SilexPersonality
```

## ./characterData.lua
```lua
-- characterData.lua
-- Defines color and spellbook data for each playable character

local SpellsModule = require("spells")
local Spells = SpellsModule.spells

local characterData = {}

characterData.Ashgar = {
    color = {255,100,100},
    spellbook = {
        ["1"]  = Spells.conjurefire,
        ["2"]  = Spells.firebolt,
        ["3"]  = Spells.fireball,
        ["12"] = Spells.burnToAsh,
        ["13"] = Spells.blastwave,
        ["23"] = Spells.saltcircle,
        ["123"] = Spells.eruption,
    },
    spells = {
        Spells.conjurefire,
        Spells.firebolt,
        Spells.fireball,
        Spells.burnToAsh,
        Spells.blastwave,
        Spells.saltcircle,
        Spells.eruption,
        Spells.combustMana,
        Spells.blazingAscent,
        Spells.desperationFire,
    },
    campaignOpponents = {"Selene", "Silex", "Borrak"}
}

characterData.Selene = {
    color = {100,100,255},
    spellbook = {
        ["1"]  = Spells.conjuremoonlight,
        ["2"]  = Spells.wrapinmoonlight,
        ["3"]  = Spells.moondance,
        ["12"] = Spells.infiniteprocession,
        ["13"] = Spells.eclipse,
        ["23"] = Spells.gravityTrap,
        ["123"] = Spells.fullmoonbeam,
    },
    spells = {
        Spells.conjuremoonlight,
        Spells.wrapinmoonlight,
        Spells.moondance,
        Spells.infiniteprocession,
        Spells.eclipse,
        Spells.gravityTrap,
        Spells.fullmoonbeam,
        Spells.lunardisjunction,
        Spells.lunarTides,
        Spells.moonDrain,
    },
    campaignOpponents = {"Ashgar", "Borrak", "Silex"}
}

characterData.Silex = {
    color = {200,200,200},
    spellbook = {
        ["1"]  = Spells.conjuresalt,
        ["2"]  = Spells.glitterfang,
        ["3"]  = Spells.imprison,
        ["12"] = Spells.saltcircle,
        ["13"] = Spells.stoneshield,
        ["23"] = Spells.shieldbreaker,
        ["123"] = Spells.saltstorm,
    },
    spells = {
        Spells.conjuresalt,
        Spells.glitterfang,
        Spells.imprison,
        Spells.saltcircle,
        Spells.stoneshield,
        Spells.shieldbreaker,
        Spells.saltstorm,
        Spells.jaggedearth,
    }
}

characterData.Borrak = {
    color = {100,180,255},
    spellbook = {
        ["1"]  = Spells.conjurewater,
        ["2"]  = Spells.watergun,
        ["3"]  = Spells.riptideguard,
        ["12"] = Spells.tidalforce,
        ["13"] = Spells.brinechain,
        ["23"] = Spells.maelstrom,
        ["123"] = Spells.wavecrash,
    },
    spells = {
        Spells.conjurewater,
        Spells.watergun,
        Spells.riptideguard,
        Spells.tidalforce,
        Spells.brinechain,
        Spells.maelstrom,
        Spells.wavecrash,
        Spells.forceBlast,
    }
}

characterData.Brightwulf = {
    color = {255,100,100},
    spellbook = {
        ["1"]  = Spells.burnTheSoul,
        ["2"]  = Spells.SpaceRipper,
        ["3"]  = Spells.StingingEyes,
        ["12"] = Spells.emberlift,
        ["13"] = Spells.meteor,
        ["23"] = Spells.fusionRay,
        ["123"] = Spells.CoreBolt,
    },
    spells = {
        Spells.burnTheSoul,
        Spells.SpaceRipper,
        Spells.StingingEyes,
        Spells.emberlift,
        Spells.meteor,
        Spells.fusionRay,
        Spells.CoreBolt,
    }
}

-- Placeholder spellbooks for other characters, defaulting to Ashgar's spells
local defaultSpellbook = characterData.Ashgar.spellbook
local defaultColor = {255,255,255}

local roster = {"Klaus","Ohm","Archive","End"}
for _, name in ipairs(roster) do
    characterData[name] = {
        color = defaultColor,
        spellbook = defaultSpellbook,
    }
end

return characterData
```

## ./conf.lua
```lua
-- Configuration
function love.conf(t)
    t.title = "Manastorm - The Ninefold Circle"  -- The title of the window
    t.version = "11.4"                    -- The LÖVE version this game was made for
    
    -- Base design resolution
    t.window.width = 800
    t.window.height = 600
    
    -- Allow high DPI mode on supported displays (macOS, etc)
    t.window.highdpi = true
    
    -- Make window resizable
    t.window.resizable = true
    
    -- Graphics settings
    t.window.vsync = 1                    -- Vertical sync (1 = enabled)
    t.window.msaa = 0                     -- Disable anti-aliasing to keep pixel art crisp
    
    -- For debugging
    t.console = true
    
    -- Disable unused modules
    -- Enable joystick module for gamepad input
    t.modules.joystick = true
    t.modules.physics = false
end```

## ./core/AssetCache.lua
```lua
-- AssetCache.lua
-- Centralized cache for game assets to prevent duplicate loads
-- All image and sound loading should go through this module

local AssetCache = {}

-- Create weak tables for storing loaded assets
-- Using weak keys allows unused assets to be garbage collected
local imageCache = setmetatable({}, {__mode = "v"})
local soundCache = setmetatable({}, {__mode = "v"})

-- Cache hit counters for metrics
local stats = {
    imageHits = 0,
    imageMisses = 0,
    soundHits = 0,
    soundMisses = 0
}

-- Get an image, loading it only once
function AssetCache.getImage(path)
    if not path then
        print("ERROR: AssetCache.getImage called with nil path")
        return nil
    end
    
    if imageCache[path] then
        stats.imageHits = stats.imageHits + 1
        return imageCache[path]
    end
    
    stats.imageMisses = stats.imageMisses + 1
    
    local success, result = pcall(function()
        return love.graphics.newImage(path)
    end)
    
    if not success then
        print("ERROR: Failed to load image: " .. path .. " - " .. tostring(result))
        return nil
    end
    
    imageCache[path] = result
    return result
end

-- Get a sound, loading it only once
function AssetCache.getSound(path, soundType)
    if not path then
        print("ERROR: AssetCache.getSound called with nil path")
        return nil
    end
    
    soundType = soundType or "static" -- Default to static for effects
    
    if soundCache[path] then
        stats.soundHits = stats.soundHits + 1
        return soundCache[path]
    end
    
    stats.soundMisses = stats.soundMisses + 1
    
    local success, result = pcall(function()
        return love.audio.newSource(path, soundType)
    end)
    
    if not success then
        print("ERROR: Failed to load sound: " .. path .. " - " .. tostring(result))
        return nil
    end
    
    soundCache[path] = result
    return result
end

-- Check if a file exists
local function fileExists(path)
    local success = pcall(function()
        return love.filesystem.getInfo(path) ~= nil
    end)
    return success and love.filesystem.getInfo(path) ~= nil
end

-- Preload a collection of assets (useful at startup)
function AssetCache.preload(assets)
    local loaded = {images = 0, sounds = 0}
    local failed = {images = 0, sounds = 0}
    
    for type, paths in pairs(assets) do
        if type == "images" then
            for _, path in ipairs(paths) do
                if fileExists(path) then
                    local success, _ = pcall(function()
                        AssetCache.getImage(path)
                    end)
                    if success then
                        loaded.images = loaded.images + 1
                    else
                        failed.images = failed.images + 1
                        print("Failed to load image: " .. path)
                    end
                else
                    failed.images = failed.images + 1
                    print("Image file not found: " .. path)
                end
            end
        elseif type == "sounds" then
            for _, data in ipairs(paths) do
                local path, soundType = data[1], data[2]
                if fileExists(path) then
                    local success, _ = pcall(function()
                        AssetCache.getSound(path, soundType)
                    end)
                    if success then
                        loaded.sounds = loaded.sounds + 1
                    else
                        failed.sounds = failed.sounds + 1
                        print("Failed to load sound: " .. path)
                    end
                else
                    failed.sounds = failed.sounds + 1
                    print("Sound file not found: " .. path)
                end
            end
        end
    end
    
    if failed.images > 0 or failed.sounds > 0 then
        print(string.format("AssetCache: Loaded %d images, %d sounds. Failed: %d images, %d sounds", 
                           loaded.images, loaded.sounds, failed.images, failed.sounds))
    end
    
    return loaded
end

-- Flush the cache (useful for dev hot-reload)
function AssetCache.flush()
    for k in pairs(imageCache) do
        imageCache[k] = nil
    end
    for k in pairs(soundCache) do
        soundCache[k] = nil
    end
    
    -- Reset stats
    stats.imageHits = 0
    stats.imageMisses = 0
    stats.soundHits = 0
    stats.soundMisses = 0
end

-- Helper function to count table items (for weak tables)
local function countTableItems(t)
    local count = 0
    for _ in pairs(t) do 
        count = count + 1 
    end
    return count
end

-- Get cache statistics for debug overlay
function AssetCache.dumpStats()
    return {
        images = {
            loaded = countTableItems(imageCache),
            hits = stats.imageHits,
            misses = stats.imageMisses
        },
        sounds = {
            loaded = countTableItems(soundCache),
            hits = stats.soundHits,
            misses = stats.soundMisses
        }
    }
end

return AssetCache```

## ./core/Constants.lua
```lua
-- core/Constants.lua
-- Centralized constants for Manastorm
-- Replaces string literals with structured tables for better typesafety and autocomplete

local Constants = {}

-- Token types (mana/resource types)
Constants.TokenType = {
    FIRE = "fire",
    WATER = "water",
    SALT = "salt",
    SUN = "sun",
    MOON = "moon",
    STAR = "star",
    LIFE = "life",
    MIND = "mind",
    VOID = "void",
    RANDOM = "random",   -- Special: used in spell costs to indicate any token
    ANY = "any"          -- Special: used in keywords for wildcard matching
}

-- Token states in the mana pool
Constants.TokenState = {
    FREE = "FREE",             -- Available in the pool
    CHANNELED = "CHANNELED",   -- Being used in a spell slot
    SHIELDING = "SHIELDING",   -- Being used for a shield spell
    LOCKED = "LOCKED",         -- Temporarily unavailable
    DESTROYED = "DESTROYED"    -- Removed from play (legacy state for backwards compatibility)
}

-- Token status in the lifecycle state machine
Constants.TokenStatus = {
    FREE = "FREE",             -- Available in the pool
    CHANNELED = "CHANNELED",   -- Being used in a spell slot
    SHIELDING = "SHIELDING",   -- Being used for a shield spell
    LOCKED = "LOCKED",         -- Temporarily unavailable
    APPEARING = "APPEARING",   -- Animating into existence from wizard to pool (transition state)
    RETURNING = "RETURNING",   -- Animating back to pool center (transition state)
    ORBITING = "ORBITING",     -- Animating from pool center to orbit (transition state)
    DISSOLVING = "DISSOLVING", -- Animating destruction (transition state)
    POOLED = "POOLED"          -- Released to the object pool
}

-- Visual constants for tokens
Constants.TokenVisuals = {
    -- Scale applied when a token is placed in a spell slot
    CHANNELED_SCALE = 1.0
}

-- Range positioning between wizards
Constants.RangeState = {
    NEAR = "NEAR",
    FAR = "FAR"
}

-- Elevation positioning of wizards
Constants.ElevationState = {
    GROUNDED = "GROUNDED",
    AERIAL = "AERIAL"
}

-- Color Palette (RGBA, 0-1 range)
-- Constants.Color = {
--     BLACK = {0, 0, 0, 1},                    -- #000000
--     MAROON = {0.592, 0.184, 0.278, 1},       -- #972f47
--     FOREST = {0.482, 0.620, 0.145, 1},       -- #7b9e25
--     OCEAN = {0.282, 0.184, 0.745, 1},        -- #482fbe
--     SMOKE = {0.557, 0.475, 0.420, 1},        -- #8e796b
--     CRIMSON = {0.906, 0.122, 0.231, 1},      -- #e71f3b
--     LIME = {0.651, 0.871, 0, 1},             -- #a6de00
--     SKY = {0.365, 0.459, 0.745, 1},          -- #5d75be
--     SAND = {0.906, 0.722, 0.427, 1},         -- #e7b86d
--     OCHRE = {0.847, 0.349, 0.024, 1},        -- #d85906
--     ORANGE = {0.984, 0.675, 0.043, 1},       -- #fbac0b
--     PUCE = {0.851, 0.502, 0.494, 1},         -- #d9807e
--     BONE = {0.906, 0.890, 0.745, 1},         -- #e7e3be
--     YELLOW = {0.984, 0.941, 0.024, 1},       -- #fbf006
--     MINT = {0.502, 0.953, 0.561, 1},         -- #80f38f
--     PINK = {1, 0.820, 1, 1}                  -- #ffd1ff
-- }

Constants.Color = {
    BLACK          = {0.000, 0.000, 0.000, 1}, -- #000000
    VOID           = {0.102, 0.043, 0.118, 1}, -- #1a0b1e
    GRAY           = {0.620, 0.620, 0.620, 1}, -- #9e9e9e
    WHITE          = {1.000, 1.000, 1.000, 1}, -- #ffffff
    RED_HERO       = {1.000, 0.290, 0.141, 1}, -- #ff4a24
    RED_SHADE      = {0.765, 0.212, 0.094, 1}, -- #c33618
    GREEN_HERO     = {0.651, 0.871, 0.000, 1}, -- #a6de00
    GREEN_SHADE    = {0.275, 0.400, 0.000, 1}, -- #466600
    BLUE_HERO      = {0.000, 0.573, 0.875, 1}, -- #0092df
    BLUE_SHADE     = {0.000, 0.322, 0.600, 1}, -- #005299
    YELLOW_HERO    = {1.000, 0.843, 0.000, 1}, -- #ffd700
    YELLOW_SHADE   = {0.784, 0.651, 0.000, 1}, -- #c8a600
    LAVENDER_HERO  = {0.788, 0.722, 1.000, 1}, -- #c9b8ff
    LAVENDER_SHADE = {0.478, 0.424, 0.769, 1}, -- #7a6cc4
    PURPLE_HERO    = {0.353, 0.204, 0.769, 1}, -- #5a34c4
    MAGENTA_HERO   = {0.820, 0.145, 0.659, 1}, -- #d125a8
}

-- Default color for unknown types
Constants.Color.DEFAULT = Constants.Color.SMOKE

-- Helper function to get color based on token type
-- Added mappings for types found in manapool.lua (Nature, Force)
function Constants.getColorForTokenType(tokenType)
    if tokenType == Constants.TokenType.FIRE then return Constants.Color.RED_HERO
    elseif tokenType == Constants.TokenType.WATER then return Constants.Color.BLUE_HERO
    elseif tokenType == Constants.TokenType.SALT then return Constants.Color.GRAY
    elseif tokenType == Constants.TokenType.SUN then return Constants.Color.YELLOW_HERO
    elseif tokenType == Constants.TokenType.MOON then return Constants.Color.LAVENDER_HERO
    elseif tokenType == Constants.TokenType.STAR then return Constants.Color.YELLOW_HERO
    elseif tokenType == Constants.TokenType.LIFE then return Constants.Color.GREEN_HERO
    elseif tokenType == Constants.TokenType.MIND then return Constants.Color.MAGENTA_HERO
    elseif tokenType == Constants.TokenType.VOID then return Constants.Color.WHITE
    else
        print("Warning: Unknown token type for color lookup: " .. tostring(tokenType))
        return Constants.Color.DEFAULT
    end
end

-- Shield types for blocking spells
Constants.ShieldType = {
    BARRIER = "barrier",    -- Physical barrier (blocks projectiles)
    WARD = "ward",          -- Magical ward (blocks remote spells)
    FIELD = "field"         -- Magical field (flexible defense)
}

-- Attack types for spells
-- This makes the overall palette: Projectiles, Beams, and Blasts beat nothing, Remotes beat Barriers, Zones beat Wards.
Constants.AttackType = {
    PROJECTILE = "projectile",  -- Magic flies toward a target, blocked by all shield types but efficient
    REMOTE = "remote",          -- Magic directly affects target, beats Barriers, expensive or slow
    ZONE = "zone",              -- Magic affects a physical area, beats Wards, position-dependent
    UTILITY = "utility"         -- Non-damaging effect, can't be blocked
}

Constants.VisualShape = {
    BOLT = "bolt",
    BEAM = "beam",
    BLAST = "blast",
    ZAP = "zap",
    CONE = "cone",
    REMOTE = "remote",
    METEOR = "meteor",
    CONJURE_BASE = "conjure",
    SURGE = "surge",
    AURA = "aura",
    VORTEX = "vortex",
    TORNADO = "tornado",
    WAVE = "wave",
}

local function buildCastSpeedSet(oneTier)
    return {
        ONE_TIER = oneTier,
        VERY_SLOW = oneTier * 5,
        SLOW = oneTier * 4,
        NORMAL = oneTier * 3,
        FAST = oneTier * 2,
        VERY_FAST = oneTier
    }
end

Constants.CastSpeedSets = {
    FAST = buildCastSpeedSet(3),
    SLOW = buildCastSpeedSet(5)
}

Constants.CastSpeed = Constants.CastSpeedSets.FAST

function Constants.setCastSpeedSet(name)
    if Constants.CastSpeedSets[name] then
        Constants.CastSpeed = Constants.CastSpeedSets[name]
    end
end

-- Target types for keywords
Constants.TargetType = {
    -- Simple targeting - used in spell definitions
    SELF = "SELF",             -- Target the caster
    ENEMY = "ENEMY",           -- Target the opponent
    ALL = "ALL",               -- Target all wizards
    
    -- Complex targeting - used in keyword behaviors
    SLOT_SELF = "SLOT_SELF",     -- Target caster's spell slots
    SLOT_ENEMY = "SLOT_ENEMY",   -- Target opponent's spell slots
    POOL_SELF = "POOL_SELF",     -- Affect mana pool from caster's perspective
    POOL_ENEMY = "POOL_ENEMY",   -- Affect mana pool from opponent's perspective
    
    -- Legacy targeting (lowercase) - should be migrated to uppercase
    CASTER = "caster",         -- The casting wizard
    TARGET = "target"          -- The targeted wizard
}

-- Damage types for spells
Constants.DamageType = {
    FIRE = "fire",
    WATER = "water",
    SALT = "salt",
    SUN = "sun",
    MOON = "moon",
    STAR = "star",
    LIFE = "life",
    MIND = "mind",
    VOID = "void",
    GENERIC = "generic",
    MIXED = "mixed"
}

-- Player sides in battle
Constants.PlayerSide = {
    PLAYER = "PLAYER",
    OPPONENT = "OPPONENT",
    NEUTRAL = "NEUTRAL"
}

-- Status effect types applied to wizards
Constants.StatusType = {
    BURN = "burn",       -- Damage over time
    SLOW = "slow",       -- Increases next cast time
    STUN = "stun",       -- Prevents actions
    REFLECT = "reflect"  -- Reflects incoming spells
}

-- Helper functions for dynamic string generation
-- E.g., replaces patterns like "POOL_" .. side with Constants.poolSide(side)

-- Generate pool target based on side
function Constants.poolSide(side)
    if side == Constants.TargetType.SELF then
        return Constants.TargetType.POOL_SELF
    elseif side == Constants.TargetType.ENEMY then
        return Constants.TargetType.POOL_ENEMY
    else
        return nil
    end
end

-- Generate slot target based on side
function Constants.slotSide(side)
    if side == Constants.TargetType.SELF then
        return Constants.TargetType.SLOT_SELF
    elseif side == Constants.TargetType.ENEMY then
        return Constants.TargetType.SLOT_ENEMY
    else
        return nil
    end
end

-- Utility function to get all token types (excluding special types)
function Constants.getAllTokenTypes()
    return {
        Constants.TokenType.FIRE,
        Constants.TokenType.WATER,
        Constants.TokenType.SALT,
        Constants.TokenType.SUN,
        Constants.TokenType.MOON,
        Constants.TokenType.STAR,
        Constants.TokenType.LIFE,
        Constants.TokenType.MIND,
        Constants.TokenType.VOID
    }
end

-- Utility function to get all shield types
function Constants.getAllShieldTypes()
    return {
        Constants.ShieldType.BARRIER,
        Constants.ShieldType.WARD,
        Constants.ShieldType.FIELD
    }
end

-- Utility function to get all attack types
function Constants.getAllAttackTypes()
    return {
        Constants.AttackType.PROJECTILE,
        Constants.AttackType.REMOTE,
        Constants.AttackType.ZONE,
        Constants.AttackType.UTILITY
    }
end
-- Spell metadata field names for consistent reference
Constants.SpellMetadata = {
    ID = "id",
    NAME = "name",
    AFFINITY = "affinity",
    DESCRIPTION = "description",
    ATTACK_TYPE = "attackType",
    CAST_TIME = "castTime",
    COST = "cost",
    KEYWORDS = "keywords",
    VISUAL_SHAPE = "visualShape",
    VFX = "vfx",
    SFX = "sfx",
    ZONE = "zone"
}

-- Utility function to get all spell metadata field names
function Constants.getAllSpellMetadataFields()
    local fields = {}
    for _, value in pairs(Constants.SpellMetadata) do
        table.insert(fields, value)
    end
    return fields
end

-- Keyword metadata field names for consistent reference
Constants.KeywordMetadata = {
    BEHAVIOR = "behavior",
    EXECUTE = "execute",
    TARGET_TYPE = "targetType",
    CATEGORY = "category",
    PARAMS = "params",
    ENABLED = "enabled",
    VALUE = "value"
}

-- Utility function to get all keyword metadata field names
function Constants.getAllKeywordMetadataFields()
    local fields = {}
    for _, value in pairs(Constants.KeywordMetadata) do
        table.insert(fields, value)
    end
    return fields
end

-- Event metadata field names for consistent reference
Constants.EventMetadata = {
    TYPE = "type",
    SOURCE = "source",
    TARGET = "target",
    AMOUNT = "amount",
    DAMAGE_TYPE = "damageType",
    TOKEN_TYPE = "tokenType",
    DURATION = "duration",
    POSITION = "position",
    ELEVATION = "elevation",
    SLOT_INDEX = "slotIndex",
    VFX = "vfx",
    SFX = "sfx",
    AFFINITY = "affinity",
    ATTACK_TYPE = "attackType",
    TAGS = "tags"
}

-- Utility function to get all event metadata field names
function Constants.getAllEventMetadataFields()
    local fields = {}
    for _, value in pairs(Constants.EventMetadata) do
        table.insert(fields, value)
    end
    return fields
end

-- Visual effect types for consistent usage across the codebase
Constants.VFXType = {
    -- General effects
    IMPACT = "impact",
    
    -- Base template effects (used by VisualResolver)
    PROJ_BASE = "proj_base",       -- Base projectile effect
    BOLT_BASE = "bolt_base",       -- Base bolt effect
    ZAP_BASE = "zap_base",        -- Base zap lightning effect
    ORB_BASE = "orb_base",         -- Base orb effect (lobbed arc projectile)
    BEAM_BASE = "beam_base",       -- Base beam effect
    REMOTE_BASE = "remote_base",   -- Base remote effect (explosion/flash)
    WARP_BASE = "warp_base",       -- Base warp effect (reality distortion)
    ZONE_BASE = "zone_base",       -- Base zone/area effect
    BLAST_BASE = "blast_base",     -- Base conical blast effect
    UTIL_BASE = "util_base",       -- Base utility effect
    SURGE_BASE = "surge_base",      -- Base surge fountain effect
    WAVE_BASE = "wave_base",       -- Base flowing wave effect
    CONJURE_BASE = "conjure_base", -- Base token conjuration effect
    IMPACT_BASE = "impact_base",   -- Base impact effect
    
    -- Overlay addon effects (used by VisualResolver)
    DAMAGE_OVERLAY = "damage_overlay",
    EMBER_OVERLAY = "ember_overlay",
    DOT_OVERLAY = "dot_overlay",
    SPARKLE_OVERLAY = "sparkle_overlay",
    RESOURCE_OVERLAY = "resource_overlay",
    MOVEMENT_OVERLAY = "movement_overlay",
    RISE_OVERLAY = "rise_overlay",
    FALL_OVERLAY = "fall_overlay",
    SHIELD_OVERLAY = "shield_overlay",
    BARRIER_OVERLAY = "barrier_overlay",
    
    -- Movement and positioning effects
    TIDAL_FORCE_GROUND = "tidal_force_ground",
    GRAVITY_PIN_GROUND = "gravity_pin_ground",
    GRAVITY_TRAP_SET = "gravity_trap_set",
    FORCE_BLAST = "force_blast",
    
    -- Special fire effects
    FORCE_BLAST_UP = "force_blast_up",
    ELEVATION_UP = "elevation_up",
    ELEVATION_DOWN = "elevation_down",
    RANGE_CHANGE = "range_change",
    FORCE_POSITION = "force_position",
    
    -- Resource effects
    FREE_MANA = "free_mana",
    TOKEN_LOCK = "token_lock",
    TOKEN_SHIFT = "token_shift",
    TOKEN_CONSUME = "token_consume",
    
    -- Projectile spells
    FIREBOLT = "firebolt",
    METEOR = "meteor",
    TIDAL_FORCE = "tidal_force",
    LUNARDISJUNCTION = "lunardisjunction",
    
    -- Area/zone effects
    MISTVEIL = "mistveil",
    EMBERLIFT = "emberlift",
    FULLMOONBEAM = "fullmoonbeam",
    DISJOINT_CANCEL = "disjoint_cancel",
    
    -- Conjuration effects
    CONJUREFIRE = "conjurefire",
    CONJUREMOONLIGHT = "conjuremoonlight",
    FORCE_CONJURE = "force_conjure",
    STAR_CONJURE = "star_conjure",
    VOLATILECONJURING = "volatileconjuring",
    NOVA_CONJURE = "nova_conjure",
    WITCH_CONJURE = "witch_conjure",
    
    -- Defense effects
    SHIELD = "shield",
    REFLECT = "reflect",
    
    -- Spell timing effects
    SPELL_ACCELERATE = "spell_accelerate",
    SPELL_CANCEL = "spell_cancel",
    SPELL_FREEZE = "spell_freeze",
    SPELL_ECHO = "spell_echo"
}

-- Utility function to get all VFX types
function Constants.getAllVFXTypes()
    local types = {}
    for _, value in pairs(Constants.VFXType) do
        table.insert(types, value)
    end
    return types
end

-- Utility function to check if a value exists in VFXType
function Constants.isValidVFXType(value)
    for _, v in pairs(Constants.VFXType) do
        if v == value then
            return true
        end
    end
    return false
end

-- Abstract game actions for input mapping
Constants.ControlAction = {
    -- Player 1 actions
    P1_SLOT1 = "p1_slot1",
    P1_SLOT2 = "p1_slot2",
    P1_SLOT3 = "p1_slot3",
    P1_CAST  = "p1_cast",
    P1_FREE  = "p1_free",
    P1_BOOK  = "p1_book",
    P1_SLOT1_RELEASE = "p1_slot1_release",
    P1_SLOT2_RELEASE = "p1_slot2_release",
    P1_SLOT3_RELEASE = "p1_slot3_release",

    -- Player 2 actions
    P2_SLOT1 = "p2_slot1",
    P2_SLOT2 = "p2_slot2",
    P2_SLOT3 = "p2_slot3",
    P2_CAST  = "p2_cast",
    P2_FREE  = "p2_free",
    P2_BOOK  = "p2_book",
    P2_SLOT1_RELEASE = "p2_slot1_release",
    P2_SLOT2_RELEASE = "p2_slot2_release",
    P2_SLOT3_RELEASE = "p2_slot3_release",

    -- Menu navigation
    MENU_UP    = "menu_up",
    MENU_DOWN  = "menu_down",
    MENU_LEFT  = "menu_left",
    MENU_RIGHT = "menu_right",

    -- Menu actions
    MENU_CONFIRM      = "menu_confirm",
    MENU_CANCEL_BACK  = "menu_cancel_back",

    -- System actions
    SYS_TOGGLE_DEBUG   = "sys_toggle_debug",
    SYS_QUIT_MENU_BACK = "sys_quit_menu_back"
}

-- Motion styles for VFX particles
Constants.MotionStyle = {
    RADIAL = "radial",     -- Particles expand outward in all directions (default)
    DIRECTIONAL = "directional", -- Particles move in a specific direction
    SWIRL = "swirl",       -- Particles move in a circular/spiral pattern
    RISE = "rise",         -- Particles float upward
    FALL = "fall",         -- Particles fall downward
    PULSE = "pulse",       -- Particles expand and contract rhythmically
    RIPPLE = "ripple",     -- Particles move in wave-like patterns
    STATIC = "static"      -- Particles stay in place with minimal motion
}

-- Utility function to get all motion styles
function Constants.getAllMotionStyles()
    local styles = {}
    for _, value in pairs(Constants.MotionStyle) do
        table.insert(styles, value)
    end
    return styles
end

return Constants
```

## ./core/Input.lua
```lua
-- Input.lua
-- Unified input routing system for Manastorm

local Input = {}
local Constants = require("core.Constants")

-- Store a reference to the game state for routing
local gameState = nil
Input.controls = nil

-- States considered to have a menu active
local MENU_STATES = {
    MENU = true,
    SETTINGS = true,
    CHARACTER_SELECT = true,
    COMPENDIUM = true,
    CAMPAIGN_MENU = true,
    CAMPAIGN_VICTORY = true,
    CAMPAIGN_DEFEAT = true
}

-- Set up input routes by category
Input.Routes = {
    -- System-level controls (scaling, fullscreen, quit)
    system = {},

    -- Player 1 keyboard controls
    p1_kb = {},

    -- Player 2 keyboard controls
    p2_kb = {},

    -- Gamepad routes will be added later
    gp1 = {},
    gp2 = {},

    -- Debug controls (only available outside gameOver state)
    debug = {},

    -- Test controls (only available outside gameOver state)
    test = {},

    -- UI controls (available in any state)
    ui = {},

    -- Game over state controls
    gameOver = {}
}

-- Initialize with game state reference
function Input.init(game)
    gameState = game
    Input.controls = gameState.settings.get("controls")
    Input.setupRoutes()
end

-- Central dispatch for abstract control actions
function Input.triggerAction(action, playerIndex, params)
    local gs = gameState
    if not gs then return false end

    -- Player 1 actions
    if action == Constants.ControlAction.P1_SLOT1 and playerIndex == 1 then
        gs.wizards[1]:keySpell(1, true)
    elseif action == Constants.ControlAction.P1_SLOT2 and playerIndex == 1 then
        gs.wizards[1]:keySpell(2, true)
    elseif action == Constants.ControlAction.P1_SLOT3 and playerIndex == 1 then
        gs.wizards[1]:keySpell(3, true)
    elseif action == Constants.ControlAction.P1_CAST and playerIndex == 1 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM, params)
        end
        gs.wizards[1]:castKeyedSpell()
    elseif action == Constants.ControlAction.P1_FREE and playerIndex == 1 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK, params)
        end
        gs.wizards[1]:freeAllSpells()
    elseif action == Constants.ControlAction.P1_BOOK and playerIndex == 1 then
        require("ui").toggleSpellbook(1)
    elseif action == Constants.ControlAction.P1_SLOT1_RELEASE and playerIndex == 1 then
        gs.wizards[1]:keySpell(1, false)
    elseif action == Constants.ControlAction.P1_SLOT2_RELEASE and playerIndex == 1 then
        gs.wizards[1]:keySpell(2, false)
    elseif action == Constants.ControlAction.P1_SLOT3_RELEASE and playerIndex == 1 then
        gs.wizards[1]:keySpell(3, false)

    -- Player 2 actions
    elseif action == Constants.ControlAction.P2_SLOT1 and playerIndex == 2 then
        gs.wizards[2]:keySpell(1, true)
    elseif action == Constants.ControlAction.P2_SLOT2 and playerIndex == 2 then
        gs.wizards[2]:keySpell(2, true)
    elseif action == Constants.ControlAction.P2_SLOT3 and playerIndex == 2 then
        gs.wizards[2]:keySpell(3, true)
    elseif action == Constants.ControlAction.P2_CAST and playerIndex == 2 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM, params)
        end
        gs.wizards[2]:castKeyedSpell()
    elseif action == Constants.ControlAction.P2_FREE and playerIndex == 2 then
        if MENU_STATES[gs.currentState] then
            Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK, params)
        end
        gs.wizards[2]:freeAllSpells()
    elseif action == Constants.ControlAction.P2_BOOK and playerIndex == 2 then
        require("ui").toggleSpellbook(2)
    elseif action == Constants.ControlAction.P2_SLOT1_RELEASE and playerIndex == 2 then
        gs.wizards[2]:keySpell(1, false)
    elseif action == Constants.ControlAction.P2_SLOT2_RELEASE and playerIndex == 2 then
        gs.wizards[2]:keySpell(2, false)
    elseif action == Constants.ControlAction.P2_SLOT3_RELEASE and playerIndex == 2 then
        gs.wizards[2]:keySpell(3, false)

    -- Menu/UI actions
    elseif action == Constants.ControlAction.MENU_UP
        or action == Constants.ControlAction.MENU_DOWN
        or action == Constants.ControlAction.MENU_LEFT
        or action == Constants.ControlAction.MENU_RIGHT
        or action == Constants.ControlAction.MENU_CONFIRM
        or action == Constants.ControlAction.MENU_CANCEL_BACK then
        return Input.triggerUIAction(action, params)
    else
        return false
    end
    return true
end

-- Handle UI related actions based on current state
function Input.triggerUIAction(action, params)
    local gs = gameState
    if not gs then return false end

    if action == Constants.ControlAction.MENU_CANCEL_BACK then
        if gs.currentState == "MENU" then
            love.event.quit()
        elseif gs.currentState == "BATTLE" then
            gs.currentState = "MENU"
        elseif gs.currentState == "GAME_OVER" then
            gs.currentState = "MENU"
            gs.resetGame()
        elseif gs.currentState == "CHARACTER_SELECT" then
            gs.characterSelectBack(true)
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.currentState = "MENU"
            gs.campaignMenu = nil
        elseif gs.currentState == "CAMPAIGN_VICTORY" then
            gs.currentState = "MENU"
            gs.campaignProgress = nil
        elseif gs.currentState == "CAMPAIGN_DEFEAT" then
            gs.currentState = "MENU"
            gs.campaignProgress = nil
        elseif gs.currentState == "SETTINGS" then
            if gs.settingsBack then
                gs.settingsBack()
            else
                gs.currentState = "MENU"
            end
        elseif gs.currentState == "COMPENDIUM" then
            gs.currentState = "MENU"
        end
        return true
    elseif action == Constants.ControlAction.MENU_CONFIRM then
        if gs.currentState == "MENU" then
            gs.startCharacterSelect()
            return true
        elseif gs.currentState == "SETTINGS" then
            gs.settingsSelect()
            return true
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.campaignMenuConfirm()
            return true
        elseif gs.currentState == "CHARACTER_SELECT" then
            gs.characterSelectConfirm()
            return true
        elseif gs.currentState == "CAMPAIGN_DEFEAT" then
            gs.retryCampaignBattle()
            return true
        elseif gs.currentState == "CAMPAIGN_VICTORY" then
            gs.currentState = "MENU"
            gs.campaignProgress = nil
            return true
        end
        return false
    elseif action == Constants.ControlAction.MENU_UP then
        if gs.currentState == "SETTINGS" then
            gs.settingsMove(-1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumMove(-1)
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.campaignMenuMove(-1)
        end
        return true
    elseif action == Constants.ControlAction.MENU_DOWN then
        if gs.currentState == "SETTINGS" then
            gs.settingsMove(1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumMove(1)
        elseif gs.currentState == "CAMPAIGN_MENU" then
            gs.campaignMenuMove(1)
        end
        return true
    elseif action == Constants.ControlAction.MENU_LEFT then
        if gs.currentState == "SETTINGS" then
            gs.settingsAdjust(-1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumChangePage(-1)
        end
        return true
    elseif action == Constants.ControlAction.MENU_RIGHT then
        if gs.currentState == "SETTINGS" then
            gs.settingsAdjust(1)
        elseif gs.currentState == "COMPENDIUM" then
            gs.compendiumChangePage(1)
        end
        return true
    end

    return false
end

-- Main entry point for key handling
function Input.handleKey(key, scancode, isrepeat)
    -- Log key presses for debugging
    print("DEBUG: Key pressed: '" .. key .. "'")

    -- Handle settings key capture
    if gameState and gameState.currentState == "SETTINGS" and gameState.settingsMenu and gameState.settingsMenu.waitingForKey then
        local capture = gameState.settingsMenu.waitingForKey
        local controls = gameState.settings.get("controls")
        if controls[capture.playerType] then
            controls[capture.playerType][capture.action] = key
            gameState.settings.set("controls", controls)
            if gameState.settings.save then gameState.settings.save() end
            -- update list for UI
            if gameState.settingsMenu.rebindActionList then
                for _, entry in ipairs(gameState.settingsMenu.rebindActionList) do
                    if entry.action == capture.action then
                        entry.binding = key
                    end
                end
            end
        end
        gameState.settingsMenu.waitingForKey = nil
        Input.setupRoutes()
        return true
    end
    
    -- First check gameOver state - these have highest priority
    if gameState and gameState.gameOver then
        local handler = Input.Routes.gameOver[key]
        if handler then
            return handler(key, scancode, isrepeat)
        end
        return false -- Don't process other keys in gameOver state
    end
    
    -- Check system shortcuts (with modifiers) next
    if love.keyboard.isDown("lalt") or love.keyboard.isDown("ralt") then
        local handler = Input.Routes.system[key]
        if handler then
            return handler(key, scancode, isrepeat)
        end
    end
    
    -- Check developer shortcuts
    if love.keyboard.isDown("lctrl") or love.keyboard.isDown("rctrl") then
        local handler = Input.Routes.system["ctrl_" .. key]
        if handler then
            return handler(key, scancode, isrepeat)
        end
    end
    
    -- Check UI controls (always active). Only stop processing if handled
    local uiHandler = Input.Routes.ui[key]
    if uiHandler then
        local handled = uiHandler(key, scancode, isrepeat)
        if handled then
            return true
        end
        -- fall through to player controls when not handled
    end

    -- Check player 1 keyboard controls
    local p1Handler = Input.Routes.p1_kb[key]
    if p1Handler then
        return p1Handler(key, scancode, isrepeat)
    end

    -- Check player 2 keyboard controls if allowed
    local p2Handler = Input.Routes.p2_kb[key]
    if p2Handler and not gameState.useAI and not gameState.p2UsingGamepad then
        return p2Handler(key, scancode, isrepeat)
    end
    
    -- Check debug controls
    local debugHandler = Input.Routes.debug[key]
    if debugHandler then
        return debugHandler(key, scancode, isrepeat)
    end
    
    -- Check test controls (lowest priority)
    local testHandler = Input.Routes.test[key]
    if testHandler then
        return testHandler(key, scancode, isrepeat)
    end
    
    -- No handler found
    return false
end

-- Handle key release events
function Input.handleKeyReleased(key, scancode)
    local controls = gameState.settings.get("controls")
    local kp1 = controls.keyboardP1 or (controls.p1 or {})
    local kp2 = controls.keyboardP2 or (controls.p2 or {})

    local p1s1 = kp1[Constants.ControlAction.P1_SLOT1] or kp1.slot1
    local p1s2 = kp1[Constants.ControlAction.P1_SLOT2] or kp1.slot2
    local p1s3 = kp1[Constants.ControlAction.P1_SLOT3] or kp1.slot3
    if key == p1s1 or key == p1s2 or key == p1s3 then
        local slotIndex = (key == p1s1) and 1 or (key == p1s2 and 2 or 3)
        if slotIndex == 1 then
            return Input.triggerAction(Constants.ControlAction.P1_SLOT1_RELEASE, 1)
        elseif slotIndex == 2 then
            return Input.triggerAction(Constants.ControlAction.P1_SLOT2_RELEASE, 1)
        else
            return Input.triggerAction(Constants.ControlAction.P1_SLOT3_RELEASE, 1)
        end
    end

    if not gameState.useAI and not gameState.p2UsingGamepad then
        local p2s1 = kp2[Constants.ControlAction.P2_SLOT1] or kp2.slot1
        local p2s2 = kp2[Constants.ControlAction.P2_SLOT2] or kp2.slot2
        local p2s3 = kp2[Constants.ControlAction.P2_SLOT3] or kp2.slot3
        if key == p2s1 or key == p2s2 or key == p2s3 then
            local slotIndex = (key == p2s1) and 1 or (key == p2s2 and 2 or 3)
            if slotIndex == 1 then
                return Input.triggerAction(Constants.ControlAction.P2_SLOT1_RELEASE, 2)
            elseif slotIndex == 2 then
                return Input.triggerAction(Constants.ControlAction.P2_SLOT2_RELEASE, 2)
            else
                return Input.triggerAction(Constants.ControlAction.P2_SLOT3_RELEASE, 2)
            end
        end
    end

    return false
end

-- Process gamepad button events
function Input.handleGamepadButton(joystickID, buttonName, isPressed)
    local playerIndex
    if joystickID == gameState.p1GamepadID then
        playerIndex = 1
    elseif joystickID == gameState.p2GamepadID then
        playerIndex = 2
    end
    if not playerIndex then return false end

    if playerIndex == 2 then
        if gameState.useAI then return false end
        gameState.p2UsingGamepad = true
    end

    if gameState and gameState.currentState == "SETTINGS" and gameState.settingsMenu and gameState.settingsMenu.waitingForKey then
        local capture = gameState.settingsMenu.waitingForKey
        if capture.playerType == "gamepadP1" and playerIndex == 1 or capture.playerType == "gamepadP2" and playerIndex == 2 then
            if isPressed then
                local controls = gameState.settings.get("controls")
                controls[capture.playerType][capture.action] = buttonName
                gameState.settings.set("controls", controls)
                if gameState.settings.save then gameState.settings.save() end
                if gameState.settingsMenu.rebindActionList then
                    for _, entry in ipairs(gameState.settingsMenu.rebindActionList) do
                        if entry.action == capture.action then
                            entry.binding = buttonName
                        end
                    end
                end
                gameState.settingsMenu.waitingForKey = nil
                Input.setupRoutes()
            end
            return true
        end
    end

    local controls = Input.controls or gameState.settings.get("controls")
    local map = (playerIndex == 1) and (controls.gamepadP1 or {}) or (controls.gamepadP2 or {})

    for action, button in pairs(map) do
        if button == buttonName then
            if not isPressed then
                -- Trigger release variants for spell slot buttons
                if action == Constants.ControlAction.P1_SLOT1 then
                    return Input.triggerAction(Constants.ControlAction.P1_SLOT1_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P1_SLOT2 then
                    return Input.triggerAction(Constants.ControlAction.P1_SLOT2_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P1_SLOT3 then
                    return Input.triggerAction(Constants.ControlAction.P1_SLOT3_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P2_SLOT1 then
                    return Input.triggerAction(Constants.ControlAction.P2_SLOT1_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P2_SLOT2 then
                    return Input.triggerAction(Constants.ControlAction.P2_SLOT2_RELEASE, playerIndex)
                elseif action == Constants.ControlAction.P2_SLOT3 then
                    return Input.triggerAction(Constants.ControlAction.P2_SLOT3_RELEASE, playerIndex)
                end
            end
            return Input.triggerAction(action, playerIndex, {pressed = isPressed})
        end
    end

    return false
end

-- Store previous axis values to implement deadzone and edge detection
Input._axisState = { [1] = {}, [2] = {} }
Input._axisRepeat = { [1] = {}, [2] = {} }
Input.AXIS_DEADZONE = 0.3
Input.AXIS_REPEAT_DELAY = 0.4
Input.AXIS_REPEAT_INTERVAL = 0.2

-- Process gamepad axis movements for menu navigation
function Input.handleGamepadAxis(joystickID, axisName, value)
    local playerIndex
    if joystickID == gameState.p1GamepadID then
        playerIndex = 1
    elseif joystickID == gameState.p2GamepadID then
        playerIndex = 2
    end
    if not playerIndex then return false end

    if playerIndex == 2 then
        if gameState.useAI then return false end
        if math.abs(value) > Input.AXIS_DEADZONE then
            gameState.p2UsingGamepad = true
        end
    end

    if gameState and gameState.currentState == "SETTINGS" and gameState.settingsMenu and gameState.settingsMenu.waitingForKey then
        local capture = gameState.settingsMenu.waitingForKey
        if (capture.playerType == "gamepadP1" and playerIndex == 1) or (capture.playerType == "gamepadP2" and playerIndex == 2) then
            if math.abs(value) > Input.AXIS_DEADZONE then
                local controls = gameState.settings.get("controls")
                controls[capture.playerType][capture.action] = axisName
                gameState.settings.set("controls", controls)
                if gameState.settings.save then gameState.settings.save() end
                if gameState.settingsMenu.rebindActionList then
                    for _, entry in ipairs(gameState.settingsMenu.rebindActionList) do
                        if entry.action == capture.action then
                            entry.binding = axisName
                        end
                    end
                end
                gameState.settingsMenu.waitingForKey = nil
                Input.setupRoutes()
            end
            return true
        end
    end

    local prev = Input._axisState[playerIndex][axisName] or 0
    Input._axisState[playerIndex][axisName] = value

    local action
    if axisName == "lefty" or axisName == "righty" then
        if value < -Input.AXIS_DEADZONE and prev >= -Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_UP
        elseif value > Input.AXIS_DEADZONE and prev <= Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_DOWN
        end
    elseif axisName == "leftx" or axisName == "rightx" then
        if value < -Input.AXIS_DEADZONE and prev >= -Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_LEFT
        elseif value > Input.AXIS_DEADZONE and prev <= Input.AXIS_DEADZONE then
            action = Constants.ControlAction.MENU_RIGHT
        end
    end

    if action then
        Input._axisRepeat[playerIndex][axisName] = {action = action, timer = Input.AXIS_REPEAT_DELAY}
        return Input.triggerUIAction(action, {value = value})
    elseif math.abs(value) < Input.AXIS_DEADZONE then
        Input._axisRepeat[playerIndex][axisName] = nil
    end

    return false
end

-- Define all keyboard shortcuts and routes
function Input.setupRoutes()
    -- Reset route tables
    Input.Routes.system = {}
    Input.Routes.p1_kb = {}
    Input.Routes.p2_kb = {}
    Input.Routes.gp1 = {}
    Input.Routes.gp2 = {}
    Input.Routes.debug = {}
    Input.Routes.test = {}
    Input.Routes.ui = {}
    Input.Routes.gameOver = {}

    local c = gameState.settings.get("controls")
    Input.controls = c

    local function addRoute(tbl, key, actionDesc, fn)
        if not key or key == "" then
            print("[Input] Warning: action " .. actionDesc .. " has no binding")
            return
        end
        if tbl[key] then
            print("[Input] Warning: conflicting binding for key/button '" .. key .. "'")
        end
        tbl[key] = fn
    end

    -- Build player 1 keyboard routes
    local kp1 = c.keyboardP1 or {}
    for action, key in pairs(kp1) do
        addRoute(Input.Routes.p1_kb, key, action, function()
            return Input.triggerAction(action, 1)
        end)
    end

    -- Build player 2 keyboard routes
    local kp2 = c.keyboardP2 or {}
    for action, key in pairs(kp2) do
        addRoute(Input.Routes.p2_kb, key, action, function()
            return Input.triggerAction(action, 2)
        end)
    end

    -- Build player 1 gamepad routes (button to action lookup)
    local gp1 = c.gamepadP1 or {}
    for action, button in pairs(gp1) do
        addRoute(Input.Routes.gp1, button, action, function(pressed)
            return Input.handleGamepadButton(gameState.p1GamepadID, button, pressed)
        end)
    end

    -- Build player 2 gamepad routes
    local gp2 = c.gamepadP2 or {}
    for action, button in pairs(gp2) do
        addRoute(Input.Routes.gp2, button, action, function(pressed)
            return Input.handleGamepadButton(gameState.p2GamepadID, button, pressed)
        end)
    end

    -- SYSTEM CONTROLS (with ALT modifier)
    Input.Routes.system["1"] = function()
        love.window.setMode(gameState.baseWidth, gameState.baseHeight)
        Input.recalculateScaling()
        return true
    end

    Input.Routes.system["2"] = function()
        love.window.setMode(gameState.baseWidth * 2, gameState.baseHeight * 2)
        Input.recalculateScaling()
        return true
    end

    Input.Routes.system["3"] = function()
        love.window.setMode(gameState.baseWidth * 3, gameState.baseHeight * 3)
        Input.recalculateScaling()
        return true
    end

    Input.Routes.system["f"] = function()
        love.window.setFullscreen(not love.window.getFullscreen())
        Input.recalculateScaling()
        return true
    end

    -- Developer hot-reload with Ctrl+R
    Input.Routes.system["ctrl_r"] = function()
        print("Hot-reloading assets...")
        local AssetPreloader = require("core.assetPreloader")
        local reloadStats = AssetPreloader.reloadAllAssets()
        print(string.format("Asset reload complete: %d images, %d sounds in %.2f seconds",
                          reloadStats.imageCount,
                          reloadStats.soundCount,
                          reloadStats.loadTime))
        return true
    end

    -- GAME OVER STATE CONTROLS
    Input.Routes.gameOver["space"] = function()
        if gameState.currentState == "GAME_OVER" then
            gameState.winScreenTimer = gameState.winScreenDuration
            return true
        end
        return false
    end
    
    -- SYSTEM CONTROLS (with ALT modifier)
    -- Set window to 1x scale
    Input.Routes.system["1"] = function()
        love.window.setMode(gameState.baseWidth, gameState.baseHeight)
        Input.recalculateScaling()
        return true
    end
    
    -- Set window to 2x scale
    Input.Routes.system["2"] = function()
        love.window.setMode(gameState.baseWidth * 2, gameState.baseHeight * 2)
        Input.recalculateScaling()
        return true
    end
    
    -- Set window to 3x scale
    Input.Routes.system["3"] = function()
        love.window.setMode(gameState.baseWidth * 3, gameState.baseHeight * 3)
        Input.recalculateScaling()
        return true
    end
    
    -- Toggle fullscreen
    Input.Routes.system["f"] = function()
        love.window.setFullscreen(not love.window.getFullscreen())
        Input.recalculateScaling()
        return true
    end
    
    -- Developer hot-reload with Ctrl+R
    Input.Routes.system["ctrl_r"] = function()
        print("Hot-reloading assets...")
        local AssetPreloader = require("core.assetPreloader")
        local reloadStats = AssetPreloader.reloadAllAssets()
        print(string.format("Asset reload complete: %d images, %d sounds in %.2f seconds",
                          reloadStats.imageCount,
                          reloadStats.soundCount,
                          reloadStats.loadTime))
        return true
    end
    
    -- MENU CONTROLS
    Input.Routes.ui["1"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCampaignMenu()
            return true
        end
        return false
    end

    -- Character Duel - goes to character select screen
    Input.Routes.ui["2"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCharacterSelect()
            return true
        end
        return false
    end

    -- Research Duel stub
    Input.Routes.ui["3"] = function()
        if gameState.currentState == "MENU" then
            print("Research Duel not implemented yet")
            return true
        end
        return false
    end

    -- Open Compendium screen (with number key 4)
    Input.Routes.ui["4"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCompendium()
            return true
        end
        return false
    end
    
    -- Open Compendium screen (with letter C for easier access)
    Input.Routes.ui["c"] = function()
        if gameState.currentState == "MENU" then
            gameState.startCompendium()
            return true
        end
        return false
    end

    -- Open settings menu
    Input.Routes.ui["5"] = function()
        if gameState.currentState == "MENU" then
            gameState.startSettings()
            return true
        end
        return false
    end

    -- Exit the game
    Input.Routes.ui["6"] = function()
        if gameState.currentState == "MENU" then
            love.event.quit()
            return true
        end
        return false
    end

    -- Generic menu navigation keys
    Input.Routes.ui["return"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)
    end
    Input.Routes.ui["space"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)
    end
    Input.Routes.ui["escape"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK)
    end

    Input.Routes.ui["up"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_UP)
    end
    Input.Routes.ui["down"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_DOWN)
    end
    Input.Routes.ui["left"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_LEFT)
    end
    Input.Routes.ui["right"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_RIGHT)
    end

    -- Assign spells to slots when in Compendium
    for i=1,7 do
        local existing = Input.Routes.ui[tostring(i)]
        Input.Routes.ui[tostring(i)] = function()
            if gameState.currentState == "COMPENDIUM" then
                gameState.compendiumAssign(i)
                return true
            elseif existing then
                return existing()
            end
            return false
        end
    end

    -- CHARACTER SELECT CONTROLS
    -- Move cursor left
    Input.Routes.ui["q"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(-1)
            return true
        end
        return false
    end

    -- Move cursor right
    Input.Routes.ui["e"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(1)
            return true
        end
        return false
    end

    -- CHARACTER SELECT CONTROLS
    -- Move cursor left
    Input.Routes.ui["q"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(-1)
            return true
        end
        return false
    end

    -- Move cursor right
    Input.Routes.ui["e"] = function()
        if gameState.currentState == "CHARACTER_SELECT" then
            gameState.characterSelectMove(1)
            return true
        end
        return false
    end

    -- Confirm selection / Fight (legacy key)
    Input.Routes.ui["f"] = function()
        return Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)
    end

    -- Toggle Player 2 mode between Human and AI
    Input.Routes.ui["tab"] = function()
        if gameState.currentState == "CHARACTER_SELECT" and gameState.characterSelect.stage >= 2 then
            gameState.useAI = not gameState.useAI
            return true
        end
        return false
    end

    Input.Routes.ui["r"] = function()
        if gameState.currentState == "CAMPAIGN_DEFEAT" or gameState.currentState == "CAMPAIGN_VICTORY" then
            gameState.restartCampaign()
            return true
        end
        return false
    end

    
    -- DEBUG CONTROLS
    -- Add 30 random tokens with T key
    Input.Routes.debug["t"] = function()
        local addedTokens = {}
        for i = 1, 30 do
            local tokenType = gameState.addRandomToken()
            addedTokens[tokenType] = (addedTokens[tokenType] or 0) + 1
        end
        
        -- Print summary of added tokens
        for tokenType, count in pairs(addedTokens) do
            print("Added " .. count .. " " .. tokenType .. " tokens to the mana pool")
        end
        return true
    end
    
    -- Add specific tokens for testing
    Input.Routes.debug["z"] = function()
        local tokenType = "moon"
        gameState.manaPool:addToken(tokenType, gameState.tokenImages[tokenType])
        print("Added a " .. tokenType .. " token to the mana pool")
        return true
    end
    
    Input.Routes.debug["x"] = function()
        local tokenType = "star"
        gameState.manaPool:addToken(tokenType, gameState.tokenImages[tokenType])
        print("Added a " .. tokenType .. " token to the mana pool")
        return true
    end
    
    Input.Routes.debug["c"] = function()
        local tokenType = "force"
        gameState.manaPool:addToken(tokenType, gameState.tokenImages[tokenType])
        print("Added a " .. tokenType .. " token to the mana pool")
        return true
    end
    
    -- Position/elevation test controls
    -- Toggle range state with R key
    Input.Routes.debug["r"] = function()
        if gameState.rangeState == "NEAR" then
            gameState.rangeState = "FAR"
        else
            gameState.rangeState = "NEAR"
        end
        print("Range state toggled to: " .. gameState.rangeState)
        return true
    end
    
    -- Toggle Ashgar's elevation with A key
    Input.Routes.debug["a"] = function()
        if gameState.wizards[1].elevation == "GROUNDED" then
            gameState.wizards[1].elevation = "AERIAL"
        else
            gameState.wizards[1].elevation = "GROUNDED"
        end
        print("Ashgar elevation toggled to: " .. gameState.wizards[1].elevation)
        return true
    end
    
    -- Toggle Selene's elevation with S key
    Input.Routes.debug["s"] = function()
        if gameState.wizards[2].elevation == "GROUNDED" then
            gameState.wizards[2].elevation = "AERIAL"
        else
            gameState.wizards[2].elevation = "GROUNDED"
        end
        print("Selene elevation toggled to: " .. gameState.wizards[2].elevation)
        return true
    end
    
    -- TESTING / VFX CONTROLS
    -- Namespace these differently to avoid conflict with custom spell hotkeys
    -- Using a safeguard to check the context
    
    -- Test firebolt effect
    Input.Routes.test["1"] = function()
        if not hasActiveSpellInput() then
            gameState.vfx.createEffect("firebolt", gameState.wizards[1].x, gameState.wizards[1].y, gameState.wizards[2].x, gameState.wizards[2].y)
            print("Testing firebolt VFX")
            return true
        end
        return false
    end
    
    -- Test meteor effect
    Input.Routes.test["2"] = function()
        if not hasActiveSpellInput() then
            gameState.vfx.createEffect("meteor", gameState.wizards[2].x, gameState.wizards[2].y - 100, gameState.wizards[2].x, gameState.wizards[2].y)
            print("Testing meteor VFX")
            return true
        end
        return false
    end
    
    -- Test mist veil effect
    Input.Routes.test["3"] = function()
        gameState.vfx.createEffect("mistveil", gameState.wizards[1].x, gameState.wizards[1].y)
        print("Testing mist veil VFX")
        return true
    end
    
    -- Test emberlift effect
    Input.Routes.test["4"] = function()
        gameState.vfx.createEffect("emberlift", gameState.wizards[2].x, gameState.wizards[2].y)
        print("Testing emberlift VFX") 
        return true
    end
    
    -- Test full moon beam effect
    Input.Routes.test["5"] = function()
        gameState.vfx.createEffect("fullmoonbeam", gameState.wizards[2].x, gameState.wizards[2].y, gameState.wizards[1].x, gameState.wizards[1].y)
        print("Testing full moon beam VFX")
        return true
    end
    
    -- Test conjure fire effect
    Input.Routes.test["6"] = function()
        gameState.vfx.createEffect("conjurefire", gameState.wizards[1].x, gameState.wizards[1].y, nil, nil, {
            manaPoolX = gameState.manaPool.x,
            manaPoolY = gameState.manaPool.y
        })
        print("Testing conjure fire VFX")
        return true
    end
    
    -- Test conjure moonlight effect
    Input.Routes.test["7"] = function()
        gameState.vfx.createEffect("conjuremoonlight", gameState.wizards[2].x, gameState.wizards[2].y, nil, nil, {
            manaPoolX = gameState.manaPool.x,
            manaPoolY = gameState.manaPool.y
        })
        print("Testing conjure moonlight VFX")
        return true
    end
    
    -- Test volatile conjuring effect
    Input.Routes.test["8"] = function()
        gameState.vfx.createEffect("volatileconjuring", gameState.wizards[1].x, gameState.wizards[1].y, nil, nil, {
            manaPoolX = gameState.manaPool.x,
            manaPoolY = gameState.manaPool.y
        })
        print("Testing volatile conjuring VFX")
        return true
    end
    
    -- Add direct keys for casting shield spells
    -- This is a special case for spell debugging
    Input.Routes.debug["kp1"] = function() -- Using KeyPad 1 instead of regular 1
        -- Force cast Moon Ward for Selene
        print("DEBUG: Directly casting Moon Ward for Selene")
        local result = gameState.wizards[2]:queueSpell(gameState.customSpells.moonWard)
        print("DEBUG: Moon Ward cast result: " .. tostring(result))
        return true
    end
    
    Input.Routes.debug["kp2"] = function() -- Using KeyPad 2 instead of regular 2
        -- Force cast Mirror Shield for Selene
        print("DEBUG: Directly casting Mirror Shield for Selene")
        local result = gameState.wizards[2]:queueSpell(gameState.customSpells.mirrorShield)
        print("DEBUG: Mirror Shield cast result: " .. tostring(result))
        return true
    end
end

-- Helper to check if there's active spell input happening
-- Prevents VFX test keys from conflicting with spell casting
function hasActiveSpellInput()
    if not gameState or not gameState.wizards then
        return false
    end
    
    -- Check if any wizard has active key combinations
    for _, wizard in ipairs(gameState.wizards) do
        if wizard.activeKeys and (wizard.activeKeys[1] or wizard.activeKeys[2] or wizard.activeKeys[3]) then
            return true
        end
    end
    
    return false
end

-- Helper function to recalculate scaling
function Input.recalculateScaling()
    if gameState and gameState.calculateScaling then
        gameState.calculateScaling()
    end
end

-- Update repeat timers for held gamepad axes
function Input.update(dt)
    for playerIndex, axes in pairs(Input._axisRepeat) do
        for axis, state in pairs(axes) do
            state.timer = state.timer - dt
            if state.timer <= 0 then
                Input.triggerUIAction(state.action, {value = Input._axisState[playerIndex][axis]})
                state.timer = Input.AXIS_REPEAT_INTERVAL
            end
        end
    end
end

-- Document all currently used keys and default bindings
-- `actions` mirrors the defaults defined in core/Settings.lua so that
-- documentation and debug overlays can display current mappings.
Input.reservedKeys = {
    actions = {
        [Constants.ControlAction.P1_SLOT1] = {keyboardP1 = "q", gamepadP1 = "dpdown"},
        [Constants.ControlAction.P1_SLOT2] = {keyboardP1 = "w", gamepadP1 = "dpleft"},
        [Constants.ControlAction.P1_SLOT3] = {keyboardP1 = "e", gamepadP1 = "dpright"},
        [Constants.ControlAction.P1_CAST]  = {keyboardP1 = "f", gamepadP1 = "a"},
        [Constants.ControlAction.P1_FREE]  = {keyboardP1 = "g", gamepadP1 = "y"},
        [Constants.ControlAction.P1_BOOK]  = {keyboardP1 = "b", gamepadP1 = "b"},

        [Constants.ControlAction.P2_SLOT1] = {keyboardP2 = "i", gamepadP2 = "dpdown"},
        [Constants.ControlAction.P2_SLOT2] = {keyboardP2 = "o", gamepadP2 = "dpleft"},
        [Constants.ControlAction.P2_SLOT3] = {keyboardP2 = "p", gamepadP2 = "dpright"},
        [Constants.ControlAction.P2_CAST]  = {keyboardP2 = "j", gamepadP2 = "a"},
        [Constants.ControlAction.P2_FREE]  = {keyboardP2 = "h", gamepadP2 = "y"},
        [Constants.ControlAction.P2_BOOK]  = {keyboardP2 = "m", gamepadP2 = "b"},

        [Constants.ControlAction.MENU_UP]    = {keyboardP1 = "up",    keyboardP2 = "up",    gamepadP1 = "dpup",    gamepadP2 = "dpup"},
        [Constants.ControlAction.MENU_DOWN]  = {keyboardP1 = "down",  keyboardP2 = "down",  gamepadP1 = "dpdown",  gamepadP2 = "dpdown"},
        [Constants.ControlAction.MENU_LEFT]  = {keyboardP1 = "left",  keyboardP2 = "left",  gamepadP1 = "dpleft",  gamepadP2 = "dpleft"},
        [Constants.ControlAction.MENU_RIGHT] = {keyboardP1 = "right", keyboardP2 = "right", gamepadP1 = "dpright", gamepadP2 = "dpright"},
        [Constants.ControlAction.MENU_CONFIRM]     = {keyboardP1 = "return", keyboardP2 = "return", gamepadP1 = "a", gamepadP2 = "a"},
        [Constants.ControlAction.MENU_CANCEL_BACK] = {keyboardP1 = "escape", keyboardP2 = "escape", gamepadP1 = "b", gamepadP2 = "b"}
    },

    system = {
        "Alt+1", "Alt+2", "Alt+3", "Alt+f", -- Window scaling
        "Ctrl+R", -- Asset reload
    },
    
    menu = {
        "1", "2", "3", "4", "5", "6", -- Main menu options
        "Up", "Down", "Left", "Right", -- Navigation
        "Enter", "Space", -- Confirm
        "Escape", -- Quit/Back
    },
    
    battle = {
        "Escape", -- Return to menu from battle
    },

    campaignMenu = {
        "Up", "Down", "Left", "Right", "F", "Enter", "Space", "Escape"
    },

    characterSelect = {
        "Q", "E", -- Move cursor
        "F", "Enter", "Space", -- Confirm
        "Escape" -- Back
    },
    
    gameOver = {
        "Space", "Enter", -- Return to menu after game over
        "Escape", -- Return to menu immediately
    },
    
    player1 = {
        "Q", "W", "E", -- Spell slots
        "F", -- Cast keyed spell
        "G", -- Free all spells
        "B", -- Toggle spellbook
    },
    
    player2 = {
        "I", "O", "P", -- Spell slots
        "J", -- Cast keyed spell
        "H", -- Free all spells
        "M", -- Toggle spellbook
    },
    
    debug = {
        "T", -- Add random token
        "Z", "X", "C", -- Add specific tokens
        "R", -- Toggle range state
        "A", "S", -- Toggle elevations
        "P", -- Show object pool stats
        "Keypad 1", "Keypad 2", -- Direct shield spell casts
    },
    
    testing = {
        "1-8", -- VFX tests
    }
}

return Input
```

## ./core/Log.lua
```lua
local Log = {}

-- Flag to enable verbose debug logging
Log.verbose = false

--- Set verbose logging flag
-- @param enabled boolean
function Log.setVerbose(enabled)
    Log.verbose = not not enabled
end

--- Print a debug message if verbose logging is enabled
function Log.debug(...)
    if Log.verbose then
        print(...)
    end
end

return Log
```

## ./core/Pool.lua
```lua
-- Pool.lua
-- Object pooling system to reduce garbage generation and frame spikes
-- by reusing tables for frequently created and destroyed objects

local Pool = {}
Pool.__index = Pool

-- Store different pools for different object types
Pool.pools = {}

-- Debug statistics
Pool.stats = {
    acquires = {},
    releases = {},
    creates = {},
    poolSizes = {}
}

-- Create a new pool of objects with a given id
function Pool.create(id, initialSize, factoryFn, resetFn)
    if Pool.pools[id] then
        print("[POOL] WARNING: Pool with id '" .. id .. "' already exists! Using existing pool.")
        return Pool.pools[id]
    end
    
    local pool = {
        id = id,
        objects = {}, -- Available objects
        active = {}, -- Currently in use
        factory = factoryFn or function() return {} end, -- Creates new objects
        reset = resetFn or function(obj) 
            -- Basic reset function (clear all fields)
            for k, _ in pairs(obj) do
                obj[k] = nil
            end
            return obj
        end
    }
    
    -- Initialize stats for this pool
    Pool.stats.acquires[id] = 0
    Pool.stats.releases[id] = 0
    Pool.stats.creates[id] = 0
    Pool.stats.poolSizes[id] = 0
    
    -- Pre-populate the pool with specified number of objects
    for i = 1, initialSize or 0 do
        local obj = pool.factory()
        table.insert(pool.objects, obj)
        Pool.stats.creates[id] = Pool.stats.creates[id] + 1
        Pool.stats.poolSizes[id] = Pool.stats.poolSizes[id] + 1
    end
    
    Pool.pools[id] = pool
    print("[POOL] Created new pool '" .. id .. "' with " .. (initialSize or 0) .. " objects")
    
    return pool
end

-- Get an object from the pool, creating a new one if none are available
function Pool.acquire(id, ...)
    local pool = Pool.pools[id]
    if not pool then
        print("[POOL] WARNING: Acquiring from non-existent pool '" .. id .. "'. Creating new pool.")
        local varArgs = {...}
        -- Using the varargs to determine initialization functions
        local factoryFn = varArgs[1]
        local resetFn = varArgs[2]
        pool = Pool.create(id, 0, factoryFn, resetFn)
    end
    
    local obj
    if #pool.objects > 0 then
        -- Use an existing object from the pool
        obj = table.remove(pool.objects)
    else
        -- Create a new object
        obj = pool.factory()
        Pool.stats.creates[id] = Pool.stats.creates[id] + 1
        Pool.stats.poolSizes[id] = Pool.stats.poolSizes[id] + 1
        -- Debug message when creating a new object (uncomment for debugging)
        -- print("[POOL] Created new object for pool '" .. id .. "'")
    end
    
    -- Mark as active and track statistics
    pool.active[obj] = true
    Pool.stats.acquires[id] = Pool.stats.acquires[id] + 1
    
    return obj
end

-- Return an object to the pool
function Pool.release(id, obj)
    local pool = Pool.pools[id]
    if not pool then
        print("[POOL] ERROR: Trying to release to non-existent pool '" .. id .. "'. Object discarded.")
        return false
    end
    
    -- Check if object is actually from this pool
    if not pool.active[obj] then
        print("[POOL] WARNING: Object being released was not acquired from pool '" .. id .. "'. Object discarded.")
        return false
    end
    
    -- Remove from active set
    pool.active[obj] = nil
    
    -- Reset the object to clean state using pool's reset function
    obj = pool.reset(obj)
    
    -- Add back to available pool
    table.insert(pool.objects, obj)
    Pool.stats.releases[id] = Pool.stats.releases[id] + 1
    
    return true
end

-- Get the current size of a pool (available + active)
function Pool.size(id)
    local pool = Pool.pools[id]
    if not pool then return 0 end
    
    local activeCount = 0
    for _ in pairs(pool.active) do
        activeCount = activeCount + 1
    end
    
    return #pool.objects + activeCount
end

-- Get the number of available objects in the pool
function Pool.available(id)
    local pool = Pool.pools[id]
    if not pool then return 0 end
    
    return #pool.objects
end

-- Get number of active objects from the pool
function Pool.activeCount(id)
    local pool = Pool.pools[id]
    if not pool then return 0 end
    
    local count = 0
    for _ in pairs(pool.active) do
        count = count + 1
    end
    
    return count
end

-- Clear a pool (useful during level transitions or game resets)
function Pool.clear(id)
    local pool = Pool.pools[id]
    if not pool then return end
    
    -- Clear both active and inactive objects
    pool.objects = {}
    pool.active = {}
    
    -- Reset stats
    Pool.stats.poolSizes[id] = 0
    
    print("[POOL] Cleared pool '" .. id .. "'")
end

-- Get debug stats about pool usage
function Pool.getStats()
    local stats = {
        pools = {},
        totalObjects = 0,
        totalActive = 0,
        totalAvailable = 0
    }
    
    for id, pool in pairs(Pool.pools) do
        local activeCount = 0
        for _ in pairs(pool.active) do
            activeCount = activeCount + 1
        end
        
        local poolStats = {
            id = id,
            size = Pool.size(id),
            active = activeCount,
            available = #pool.objects,
            acquires = Pool.stats.acquires[id] or 0,
            releases = Pool.stats.releases[id] or 0,
            creates = Pool.stats.creates[id] or 0
        }
        
        table.insert(stats.pools, poolStats)
        stats.totalObjects = stats.totalObjects + poolStats.size
        stats.totalActive = stats.totalActive + poolStats.active
        stats.totalAvailable = stats.totalAvailable + poolStats.available
    end
    
    return stats
end

-- Print debug stats for all pools
function Pool.printStats()
    local stats = Pool.getStats()
    
    print("\n=== OBJECT POOL STATISTICS ===")
    print(string.format("Total Objects: %d (Active: %d, Available: %d)", 
        stats.totalObjects, stats.totalActive, stats.totalAvailable))
    
    for _, poolStats in ipairs(stats.pools) do
        print(string.format("Pool '%s': %d objects (%d active, %d available)", 
            poolStats.id, poolStats.size, poolStats.active, poolStats.available))
        print(string.format("  - Created: %d, Acquired: %d, Released: %d, Reuse: %.1f%%", 
            poolStats.creates, poolStats.acquires, poolStats.releases,
            poolStats.acquires > 0 and ((poolStats.acquires - poolStats.creates) / poolStats.acquires * 100) or 0))
    end
    print("==============================\n")
end

-- Debug overlay showing pool stats
function Pool.drawDebugOverlay()
    local stats = Pool.getStats()
    
    -- Check if love.graphics is available
    if not love or not love.graphics then return end
    
    -- Save current graphics state
    love.graphics.push("all")
    
    -- Set up colors and font
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 10, 10, 300, 20 + #stats.pools * 40)
    
    love.graphics.setColor(1, 1, 1, 1)
    love.graphics.print("OBJECT POOLS: " .. stats.totalObjects .. " objects (" .. 
        stats.totalActive .. " active, " .. stats.totalAvailable .. " available)", 15, 15)
    
    for i, poolStats in ipairs(stats.pools) do
        love.graphics.print(string.format("'%s': %d obj (%d active, %d avail)", 
            poolStats.id, poolStats.size, poolStats.active, poolStats.available), 20, 15 + i * 20)
        
        -- Calculate reuse percentage
        local reusePercent = poolStats.acquires > 0 and 
            ((poolStats.acquires - poolStats.creates) / poolStats.acquires * 100) or 0
        
        love.graphics.print(string.format("Created: %d, Acq: %d, Reuse: %.1f%%", 
            poolStats.creates, poolStats.acquires, reusePercent), 30, 15 + i * 20 + 12)
        
        -- Draw a small bar showing active vs available
        if poolStats.size > 0 then
            -- Background bar
            love.graphics.setColor(0.3, 0.3, 0.3, 1)
            love.graphics.rectangle("fill", 180, 19 + i * 20, 100, 8)
            
            -- Active portion
            love.graphics.setColor(0.8, 0.3, 0.3, 1)
            love.graphics.rectangle("fill", 180, 19 + i * 20, 
                100 * (poolStats.active / poolStats.size), 8)
        end
    end
    
    -- Restore graphics state
    love.graphics.pop()
end

return Pool```

## ./core/Settings.lua
```lua
local Settings = {}
local Constants = require("core.Constants")

-- Default configuration
local defaults = {
    dummyFlag = false,
    gameSpeed = "FAST",
    controls = {
        keyboardP1 = {
            [Constants.ControlAction.P1_SLOT1] = "q",
            [Constants.ControlAction.P1_SLOT2] = "w",
            [Constants.ControlAction.P1_SLOT3] = "e",
            [Constants.ControlAction.P1_CAST]  = "f",
            [Constants.ControlAction.P1_FREE]  = "g",
            [Constants.ControlAction.P1_BOOK]  = "b",
            [Constants.ControlAction.MENU_UP]    = "up",
            [Constants.ControlAction.MENU_DOWN]  = "down",
            [Constants.ControlAction.MENU_LEFT]  = "left",
            [Constants.ControlAction.MENU_RIGHT] = "right",
            [Constants.ControlAction.MENU_CONFIRM]     = "return",
            [Constants.ControlAction.MENU_CANCEL_BACK] = "escape"
        },
        keyboardP2 = {
            [Constants.ControlAction.P2_SLOT1] = "i",
            [Constants.ControlAction.P2_SLOT2] = "o",
            [Constants.ControlAction.P2_SLOT3] = "p",
            [Constants.ControlAction.P2_CAST]  = "j",
            [Constants.ControlAction.P2_FREE]  = "h",
            [Constants.ControlAction.P2_BOOK]  = "m"
        },
        gamepadP1 = {
            [Constants.ControlAction.P1_SLOT1] = "dpdown",
            [Constants.ControlAction.P1_SLOT2] = "dpleft",
            [Constants.ControlAction.P1_SLOT3] = "dpright",
            [Constants.ControlAction.P1_CAST]  = "a",
            [Constants.ControlAction.P1_FREE]  = "y",
            [Constants.ControlAction.P1_BOOK]  = "b",
            [Constants.ControlAction.MENU_UP]    = "dpup",
            [Constants.ControlAction.MENU_DOWN]  = "dpdown",
            [Constants.ControlAction.MENU_LEFT]  = "dpleft",
            [Constants.ControlAction.MENU_RIGHT] = "dpright",
            [Constants.ControlAction.MENU_CONFIRM]     = "a",
            [Constants.ControlAction.MENU_CANCEL_BACK] = "b"
        },
        gamepadP2 = {
            [Constants.ControlAction.P2_SLOT1] = "dpdown",
            -- Placeholder for P2 controller mappings
        }
    }
}

local function deepcopy(tbl)
    if type(tbl) ~= "table" then return tbl end
    local result = {}
    for k, v in pairs(tbl) do
        result[k] = deepcopy(v)
    end
    return result
end

local function serialize(tbl, indent)
    indent = indent or 0
    local parts = {"{\n"}
    local pad = string.rep(" ", indent + 2)
    for k, v in pairs(tbl) do
        local key
        if type(k) == "string" then
            key = k .. " = "
        else
            key = "[" .. k .. "] = "
        end
        if type(v) == "table" then
            table.insert(parts, pad .. key .. serialize(v, indent + 2) .. ",\n")
        elseif type(v) == "string" then
            table.insert(parts, pad .. key .. string.format("%q", v) .. ",\n")
        else
            table.insert(parts, pad .. key .. tostring(v) .. ",\n")
        end
    end
    table.insert(parts, string.rep(" ", indent) .. "}")
    return table.concat(parts)
end

local function mergeDefaults(target, default)
    for k, v in pairs(default) do
        if type(v) == "table" then
            if type(target[k]) ~= "table" then
                target[k] = deepcopy(v)
            else
                mergeDefaults(target[k], v)
            end
        elseif target[k] == nil then
            target[k] = v
        end
    end
end

Settings.data = nil

function Settings.load()
    if love.filesystem.getInfo("settings.lua") then
        local chunk = love.filesystem.load("settings.lua")
        local ok, result = pcall(chunk)
        if ok and type(result) == "table" then
            Settings.data = result
            -- Backwards compatibility: convert numeric gameSpeed
            if type(Settings.data.gameSpeed) ~= "string" then
                Settings.data.gameSpeed = "FAST"
            end
            -- Merge new defaults for missing values
            mergeDefaults(Settings.data, defaults)
            return
        end
    end
    Settings.data = deepcopy(defaults)
    Settings.save()
end

function Settings.save()
    if not Settings.data then return end
    local serialized = "return " .. serialize(Settings.data) .. "\n"
    love.filesystem.write("settings.lua", serialized)
end

function Settings.get(key)
    if not Settings.data then Settings.load() end
    return Settings.data[key]
end

function Settings.set(key, value)
    if not Settings.data then Settings.load() end
    Settings.data[key] = value
    Settings.save()
end

function Settings.getDefaults()
    return deepcopy(defaults)
end

return Settings
```

## ./core/Tips.lua
```lua
local Tips = {}

local loadedTips = nil

local function parseTips(json)
    local tips = {}
    if not json then return tips end
    for tipBlock in json:gmatch("%{[^{}]*%}") do
        local title = tipBlock:match('"title"%s*:%s*"(.-)"')
        local content = tipBlock:match('"content"%s*:%s*"(.-)"')
        local source = tipBlock:match('"source"%s*:%s*"(.-)"')
        if title and content and source then
            table.insert(tips, {
                title = title,
                content = content,
                source = source
            })
        end
    end
    return tips
end

function Tips.load(path)
    if loadedTips then
        return loadedTips
    end
    local data = love.filesystem.read(path)
    if not data then
        print("ERROR: Could not load tips file: " .. tostring(path))
        loadedTips = {}
        return loadedTips
    end
    loadedTips = parseTips(data)
    return loadedTips
end

function Tips.getRandomTip()
    if not loadedTips then
        return nil
    end
    if #loadedTips == 0 then
        return nil
    end
    return loadedTips[love.math.random(#loadedTips)]
end

return Tips
```

## ./core/assetPreloader.lua
```lua
-- assetPreloader.lua
-- Centralized preloader for game assets

local AssetCache = require("core.AssetCache")

local AssetPreloader = {}

-- Preload all game assets to avoid hitches during gameplay
function AssetPreloader.preloadAllAssets()
    local startTime = love.timer.getTime()
    
    -- Manifest of all assets to preload
    local assetManifest = {
        images = {
            -- Token & UI assets
            "assets/sprites/token-lock.png",
            
            -- Elemental tokens
            "assets/sprites/v2Tokens/fire-token.png", 
            "assets/sprites/v2Tokens/water-token.png",
            "assets/sprites/v2Tokens/salt-token.png",
            "assets/sprites/v2Tokens/sun-token.png",
            "assets/sprites/v2Tokens/moon-token.png",
            "assets/sprites/v2Tokens/star-token.png",
            "assets/sprites/v2Tokens/life-token.png",
            "assets/sprites/v2Tokens/mind-token.png",
            "assets/sprites/v2Tokens/void-token.png",
            
            -- VFX assets
            "assets/sprites/fire-particle.png",
            "assets/sprites/fire-glow.png",
            "assets/sprites/force-wave.png", 
            "assets/sprites/moon-glow.png",
            "assets/sprites/sparkle.png",
            "assets/sprites/impact-ring.png",
            "assets/sprites/1px.png",
            "assets/sprites/3px-twinkle1.png",
            "assets/sprites/3px-twinkle2.png",
            
            
            -- Game entity assets
            "assets/sprites/wizard.png",
            "assets/sprites/ashgar.png",
            "assets/sprites/ashgar-cast.png",
            "assets/sprites/ashgar-idle-1.png",
            "assets/sprites/ashgar-idle-2.png",
            "assets/sprites/ashgar-idle-3.png",
            "assets/sprites/ashgar-idle-4.png",
            "assets/sprites/ashgar-idle-5.png",
            "assets/sprites/ashgar-idle-6.png",
            "assets/sprites/ashgar-idle-7.png",
            "assets/sprites/selene.png",
            "assets/sprites/selene-cast.png",

            "assets/sprites/grounded-circle.png"
        },
        
        sounds = {
            -- These are placeholders until actual sound assets are created
            -- Format: {path, type} where type is "static" or "stream"
            -- {"assets/sounds/firebolt.wav", "static"},
            -- {"assets/sounds/meteor.wav", "static"},
            -- {"assets/sounds/mist.wav", "static"}
        }
    }
    
    -- Check assets directory structure
    local assetsExist = love.filesystem.getInfo("assets/sprites")
    if not assetsExist then
        print("WARNING: assets/sprites directory not found. Asset loading may fail.")
    end
    
    -- Filter manifest to only include existing paths
    local filteredManifest = {
        images = {},
        sounds = {}
    }
    
    for _, path in ipairs(assetManifest.images) do
        if love.filesystem.getInfo(path) then
            table.insert(filteredManifest.images, path)
        else
            print("Asset not found, will skip: " .. path)
        end
    end
    
    for _, soundData in ipairs(assetManifest.sounds) do
        if love.filesystem.getInfo(soundData[1]) then
            table.insert(filteredManifest.sounds, soundData)
        else
            print("Sound asset not found, will skip: " .. soundData[1])
        end
    end
    
    -- Preload all assets in the filtered manifest
    local loaded = AssetCache.preload(filteredManifest)
    
    -- Report preload time
    local loadTime = love.timer.getTime() - startTime
    print(string.format("AssetPreloader: Loaded %d images and %d sounds in %.2f seconds", 
                        loaded.images, loaded.sounds, loadTime))
                        
    -- Return statistics for verification
    return {
        imageCount = loaded.images,
        soundCount = loaded.sounds,
        loadTime = loadTime
    }
end

-- Helper to reload all assets (useful for development hot-reload)
function AssetPreloader.reloadAllAssets()
    AssetCache.flush()
    return AssetPreloader.preloadAllAssets()
end

-- Get asset cache statistics
function AssetPreloader.getStats()
    return AssetCache.dumpStats()
end

return AssetPreloader```

## ./docs/keywords.lua
```lua
-- Keywords Documentation Generator
-- This file helps maintain up-to-date documentation for the keyword system

local Spells = require("spells")

local DocGenerator = {}

-- Function to get the default target type description for a keyword
local function getTargetTypeDescription(keyword)
    local targetType = Spells.keywordSystem.keywordTargets[keyword]
    local descriptions = {
        self = "Affects the caster",
        enemy = "Affects the opponent",
        pool_self = "Affects the caster's mana pool",
        pool_enemy = "Affects the opponent's mana pool",
        slot_self = "Affects the caster's spell slots",
        slot_enemy = "Affects the opponent's spell slots",
        global = "Affects the game state",
        none = "No specific target"
    }
    
    return descriptions[targetType] or "Unknown target type"
end

-- Generate markdown documentation for all available keywords
function DocGenerator.generateMarkdown()
    local output = "# Manastorm Spell Keyword Reference\n\n"
    output = output .. "This document provides a reference for all available keywords in the Manastorm spell system.\n\n"
    
    -- Get keyword info organized by category
    local keywordsByCategory = Spells.keywordSystem.getKeywordHelp("byCategory")
    
    -- Table of contents
    output = output .. "## Contents\n\n"
    for categoryKey, category in pairs(keywordsByCategory) do
        output = output .. "- [" .. category.name .. "](#" .. string.lower(category.name:gsub("%s+", "-")) .. ")\n"
    end
    output = output .. "\n\n"
    
    -- Generate sections for each category
    for categoryKey, category in pairs(keywordsByCategory) do
        output = output .. "## " .. category.name .. "\n\n"
        
        for _, keyword in ipairs(category.keywords) do
            output = output .. "### " .. keyword.name .. "\n\n"
            output = output .. keyword.description .. "\n\n"
            output = output .. "**Default targeting:** " .. getTargetTypeDescription(keyword.name) .. "\n\n"
            output = output .. "**Example usage:**\n\n"
            output = output .. "```lua\n" .. keyword.example .. "\n```\n\n"
            
            -- Add targeting example if appropriate
            if Spells.keywordSystem.keywordTargets[keyword.name] then
                output = output .. "**Custom targeting example:**\n\n"
                output = output .. "```lua\n" .. keyword.name .. " = {\n"
                output = output .. "    -- Parameters as above\n"
                output = output .. "    target = \"" .. Spells.keywordSystem.keywordTargets[keyword.name] .. "\"  -- Default target\n"
                output = output .. "    -- You can override with any of: \"self\", \"enemy\", \"pool_self\", \"pool_enemy\", \"slot_self\", \"slot_enemy\", \"global\", \"none\"\n"
                output = output .. "}\n```\n\n"
            end
        end
    end
    
    -- Add a section with sample spells
    output = output .. "## Sample Spells\n\n"
    output = output .. "These examples show how to combine multiple keywords to create complex spell effects.\n\n"
    
    -- Targeting section
    output = output .. "### About Targeting\n\n"
    output = output .. "Each keyword has a default target (shown in the keyword documentation). You can override this by specifying a `target` parameter in the keyword configuration.\n\n"
    output = output .. "Available target types:\n\n"
    output = output .. "| Target Type | Description |\n"
    output = output .. "|------------|-------------|\n"
    output = output .. "| `self` | Affects the caster |\n"
    output = output .. "| `enemy` | Affects the opponent |\n"
    output = output .. "| `pool_self` | Affects the caster's mana pool |\n"
    output = output .. "| `pool_enemy` | Affects the opponent's mana pool |\n"
    output = output .. "| `slot_self` | Affects the caster's spell slots |\n"
    output = output .. "| `slot_enemy` | Affects the opponent's spell slots |\n"
    output = output .. "| `global` | Affects the game state |\n"
    output = output .. "| `none` | No specific target |\n\n"
    
    -- Multi-target spell example
    output = output .. "### Arcane Reversal (Multi-Target Example)\n\n"
    output = output .. "```lua\nSpells.arcaneReversal = {\n"
    output = output .. "    id = \"arcanereversal\",\n"
    output = output .. "    name = \"Arcane Reversal\",\n"
    output = output .. "    description = \"A complex spell that manipulates mana, movement, and timing simultaneously\",\n"
    output = output .. "    attackType = \"remote\",\n"
    output = output .. "    castTime = 6.0,\n"
    output = output .. "    cost = {\"moon\", \"star\", \"force\", \"force\"},\n"
    output = output .. "    keywords = {\n"
    output = output .. "        -- Apply damage to enemy\n"
    output = output .. "        damage = {\n"
    output = output .. "            amount = function(caster, target)\n"
    output = output .. "                -- More damage if enemy has active shields\n"
    output = output .. "                local shieldCount = 0\n"
    output = output .. "                for _, slot in ipairs(target.spellSlots) do\n"
    output = output .. "                    if slot.active and slot.isShield then\n"
    output = output .. "                        shieldCount = shieldCount + 1\n"
    output = output .. "                    end\n"
    output = output .. "                end\n"
    output = output .. "                return 8 + (shieldCount * 4)  -- 8 base + 4 per shield\n"
    output = output .. "            end,\n"
    output = output .. "            type = \"star\",\n"
    output = output .. "            target = \"ENEMY\"  -- Explicit targeting\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Move self to opposite range\n"
    output = output .. "        rangeShift = {\n"
    output = output .. "            position = function(caster, target)\n"
    output = output .. "                return caster.gameState.rangeState == \"NEAR\" and \"FAR\" or \"NEAR\"\n"
    output = output .. "            end,\n"
    output = output .. "            target = \"SELF\"  -- Different target from damage\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Lock opponent's mana tokens\n"
    output = output .. "        lock = {\n"
    output = output .. "            duration = 4.0,\n"
    output = output .. "            target = \"POOL_ENEMY\"  -- Target opponent's pool\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Add tokens to own pool\n"
    output = output .. "        conjure = {\n"
    output = output .. "            token = \"force\",\n"
    output = output .. "            amount = 1,\n"
    output = output .. "            target = \"POOL_SELF\"  -- Target own pool\n"
    output = output .. "        },\n"
    output = output .. "        \n"
    output = output .. "        -- Accelerate own next spell\n"
    output = output .. "        accelerate = {\n"
    output = output .. "            amount = 2.0,\n"
    output = output .. "            slot = 1,  -- First slot\n"
    output = output .. "            target = \"SLOT_SELF\"  -- Target own slot\n"
    output = output .. "        }\n"
    output = output .. "    },\n"
    output = output .. "    vfx = \"arcane_reversal\",\n"
    output = output .. "}\n```\n\n"
    
    -- Fireball example
    output = output .. "### Fireball\n\n"
    output = output .. "```lua\nSpells.fireball = {\n"
    output = output .. "    id = \"fireball\",\n"
    output = output .. "    name = \"Fireball\",\n"
    output = output .. "    description = \"Launches a ball of fire that deals heavy damage\",\n"
    output = output .. "    attackType = \"projectile\",\n"
    output = output .. "    castTime = 4.0,\n"
    output = output .. "    cost = {\"fire\", \"fire\", \"force\"},\n"
    output = output .. "    keywords = {\n"
    output = output .. "        damage = {\n"
    output = output .. "            amount = function(caster, target)\n"
    output = output .. "                -- More damage at FAR range\n"
    output = output .. "                return caster.gameState.rangeState == \"FAR\" and 18 or 12\n"
    output = output .. "            end,\n"
    output = output .. "            type = \"fire\"\n"
    output = output .. "            -- No target specified, uses default: ENEMY\n"
    output = output .. "        },\n"
    output = output .. "        -- Add AOE effect if cast from AERIAL\n"
    output = output .. "        zoneMulti = function(caster, target)\n"
    output = output .. "            return caster.elevation == \"AERIAL\"\n"
    output = output .. "        end\n"
    output = output .. "    },\n"
    output = output .. "    vfx = \"fireball\",\n"
    output = output .. "    sfx = \"explosion\",\n"
    output = output .. "}\n```\n\n"
    
    return output
end

-- Generate a documentation file
function DocGenerator.writeDocumentation(outputPath)
    outputPath = outputPath or "/Users/russell/Manastorm/docs/KEYWORDS.md"
    
    local markdown = DocGenerator.generateMarkdown()
    
    local file = io.open(outputPath, "w")
    if file then
        file:write(markdown)
        file:close()
        print("Keyword documentation written to: " .. outputPath)
        return true
    else
        print("Error: Could not open file for writing: " .. outputPath)
        return false
    end
end

-- Execute documentation generation if this file is run directly
if not ... then
    DocGenerator.writeDocumentation()
end

return DocGenerator```

## ./expr.lua
```lua
-- expr.lua
-- Expression helper functions for spell parameter evaluation

local Constants = require("core.Constants")
local ManaHelpers = require("systems.ManaHelpers")

local expr = {}

-- Choose whichever token is more abundant in the shared pool
function expr.more(a, b)
    return function(caster)
        local manaPool = caster and caster.manaPool
        return ManaHelpers.count(a, manaPool) > ManaHelpers.count(b, manaPool) and b or a
    end
end

-- Choose the scarcer token
function expr.less(a, b)
    return function(caster)
        local manaPool = caster and caster.manaPool
        return ManaHelpers.count(a, manaPool) < ManaHelpers.count(b, manaPool) and a or b
    end
end

-- Choose a token type based on a condition
function expr.ifCond(condition, trueValue, falseValue)
    return function(caster, target, slot)
        if condition(caster, target, slot) then
            return trueValue
        else
            return falseValue
        end
    end
end

-- Choose a value based on elevation state
function expr.byElevation(elevationValues)
    return function(caster, target, slot)
        local entityToCheck = target or caster
        local elevation = entityToCheck and entityToCheck.elevation or "GROUNDED"
        return elevationValues[elevation] or elevationValues.default
    end
end

-- Choose a value based on range state
function expr.byRange(rangeValues)
    return function(caster, target, slot)
        local rangeState = caster and caster.gameState and caster.gameState.rangeState or "NEAR"
        return rangeValues[rangeState] or rangeValues.default
    end
end

-- Choose a value based on which wizard has more tokens
function expr.whoHasMore(tokenType, casterValue, targetValue)
    return function(caster, target, slot)
        if not caster or not target or not caster.manaPool or not target.manaPool then
            return casterValue -- Default to caster value if we can't determine
        end
        
        local casterCount = ManaHelpers.count(tokenType, caster.manaPool)
        local targetCount = ManaHelpers.count(tokenType, target.manaPool)
        
        return casterCount >= targetCount and casterValue or targetValue
    end
end

-- Calculate a value based on the number of tokens
function expr.countScale(tokenType, baseValue, multiplier)
    return function(caster, target, slot)
        if not caster or not caster.manaPool then 
            return baseValue
        end
        
        local count = ManaHelpers.count(tokenType, caster.manaPool)
        return baseValue + (count * multiplier)
    end
end

return expr```

## ./keywords.lua
```lua
-- keywords.lua
-- Defines all keywords and their behaviors for the spell system
--
-- IMPORTANT: Keyword execute functions should create and return events rather than directly modifying game state.
-- The events are collected and processed by the EventRunner module.
--
-- When creating a new keyword, follow this pattern:
--
-- Keywords.newKeyword = {
--     behavior = {
--         -- Define behavior metadata here to document the effect
--         descriptiveProperty = true,
--         targetType = Constants.TargetType.ENEMY,
--         category = "CATEGORY"
--     },
--     
--     -- Implementation function should return events
--     execute = function(params, caster, target, results)
--         -- Create your event(s) here 
--         results.myEvent = {
--             type = "EVENT_TYPE", 
--             source = "caster",
--             target = "enemy",
--             property = params.property
--         }
--         
--         -- Return the results table containing events
--         return results
--     end
-- }
--
-- Parameter resolution:
-- Keyword parameters can now be static values or functions. If a function is provided, 
-- it will be called with (caster, target, slot) and the result used as the parameter value.
--
-- Example static parameter:
--   damage = { amount = 10 }
--
-- Example function parameter:
--   damage = { 
--     amount = function(caster, target, slot)
--       return target.elevation == "AERIAL" and 15 or 10
--     end
--   }
--
-- Example using expression helpers:
--   tokenShift = {
--     type = expr.more(Constants.TokenType.SUN, Constants.TokenType.MOON),
--     amount = 1
--   }
--
-- See docs/combat_events.md for the event schema and types.

local Constants = require("core.Constants")

-- Utility: resolve a param that may be a callable
local function resolve(value, caster, target, slot, default)
    if type(value) == "function" then
        local ok, result = pcall(value, caster, target, slot)
        return ok and result or default
    end
    return value ~= nil and value or default
end

local Keywords = {}

-- Export utility functions
Keywords.util = { resolve = resolve }

-- Keyword categories for organization
Keywords.categories = {
    DAMAGE = "Damage Effects",
    DOT = "Damage Over Time",
    TIMING = "Spell Timing",
    MOVEMENT = "Movement & Position",
    RESOURCE = "Resource Manipulation",
    TOKEN = "Token Manipulation",
    DEFENSE = "Defense Mechanisms",
    SPECIAL = "Special Effects",
    ZONE = "Zone Mechanics",
    TRAP = "Trap Mechanics"
}

-- Target types for keywords (legacy support - new code should use Constants.TargetType directly)

-- Sustained spell system keywords
-- These are keywords related to the sustained spell system, which allows spells
-- to continue occupying a slot after being cast (shields, traps, etc)

-- sustain: Marks a spell to remain active in its slot after casting
Keywords.sustain = {
    -- Behavior definition
    behavior = {
        marksSpellAsSustained = true,
        category = "TIMING"
    },
    
    -- Implementation function - Sets results.isSustained flag
    execute = function(params, caster, target, results, events)
        results.isSustained = true
        return results
    end
}

-- trap_trigger: Defines the condition that triggers a trap spell
Keywords.trap_trigger = {
    -- Behavior definition
    behavior = {
        storesTriggerCondition = true,
        category = "TRAP"
    },
    
    -- Implementation function - Stores trigger condition
    execute = function(params, caster, target, results, events)
        results.trapTrigger = params
        print(string.format("[TRAP] Stored trigger condition: %s", 
            params.condition or "unknown"))
        return results
    end
}


-- trap_effect: Defines the effect that occurs when a trap is triggered
Keywords.trap_effect = {
    -- Behavior definition
    behavior = {
        storesEffectPayload = true,
        category = "TRAP"
    },
    
    -- Implementation function - Stores effect payload
    execute = function(params, caster, target, results, events)
        results.trapEffect = params
        
        -- Get a list of the effects included
        local effectNames = {}
        for effectName, _ in pairs(params) do
            table.insert(effectNames, effectName)
        end
        
        -- Log the effects included
        if #effectNames > 0 then
            print(string.format("[TRAP] Stored effect payload with effects: %s", 
                table.concat(effectNames, ", ")))
        else
            print("[TRAP] Warning: Effect payload with no effects defined")
        end
        
        return results
    end
}

-- field_status: Defines a persistent status applied while the field is active
Keywords.field_status = {
    behavior = {
        marksSpellAsSustained = true,
        category = "FIELD"
    },

    execute = function(params, caster, target, results, events)
        results.fieldStatus = params
        results.isField = true
        results.isSustained = true
        return results
    end
}
Keywords.targetTypes = Constants.TargetType

-- ===== Core Combat Keywords =====

-- damage: Deals direct damage to a target
Keywords.damage = {
    -- Behavior definition
    behavior = {
        dealsDamage = true,
        targetType = Constants.TargetType.ENEMY,
        category = "DAMAGE",
        
        -- Default parameters
        defaultAmount = 0,
        defaultType = Constants.DamageType.GENERIC
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events, spell)
        -- Use resolve to handle conditional parameter
        local applyDamage = resolve(params.condition, caster, target, results.currentSlot, true)
        
        -- Only generate event if condition passed (or no condition)
        if applyDamage then
            -- Use resolve for damage amount and type
            local calculatedDamage = resolve(params.amount, caster, target, results.currentSlot, 0)
            local damageType = resolve(params.type, caster, target, results.currentSlot, Constants.DamageType.GENERIC)

            -- Get relevant token count from slot for manaCost approximation
            local manaCost = 0
            if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
                manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
            end

            -- Determine if we should delay damage display for visual sync
            local delayDamage = false
            
            -- For projectile and meteor spells, we want to delay damage until visual completes
            if spell and (spell.attackType == "projectile" or spell.attackType == "meteor" or
                          spell.visualShape == "meteor") then
                delayDamage = true
            end
            
            -- Generate event with enriched visual metadata
            table.insert(events or {}, {
                type = "DAMAGE", 
                source = "caster", 
                target = "enemy",
                amount = calculatedDamage, 
                damageType = damageType,
                scaledDamage = (type(params.amount) == "function"), -- Keep scaledDamage flag based on original param type
                -- Add delay flag for visual synchronization
                delayDamage = delayDamage,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { DAMAGE = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil,
                -- Add debug flag to track this event's flow
                _debug_enriched = true
            })
        end

        return results
    end
}

-- burn: Applies damage over time effect
Keywords.burn = {
    -- refactor to more consistent behavior: each second, apply damage equal to Burn X and --X.
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true,
        statusType = Constants.StatusType.BURN,
        dealsDamageOverTime = true,
        targetType = Constants.TargetType.ENEMY,
        category = "DOT",
        
        -- Default parameters
        defaultDuration = 3.0,
        defaultTickDamage = 2,
        defaultTickInterval = 1.0
    },
    
    -- Implementation function - Generates APPLY_STATUS event
    execute = function(params, caster, target, results, events, spell)
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end

        if params.target == Constants.TargetType.ALL then
            table.insert(events or {}, {
                type = "APPLY_STATUS",
                source = "caster",
                target = "self",
                statusType = Constants.StatusType.BURN,
                duration = params.duration or 3.0,
                tickDamage = params.tickDamage or 2,
                tickInterval = params.tickInterval or 1.0,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { BURN = true, DOT = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil
            })
            table.insert(events or {}, {
                type = "APPLY_STATUS",
                source = "caster",
                target = "enemy",
                statusType = Constants.StatusType.BURN,
                duration = params.duration or 3.0,
                tickDamage = params.tickDamage or 2,
                tickInterval = params.tickInterval or 1.0,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { BURN = true, DOT = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil
            })
        else
            table.insert(events or {}, {
                type = "APPLY_STATUS",
                source = "caster",
                target = params.target or "enemy",
                statusType = Constants.StatusType.BURN,
                duration = params.duration or 3.0,
                tickDamage = params.tickDamage or 2,
                tickInterval = params.tickInterval or 1.0,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                visualShape = spell and spell.visualShape or nil, -- Copy visualShape if present
                manaCost = manaCost,
                tags = { BURN = true, DOT = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = caster and caster.elevation or nil
            })
        end
        return results
    end
}

-- stagger: Interrupts a spell and prevents recasting for a duration
Keywords.stagger = {
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true, -- Assuming stagger applies a stun/daze status
        statusType = Constants.StatusType.STUN,      -- Using "stun" status for simplicity
        interruptsSpell = true,    -- Stagger implies interruption
        targetType = "ENEMY",     -- Typically targets enemy
        category = "TIMING",
        
        -- Default parameters
        defaultDuration = 3.0
    },
    
    -- Implementation function - Generates APPLY_STATUS event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "APPLY_STATUS",
            source = "caster",
            target = params.target or "enemy",
            statusType = "stun", -- Using "stun" as the status effect
            duration = params.duration or 3.0
        })
        
        -- Optionally, could also add a CANCEL_SPELL event if stagger should interrupt
        -- table.insert(events or {}, { type = "CANCEL_SPELL", target = "enemy_slot", ... })
        
        return results
    end
}

-- ===== Movement & Positioning Keywords =====

-- elevate: Sets a wizard to AERIAL state
Keywords.elevate = {
    -- Behavior definition
    behavior = {
        setsElevationState = Constants.ElevationState.AERIAL,
        hasDefaultDuration = true,
        targetType = Constants.TargetType.SELF,
        category = "MOVEMENT",
        
        -- Default parameters
        defaultDuration = 5.0,
        defaultVfx = "emberlift"
    },
    
    -- Implementation function - Generates SET_ELEVATION event
    execute = function(params, caster, target, results, events, spell)
        -- Create elevation event
        local vfxValue = params.vfx or "emberlift"
        -- Check if we have a vfx parameter that's a table and should be a string
        if type(vfxValue) == "table" and vfxValue.effect then
            vfxValue = vfxValue.effect
        end
        
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end
        
        table.insert(events or {}, {
            type = "SET_ELEVATION",
            source = "caster",
            target = params.target or "self", -- Use specified target or default to self
            elevation = Constants.ElevationState.AERIAL,
            duration = params.duration or 5.0,
            vfx = vfxValue,
            
            -- Visual metadata for VisualResolver
            affinity = spell and spell.affinity or nil,
            attackType = spell and spell.attackType or nil,
            manaCost = manaCost,
            tags = { MOVEMENT = true, ELEVATE = true },
            rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
            elevation = Constants.ElevationState.AERIAL  -- The new elevation state
        })
        return results
    end
}

-- ground: Forces a wizard to GROUNDED state
Keywords.ground = {
    -- Behavior definition
    behavior = {
        setsElevationState = Constants.ElevationState.GROUNDED,
        canBeConditional = true,
        targetType = Constants.TargetType.ENEMY,
        category = "MOVEMENT",
        defaultVfx = "tidal_force_ground" -- Add default VFX for ground
    },
    
    -- Implementation function - Generates SET_ELEVATION event
    execute = function(params, caster, target, results, events, spell)
        -- Use resolver for conditional parameter
        local applyGrounding = resolve(params.conditional, caster, target, results.currentSlot, true)
        
        if applyGrounding then
            -- Resolve other parameters
            local targetEntity = resolve(params.target, caster, target, results.currentSlot, "enemy")
            local vfxEffect = resolve(params.vfx, caster, target, results.currentSlot, "tidal_force_ground")
            
            -- Handle vfx parameter conversion if needed
            local vfxString = vfxEffect
            -- If vfxEffect is a table with an effect property, extract that string
            if type(vfxEffect) == "table" and vfxEffect.effect then
                vfxString = vfxEffect.effect
            end
            
            -- Get relevant token count from slot for manaCost approximation
            local manaCost = 0
            if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
                manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
            end
            
            table.insert(events or {}, {
                type = "SET_ELEVATION",
                source = "caster",
                target = targetEntity,
                elevation = Constants.ElevationState.GROUNDED,
                vfx = vfxString,
                
                -- Visual metadata for VisualResolver
                affinity = spell and spell.affinity or nil,
                attackType = spell and spell.attackType or nil,
                manaCost = manaCost,
                tags = { MOVEMENT = true, GROUND = true },
                rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                elevation = Constants.ElevationState.GROUNDED  -- The new elevation state
            })
        end
        return results
    end
}

-- rangeShift: Changes the range state (NEAR/FAR)
Keywords.rangeShift = {
    -- Behavior definition
    behavior = {
        setsRangeState = true,
        targetType = Constants.TargetType.SELF,
        category = "MOVEMENT",
        
        -- Default parameters
        defaultPosition = Constants.RangeState.NEAR 
    },
    
    -- Implementation function - Generates SET_RANGE event
    execute = function(params, caster, target, results, events)
        -- Use resolver for all parameters
        local targetPosition = resolve(params.position, caster, target, results.currentSlot, Constants.RangeState.NEAR)
        local targetEntity = resolve(params.target, caster, target, results.currentSlot, "self")
        
        table.insert(events or {}, {
            type = "SET_RANGE",
            source = "caster",
            target = targetEntity, -- Usually affects both, but can be targeted
            position = targetPosition
        })
        return results
    end
}

-- forcePull: Forces opponent to move to caster's range
Keywords.forcePull = {
    -- Behavior definition
    behavior = {
        forcesOpponentPosition = true,
        targetType = Constants.TargetType.ENEMY,
        category = "MOVEMENT"
    },
    
    -- Implementation function - Generates FORCE_POSITION event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "FORCE_POSITION",
            source = "caster",
            target = "enemy" -- Force position applies to the enemy relative to caster
        })
        return results
    end
}

-- ===== Resource & Token Keywords =====

-- conjure: Creates new tokens in the shared mana pool
Keywords.conjure = {
    -- Behavior definition
    behavior = {
        addsTokensToSharedPool = true,
        targetType = "POOL_SELF", -- Indicates who gets credit for the conjuring, not a separate pool
        category = "RESOURCE",
        
        -- Default parameters
        defaultTokenType = "fire",
        defaultAmount = 1
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events, spell)
        local tokenTypeParam = params.token or Constants.TokenType.FIRE -- Default if nil
        local amount = params.amount or 1
        local targetPool = params.target or "POOL_SELF" -- Default target pool

        events = events or {} -- Ensure events table exists

        -- Set the justConjuredMana flag on the wizard
        if caster and caster.justConjuredMana ~= nil then
            caster.justConjuredMana = true
        end
        
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end

        if type(tokenTypeParam) == "table" then
            -- Handle array of token types
            for _, specificTokenType in ipairs(tokenTypeParam) do
                for i = 1, amount do -- Assuming amount applies per token type
                    table.insert(events, {
                        type = "CONJURE_TOKEN",
                        source = "caster",
                        target = targetPool,
                        tokenType = specificTokenType,
                        amount = 1, -- Conjure one of this specific type
                        
                        -- Visual metadata for VisualResolver
                        affinity = spell and spell.affinity or nil,
                        attackType = spell and spell.attackType or nil,
                        manaCost = manaCost,
                        tags = { CONJURE = true, RESOURCE = true },
                        rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                        elevation = caster and caster.elevation or nil
                    })
                end
            end
        elseif type(tokenTypeParam) == "string" then
             -- Handle single token type string (original behavior)
             for i = 1, amount do
                 table.insert(events, {
                     type = "CONJURE_TOKEN",
                     source = "caster",
                     target = targetPool,
                     tokenType = tokenTypeParam,
                     amount = 1, -- Conjure one of this specific type
                     
                     -- Visual metadata for VisualResolver
                     affinity = spell and spell.affinity or nil,
                     attackType = spell and spell.attackType or nil,
                     manaCost = manaCost,
                     tags = { CONJURE = true, RESOURCE = true },
                     rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
                     elevation = caster and caster.elevation or nil
                 })
             end
        else
            print("WARN: Conjure keyword received unexpected token type: " .. type(tokenTypeParam))
        end
        
        -- Event-based system, no direct modification needed
        return results
    end
}

-- dissipate: Removes tokens from the shared mana pool
Keywords.dissipate = {
    -- Behavior definition
    behavior = {
        removesTokensFromSharedPool = true,
        targetType = "POOL_ENEMY", -- Indicates which player is causing the removal, not separate pools
        category = "RESOURCE",
        
        -- Default parameters
        defaultTokenType = "any",
        defaultAmount = 1
    },
    
    -- Implementation function - Generates DISSIPATE_TOKEN event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "DISSIPATE_TOKEN",
            source = "caster",
            target = "pool", -- Target the shared pool
            tokenType = params.token or "any",
            amount = params.amount or 1,
            dissipateTarget = params.target or "enemy" -- Specify whose tokens to target within the pool
        })
        return results
    end
}

-- tokenShift: Changes token types in the shared mana pool
Keywords.tokenShift = {
    -- Behavior definition
    behavior = {
        transformsTokensInSharedPool = true,
        targetType = "POOL_SELF", -- Indicates who initiates the transformation, not separate pools
        category = "RESOURCE",
        
        -- Default parameters
        defaultTokenType = "fire",
        defaultAmount = 1,
        supportedTypes = {"fire", "water", "salt", "sun", "moon", "star", "life", "mind", "void", "random"}
    },
    
    -- Implementation function - Generates SHIFT_TOKEN event
    execute = function(params, caster, target, results, events)
        local tokenType = resolve(params.type, caster, target, results.currentSlot, "fire")
        local amount = resolve(params.amount, caster, target, results.currentSlot, 1)
        
        table.insert(events or {}, {
            type = "SHIFT_TOKEN",
            source = "caster",
            target = "pool",
            tokenType = tokenType,
            amount = amount,
            shiftTarget = params.target or "self" -- Whose tokens to target within the pool
        })
        return results
    end
}

-- NEW KEYWORD: disruptAndShift
-- Removes a token from an opponent's channeling slot and changes its type
Keywords.disruptAndShift = {
    behavior = {
        disruptsChanneling = true,
        transformsTokens = true, -- Indicates it changes token type
        targetType = "SLOT_ENEMY", -- Targets an enemy spell slot
        category = "TOKEN",
        
        -- Default parameters
        defaultTargetType = "fire" -- Default type to shift to
    },
    
    -- Implementation function - Generates DISRUPT_AND_SHIFT event
    execute = function(params, caster, target, results, events)
        -- Determine target slot (using same logic as disjoint/cancel)
        local targetSlotIndex = 0
        if params.slot and type(params.slot) == "function" then
            targetSlotIndex = params.slot(caster, target, results.currentSlot)
        elseif params.slot then
            targetSlotIndex = params.slot
        end
        targetSlotIndex = tonumber(targetSlotIndex) or 0 -- 0 means random active

        -- Generate DISRUPT_AND_SHIFT event
        table.insert(events or {}, {
            type = "DISRUPT_AND_SHIFT",
            source = "caster",
            target = "enemy_slot", -- Target opponent's slot
            slotIndex = targetSlotIndex, -- 0 means random active slot handled by EventRunner
            newType = params.targetType or "fire" -- Type to shift the removed token to
        })
        
        return results
    end
}

-- ===== Cast Time Keywords =====

-- slow: Applies a status effect that increases the cast time of the opponent's next spell
Keywords.slow = {
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true,
        statusType = Constants.StatusType.SLOW,
        targetType = Constants.TargetType.ENEMY, -- Applies status to enemy wizard
        category = "TIMING",
        
        -- Default parameters
        defaultMagnitude = Constants.CastSpeed.ONE_TIER, -- How much to increase cast time by
        defaultDuration = 10.0, -- How long the slow effect waits for a cast
        defaultSlot = nil -- nil or 0 means next cast in any slot, 1/2/3 targets specific slot
    },
    
    -- Implementation function - Generates an APPLY_STATUS event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "APPLY_STATUS",
            source = "caster",
            target = params.target or "enemy", -- Target the enemy wizard entity
            statusType = Constants.StatusType.SLOW,
            magnitude = params.magnitude or Constants.CastSpeed.ONE_TIER, -- How much time to add
            duration = params.duration or 10.0, -- How long effect persists waiting for cast
            targetSlot = params.slot or nil -- Which slot to affect (nil for any)
        })
        return results
    end
}

-- accelerate: Reduces cast time of a spell
Keywords.accelerate = {
    -- Behavior definition
    behavior = {
        reducesSpellCastTime = true,
        targetType = "SLOT_SELF",
        category = "TIMING",
        
        -- Default parameters
        defaultAmount = 1.0
    },
    
    -- Implementation function - Generates ACCELERATE_SPELL event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "ACCELERATE_SPELL",
            source = "caster",
            target = "self_slot", -- Target own spell slot
            slotIndex = params.slot or 0, -- 0 means current/last cast slot
            amount = params.amount or 1.0
        })
        return results
    end
}

-- dispel: Cancels a spell and returns mana to the pool
Keywords.dispel = {
    -- Behavior definition
    behavior = {
        cancelsSpell = true,
        returnsManaToPool = true,
        targetType = "SLOT_ENEMY",
        category = "TIMING"
    },
    
    -- Implementation function - Generates CANCEL_SPELL event
    execute = function(params, caster, target, results, events)
        local targetSlotIndex = 0
        if params.slot and type(params.slot) == "function" then
            targetSlotIndex = params.slot(caster, target, results.currentSlot)
        elseif params.slot then
            targetSlotIndex = params.slot
        end
        targetSlotIndex = tonumber(targetSlotIndex) or 0

        table.insert(events or {}, {
            type = "CANCEL_SPELL",
            source = "caster",
            target = "enemy_slot",
            slotIndex = targetSlotIndex,
            returnMana = true -- Key difference for dispel
        })
        return results
    end
}

-- disjoint: Cancels a spell and destroys its mana
Keywords.disjoint = {
    -- Behavior definition
    behavior = {
        cancelsSpell = true,
        destroysMana = true,
        targetType = "SLOT_ENEMY",
        category = "TIMING"
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events)
        -- Use resolver to handle the slot parameter
        local targetSlotIndex = resolve(params.slot, caster, target, results.currentSlot, 0)
        targetSlotIndex = tonumber(targetSlotIndex) or 0 -- Ensure it's a number, default to 0
        
        -- Create a CANCEL_SPELL event with returnMana = false
        table.insert(events or {}, {
            type = "CANCEL_SPELL",
            source = "caster",
            target = "enemy_slot", -- Use string that EventRunner.resolveTarget understands
            slotIndex = targetSlotIndex, -- 0 means random active slot handled by EventRunner
            returnMana = false -- Key difference for disjoint
        })
        return results
    end
}

-- freeze: Pauses a spell's progress for a duration
Keywords.freeze = {
    -- Behavior definition
    behavior = {
        pausesSpellProgress = true,
        targetType = "SLOT_ENEMY", -- Can be overridden by spell
        category = "TIMING",
        
        -- Default parameters
        defaultSlot = 2,  -- Default to middle slot
        defaultDuration = 2.0
    },
    
    -- Implementation function
    execute = function(params, caster, target, results, events)
        -- Get the slot to target (default to middle slot)
        local targetSlot = params.slot or 2  
        
        -- Determine the target entity (caster or enemy)
        local targetEntity = params.target or "enemy_slot" -- Default to enemy if not specified
        
        -- Make sure we have an events table
        events = events or {}
        
        -- Create a FREEZE_SPELL event directly, using the targetEntity
        table.insert(events, {
            type = "FREEZE_SPELL",
            source = "caster",
            target = targetEntity, -- Use the resolved target (e.g., "self" or "enemy_slot")
            slotIndex = targetSlot, -- Use specified slot or default 2
            duration = params.duration or 2.0
        })
        return results
    end
}

-- ===== Defense Keywords =====

-- block: Creates a shield to block specific attack types
Keywords.block = {
    -- Behavior definition
    behavior = {
        createsShield = true,
        targetType = "SELF",
        category = "DEFENSE",
        marksSpellAsSustained = true,
        
        -- Shield properties
        shieldTypes = {"barrier", "ward"},
        attackTypes = {"projectile", "remote", "zone"}
    },
    
    -- Implementation function - Generates CREATE_SHIELD event
    execute = function(params, caster, target, results, events, spell)
        -- Mark the spell as sustained
        results.isSustained = true
        print("[DEBUG] Block keyword setting results.isSustained = true")
        
        -- Get relevant token count from slot for manaCost approximation
        local manaCost = 0
        if caster and caster.spellSlots and results.currentSlot and caster.spellSlots[results.currentSlot] then
            manaCost = #(caster.spellSlots[results.currentSlot].tokens or {})
        end
        
        table.insert(events or {}, {
            type = "CREATE_SHIELD",
            source = "caster",
            target = "self_slot", -- Shields are created in the caster's slot
            slotIndex = results.currentSlot, -- Use the slot the spell was cast from
            defenseType = params.type or "barrier",
            blocksAttackTypes = params.blocks or {"projectile"},
            reflect = params.reflect or false,
            onBlock = params.onBlock, -- Add support for the onBlock callback
            
            -- Visual metadata for VisualResolver
            affinity = spell and spell.affinity or nil,
            attackType = spell and spell.attackType or nil,
            manaCost = manaCost,
            tags = { SHIELD = true, DEFENSE = true },
            rangeBand = caster and caster.gameState and caster.gameState.rangeState or nil,
            elevation = caster and caster.elevation or nil
        })
        return results
    end
}

-- reflect: Reflects incoming spells
Keywords.reflect = {
    -- Behavior definition
    behavior = {
        appliesStatusEffect = true, -- Reflect handled as a status effect
        statusType = Constants.StatusType.REFLECT,
        targetType = "SELF",
        category = "DEFENSE",
        
        -- Default parameters
        defaultDuration = 3.0
    },
    
    -- Implementation function - Generates APPLY_STATUS event
    execute = function(params, caster, target, results, events)
         table.insert(events or {}, {
            type = "APPLY_STATUS",
            source = "caster",
            target = "self",
            statusType = Constants.StatusType.REFLECT,
            duration = params.duration or 3.0
        })
        return results
    end
}

-- ===== Special Effect Keywords =====

-- echo: Recasts the spell after a delay
Keywords.echo = {
    -- Behavior definition
    behavior = {
        recastsSpell = true,
        targetType = "SLOT_SELF",
        category = "SPECIAL",
        
        -- Default parameters
        defaultDelay = 2.0
    },
    
    -- Implementation function - New event-based pattern
    execute = function(params, caster, target, results, events)
        -- Create an ECHO event directly
        table.insert(events or {}, {
            type = "ECHO",
            source = "caster",
            target = "self_slot",
            slotIndex = results.currentSlot, -- Use the current slot or specified one
            delay = params.delay or 2.0
        })
        return results
    end
}

-- ===== Zone Keywords =====

-- zoneAnchor: Locks spell to cast-time range; fails if range changes
Keywords.zoneAnchor = {
    -- Behavior definition
    behavior = {
        anchorsSpellToConditions = true,
        targetType = "SELF",
        category = "ZONE",
        
        -- Parameters
        conditionTypes = {"range", "elevation"}
    },
    
    -- Implementation function - Generates ZONE_ANCHOR event
    execute = function(params, caster, target, results, events)
        local anchorRange = "ANY"
        local anchorElevation = "ANY"
        
        if params.range then
            anchorRange = params.range
        elseif caster and caster.gameState then
            anchorRange = caster.gameState.rangeState
        end
        
        if params.elevation then
            anchorElevation = params.elevation
        elseif target then
            anchorElevation = target.elevation
        end
        
        local requireAll = params.requireAll
        if requireAll == nil then requireAll = true end
        
        table.insert(events or {}, {
            type = "ZONE_ANCHOR",
            source = "caster",
            target = "self_slot",
            slotIndex = results.currentSlot,
            anchorRange = anchorRange,
            anchorElevation = anchorElevation,
            requireAll = requireAll
        })
        return results
    end
}

-- zoneMulti: Makes zone affect both NEAR and FAR ranges
Keywords.zoneMulti = {
    -- Behavior definition
    behavior = {
        affectsBothRanges = true,
        targetType = "SELF",
        category = "ZONE"
    },
    
    -- Implementation function - Generates ZONE_MULTI event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "ZONE_MULTI",
            source = "caster",
            target = "self_slot",
            slotIndex = results.currentSlot
        })
        return results
    end
}

-- consume: Permanently removes the tokens channeled to cast this spell
Keywords.consume = {
    -- Behavior definition
    behavior = {
        destroysChanneledTokens = true,
        targetType = "SLOT_SELF",
        category = "RESOURCE",
        
        -- Default parameters
        defaultAmount = "all" -- By default, consume all channeled tokens
    },
    
    -- Implementation function - Generates CONSUME_TOKENS event
    execute = function(params, caster, target, results, events)
        table.insert(events or {}, {
            type = "CONSUME_TOKENS",
            source = "caster",
            target = "self_slot", -- Target own spell slot
            slotIndex = results.currentSlot, -- Use the slot the spell was cast from
            amount = params.amount or "all" -- "all" means consume all tokens used for the spell
        })
        return results
    end
}

-- vfx: Handles explicit visual effect overrides for spells
Keywords.vfx = {
    behavior = {
        overridesVisualEffect = true,
        category = "SPECIAL"
    },
    execute = function(params, caster, target, results, events, spell)
        -- Instead of creating an event, just set effectOverride in results
        if params.effect then
            -- Get the effect type, whether it's a string or constant
            local effectType
            if type(params.effect) == "string" then
                effectType = params.effect
            else
                effectType = params.effect
            end
            
            -- Store the override in the results object
            results.effectOverride = effectType
            
            -- Debug output
            print(string.format("[VFX KEYWORD] Setting effectOverride: %s for %s", 
                tostring(effectType),
                caster and caster.name or "unknown"))
        end
        
        -- Also store any other relevant parameters
        if params.duration then
            results.effectDuration = params.duration
        end
        
        if params.target then
            results.effectTarget = params.target
        end
        
        -- Store other vfx parameters that might be useful
        results.vfxParams = params
        
        return results
    end
}

return Keywords

```

## ./main.lua
```lua
-- Manastorm - Wizard Duel Game
-- Main game file

-- Load dependencies
local AssetCache = require("core.AssetCache")
local AssetPreloader = require("core.assetPreloader")
local Constants = require("core.Constants")
local Input = require("core.Input")
local Pool = require("core.Pool")
local Wizard = require("wizard")
local ManaPool = require("manapool")
local UI = require("ui")
local VFX = require("vfx")
local Keywords = require("keywords")
local SpellCompiler = require("spellCompiler")
local SpellsModule = require("spells") -- Now using the modular spells structure
local SustainedSpellManager = require("systems.SustainedSpellManager")
local Settings = require("core.Settings")
local Tips = require("core.Tips")
local OpponentAI = require("ai.OpponentAI")
local SelenePersonality = require("ai.personalities.SelenePersonality")
local AshgarPersonality = require("ai.personalities.AshgarPersonality")
local SilexPersonality = require("ai.personalities.SilexPersonality")
local BorrakPersonality = require("ai.personalities.BorrakPersonality")
local CharacterData = require("characterData")

-- Resolution settings
local baseWidth = 800    -- Base design resolution width
local baseHeight = 600   -- Base design resolution height
local scale = 1          -- Current scaling factor
local offsetX = 0        -- Horizontal offset for pillarboxing
local offsetY = 0        -- Vertical offset for letterboxing

-- Screen shake variables
local shakeTimer = 0
local shakeIntensity = 0

-- Hitstop variables
local hitstopTimer = 0

-- Game state (globally accessible)
game = {
    wizards = {},
    manaPool = nil,
    font = nil,
    characterData = CharacterData,
    rangeState = Constants.RangeState.FAR,  -- Initial range state (NEAR or FAR)
    gameOver = false,
    winner = nil,
    winScreenTimer = 0,
    winScreenDuration = 5,  -- How long to show the win screen before auto-reset
    keywords = Keywords,
    spellCompiler = SpellCompiler,
    -- State management
    currentState = "MENU", -- Start in the menu state (MENU, CHARACTER_SELECT, BATTLE, GAME_OVER, BATTLE_ATTRACT, GAME_OVER_ATTRACT, CAMPAIGN_MENU, CAMPAIGN_VICTORY, CAMPAIGN_DEFEAT)
    campaignProgress = nil, -- Holds campaign run info when active
    -- Game mode
    useAI = false,         -- Whether to use AI for the second player
    -- Gamepad identifiers (assigned when controllers connect)
    p1GamepadID = nil,
    p2GamepadID = nil,
    p2UsingGamepad = false,
    -- Attract mode properties
    attractModeActive = false,
    menuIdleTimer = 0,
    ATTRACT_MODE_DELAY = 15, -- Start attract mode after 15 seconds of inactivity
    settings = Settings,
    settingsMenu = {
        selected = 1,
        mode = nil,
        waitingForKey = nil,
        bindOrder = {
            {"p1","slot1","P1 Slot 1"},
            {"p1","slot2","P1 Slot 2"},
            {"p1","slot3","P1 Slot 3"},
            {"p1","cast","P1 Cast"},
            {"p2","slot1","P2 Slot 1"},
            {"p2","slot2","P2 Slot 2"},
            {"p2","slot3","P2 Slot 3"},
            {"p2","cast","P2 Cast"}
        },
        rebindIndex = 1,
        rebindSelection = 1,
        rebindPlayerType = nil,
        rebindActionList = nil,
        rebindOptions = nil
    },
    -- Resolution properties
    baseWidth = baseWidth,
    baseHeight = baseHeight,
    scale = scale,
    offsetX = offsetX,
    offsetY = offsetY,
    currentTip = nil
}

-- Helper function to trigger screen shake
function triggerShake(duration, intensity)
    shakeTimer = duration or 0.5
    shakeIntensity = intensity or 5
    print("Screen shake triggered: " .. duration .. "s, intensity " .. intensity)
end

-- Helper function to trigger hitstop (game pause)
function triggerHitstop(duration)
    hitstopTimer = duration or 0.1
    print("Hitstop triggered: " .. duration .. "s")
end

-- Make these functions available to other modules through the game table
game.triggerShake = triggerShake
game.triggerHitstop = triggerHitstop

-- Define token types and images (globally available for consistency)
game.tokenTypes = {
    Constants.TokenType.FIRE, 
    Constants.TokenType.WATER, 
    Constants.TokenType.SALT, 
    Constants.TokenType.SUN, 
    Constants.TokenType.MOON, 
    Constants.TokenType.STAR,
    Constants.TokenType.LIFE,
    Constants.TokenType.MIND,
    Constants.TokenType.VOID
}
game.tokenImages = {
    [Constants.TokenType.FIRE] = "assets/sprites/v2Tokens/fire-token.png",
    [Constants.TokenType.WATER] = "assets/sprites/v2Tokens/water-token.png",
    [Constants.TokenType.SALT] = "assets/sprites/v2Tokens/salt-token.png",
    [Constants.TokenType.SUN] = "assets/sprites/v2Tokens/sun-token.png",
    [Constants.TokenType.MOON] = "assets/sprites/v2Tokens/moon-token.png",
    [Constants.TokenType.STAR] = "assets/sprites/v2Tokens/star-token.png",
    [Constants.TokenType.LIFE] = "assets/sprites/v2Tokens/life-token.png",
    [Constants.TokenType.MIND] = "assets/sprites/v2Tokens/mind-token.png",
    [Constants.TokenType.VOID] = "assets/sprites/v2Tokens/void-token.png"
}

-- Character roster and unlocks
game.characterRoster = {
    "Ashgar", "Borrak", "Silex",
    "Brightwulf", "Selene", "Klaus",
    "Ohm", "Archive", "End"
}

game.unlockedCharacters = {
    Ashgar = true,
    Borrak = true,
    Silex = false,
    Selene = true,
    Brightwulf = true,
    Klaus = false,
    Ohm = false,
    Archive = false,
    End = false
}

-- Spells unlocked for customization
game.unlockedSpells = {
    conjurefire = true,
    firebolt = true,
    fireball = true,
    burnToAsh = true,
    blastwave = true,
    saltcircle = true,
    eruption = true,

    conjuremoonlight = true,
    wrapinmoonlight = true,
    moondance = true,
    infiniteprocession = true,
    eclipse = true,
    gravityTrap = true,
    fullmoonbeam = true,

    conjuresalt = true,
    glitterfang = true,
    imprison = true,
    stoneshield = true,
    shieldbreaker = true,
    saltstorm = true,

    conjurewater = true,
    watergun = true,
    riptideguard = true,
    tidalforce = true,
    brinechain = true,
    maelstrom = true,
    wavecrash = true,
    desperationfire = true,
    moondrain = true,
}

-- Custom spellbooks configured by the player
game.customSpellbooks = {}

game.compendium = {
    page = 1,
    cursor = 1,
    scrollOffset = 0,
    assignFeedback = {
        active = false,
        slot = 0,
        timer = 0
    }
}

-- Temporary state for the campaign character selection menu
game.campaignMenu = {
    selectedCharacterIndex = 1
}

-- Get a list of all unlocked characters in the roster
local function getUnlockedCharacterList()
    local list = {}
    for _, name in ipairs(game.characterRoster) do
        if game.unlockedCharacters[name] then
            table.insert(list, name)
        end
    end
    return list
end

-- Helper to grab an AI personality for a given character name
local function getPersonalityFor(name)
    if name == "Selene" then
        return SelenePersonality
    elseif name == "Ashgar" then
        return AshgarPersonality
    elseif name == "Borrak" then
        return BorrakPersonality
    elseif name == "Silex" then
        return SilexPersonality
    else
        return nil
    end
end

game.characterSelect = {
    stage = 1, -- 1: choose player, 2: choose opponent, 3: confirm
    cursor = 1,
    selected = {nil, nil}
}

-- Helper function to add a random token to the mana pool
function game.addRandomToken()
    local randomType = game.tokenTypes[math.random(#game.tokenTypes)]
    game.manaPool:addToken(randomType, game.tokenImages[randomType])
    return randomType
end

-- Calculate the appropriate scaling for the current window size
function calculateScaling()
    local windowWidth, windowHeight = love.graphics.getDimensions()
    
    -- Calculate potential scales based on window dimensions
    local scaleX = windowWidth / baseWidth
    local scaleY = windowHeight / baseHeight
    
    -- Use the smaller scale factor to maintain aspect ratio and fit within the window
    scale = math.min(scaleX, scaleY)
    
    -- Calculate offsets needed to center the scaled content
    offsetX = (windowWidth - baseWidth * scale) / 2
    offsetY = (windowHeight - baseHeight * scale) / 2
    
    -- Update global references
    game.scale = scale
    game.offsetX = offsetX
    game.offsetY = offsetY
    
    print("Window resized: " .. windowWidth .. "x" .. windowHeight .. " -> Simple scale: " .. scale .. ", Offset: (" .. offsetX .. ", " .. offsetY .. ")")
end

-- Set a scissor rectangle taking current scale and offsets into account
local function setScaledScissor(x, y, w, h)
    love.graphics.setScissor(
        offsetX + x * scale,
        offsetY + y * scale,
        w * scale,
        h * scale
    )
end

-- Handle window resize events
function love.resize(width, height)
    calculateScaling()
end

-- Set up pixel art-friendly scaling
-- function configurePixelArtRendering()
--     -- Disable texture filtering for crisp pixel art
--     love.graphics.setDefaultFilter("nearest", "nearest", 1)
--     
--     -- Use integer scaling when possible
--     love.graphics.setLineStyle("rough")
-- end

function love.load()
    -- Set up window
    love.window.setTitle("Manastorm - Realtime Strategic Wizard Duels")
    
    -- Configure pixel art rendering -- REMOVE THIS CALL
    -- configurePixelArtRendering()

    -- Set default texture filtering for sharper (potentially pixelated) look
    love.graphics.setDefaultFilter("nearest", "nearest")
    
    -- Calculate initial scaling
    calculateScaling()
    
    -- Load background image
    game.backgroundImage = AssetCache.getImage("assets/sprites/background.png")
    
    -- Preload all assets to prevent in-game loading hitches
    print("Preloading game assets...")
    local preloadStats = AssetPreloader.preloadAllAssets()
    print(string.format("Asset preloading complete: %d images, %d sounds in %.2f seconds",
                        preloadStats.imageCount,
                        preloadStats.soundCount,
                        preloadStats.loadTime))

    -- Load persisted settings
    Settings.load()
    Constants.setCastSpeedSet(Settings.get("gameSpeed") or "FAST")
    
    -- Set up game object to have calculateScaling function that can be called by Input
    game.calculateScaling = calculateScaling
    
    -- Load game font
    -- For now, fall back to system font if custom font isn't available
    local fontPath = "assets/fonts/LionscriptNew-Regular.ttf"
    local fontExists = love.filesystem.getInfo(fontPath)
    
    if fontExists then
        game.font = love.graphics.newFont(fontPath, 16)
        print("Using custom game font: " .. fontPath)
    else
        game.font = love.graphics.newFont(16)  -- Default system font
        print("Custom font not found, using system font")
    end
    
    -- Set default font for normal rendering
    love.graphics.setFont(game.font)

    -- Load gameplay tips
    Tips.load("assets/text/tips.json")
    
    -- Create mana pool positioned above the battlefield, but below health bars
    game.manaPool = ManaPool.new(baseWidth/2, 120)  -- Positioned between health bars and wizards
    
    -- Create wizards - moved lower on screen to allow more room for aerial movement
    local d1 = CharacterData.Ashgar
    local d2 = CharacterData.Selene
    game.wizards[1] = Wizard.new("Ashgar", 200, 370, d1.color, d1.spellbook)
    game.wizards[2] = Wizard.new("Selene", 600, 370, d2.color, d2.spellbook)
    
    -- Set up references
    for _, wizard in ipairs(game.wizards) do
        wizard.manaPool = game.manaPool
        wizard.gameState = game
    end
    
    -- Initialize VFX system
    game.vfx = VFX.init()
    
    -- Make screen shake and hitstop functions directly available to VFX module
    VFX.triggerShake = triggerShake
    VFX.triggerHitstop = triggerHitstop
    
    -- Precompile all spells for better performance
    print("Precompiling all spells...")
    
    -- Create a compiledSpells table and do the compilation ourselves
    game.compiledSpells = {}
    
    -- Get all spells from the SpellsModule
    local allSpells = SpellsModule.spells
    
    -- Compile each spell
    for id, spell in pairs(allSpells) do
        game.compiledSpells[id] = game.spellCompiler.compileSpell(spell, game.keywords)
        print("Compiled spell: " .. spell.name)
    end
    
    -- Count compiled spells
    local count = 0
    for _ in pairs(game.compiledSpells) do
        count = count + 1
    end
    
    print("Precompiled " .. count .. " spells")
    
    -- Create custom shield spells just for hotkeys
    -- These are complete, independent spell definitions
    game.customSpells = {}
    
    -- Define Moon Ward with minimal dependencies
    game.customSpells.moonWard = {
        id = "customMoonWard",
        name = "Moon Ward",
        description = "A mystical ward that blocks projectiles and remotes",
        attackType = Constants.AttackType.UTILITY,
        castTime = 4.5,
        cost = {Constants.TokenType.MOON, Constants.TokenType.MOON},
        keywords = {
            block = {
                type = Constants.ShieldType.WARD,
                blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.REMOTE},
                manaLinked = true
            }
        },
        vfx = "moon_ward",
        sfx = "shield_up",
    }
    
    -- Define Mirror Shield with minimal dependencies
    game.customSpells.mirrorShield = {
        id = "customMirrorShield",
        name = "Mirror Shield",
        description = "A reflective barrier that returns damage to attackers",
        attackType = Constants.AttackType.UTILITY,
        castTime = 5.0,
        cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.STAR},
        keywords = {
            block = {
                type = Constants.ShieldType.BARRIER,
                blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
                manaLinked = false,
                reflect = true,
                hitPoints = 3
            }
        },
        vfx = "mirror_shield",
        sfx = "crystal_ring",
    }
    
    -- Compile custom spells too
    for id, spell in pairs(game.customSpells) do
        game.compiledSpells[id] = game.spellCompiler.compileSpell(spell, game.keywords)
        print("Compiled custom spell: " .. spell.name)
    end
    
    -- Initialize mana pool with a single random token to start
    local tokenType = game.addRandomToken()
    
    -- Log which token was added
    print("Starting the game with a single " .. tokenType .. " token")
    
    -- Initialize input system with game state reference
    Input.init(game)
    print("Input system initialized")
    
    -- Initialize SustainedSpellManager
    game.sustainedSpellManager = SustainedSpellManager
    print("SustainedSpellManager initialized")
    
    -- We'll initialize the AI opponent when starting a game with AI
    -- instead of here, so it's not always active
end

-- Display hotkey help overlay
function drawHotkeyHelp()
    local x = baseWidth - 300
    local y = 50
    local lineHeight = 20
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", x - 10, y - 10, 290, 500)
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print("HOTKEY REFERENCE", x, y)
    y = y + lineHeight * 2
    
    -- System keys
    love.graphics.setColor(0.8, 0.8, 1, 1)
    love.graphics.print("SYSTEM:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.system) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    y = y + lineHeight/2
    
    -- Player 1 keys
    love.graphics.setColor(1, 0.5, 0.5, 1)
    love.graphics.print("PLAYER 1:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.player1) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    y = y + lineHeight/2
    
    -- Player 2 keys
    love.graphics.setColor(0.5, 0.5, 1, 1)
    love.graphics.print("PLAYER 2:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.player2) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    y = y + lineHeight/2
    
    -- Debug keys
    love.graphics.setColor(0.8, 1, 0.8, 1)
    love.graphics.print("DEBUG:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.debug) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
    
    -- Testing keys
    y = y + lineHeight/2
    love.graphics.setColor(1, 0.8, 0.5, 1)
    love.graphics.print("TESTING:", x, y)
    y = y + lineHeight
    love.graphics.setColor(1, 1, 1, 0.8)
    for i, key in ipairs(Input.reservedKeys.testing) do
        love.graphics.print("  " .. key, x, y)
        y = y + lineHeight
    end
end

-- Reset the game
function resetGame()
    -- Reset game state
    game.gameOver = false
    game.winner = nil
    game.winScreenTimer = 0
    game.currentTip = nil
    
    -- Reset wizards
    for _, wizard in ipairs(game.wizards) do
        wizard.health = 100
        wizard.elevation = Constants.ElevationState.GROUNDED
        wizard.elevationTimer = 0
        if wizard.statusEffects and wizard.statusEffects[Constants.StatusType.STUN] then
            wizard.statusEffects[Constants.StatusType.STUN].active = false
            wizard.statusEffects[Constants.StatusType.STUN].duration = 0
            wizard.statusEffects[Constants.StatusType.STUN].elapsed = 0
            wizard.statusEffects[Constants.StatusType.STUN].totalTime = 0
        end
        
        -- Reset spell slots
        for i = 1, 3 do
            wizard.spellSlots[i] = {
                active = false,
                progress = 0,
                spellType = nil,
                castTime = 0,
                tokens = {},
                isShield = false,
                defenseType = nil,
                shieldStrength = 0,
                blocksAttackTypes = nil,
                wasAlreadyCast = false -- Add this flag to prevent repeated spell casts
            }
        end
        
        -- Reset status effects
        wizard.statusEffects[Constants.StatusType.BURN].active = false
        wizard.statusEffects[Constants.StatusType.BURN].duration = 0
        wizard.statusEffects[Constants.StatusType.BURN].tickDamage = 0
        wizard.statusEffects[Constants.StatusType.BURN].tickInterval = 1.0
        wizard.statusEffects[Constants.StatusType.BURN].elapsed = 0
        wizard.statusEffects[Constants.StatusType.BURN].totalTime = 0
        
        -- Reset blockers
        if wizard.blockers then
            for blockType in pairs(wizard.blockers) do
                wizard.blockers[blockType] = 0
            end
        end
        
        -- Reset spell keying
        wizard.activeKeys = {[1] = false, [2] = false, [3] = false}
        wizard.currentKeyedSpell = nil
    end
    
    -- Reset range state
    game.rangeState = Constants.RangeState.FAR
    
    -- Clear sustained spells
    if game.sustainedSpellManager then
        game.sustainedSpellManager.activeSpells = {}
    end
    
    -- Clear mana pool and add a single token to start
    if game.manaPool then
        game.manaPool:clear()
        local tokenType = game.addRandomToken()
        print("Game reset! Starting with a single " .. tokenType .. " token")
    end
    
    -- Reinitialize AI opponent if AI mode is enabled and not being set up by campaign
    if game.useAI then
        if not game.isSettingUpCampaignBattle then
            local aiWizard = game.wizards[2]
            local personality = getPersonalityFor(aiWizard.name)
            if personality then
                print("Initializing " .. aiWizard.name .. " AI personality")
            else
                print("Unknown wizard type: " .. aiWizard.name .. ". Using default personality.")
            end
            game.opponentAI = OpponentAI.new(aiWizard, game, personality)
            print("AI opponent reinitialized with personality: " .. (personality and personality.name or "Default"))
        end
    else
        -- Disable AI if we're switching to PvP mode
        game.opponentAI = nil
    end
    
    -- Reset health display animation state
    if UI and UI.healthDisplay then
        for i = 1, 2 do
            local display = UI.healthDisplay["player" .. i]
            if display then
                display.currentHealth = 100
                display.targetHealth = 100
                display.pendingDamage = 0
                display.lastDamageTime = 0
            end
        end
    end
    
    -- The current state is handled by the caller
    print("Game reset complete")
end

-- Add resetGame function to game state so Input system can call it
function game.resetGame()
    resetGame()
end

-- Function to start an AI vs AI attract mode game
function startGameAttractMode()
    print("Starting attract mode...")

    -- Mark attract mode as active
    game.attractModeActive = true

    -- Reset the game to clear any existing state
    resetGame()

    -- Choose two random unlocked characters
    local unlocked = getUnlockedCharacterList()
    if #unlocked < 2 then
        print("Not enough unlocked characters for attract mode")
        return
    end

    local name1 = unlocked[math.random(#unlocked)]
    local name2 = unlocked[math.random(#unlocked)]
    while name2 == name1 do
        name2 = unlocked[math.random(#unlocked)]
    end

    setupWizards(name1, name2)

    -- Temporarily store input routes so we can restore them later
    game.savedInputRoutes = {
        p1 = Input.Routes.p1,
        p2 = Input.Routes.p2
    }

    -- Disable player input during attract mode
    Input.Routes.p1 = {}
    Input.Routes.p2 = {}

    -- Make sure AI mode is enabled but not tracked by the normal flag
    -- This way we can have two AI players without affecting the normal mode
    game.useAI = false

    -- Create AIs for both players
    game.player1AI = OpponentAI.new(game.wizards[1], game, getPersonalityFor(name1))
    game.player2AI = OpponentAI.new(game.wizards[2], game, getPersonalityFor(name2))

    -- Reset idle timer
    game.menuIdleTimer = 0

    -- Transition to the attract mode battle state
    game.currentState = "BATTLE_ATTRACT"

    print("Attract mode started: " .. game.wizards[1].name .. " vs " .. game.wizards[2].name)
end

-- Function to exit attract mode and return to the menu
function exitAttractMode()
    print("Exiting attract mode...")

    -- Disable attract mode
    game.attractModeActive = false

    -- Clean up AI instances
    game.player1AI = nil
    game.player2AI = nil

    -- Reset the game
    resetGame()

    -- Restore input routes if we saved them
    if game.savedInputRoutes then
        Input.Routes.p1 = game.savedInputRoutes.p1
        Input.Routes.p2 = game.savedInputRoutes.p2
        game.savedInputRoutes = nil
    end

    -- Reset idle timer
    game.menuIdleTimer = 0

    -- Return to menu
    game.currentState = "MENU"

    print("Attract mode ended, returned to menu")
end

-- Handle successful completion of a campaign
function handleCampaignVictory()
    if not game.campaignProgress then return end
    print(game.campaignProgress.characterName .. " campaign complete! Wins: " .. game.campaignProgress.wins)
    game.currentState = "CAMPAIGN_VICTORY"
end

-- Handle failure of a campaign run
function handleCampaignDefeat()
    if not game.campaignProgress then return end
    print(game.campaignProgress.characterName .. " campaign failed at opponent " .. game.campaignProgress.currentOpponentIndex)
    resetGame()
    game.currentState = "CAMPAIGN_DEFEAT"
end

-- Restart the entire campaign from the first opponent
function restartCampaign()
    if not game.campaignProgress then return end
    game.campaignProgress.currentOpponentIndex = 1
    game.campaignProgress.wins = 0
    startCampaignBattle()
end

-- Retry the current campaign battle
function retryCampaignBattle()
    if not game.campaignProgress then return end
    startCampaignBattle()
end

-- Expose campaign helpers
game.restartCampaign = restartCampaign
game.retryCampaignBattle = retryCampaignBattle

-- Placeholder implementation for starting a campaign battle
function startCampaignBattle()
    if not game.campaignProgress then
        print("ERROR: startCampaignBattle called without campaignProgress")
        return
    end

    local playerCharacterName = game.campaignProgress.characterName
    local opponentIndex = game.campaignProgress.currentOpponentIndex or 1
    local playerData = game.characterData[playerCharacterName] or {}
    local opponentName
    if playerData.campaignOpponents then
        opponentName = playerData.campaignOpponents[opponentIndex]
    end

    if not opponentName then
        if handleCampaignVictory then
            handleCampaignVictory()
        else
            print("Campaign complete for " .. tostring(playerCharacterName))
        end
        return
    end

    setupWizards(playerCharacterName, opponentName)

    game.useAI = true

    local personality = getPersonalityFor(opponentName)
    game.opponentAI = OpponentAI.new(game.wizards[2], game, personality)

    game.isSettingUpCampaignBattle = true
    resetGame()
    game.isSettingUpCampaignBattle = nil

    game.currentState = "BATTLE"
end

-- Initialize wizards for battle based on selected names
function setupWizards(name1, name2)
    local data1 = game.characterData[name1] or {}
    local data2 = game.characterData[name2] or {}
    local book1 = game.customSpellbooks[name1] or data1.spellbook
    local book2 = game.customSpellbooks[name2] or data2.spellbook
    game.wizards[1] = Wizard.new(name1, 200, 370, data1.color or {255,255,255}, book1)
    game.wizards[2] = Wizard.new(name2, 600, 370, data2.color or {255,255,255}, book2)
    for _, wizard in ipairs(game.wizards) do
        wizard.manaPool = game.manaPool
        wizard.gameState = game
    end
end

-- Start character selection
function game.startCharacterSelect()
    game.characterSelect.stage = 1
    game.characterSelect.cursor = 1
    game.characterSelect.selected = {nil,nil}
    game.useAI = true -- default to AI opponent
    game.p2UsingGamepad = false
    game.currentState = "CHARACTER_SELECT"
end

-- Move selection cursor
function game.characterSelectMove(dir)
    local count = #game.characterRoster
    local idx = game.characterSelect.cursor
    repeat
        idx = ((idx -1 + dir -1) % count) + 1
    until game.unlockedCharacters[game.characterRoster[idx]]
    game.characterSelect.cursor = idx
end

-- Confirm selection or start fight
function game.characterSelectConfirm()
    local idx = game.characterSelect.cursor
    local name = game.characterRoster[idx]
    if not game.unlockedCharacters[name] then return end

    if game.characterSelect.stage == 1 then
        game.characterSelect.selected[1] = name
        game.characterSelect.stage = 2
    elseif game.characterSelect.stage == 2 then
        game.characterSelect.selected[2] = name
        game.characterSelect.stage = 3
    else
        setupWizards(game.characterSelect.selected[1], game.characterSelect.selected[2])
        resetGame()
        game.currentState = "BATTLE"
    end
end

-- Back out of selection
function game.characterSelectBack(toMenu)
    if toMenu then
        game.currentState = "MENU"
        return
    end
    if game.characterSelect.stage == 2 then
        game.characterSelect.stage = 1
        game.characterSelect.selected[1] = nil
    elseif game.characterSelect.stage == 3 then
        game.characterSelect.stage = 2
        game.characterSelect.selected[2] = nil
    else
        game.currentState = "MENU"
    end
end

-- Start settings menu
function game.startSettings()
    game.settingsMenu.selected = 1
    game.settingsMenu.mode = nil
    game.settingsMenu.waitingForKey = nil
    game.settingsMenu.rebindIndex = 1
    game.settingsMenu.rebindSelection = 1
    game.settingsMenu.rebindPlayerType = nil
    game.settingsMenu.rebindActionList = nil
    game.settingsMenu.rebindOptions = {
        {playerType = "keyboardP1", label = "Player 1 Keyboard"},
        {playerType = "keyboardP2", label = "Player 2 Keyboard"},
        {playerType = "gamepadP1",  label = "Player 1 Gamepad"}
    }
    game.currentState = "SETTINGS"
end

function game.settingsMove(dir)
    if game.settingsMenu.mode == "rebind_select_player" or game.settingsMenu.mode == "rebind_action_list" then
        local list = (game.settingsMenu.mode == "rebind_select_player") and game.settingsMenu.rebindOptions or game.settingsMenu.rebindActionList
        if not list then return end
        local count = #list
        local idx = game.settingsMenu.rebindSelection + dir
        if idx < 1 then idx = count end
        if idx > count then idx = 1 end
        game.settingsMenu.rebindSelection = idx
        return
    elseif game.settingsMenu.mode then
        return
    end
    local count = 4
    local idx = game.settingsMenu.selected + dir
    if idx < 1 then idx = count end
    if idx > count then idx = 1 end
    game.settingsMenu.selected = idx
end

function game.settingsAdjust(dir)
    if game.settingsMenu.mode then return end
    if game.settingsMenu.selected == 1 then
        if dir ~= 0 then
            local val = Settings.get("dummyFlag")
            Settings.set("dummyFlag", not val)
        end
    elseif game.settingsMenu.selected == 2 then
        if dir ~= 0 then
            local current = Settings.get("gameSpeed") or "FAST"
            if current == "FAST" then
                current = "SLOW"
            else
                current = "FAST"
            end
            Settings.set("gameSpeed", current)
            Constants.setCastSpeedSet(current)
        end
    end
end

function game.unlockAll()
    -- Unlock all characters
    for _, characterName in ipairs(game.characterRoster) do
        game.unlockedCharacters[characterName] = true
    end
    
    -- Unlock all spells
    local allSpellIds = {
        -- Fire
        "conjurefire", "firebolt", "fireball", "blastwave", "combustMana", 
        "blazingascent", "eruption", "battleshield",
        -- Mind
        "thoughtscalp",
        -- Moon
        "conjuremoonlight", "tidalforce", "lunardisjunction", "moondance", 
        "gravity", "eclipse", "fullmoonbeam", "lunartides", "wrapinmoonlight", 
        "gravityTrap", "infiniteprocession", "enhancedmirrorshield",
        -- Salt
        "conjuresalt", "glitterfang", "burnToAsh", "saltstorm", "imprison", 
        "jaggedearth", "saltcircle", "stoneshield", "shieldbreaker",
        -- Star
        "conjurestars", "adaptivesurge", "cosmicrift",
        -- Sun
        "radiantbolt", "fusionRay", "meteor", "emberlift", "novaconjuring", 
        "burnTheSoul", "SpaceRipper", "StingingEyes", "CoreBolt", "NuclearFurnace", 
        "forcebarrier", "radiantfield",
        -- Void
        "conjurenothing", "riteofemptiness", "quenchPower", "heartripper",
        -- Water
        "watergun", "forceblast", "conjurewater", "maelstrom", "riptideguard", 
        "brinechain", "wavecrash",
        -- Generic
        "none"
    }
    
    for _, spellId in ipairs(allSpellIds) do
        game.unlockedSpells[spellId] = true
    end
    
    print("[DEV] All characters and spells unlocked!")
end

function game.settingsSelect()
    if game.settingsMenu.mode == "rebind_select_player" then
        local option = game.settingsMenu.rebindOptions[game.settingsMenu.rebindSelection]
        if option then
            game.settingsMenu.rebindPlayerType = option.playerType
            local controls = Settings.get("controls")[option.playerType] or {}
            game.settingsMenu.rebindActionList = {}
            for action, binding in pairs(controls) do
                table.insert(game.settingsMenu.rebindActionList, {action = action, binding = binding})
            end
            table.sort(game.settingsMenu.rebindActionList, function(a,b) return a.action < b.action end)
            game.settingsMenu.rebindSelection = 1
            game.settingsMenu.mode = "rebind_action_list"
        end
    elseif game.settingsMenu.mode == "rebind_action_list" then
        local entry = game.settingsMenu.rebindActionList[game.settingsMenu.rebindSelection]
        if entry then
            game.settingsMenu.waitingForKey = {playerType = game.settingsMenu.rebindPlayerType, action = entry.action, label = entry.action}
        end
    else
        if game.settingsMenu.selected == 3 then
            game.unlockAll()
        elseif game.settingsMenu.selected == 4 then
            game.settingsMenu.mode = "rebind_select_player"
            game.settingsMenu.rebindSelection = 1
        else
            game.settingsAdjust(1)
        end
    end
end

function game.settingsBack()
    if game.settingsMenu.waitingForKey then
        game.settingsMenu.waitingForKey = nil
        return
    end
    if game.settingsMenu.mode == "rebind_action_list" then
        game.settingsMenu.mode = "rebind_select_player"
        game.settingsMenu.rebindSelection = 1
        return
    elseif game.settingsMenu.mode == "rebind_select_player" then
        game.settingsMenu.mode = nil
        game.settingsMenu.rebindPlayerType = nil
        game.settingsMenu.rebindActionList = nil
        game.settingsMenu.rebindSelection = 1
        return
    end
    game.currentState = "MENU"
end

function game.startCompendium()
    game.compendium.page = 1
    game.compendium.cursor = 1
    game.compendium.scrollOffset = 0
    game.compendium.assignFeedback = {
        active = false,
        slot = 0,
        timer = 0
    }
    game.assignmentError = nil
    game.currentState = "COMPENDIUM"
end

function game.compendiumMove(dir)
    local name = game.characterRoster[game.compendium.page]
    local spells = game.characterData[name].spells or {}
    local count = #spells
    if count == 0 then return end
    
    -- Simple approach: add dir (+1 for down, -1 for up) and handle wrapping
    local newIdx = game.compendium.cursor + dir
    
    -- Handle wrapping around the list
    if newIdx < 1 then 
        newIdx = count
    elseif newIdx > count then
        newIdx = 1
    end
    
    game.compendium.cursor = newIdx
    
    -- Scrolling logic: Calculate visible items based on pane height
    if game.compendiumPanes then
        local pane = game.compendiumPanes.bottomLeft
        local spellLineHeight = 20 -- Height of each spell entry in the list
        local maxVisibleSpells = math.floor((pane.h - 50) / spellLineHeight) -- 50px for padding/header
        
        -- Adjust scroll offset if cursor moves outside visible range
        if game.compendium.cursor <= game.compendium.scrollOffset then
            -- Cursor moved above visible top
            game.compendium.scrollOffset = math.max(0, game.compendium.cursor - 1)
        elseif game.compendium.cursor > game.compendium.scrollOffset + maxVisibleSpells then
            -- Cursor moved below visible bottom
            game.compendium.scrollOffset = game.compendium.cursor - maxVisibleSpells
        end
    end
end

function game.compendiumChangePage(dir)
    local count = #game.characterRoster
    
    -- Use same approach as compendiumMove for consistency
    local newPage = game.compendium.page + dir
    
    -- Handle wrapping
    if newPage < 1 then
        newPage = count
    elseif newPage > count then
        newPage = 1
    end
    
    game.compendium.page = newPage
    game.compendium.cursor = 1 -- Reset cursor when changing pages
    game.compendium.scrollOffset = 0 -- Reset scroll offset when changing pages
    
    -- Reset feedback states
    game.compendium.assignFeedback = {
        active = false,
        slot = 0,
        timer = 0
    }
    game.assignmentError = nil
end

local slotKeys = {"1","2","3","12","13","23","123"}
function game.compendiumAssign(slot)
    local name = game.characterRoster[game.compendium.page]
    local spells = game.characterData[name].spells or {}
    local spell = spells[game.compendium.cursor]
    
    -- Check if spell is valid and unlocked
    if not spell then
        -- No spell selected
        return
    end
    
    if not game.unlockedSpells[spell.id] then
        -- Spell is locked, provide feedback
        game.assignmentError = {
            message = "Spell is locked and cannot be assigned",
            timer = 2.0 -- Show message for 2 seconds
        }
        return
    end
    
    -- Create custom spellbook if it doesn't exist yet
    if not game.customSpellbooks[name] then
        -- Copy default spellbook
        local copy = {}
        for k,v in pairs(game.characterData[name].spellbook) do copy[k]=v end
        game.customSpellbooks[name] = copy
    end
    
    -- Assign the spell to the selected slot
    game.customSpellbooks[name][slotKeys[slot]] = spell
    
    -- Trigger visual feedback
    game.compendium.assignFeedback = {
        active = true,
        slot = slot,
        timer = 0.5 -- Show highlight for 0.5 seconds
    }
    
    -- Play a sound effect for feedback (if available)
    if love.audio and game.sounds and game.sounds.click then
        game.sounds.click:stop()
        game.sounds.click:play()
    end
end

-- Initialize the campaign character selection menu
function game.startCampaignMenu()
    game.campaignMenu = { selectedCharacterIndex = 1 }
    game.currentState = "CAMPAIGN_MENU"
end

-- Move selection cursor in the campaign menu
function game.campaignMenuMove(dir)
    local unlocked = getUnlockedCharacterList()
    local count = #unlocked
    if count == 0 then return end

    local idx = game.campaignMenu.selectedCharacterIndex + dir
    if idx < 1 then idx = count end
    if idx > count then idx = 1 end
    game.campaignMenu.selectedCharacterIndex = idx
end

-- Confirm character choice and start the campaign
function game.campaignMenuConfirm()
    local unlocked = getUnlockedCharacterList()
    local name = unlocked[game.campaignMenu.selectedCharacterIndex]
    if not name then return end

    game.campaignProgress = {
        characterName = name,
        currentOpponentIndex = 1,
        wins = 0
    }

    if startCampaignBattle then
        startCampaignBattle()
    end
end
function love.update(dt)
    -- Update shake timer
    if shakeTimer > 0 then
        shakeTimer = shakeTimer - dt
        if shakeTimer < 0 then
            shakeTimer = 0
            shakeIntensity = 0
        end
    end

    -- Update input repeat timers
    Input.update(dt)
    
    -- Update Compendium assignment feedback timers
    if game.currentState == "COMPENDIUM" then
        if game.compendium.assignFeedback.active then
            game.compendium.assignFeedback.timer = game.compendium.assignFeedback.timer - dt
            if game.compendium.assignFeedback.timer <= 0 then
                game.compendium.assignFeedback.active = false
            end
        end
        
        -- Update assignment error message timer
        if game.assignmentError and game.assignmentError.timer > 0 then
            game.assignmentError.timer = game.assignmentError.timer - dt
        end
    end
    
    -- Check for hitstop - if active, decrement timer and skip all other updates
    if hitstopTimer > 0 then
        hitstopTimer = hitstopTimer - dt
        if hitstopTimer < 0 then
            hitstopTimer = 0
        end
        return -- Skip the rest of the update
    end
    
    -- Only update the game when not in hitstop
    -- Different update logic based on current game state
    if game.currentState == "MENU" then
        -- Menu state updates (minimal, just for animations)
        -- VFX system is still updated for menu animations
        if game.vfx then
            game.vfx.update(dt)
        end

        -- Update attract mode timer when in menu
        if not game.attractModeActive then
            game.menuIdleTimer = game.menuIdleTimer + dt

            -- Start attract mode if idle timer exceeds threshold
            if game.menuIdleTimer > game.ATTRACT_MODE_DELAY then
                startGameAttractMode()
            end
        end

        -- No other updates needed in menu state
        return
    elseif game.currentState == "SETTINGS" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "COMPENDIUM" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CAMPAIGN_MENU" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CAMPAIGN_VICTORY" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CAMPAIGN_DEFEAT" then
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "CHARACTER_SELECT" then
        -- Simple animations for character select
        if game.vfx then
            game.vfx.update(dt)
        end
        return
    elseif game.currentState == "BATTLE" then
        -- Check for win condition before updates
        if game.gameOver then
            -- Transition to game over state
            game.currentState = "GAME_OVER"
            game.winScreenTimer = 0
            game.currentTip = Tips.getRandomTip()
            return
        end
        
        -- Check if any wizard's health has reached zero
        for i, wizard in ipairs(game.wizards) do
            if wizard.health <= 0 then
                game.gameOver = true
                game.winner = 3 - i  -- Winner is the other wizard (3-1=2, 3-2=1)
                game.winScreenTimer = 0
                
                -- Create victory VFX around the winner
                local winner = game.wizards[game.winner]
                for j = 1, 15 do
                    local angle = math.random() * math.pi * 2
                    local distance = math.random(40, 100)
                    local x = winner.x + math.cos(angle) * distance
                    local y = winner.y + math.sin(angle) * distance
                    
                    -- Determine winner's color for effects
                    local color
                    if game.winner == 1 then -- Ashgar
                        color = {1.0, 0.5, 0.2, 0.9} -- Fire-like
                    else -- Selene
                        color = {0.3, 0.3, 1.0, 0.9} -- Moon-like
                    end
                    
                    -- Create sparkle effect with delay
                    game.vfx.createEffect("impact", x, y, nil, nil, {
                        duration = 0.8 + math.random() * 0.5,
                        color = color,
                        particleCount = 5,
                        radius = 15,
                        delay = j * 0.1
                    })
                end
                
                print(winner.name .. " wins!")

                -- Transition to game over state
                game.currentState = "GAME_OVER"
                game.currentTip = Tips.getRandomTip()
                return
            end
        end
        
        -- Update wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:update(dt)
        end
        
        -- Update mana pool
        game.manaPool:update(dt)
        
        -- Update VFX system
        game.vfx.update(dt)
        
        -- Update SustainedSpellManager for trap and shield management
        game.sustainedSpellManager.update(dt)
        
        -- Update animated health displays
        UI.updateHealthDisplays(dt, game.wizards)
        
        -- Update AI opponent if it exists and AI mode is enabled
        if game.useAI and game.opponentAI then
            game.opponentAI:update(dt)
        end

        -- Update both AI players in attract mode
        if game.attractModeActive then
            if game.player1AI then
                game.player1AI:update(dt)
            end
            if game.player2AI then
                game.player2AI:update(dt)
            end
        end
    elseif game.currentState == "GAME_OVER" then
        -- Update win screen timer
        game.winScreenTimer = game.winScreenTimer + dt

        -- When timer expires, handle post-battle flow
        if game.winScreenTimer >= game.winScreenDuration then
            if game.campaignProgress then
                if game.winner == 1 then
                    game.campaignProgress.wins = game.campaignProgress.wins + 1
                    game.campaignProgress.currentOpponentIndex = game.campaignProgress.currentOpponentIndex + 1
                    startCampaignBattle()
                else
                    handleCampaignDefeat()
                end
            else
                resetGame()
                game.currentState = "MENU"
            end
        end

        -- Still update VFX system for visual effects
        game.vfx.update(dt)
    elseif game.currentState == "BATTLE_ATTRACT" then
        -- Check for win condition before updates
        if game.gameOver then
            -- Transition to attract mode game over state
            game.currentState = "GAME_OVER_ATTRACT"
            game.winScreenTimer = 0
            game.currentTip = Tips.getRandomTip()
            return
        end

        -- Check if any wizard's health has reached zero
        for i, wizard in ipairs(game.wizards) do
            if wizard.health <= 0 then
                game.gameOver = true
                game.winner = 3 - i  -- Winner is the other wizard (3-1=2, 3-2=1)
                game.winScreenTimer = 0

                -- Create victory VFX around the winner
                local winner = game.wizards[game.winner]
                for j = 1, 15 do
                    local angle = math.random() * math.pi * 2
                    local distance = math.random(40, 100)
                    local x = winner.x + math.cos(angle) * distance
                    local y = winner.y + math.sin(angle) * distance

                    -- Determine winner's color for effects
                    local color
                    if game.winner == 1 then -- Ashgar
                        color = {1.0, 0.5, 0.2, 0.9} -- Fire-like
                    else -- Selene
                        color = {0.3, 0.3, 1.0, 0.9} -- Moon-like
                    end

                    -- Create sparkle effect with delay
                    game.vfx.createEffect("impact", x, y, nil, nil, {
                        duration = 0.8 + math.random() * 0.5,
                        color = color,
                        particleCount = 5,
                        radius = 15,
                        delay = j * 0.1
                    })
                end

                print("[Attract Mode] " .. winner.name .. " wins!")

                -- Transition to game over state
                game.currentState = "GAME_OVER_ATTRACT"
                game.currentTip = Tips.getRandomTip()
                return
            end
        end

        -- Update wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:update(dt)
        end

        -- Update mana pool
        game.manaPool:update(dt)

        -- Update VFX system
        game.vfx.update(dt)

        -- Update SustainedSpellManager for trap and shield management
        game.sustainedSpellManager.update(dt)

        -- Update animated health displays
        UI.updateHealthDisplays(dt, game.wizards)

        -- Update both AI players in attract mode
        if game.player1AI then
            game.player1AI:update(dt)
        end
        if game.player2AI then
            game.player2AI:update(dt)
        end
    elseif game.currentState == "GAME_OVER_ATTRACT" then
        -- Update win screen timer
        game.winScreenTimer = game.winScreenTimer + dt

        -- Auto-reset after duration - start a new attract mode battle
        if game.winScreenTimer >= game.winScreenDuration then
            -- Reset game and start another attract mode battle
            resetGame()

            local unlocked = getUnlockedCharacterList()
            if #unlocked >= 2 then
                local name1 = unlocked[math.random(#unlocked)]
                local name2 = unlocked[math.random(#unlocked)]
                while name2 == name1 do
                    name2 = unlocked[math.random(#unlocked)]
                end
                setupWizards(name1, name2)
                game.player1AI = OpponentAI.new(game.wizards[1], game, getPersonalityFor(name1))
                game.player2AI = OpponentAI.new(game.wizards[2], game, getPersonalityFor(name2))
            end

            -- Keep attract mode active
            game.attractModeActive = true

            -- Go back to attract mode battle
            game.currentState = "BATTLE_ATTRACT"
        end

        -- Still update VFX system for visual effects
        game.vfx.update(dt)
    end
end

function love.draw()
    -- Clear entire screen to black first (for letterboxing/pillarboxing)
    love.graphics.clear(0, 0, 0, 1)
    
    -- Calculate shake offset if active
    local shakeOffsetX, shakeOffsetY = 0, 0
    if shakeTimer > 0 then
        -- Random shake that gradually reduces as timer decreases
        local shakeFactor = shakeTimer / (shakeTimer + 0.1) -- Smooth falloff
        shakeOffsetX = math.random(-shakeIntensity, shakeIntensity) * shakeFactor
        shakeOffsetY = math.random(-shakeIntensity, shakeIntensity) * shakeFactor
    end
    
    -- Setup scaling transform with shake offset
    love.graphics.push()
    love.graphics.translate(offsetX + shakeOffsetX, offsetY + shakeOffsetY)
    love.graphics.scale(scale, scale)
    
    -- Draw based on current game state
    if game.currentState == "MENU" then
        -- Draw the main menu
        drawMainMenu()
    elseif game.currentState == "SETTINGS" then
        drawSettingsMenu()
    elseif game.currentState == "COMPENDIUM" then
        drawCompendium()
    elseif game.currentState == "CAMPAIGN_MENU" then
        drawCampaignMenu()
    elseif game.currentState == "CAMPAIGN_VICTORY" then
        drawCampaignVictory()
    elseif game.currentState == "CAMPAIGN_DEFEAT" then
        drawCampaignDefeat()
    elseif game.currentState == "CHARACTER_SELECT" then
        drawCharacterSelect()
    elseif game.currentState == "BATTLE" or game.currentState == "BATTLE_ATTRACT" then
        -- Draw background image
        love.graphics.setColor(1, 1, 1, 1)
        if game.backgroundImage then
            love.graphics.draw(game.backgroundImage, 0, 0)
        else
            -- Fallback to solid color if background image isn't loaded
            love.graphics.setColor(20/255, 20/255, 40/255, 1)
            love.graphics.rectangle("fill", 0, 0, baseWidth, baseHeight)
            love.graphics.setColor(1, 1, 1, 1) -- Reset color
        end

        -- Draw range state indicator (NEAR/FAR)
        if love.keyboard.isDown("`") then
            drawRangeIndicator()
        end

        -- Draw mana pool
        game.manaPool:draw()

        -- Draw wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:draw()
        end

        -- Draw visual effects layer (between wizards and UI)
        game.vfx.draw()

        -- Draw UI elements in proper z-order
        love.graphics.setColor(1, 1, 1)

        -- First draw health bars and basic UI components
        UI.drawSpellInfo(game.wizards)

        -- Then draw spellbook buttons (the input feedback bar)
        UI.drawSpellbookButtons()

        -- Finally draw spellbook modals on top of everything else
        UI.drawSpellbookModals(game.wizards)

        -- If in attract mode, draw the attract mode overlay
        if game.currentState == "BATTLE_ATTRACT" then
            drawAttractModeOverlay()
        end
    elseif game.currentState == "GAME_OVER" or game.currentState == "GAME_OVER_ATTRACT" then
        -- Draw background image
        love.graphics.setColor(1, 1, 1, 1)
        if game.backgroundImage then
            love.graphics.draw(game.backgroundImage, 0, 0)
        else
            -- Fallback to solid color if background image isn't loaded
            love.graphics.setColor(20/255, 20/255, 40/255, 1)
            love.graphics.rectangle("fill", 0, 0, baseWidth, baseHeight)
            love.graphics.setColor(1, 1, 1, 1) -- Reset color
        end

        -- Draw game elements in the background (frozen in time)
        -- Draw range state indicator
        drawRangeIndicator()

        -- Draw mana pool
        game.manaPool:draw()

        -- Draw wizards
        for _, wizard in ipairs(game.wizards) do
            wizard:draw()
        end

        -- Draw visual effects layer
        game.vfx.draw()

        -- Draw win screen on top
        drawWinScreen()

        -- If in attract mode, draw the attract mode overlay
        if game.currentState == "GAME_OVER_ATTRACT" then
            drawAttractModeOverlay()
        end
    end
    
    -- Debug info only when debug key is pressed (available in all states)
    if love.keyboard.isDown("`") then
        UI.drawHelpText(game.font)
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print("FPS: " .. love.timer.getFPS(), 10, 10)
        
        -- Show current game state in debug mode
        love.graphics.print("State: " .. game.currentState, 10, 30)
        
        -- Show scaling info in debug mode
        love.graphics.print("Scale: " .. scale .. "x (" .. love.graphics.getWidth() .. "x" .. love.graphics.getHeight() .. ")", 10, 50)
        
        -- Show asset cache stats in debug mode
        local stats = AssetCache.dumpStats()
        love.graphics.print(string.format("Assets: %d images, %d sounds loaded", 
                            stats.images.loaded, stats.sounds.loaded), 10, 70)

        -- Show Pool stats in debug mode
        if love.keyboard.isDown("p") then
            -- Draw pool statistics overlay
            Pool.drawDebugOverlay()
            -- Also show VFX-specific stats
            if game.vfx and game.vfx.showPoolStats then
                game.vfx.showPoolStats()
            end
        else
            love.graphics.print("Press P while in debug mode to see object pool stats", 10, 90)
        end
        
        -- Show hotkey summary when debug overlay is active
        if love.keyboard.isDown("tab") then
            drawHotkeyHelp()
        else
            love.graphics.print("Press TAB while in debug mode to see hotkeys", 10, 110)
        end
    else
        -- Always show a small hint about the debug key
        love.graphics.setColor(0.6, 0.6, 0.6, 0.4)
        love.graphics.print("Press ` for debug controls", 10, baseHeight - 20)
    end
    
    -- End scaling transform
    love.graphics.pop()
    
    -- Draw letterbox/pillarbox borders if needed
    if offsetX > 0 or offsetY > 0 then
        love.graphics.setColor(0, 0, 0)
        -- Top letterbox
        if offsetY > 0 then
            love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), offsetY)
            love.graphics.rectangle("fill", 0, love.graphics.getHeight() - offsetY, love.graphics.getWidth(), offsetY)
        end
        -- Left/right pillarbox
        if offsetX > 0 then
            love.graphics.rectangle("fill", 0, 0, offsetX, love.graphics.getHeight())
            love.graphics.rectangle("fill", love.graphics.getWidth() - offsetX, 0, offsetX, love.graphics.getHeight())
        end
    end
end

-- Helper function to convert real screen coordinates to virtual (scaled) coordinates
function screenToGameCoords(x, y)
    if not x or not y then return nil, nil end
    
    -- Adjust for offset and scale
    local virtualX = (x - offsetX) / scale
    local virtualY = (y - offsetY) / scale
    
    -- Check if the point is outside the game area
    if virtualX < 0 or virtualX > baseWidth or virtualY < 0 or virtualY > baseHeight then
        return nil, nil  -- Out of bounds
    end
    
    return virtualX, virtualY
end

-- Override love.mouse.getPosition for seamless integration
local original_getPosition = love.mouse.getPosition
love.mouse.getPosition = function()
    local rx, ry = original_getPosition()
    local vx, vy = screenToGameCoords(rx, ry)
    return vx or 0, vy or 0
end

-- Draw the win screen
function drawWinScreen()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    local winner = game.wizards[game.winner]
    
    -- Fade in effect
    local fadeProgress = math.min(game.winScreenTimer / 0.5, 1.0)
    
    -- Draw semi-transparent overlay
    love.graphics.setColor(0, 0, 0, 0.7 * fadeProgress)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)
    
    -- Determine winner's color scheme
    local winnerColor
    if game.winner == 1 then -- Ashgar
        winnerColor = {1.0, 0.4, 0.2} -- Fire-like
    else -- Selene
        winnerColor = {0.4, 0.4, 1.0} -- Moon-like
    end
    
    -- Calculate animation progress for text
    local textProgress = math.min(math.max(game.winScreenTimer - 0.5, 0) / 0.5, 1.0)
    local textScale = 1 + (1 - textProgress) * 3 -- Text starts larger and shrinks to normal size
    local textY = screenHeight / 2 - 100
    
    -- Draw winner text with animated scale
    love.graphics.setColor(winnerColor[1], winnerColor[2], winnerColor[3], textProgress)
    
    -- Main victory text
    local victoryText = winner.name .. " WINS!"
    local victoryTextWidth = game.font:getWidth(victoryText) * textScale * 3
    love.graphics.print(
        victoryText, 
        screenWidth / 2 - victoryTextWidth / 2, 
        textY,
        0, -- rotation
        textScale * 3, -- scale X
        textScale * 3  -- scale Y
    )
    
    -- Only show restart instructions after initial animation
    if game.winScreenTimer > 1.0 then
        -- Calculate pulse effect
        local pulse = 0.7 + 0.3 * math.sin(game.winScreenTimer * 4)
        
        -- Draw restart instruction with pulse effect
        local restartText = "Press [SPACE] to play again"
        local restartTextWidth = game.font:getWidth(restartText) * 1.5
        
        love.graphics.setColor(1, 1, 1, pulse)
        love.graphics.print(
            restartText,
            screenWidth / 2 - restartTextWidth / 2,
            textY + 150,
            0, -- rotation
            1.5, -- scale X
            1.5  -- scale Y
        )
        
        -- Show auto-restart countdown
        local remainingTime = math.ceil(game.winScreenDuration - game.winScreenTimer)
        local countdownText = "Auto-restart in " .. remainingTime .. "..."
        local countdownTextWidth = game.font:getWidth(countdownText)
        
        love.graphics.setColor(0.7, 0.7, 0.7, 0.7)
        love.graphics.print(
            countdownText,
            screenWidth / 2 - countdownTextWidth / 2,
            textY + 200
        )
    end

    -- Draw gameplay tip overlay
    if game.currentTip then
        love.graphics.setColor(0, 0, 0, 0.6)
        love.graphics.rectangle("fill", 0, screenHeight - 110, screenWidth, 110)

        love.graphics.setColor(1, 1, 1, 0.9)
        local header = "TIP: " .. game.currentTip.title
        love.graphics.printf(header, 20, screenHeight - 100, screenWidth - 40, "center")

        love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        local body = game.currentTip.content .. " - " .. game.currentTip.source
        love.graphics.printf(body, 20, screenHeight - 80, screenWidth - 40, "center")
    end
    
    -- Draw some victory effect particles
    for i = 1, 3 do
        if math.random() < 0.3 then
            local x = math.random(screenWidth)
            local y = math.random(screenHeight)
            local size = math.random(10, 30)
            
            love.graphics.setColor(
                winnerColor[1], 
                winnerColor[2], 
                winnerColor[3], 
                math.random() * 0.3
            )
            love.graphics.circle("fill", x, y, size)
        end
    end
end

-- Function to draw the range indicator for NEAR/FAR states
function drawRangeIndicator()
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    local centerX = screenWidth / 2
    
    -- Only draw a subtle central line, without the text indicators
    -- The wizard positions themselves will communicate NEAR/FAR state
    
    -- Different visual style based on range state
    if game.rangeState == Constants.RangeState.NEAR then
        -- For NEAR state, draw a more vibrant, energetic line
        love.graphics.setColor(0.5, 0.5, 0.9, 0.4)
        
        -- Draw main line
        love.graphics.setLineWidth(1.5)
        love.graphics.line(centerX, 200, centerX, screenHeight - 100)
        
        -- Add a subtle energetic glow/pulse
        for i = 1, 5 do
            local pulseWidth = 3 + math.sin(love.timer.getTime() * 2.5) * 2
            local alpha = 0.12 - (i * 0.02)
            love.graphics.setColor(0.5, 0.5, 0.9, alpha)
            love.graphics.setLineWidth(pulseWidth * i)
            love.graphics.line(centerX, 200, centerX, screenHeight - 100)
        end
        love.graphics.setLineWidth(1)
    else
        -- For FAR state, draw a more distant, faded line
        love.graphics.setColor(0.3, 0.3, 0.7, 0.3)
        
        -- Draw main line with slight wave effect
        local segments = 12
        local segmentHeight = (screenHeight - 300) / segments
        local points = {}
        
        for i = 0, segments do
            local y = 200 + i * segmentHeight
            local wobble = math.sin(love.timer.getTime() + i * 0.3) * 1.5
            table.insert(points, centerX + wobble)
            table.insert(points, y)
        end
        
        love.graphics.setLineWidth(1)
        love.graphics.line(points)
        
        -- Add very subtle horizontal distortion lines
        for i = 1, 5 do
            local y = 200 + (i * (screenHeight - 300) / 6)
            local width = 15 + math.sin(love.timer.getTime() * 0.7 + i) * 5
            local alpha = 0.05
            love.graphics.setColor(0.3, 0.3, 0.7, alpha)
            love.graphics.setLineWidth(0.5)
            love.graphics.line(centerX - width, y, centerX + width, y)
        end
    end
    
    -- Reset line width
    love.graphics.setLineWidth(1)
end

-- Draw the main menu
-- Helper function to draw text with outline/drop-shadow effect
local function drawTextWithOutline(text, x, y, rotation, scaleX, scaleY, outlineWidth, textColor, outlineColor)
    rotation = rotation or 0
    scaleX = scaleX or 1
    scaleY = scaleY or scaleX
    outlineWidth = outlineWidth or 2
    outlineColor = outlineColor or {0, 0, 0, 0.8}
    
    -- Draw outline/drop-shadow by drawing the text multiple times with slight offsets
    love.graphics.setColor(outlineColor)
    for ox = -outlineWidth, outlineWidth do
        for oy = -outlineWidth, outlineWidth do
            if ox ~= 0 or oy ~= 0 then
                love.graphics.print(text, x + ox, y + oy, rotation, scaleX, scaleY)
            end
        end
    end
    
    -- Draw main text on top
    love.graphics.setColor(textColor)
    love.graphics.print(text, x, y, rotation, scaleX, scaleY)
end

function drawMainMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    
    -- Draw a magical background effect
    love.graphics.setColor(20/255, 20/255, 40/255, 1) -- Dark blue background
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)
    
    -- Draw animated arcane runes in the background
    for i = 1, 9 do
        local time = love.timer.getTime()
        local x = screenWidth * (0.1 + (i % 3) * 0.3)
        local y = screenHeight * (0.1 + math.floor(i / 3) * 0.3)
        local scale = 0.4 + 0.1 * math.sin(time + i)
        local alpha = 0.1 + 0.05 * math.sin(time * 0.5 + i * 0.7)
        local rotation = time * 0.1 * (i % 2 == 0 and 1 or -1)
        local runeTexture = AssetCache.getImage("assets/sprites/runes/rune" .. i .. ".png")
        
        if runeTexture then
            love.graphics.setColor(0.4, 0.4, 0.8, alpha)
            love.graphics.draw(
                runeTexture, 
                x, y, 
                rotation,
                scale, scale,
                runeTexture:getWidth()/2, runeTexture:getHeight()/2
            )
        end
    end
    
    -- Initialize token position history on first run
    if not game.menuTokenTrails then
        game.menuTokenTrails = {}
        for i = 1, 9 do
            game.menuTokenTrails[i] = {}
        end
    end
    
    -- Draw floating mana tokens in a circular arrangement around the content
    local centerX = screenWidth / 2
    local centerY = screenHeight / 2
    local orbitRadius = 200  -- Larger orbit radius for the tokens to circle around content
    local numTokens = 9      -- Exactly 9 tokens to show all token types
    local trailLength = 75   -- Length of the trail (5x longer than original 15)
    
    -- Track token positions for triangle drawing
    local tokenPositions = {}
    
    -- First, draw the triangles BEFORE the tokens to ensure they appear behind
    -- We'll collect positions first with a dry run through the token calculations
    for i = 1, numTokens do
        local time = love.timer.getTime()
        -- Calculate position on a circle with some oscillation
        local angle = (i / numTokens) * math.pi * 2 + time * 0.2  -- Rotate around slowly over time
        local radiusVariation = 20 * math.sin(time * 0.5 + i)     -- Make orbit radius pulse
        
        -- Calculate x,y position on the orbit
        local x = centerX + math.cos(angle) * (orbitRadius + radiusVariation)
        local y = centerY + math.sin(angle) * (orbitRadius + radiusVariation)
        
        -- Add some vertical bounce
        y = y + 15 * math.sin(time * 0.7 + i * 0.5)
        
        -- Store token position for triangle drawing
        tokenPositions[i] = {x = x, y = y}
    end
    
    -- Store triangle data for drawing later
    local triangleData = {}
    
    if #tokenPositions == numTokens then
        local time = love.timer.getTime()
        
        -- Set up triangle groups
        local triangleGroups = {
            {1, 4, 7}, -- First triangle group
            {2, 5, 8}, -- Second triangle group
            {3, 6, 9}  -- Third triangle group
        }
        
        -- Prepare triangle data
        for tIndex, group in ipairs(triangleGroups) do
            -- Get color based on the first token in the group
            local tokenType = game.tokenTypes[group[1]]
            local colorTable = Constants.getColorForTokenType(tokenType)
            
            -- Create a more pronounced pulsing effect for the lines
            local pulseRate = 0.5 + tIndex * 0.2 -- Different pulse rate for each triangle
            -- More dramatic pulsing effect
            local pulseAmount = 0.12 + 0.1 * math.sin(time * pulseRate) 
            
            -- Store color and alpha information with slightly increased base values
            local triangleInfo = {
                color = colorTable,
                alpha = 0.22 + pulseAmount, -- Higher base alpha for more visibility
                points = {}
            }
            
            -- Calculate triangle points with wobble
            for _, tokenIdx in ipairs(group) do
                if tokenPositions[tokenIdx] then
                    -- Add a small wobble to the connection points
                    local wobbleX = 2 * math.sin(time * 1.2 + tokenIdx * 0.7)
                    local wobbleY = 2 * math.cos(time * 1.1 + tokenIdx * 0.9)
                    
                    table.insert(triangleInfo.points, tokenPositions[tokenIdx].x + wobbleX)
                    table.insert(triangleInfo.points, tokenPositions[tokenIdx].y + wobbleY)
                end
            end
            
            -- Add to triangleData collection if we have enough points
            if #triangleInfo.points >= 6 then
                table.insert(triangleData, triangleInfo)
            end
        end
    end
    
    -- First draw the triangles (BEHIND the tokens and trails)
    -- Draw the triangles using the data we collected earlier
    for _, triangle in ipairs(triangleData) do
        -- Draw a glow effect behind the lines first (thicker, more transparent)
        for i = 1, 3 do -- Three layers of glow
            local glowAlpha = triangle.alpha * 0.7 * (1 - (i-1) * 0.25) -- Fade out in layers
            local glowWidth = 3.5 + (i-1) * 2.5 -- Get wider with each layer
            
            love.graphics.setColor(triangle.color[1], triangle.color[2], triangle.color[3], glowAlpha)
            love.graphics.setLineWidth(glowWidth)
            
            -- Draw the triangle outline with glow
            love.graphics.line(triangle.points[1], triangle.points[2], triangle.points[3], triangle.points[4])
            love.graphics.line(triangle.points[3], triangle.points[4], triangle.points[5], triangle.points[6])
            love.graphics.line(triangle.points[5], triangle.points[6], triangle.points[1], triangle.points[2])
        end
        
        -- Draw the main triangle lines (thicker than before)
        love.graphics.setColor(triangle.color[1], triangle.color[2], triangle.color[3], triangle.alpha * 1.2)
        love.graphics.setLineWidth(2.5) -- Thicker main line
        
        -- Draw the triangle outline
        love.graphics.line(triangle.points[1], triangle.points[2], triangle.points[3], triangle.points[4])
        love.graphics.line(triangle.points[3], triangle.points[4], triangle.points[5], triangle.points[6])
        love.graphics.line(triangle.points[5], triangle.points[6], triangle.points[1], triangle.points[2])
    end
    
    -- Now draw the tokens and their trails (on top of the triangles)
    for i = 1, numTokens do
        local time = love.timer.getTime()
        -- Ensure we display each token type exactly once
        local tokenType = game.tokenTypes[i]
        local tokenImage = AssetCache.getImage(game.tokenImages[tokenType])
        
        if tokenImage then
            -- Calculate position on a circle with some oscillation
            local angle = (i / numTokens) * math.pi * 2 + time * 0.2  -- Rotate around slowly over time
            local radiusVariation = 20 * math.sin(time * 0.5 + i)     -- Make orbit radius pulse
            
            -- Calculate x,y position on the orbit
            local x = centerX + math.cos(angle) * (orbitRadius + radiusVariation)
            local y = centerY + math.sin(angle) * (orbitRadius + radiusVariation)
            
            -- Add some vertical bounce
            y = y + 15 * math.sin(time * 0.7 + i * 0.5)
            
            -- Store token position for triangle drawing
            tokenPositions[i] = {x = x, y = y}
            
            -- Keep token size large but vary slightly for animation
            local tokenScale = 1.8 + 0.3 * math.sin(time + i * 0.3)
            local rotation = time * 0.2 * (i % 2 == 0 and 1 or -1)
            
            -- Get color for this token type
            local colorTable = Constants.getColorForTokenType(tokenType)
            
            -- Update position history for trail effect
            if not game.menuTokenTrails[i] then
                game.menuTokenTrails[i] = {}
            end
            
            -- Store new position at the beginning of history array
            table.insert(game.menuTokenTrails[i], 1, {x = x, y = y, time = time})
            
            -- Limit trail length
            if #game.menuTokenTrails[i] > trailLength then
                table.remove(game.menuTokenTrails[i])
            end
            
            -- Draw the trailing effect first (behind the token)
            -- For efficiency with longer trails, only draw every other point for trails > 30
            local stepSize = (#game.menuTokenTrails[i] > 30) and 2 or 1
            
            for j = #game.menuTokenTrails[i], 2, -stepSize do
                local pos = game.menuTokenTrails[i][j]
                local timeDiff = time - pos.time
                
                -- Calculate fade based on position in trail (older = more transparent)
                -- Use a slower fade rate for longer trails
                local trailAlpha = 0.25 * (1 - (j / trailLength)^1.5)
                
                -- Gradually reduce size for trail particles
                -- Adjusted scale formula for longer trails - slower decrease
                local trailScale = 18 * (1 - (j / trailLength) * 0.6)
                
                -- Draw trail particle
                love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], trailAlpha)
                love.graphics.circle("fill", pos.x, pos.y, trailScale)
            end
            
            -- Draw smaller glow behind token (reduced aura size)
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], 0.3)
            -- Reduce the aura size multiplier from 50 to 35
            love.graphics.circle("fill", x, y, 35 * tokenScale)
            
            -- Draw token with same large scale as before
            love.graphics.setColor(1, 1, 1, 0.9)
            love.graphics.draw(
                tokenImage, 
                x, y, 
                rotation,
                tokenScale, tokenScale,
                tokenImage:getWidth()/2, tokenImage:getHeight()/2
            )
        end
    end
    
    -- Now draw all menu text ON TOP of everything else
    
    -- Draw title with a magical glow effect and outline
    local titleY = screenHeight * 0.25
    local titleScale = 4
    local titleText = "MANASTORM"
    local titleWidth = game.font:getWidth(titleText) * titleScale
    
    -- Draw glow behind title
    local glowColor = {0.3, 0.3, 0.9, 0.3}
    local glowSize = 15 + 5 * math.sin(love.timer.getTime() * 2)
    love.graphics.setColor(glowColor)
    for i = 1, 3 do
        love.graphics.print(
            titleText,
            screenWidth/2 - titleWidth/2 + math.random(-2, 2), 
            titleY + math.random(-2, 2),
            0,
            titleScale, titleScale
        )
    end
    
    -- Draw main title with outline
    drawTextWithOutline(
        titleText,
        screenWidth/2 - titleWidth/2, 
        titleY,
        0,
        titleScale, titleScale,
        3, -- outline width
        {0.9, 0.9, 1, 1}, -- text color (light blue-white)
        {0.1, 0.1, 0.3, 0.9} -- outline color (dark blue)
    )
    
    -- Draw subtitle with outline
    local subtitleText = "Chosen of the Ninefold Circle"
    local subtitleScale = 2
    local subtitleWidth = game.font:getWidth(subtitleText) * subtitleScale
    
    drawTextWithOutline(
        subtitleText,
        screenWidth/2 - subtitleWidth/2,
        titleY + 60,
        0,
        subtitleScale, subtitleScale,
        2, -- outline width
        {0.7, 0.7, 1, 0.9}, -- text color (light blue)
        {0.1, 0.1, 0.2, 0.8} -- outline color (dark)
    )
    
    -- Draw menu options with outlines
    local menuY = screenHeight * 0.55
    local menuSpacing = 40
    local menuScale = 1.4

    local options = {
        {"[1] Campaign", {0.9, 0.9, 0.9, 0.9}},
        {"[2] Character Duel", {0.9, 0.7, 0.1, 0.9}},
        {"[3] Research Duel", {0.7, 0.9, 0.2, 0.9}},
        {"[4] Compendium", {0.7, 0.8, 1.0, 0.9}},
        {"[5] Settings", {0.8, 0.8, 0.8, 0.9}},
        {"[6] Exit", {0.7, 0.7, 0.7, 0.9}}
    }

    for i, option in ipairs(options) do
        local text, color = option[1], option[2]
        local width = game.font:getWidth(text) * menuScale
        
        drawTextWithOutline(
            text,
            screenWidth/2 - width/2,
            menuY + (i-1)*menuSpacing,
            0,
            menuScale, menuScale,
            2, -- outline width
            color, -- text color
            {0.1, 0.1, 0.1, 0.8} -- outline color (dark)
        )
    end
    
    -- Draw version and credit
    local versionText = "v0.1 - Demo"
    love.graphics.setColor(0.5, 0.5, 0.5, 0.7)
    love.graphics.print(versionText, 10, screenHeight - 30)
end

-- Draw the campaign character selection menu
function drawCampaignMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    local unlocked = getUnlockedCharacterList()
    local spacing = 30
    local startY = screenHeight * 0.4

    for i, name in ipairs(unlocked) do
        local y = startY + (i - 1) * spacing
        if i == game.campaignMenu.selectedCharacterIndex then
            love.graphics.setColor(1, 0.8, 0.3, 1)
        else
            love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        end
        local w = game.font:getWidth(name)
        love.graphics.print(name, screenWidth/2 - w/2, y)
    end

    love.graphics.setColor(0.7, 0.7, 1, 0.8)
    local hint = "Choose your wizard"
    local hw = game.font:getWidth(hint)
    love.graphics.print(hint, screenWidth/2 - hw/2, startY - spacing)
end

-- Draw the campaign defeat screen
function drawCampaignDefeat()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    local title = "Campaign Failed"
    local titleScale = 2.5
    local tw = game.font:getWidth(title) * titleScale
    love.graphics.setColor(1, 0.6, 0.6, 1)
    love.graphics.print(title, screenWidth/2 - tw/2, screenHeight*0.4, 0, titleScale, titleScale)

    local options = {
        "[R] Restart Campaign",
        "[SPACE] Retry Battle",
        "[ESC] Main Menu"
    }
    local startY = screenHeight * 0.6
    for i, text in ipairs(options) do
        local w = game.font:getWidth(text)
        love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        love.graphics.print(text, screenWidth/2 - w/2, startY + (i-1)*30)
    end
end

-- Draw the campaign victory screen
function drawCampaignVictory()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    local title = "Campaign Complete"
    local titleScale = 2.5
    local tw = game.font:getWidth(title) * titleScale
    love.graphics.setColor(0.6, 1, 0.6, 1)
    love.graphics.print(title, screenWidth/2 - tw/2, screenHeight*0.4, 0, titleScale, titleScale)

    local options = {
        "[R] Restart Campaign",
        "[ESC] Main Menu"
    }
    local startY = screenHeight * 0.6
    for i, text in ipairs(options) do
        local w = game.font:getWidth(text)
        love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        love.graphics.print(text, screenWidth/2 - w/2, startY + (i-1)*30)
    end
end

-- Draw the character selection screen
function drawCharacterSelect()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    love.graphics.setColor(20/255,20/255,40/255,1)
    love.graphics.rectangle("fill",0,0,screenWidth,screenHeight)

    local paneWidth = screenWidth/3
    local cellSize = 60
    local padding = 10
    local gridWidth = cellSize*3 + padding*2
    local gridHeight = cellSize*3 + padding*2
    local gridX = paneWidth + (paneWidth - gridWidth)/2
    local gridY = screenHeight/2 - gridHeight/2

    -- Helper to draw a character sprite
    local function drawSprite(name,x,y,scale)
        local sprite = AssetCache.getImage("assets/sprites/"..string.lower(name)..".png")
        if sprite then
            love.graphics.draw(sprite,x,y,0,scale,scale,sprite:getWidth()/2,sprite:getHeight()/2)
        else
            love.graphics.print(name,x-20,y-5)
        end
    end

    -- Draw selected characters in side panes
    if game.characterSelect.selected[1] then
        love.graphics.setColor(1,1,1)
        drawSprite(game.characterSelect.selected[1],paneWidth/2,screenHeight/2,2)
    end
    if game.characterSelect.selected[2] then
        love.graphics.setColor(1,1,1)
        drawSprite(game.characterSelect.selected[2],screenWidth-paneWidth/2,screenHeight/2,2)
    end

    -- Draw grid of characters
    for i,name in ipairs(game.characterRoster) do
        local col=(i-1)%3
        local row=math.floor((i-1)/3)
        local x=gridX+col*(cellSize+padding)
        local y=gridY+row*(cellSize+padding)

        local unlocked = game.unlockedCharacters[name]
        love.graphics.setColor(0.4,0.4,0.4)
        love.graphics.rectangle("fill",x,y,cellSize,cellSize)

        local scale = cellSize/64
        if unlocked then
            love.graphics.setColor(1,1,1)
            drawSprite(name,x+cellSize/2,y+cellSize/2,scale)
        else
            love.graphics.setColor(0,0,0)
            drawSprite(name,x+cellSize/2,y+cellSize/2,scale)
        end

        if game.characterSelect.cursor==i then
            love.graphics.setColor(1,1,0)
            love.graphics.rectangle("line",x-2,y-2,cellSize+4,cellSize+4)
        end
    end

    -- Instruction text
    love.graphics.setColor(1,1,1,0.8)
    local msg
    if game.characterSelect.stage==1 then
        msg = "Select Your Wizard"
    elseif game.characterSelect.stage==2 then
        msg = "Select Opponent"
    else
        msg = "Press F to Fight!"
    end
    local w = game.font:getWidth(msg)
    love.graphics.print(msg,screenWidth/2 - w/2,gridY+gridHeight+20)

    if game.characterSelect.stage >= 2 then
        local modeText = game.useAI and "P2: AI" or "P2: Human"
        local toggleMsg = modeText .. " (Tab to toggle)"
        local tw = game.font:getWidth(toggleMsg)
        love.graphics.print(toggleMsg, screenWidth/2 - tw/2, gridY+gridHeight+40)
    end
end

-- Draw the settings menu
function drawSettingsMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    if game.settingsMenu.mode == "rebind_select_player" or game.settingsMenu.mode == "rebind_action_list" then
        drawRebindMenu()
        return
    end

    local options = {
        "Dummy Flag: " .. tostring(Settings.get("dummyFlag")),
        "Game Speed: " .. (Settings.get("gameSpeed") or "FAST"),
        "Unlock All (Dev)",
        "Rebind Controls"
    }

    for i, text in ipairs(options) do
        local scale = 1.4
        local y = screenHeight * 0.4 + (i-1) * 40
        local w = game.font:getWidth(text) * scale
        if i == game.settingsMenu.selected and not game.settingsMenu.mode then
            love.graphics.setColor(1, 0.8, 0.3, 1)
        else
            love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
        end
        love.graphics.print(text, screenWidth/2 - w/2, y, 0, scale, scale)
    end

    if game.settingsMenu.waitingForKey then
        local msg = "Press new key for " .. game.settingsMenu.waitingForKey.label
        local scale = 1.2
        local w = game.font:getWidth(msg) * scale
        love.graphics.setColor(1, 0.6, 0.6, 1)
        love.graphics.print(msg, screenWidth/2 - w/2, screenHeight - 60, 0, scale, scale)
    end
end

function drawRebindMenu()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    love.graphics.setColor(20/255, 20/255, 40/255, 1)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)

    if game.settingsMenu.mode == "rebind_select_player" then
        for i, opt in ipairs(game.settingsMenu.rebindOptions or {}) do
            local text = opt.label
            local scale = 1.3
            local y = screenHeight * 0.4 + (i-1)*30
            local w = game.font:getWidth(text) * scale
            if i == game.settingsMenu.rebindSelection then
                love.graphics.setColor(1,0.8,0.3,1)
            else
                love.graphics.setColor(0.9,0.9,0.9,0.9)
            end
            love.graphics.print(text, screenWidth/2 - w/2, y, 0, scale, scale)
        end
    elseif game.settingsMenu.mode == "rebind_action_list" then
        local list = game.settingsMenu.rebindActionList or {}
        local startY = screenHeight * 0.3
        for i, entry in ipairs(list) do
            local text = entry.action .. " : " .. tostring(entry.binding or "")
            local scale = 1.1
            local y = startY + (i-1)*24
            if i == game.settingsMenu.rebindSelection and not game.settingsMenu.waitingForKey then
                love.graphics.setColor(1,0.8,0.3,1)
            else
                love.graphics.setColor(0.9,0.9,0.9,0.9)
            end
            love.graphics.print(text, 60, y, 0, scale, scale)
        end
    end

    if game.settingsMenu.waitingForKey then
        local msg = "Press new input for " .. game.settingsMenu.waitingForKey.label
        local scale = 1.2
        local w = game.font:getWidth(msg) * scale
        love.graphics.setColor(1,0.6,0.6,1)
        love.graphics.print(msg, screenWidth/2 - w/2, screenHeight - 60, 0, scale, scale)
    end
end

function drawCompendium()
    local screenWidth = baseWidth
    local screenHeight = baseHeight
    
    -- Background with gradient effect
    local bgColorTop = {15/255, 15/255, 35/255, 1}
    local bgColorBottom = {30/255, 30/255, 50/255, 1}
    
    -- Draw gradient background
    love.graphics.setColor(bgColorTop)
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight/2)
    love.graphics.setColor(bgColorBottom)
    love.graphics.rectangle("fill", 0, screenHeight/2, screenWidth, screenHeight/2)
    
    -- Calculate pane dimensions with padding
    local panePadding = 12
    local headerHeight = 50 -- Reduced height for the title area
    local footerHeight = 45 -- Height for the footer controls
    local paneWidth = (screenWidth - panePadding * 3) / 2
    local paneHeight = (screenHeight - panePadding * 3 - headerHeight - footerHeight) / 2
    
    -- Define pane coordinates
    local panes = {
        topLeft = {
            x = panePadding,
            y = panePadding + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Spell Details"
        },
        topRight = {
            x = panePadding * 2 + paneWidth,
            y = panePadding + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Character Info"
        },
        bottomLeft = {
            x = panePadding,
            y = panePadding * 2 + paneHeight + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Available Spells"
        },
        bottomRight = {
            x = panePadding * 2 + paneWidth,
            y = panePadding * 2 + paneHeight + headerHeight,
            w = paneWidth,
            h = paneHeight,
            title = "Equipped Spells - Press 1-7 to assign"
        }
    }
    
    -- Get character data
    local name = game.characterRoster[game.compendium.page]
    local data = game.characterData[name]
    
    -- Check if character is unlocked
    local isUnlocked = game.unlockedCharacters[name] or false
    
    -- Draw decorative header line
    love.graphics.setColor(0.4, 0.4, 0.7, 0.5)
    love.graphics.rectangle("fill", 20, headerHeight - 5, screenWidth - 40, 2)
    
    -- Draw main title with shadow effect
    local title
    if isUnlocked then
        title = "Compendium - " .. name
    else
        title = "Compendium - ???"
    end
    
    -- Shadow
    love.graphics.setColor(0.2, 0.2, 0.4, 0.6)
    love.graphics.print(title, screenWidth/2 - game.font:getWidth(title)/2 + 2, 22, 0, 1.5, 1.5)
    
    -- Title text
    love.graphics.setColor(0.9, 0.9, 1)
    love.graphics.print(title, screenWidth/2 - game.font:getWidth(title)/2, 20, 0, 1.5, 1.5)
    
    -- Draw the four panes with distinct colors and titles
    for paneName, pane in pairs(panes) do
        -- Draw pane background with slight transparency and gradient
        local bgColor1, bgColor2
        
        -- Different subtle coloring for each pane
        if paneName == "topLeft" then
            bgColor1 = {0.12, 0.12, 0.22, 0.9}
            bgColor2 = {0.15, 0.15, 0.25, 0.9}
        elseif paneName == "topRight" then
            bgColor1 = {0.14, 0.12, 0.22, 0.9}
            bgColor2 = {0.17, 0.15, 0.25, 0.9}
        elseif paneName == "bottomLeft" then
            bgColor1 = {0.12, 0.14, 0.22, 0.9}
            bgColor2 = {0.15, 0.17, 0.25, 0.9}
        else -- bottomRight
            bgColor1 = {0.13, 0.13, 0.23, 0.9}
            bgColor2 = {0.16, 0.16, 0.26, 0.9}
        end
        
        -- Draw gradient background
        love.graphics.setColor(bgColor1)
        love.graphics.rectangle("fill", pane.x, pane.y, pane.w, pane.h/2)
        love.graphics.setColor(bgColor2)
        love.graphics.rectangle("fill", pane.x, pane.y + pane.h/2, pane.w, pane.h/2)
        
        -- Draw pane border with rounded corners
        love.graphics.setColor(0.4, 0.4, 0.6, 0.8)
        love.graphics.rectangle("line", pane.x, pane.y, pane.w, pane.h, 3, 3)
        
        -- Draw title background
        love.graphics.setColor(0.2, 0.2, 0.3, 0.8)
        love.graphics.rectangle("fill", pane.x, pane.y, pane.w, 30, 3, 3)
        
        -- Draw separator line under title
        love.graphics.setColor(0.4, 0.4, 0.6, 0.5)
        love.graphics.rectangle("fill", pane.x + 5, pane.y + 30, pane.w - 10, 1)
        
        -- Draw pane title with slight shadow
        love.graphics.setColor(0.3, 0.3, 0.4, 0.8)
        love.graphics.print(pane.title, pane.x + 11, pane.y + 8)
        love.graphics.setColor(0.9, 0.9, 1)
        love.graphics.print(pane.title, pane.x + 10, pane.y + 7)
    end
    
    -- Draw detailed content for each pane
    
    -- Top Left: Selected Spell Details
    local selectedSpell = nil
    local spells = data.spells or {}
    if #spells > 0 and game.compendium.cursor <= #spells then
        selectedSpell = spells[game.compendium.cursor]
    end
    
    local pane = panes.topLeft
    if selectedSpell then
        -- Set scissor to clip content to pane
        setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
        
        -- Spell name with larger font
        love.graphics.setColor(1, 1, 0.8)
        local nameY = pane.y + 40
        
        if isUnlocked then
            love.graphics.print(selectedSpell.name, pane.x + 15, nameY, 0, 1.3, 1.3)
        else
            -- For locked characters, replace name with question marks
            local lockedName = string.rep("?", #selectedSpell.name)
            love.graphics.print(lockedName, pane.x + 15, nameY, 0, 1.3, 1.3)
        end
        
        -- Spell properties
        love.graphics.setColor(0.9, 0.9, 0.9)
        local propY = nameY + 30
        
        if isUnlocked then
            -- Affinity
            love.graphics.print("Affinity: " .. (selectedSpell.affinity or "None"), pane.x + 15, propY)
            
            -- Attack Type
            love.graphics.print("Type: " .. (selectedSpell.attackType or "None"), pane.x + 15, propY + 20)
            
            -- Cast Time
            local castTimeText = "Cast Time: " .. (selectedSpell.castTime or 0) .. "s"
            love.graphics.print(castTimeText, pane.x + 15, propY + 40)
            
            -- Mana Cost with token icons
            love.graphics.setColor(0.9, 0.9, 0.9)
            love.graphics.print("Cost:", pane.x + 15, propY + 60)
        else
            -- For locked characters, show mysterious text
            love.graphics.print("Affinity: ???", pane.x + 15, propY)
            love.graphics.print("Type: ???", pane.x + 15, propY + 20)
            love.graphics.print("Cast Time: ??.?s", pane.x + 15, propY + 40)
            love.graphics.print("Cost: ???", pane.x + 15, propY + 60)
        end
        
        if isUnlocked and selectedSpell.cost and #selectedSpell.cost > 0 then
            local iconSize = 16
            local spacing = 5
            local startX = pane.x + 60
            
            for i, tokenType in ipairs(selectedSpell.cost) do
                -- Position for this token icon
                local x = startX + (i-1) * (iconSize + spacing)
                
                -- Get token image if available
                if game.tokenImages and game.tokenImages[tokenType] then
                    local tokenImg = AssetCache.getImage(game.tokenImages[tokenType])
                    if tokenImg then
                        love.graphics.setColor(1, 1, 1)
                        love.graphics.draw(tokenImg, x, propY + 57, 0, iconSize/tokenImg:getWidth(), iconSize/tokenImg:getHeight())
                    else
                        -- Fallback if image not loaded
                        love.graphics.setColor(0.8, 0.7, 0.9)
                        love.graphics.print(tokenType, x, propY + 60)
                    end
                else
                    -- Fallback if no image defined
                    love.graphics.setColor(0.8, 0.7, 0.9)
                    love.graphics.print(tokenType, x, propY + 60)
                end
            end
        elseif not isUnlocked then
            -- Do not show any token images for locked characters
        else
            love.graphics.setColor(0.7, 0.7, 0.7)
            love.graphics.print("None", pane.x + 60, propY + 60)
        end
        
        -- Description (with word wrapping)
        if selectedSpell.description then
            love.graphics.setColor(0.8, 0.8, 0.8)
            local descY = propY + 90
            love.graphics.printf("Description:", pane.x + 15, descY, pane.w - 30)
            
            if isUnlocked then
                love.graphics.setColor(0.7, 0.7, 0.8)
                love.graphics.printf(selectedSpell.description, pane.x + 15, descY + 25, pane.w - 30)
            else
                -- Show redacted description for locked characters
                love.graphics.setColor(0.7, 0.7, 0.8)
                love.graphics.printf(string.rep("?", 100), pane.x + 15, descY + 25, pane.w - 30)
            end
        end
        
        -- Draw keywords if present
        if selectedSpell.keywords and next(selectedSpell.keywords) then
            local keywordY = propY + 170
            love.graphics.setColor(0.8, 0.8, 0.8)
            love.graphics.print("Keywords:", pane.x + 15, keywordY)
            
            love.graphics.setColor(0.6, 0.8, 0.6)
            local y = keywordY + 25
            for keyword, params in pairs(selectedSpell.keywords) do
                local keywordText = "- " .. keyword
                if type(params) == "table" and next(params) then
                    keywordText = keywordText .. " (" 
                    local paramTexts = {}
                    for k, v in pairs(params) do
                        table.insert(paramTexts, k .. ": " .. tostring(v))
                    end
                    keywordText = keywordText .. table.concat(paramTexts, ", ") .. ")"
                end
                love.graphics.print(keywordText, pane.x + 20, y)
                y = y + 20
            end
        end
        
        -- Reset scissor
        love.graphics.setScissor()
    elseif selectedSpell and not isUnlocked then
        -- Character is locked, show mystery message
        setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
        
        love.graphics.setColor(0.6, 0.6, 0.7)
        love.graphics.print("???", pane.x + 15, pane.y + 60, 0, 1.3, 1.3)
        
        love.graphics.setColor(0.5, 0.5, 0.6)
        love.graphics.print("Unlock this character to view spell details", 
                           pane.x + 15, pane.y + 100)
        
        love.graphics.setScissor()
    else
        -- No spell selected
        love.graphics.setColor(0.7, 0.7, 0.7)
        love.graphics.print("Select a spell to see details", pane.x + 15, pane.y + 60)
    end
    
    -- Bottom Left: Available spells with scrolling
    local pane = panes.bottomLeft
    local spells = data.spells or {}
    local spellCount = #spells
    local spellLineHeight = 20 -- Height of each spell entry
    local maxVisibleSpells = math.floor((pane.h - 50) / spellLineHeight) -- 50px for padding/header
    
    -- Set a scissor to clip content to the pane
    setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
    
    if isUnlocked then
        -- Draw visible spells for unlocked characters
        for i = 1, maxVisibleSpells do
            local spellIdx = i + game.compendium.scrollOffset
            if spellIdx <= spellCount then
                local spell = spells[spellIdx]
                local y = pane.y + 40 + (i-1)*spellLineHeight
                
                -- Highlight selected spell
                if spellIdx == game.compendium.cursor then
                    love.graphics.setColor(0.3, 0.3, 0.5, 0.7)
                    love.graphics.rectangle("fill", pane.x + 5, y - 2, pane.w - 10, spellLineHeight)
                    love.graphics.setColor(1, 1, 0)
                else
                    love.graphics.setColor(0.9, 0.9, 0.9)
                end
                
                -- Show spell name, grayed out if locked
                local text = spell.name
                if not game.unlockedSpells[spell.id] then
                    text = "[LOCKED] " .. text
                    love.graphics.setColor(0.6, 0.6, 0.6)
                end
                love.graphics.print(text, pane.x + 20, y)
            end
        end
    else
        -- For locked characters, show mystery entries
        for i = 1, 5 do
            local y = pane.y + 40 + (i-1)*spellLineHeight
            
            if i == game.compendium.cursor then
                love.graphics.setColor(0.3, 0.3, 0.5, 0.7)
                love.graphics.rectangle("fill", pane.x + 5, y - 2, pane.w - 10, spellLineHeight)
                love.graphics.setColor(0.7, 0.7, 0.7)
            else
                love.graphics.setColor(0.5, 0.5, 0.5)
            end
            
            -- Mystery text
            love.graphics.print("???", pane.x + 20, y)
        end
        
        -- Message about unlocking
        love.graphics.setColor(0.5, 0.5, 0.6)
        love.graphics.print("Unlock this character to see spells", 
                           pane.x + 20, pane.y + 40 + 6*spellLineHeight)
    end
    
    -- Draw scrollbar if needed
    if spellCount > maxVisibleSpells then
        love.graphics.setColor(0.4, 0.4, 0.6, 0.8)
        local scrollBarHeight = pane.h - 45
        local scrollThumbHeight = math.max(20, scrollBarHeight * (maxVisibleSpells / spellCount))
        local scrollThumbPos = (game.compendium.scrollOffset / (spellCount - maxVisibleSpells)) * 
                               (scrollBarHeight - scrollThumbHeight)
        
        -- Draw track
        love.graphics.setColor(0.2, 0.2, 0.3, 0.5)
        love.graphics.rectangle("fill", pane.x + pane.w - 15, pane.y + 40, 10, scrollBarHeight)
        
        -- Draw thumb
        love.graphics.setColor(0.4, 0.4, 0.6, 0.8)
        love.graphics.rectangle("fill", 
                                pane.x + pane.w - 15, 
                                pane.y + 40 + scrollThumbPos, 
                                10, 
                                scrollThumbHeight)
    end
    
    -- Reset scissor
    love.graphics.setScissor()
    
    -- Top Right: Character View
    local pane = panes.topRight
    setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 40)
    
    -- Character name with larger font
    love.graphics.setColor(1, 1, 0.8)
    if isUnlocked then
        love.graphics.print(name, pane.x + pane.w/2 - game.font:getWidth(name)/2, pane.y + 45, 0, 1.3, 1.3)
    else
        local hiddenName = "???"
        love.graphics.print(hiddenName, pane.x + pane.w/2 - game.font:getWidth(hiddenName)/2, pane.y + 45, 0, 1.3, 1.3)
    end
    
    -- Character sprite
    local spriteY = pane.y + 80
    local spriteFileName = "assets/sprites/" .. string.lower(name) .. ".png"
    local sprite = AssetCache.getImage(spriteFileName)
    
    if sprite then
        -- For unlocked characters, show normal sprite. For locked, show silhouette
        if isUnlocked then
            love.graphics.setColor(1, 1, 1)
        else
            -- Silhouette color - complete black for a more compelling tease
            love.graphics.setColor(0, 0, 0, 1)
        end
        
        -- Calculate scaled dimensions to fit in the pane while maintaining aspect ratio
        local baseScale = 3 -- Increased base scale by 3x as requested
        local maxWidth = pane.w - 40
        local maxHeight = pane.h - 150
        
        local spriteWidth = sprite:getWidth()
        local spriteHeight = sprite:getHeight()
        
        -- Start with the 3x scale, but reduce if needed to fit
        local scale = baseScale
        if (spriteWidth * scale) > maxWidth or (spriteHeight * scale) > maxHeight then
            local scaleX = maxWidth / spriteWidth
            local scaleY = maxHeight / spriteHeight
            scale = math.min(scaleX, scaleY)
        end
        
        local scaledWidth = spriteWidth * scale
        local scaledHeight = spriteHeight * scale
        local x = pane.x + (pane.w - scaledWidth) / 2
        
        love.graphics.draw(sprite, x, spriteY, 0, scale, scale)
        
        -- Character color display as a color box (only for unlocked characters)
        if data.color and isUnlocked then
            local colorY = spriteY + scaledHeight + 20
            love.graphics.setColor(data.color[1]/255, data.color[2]/255, data.color[3]/255)
            love.graphics.rectangle("fill", pane.x + pane.w/2 - 40, colorY, 80, 20)
            love.graphics.setColor(1, 1, 1)
            love.graphics.rectangle("line", pane.x + pane.w/2 - 40, colorY, 80, 20)
            
            -- Label for the color
            love.graphics.setColor(0.9, 0.9, 0.9)
            love.graphics.print("Character Color", 
                                pane.x + pane.w/2 - game.font:getWidth("Character Color")/2, 
                                colorY + 30)
        elseif data.color and not isUnlocked then
            -- For locked characters, show a mystery color box
            local colorY = spriteY + scaledHeight + 20
            love.graphics.setColor(0.3, 0.3, 0.3)
            love.graphics.rectangle("fill", pane.x + pane.w/2 - 40, colorY, 80, 20)
            love.graphics.setColor(0.4, 0.4, 0.4)
            love.graphics.rectangle("line", pane.x + pane.w/2 - 40, colorY, 80, 20)
            
            -- Mystery label
            love.graphics.setColor(0.6, 0.6, 0.6)
            local hiddenLabel = "???"
            love.graphics.print(hiddenLabel, 
                                pane.x + pane.w/2 - game.font:getWidth(hiddenLabel)/2, 
                                colorY + 30)
        end
    else
        -- Fallback if sprite not found
        if isUnlocked then
            love.graphics.setColor(0.7, 0.7, 0.7)
            love.graphics.print("Character sprite not available", 
                                pane.x + 20, 
                                pane.y + 100)
        else
            -- Black rectangle silhouette as fallback for locked characters
            love.graphics.setColor(0, 0, 0, 1)
            love.graphics.rectangle("fill", pane.x + pane.w/2 - 40, pane.y + 100, 80, 120)
        end
    end
    
    love.graphics.setScissor()
    
    -- Bottom Right: Configured Spellbook View
    local pane = panes.bottomRight
    setScaledScissor(pane.x, pane.y + 35, pane.w, pane.h - 5)
    
    -- Slot key input mappings
    local keyMapping = {
        ["1"] = "1",
        ["2"] = "2",
        ["3"] = "3",
        ["12"] = "1+2",
        ["13"] = "1+3",
        ["23"] = "2+3",
        ["123"] = "1+2+3"
    }
    
    -- Get active spellbook (custom or default)
    local active = game.customSpellbooks[name] or data.spellbook
    
    -- Draw each slot (removed instructions to save space)
    for i, key in ipairs(slotKeys) do
        local spell = active[key]
        local y = pane.y + 40 + (i-1)*28
        
        -- Check if a number key is being held to highlight slot
        local isSlotSelected = false
        if isUnlocked and game.currentState == "COMPENDIUM" and game.menuInput and game.menuInput[tostring(i)] then
            isSlotSelected = true
        end
        
        -- Check if this slot has the assignment feedback active
        local isAssignFeedback = isUnlocked and game.compendium.assignFeedback.active and 
                                game.compendium.assignFeedback.slot == i
        
        -- Slot background
        if isAssignFeedback then
            -- Bright successful assignment highlight
            love.graphics.setColor(0.3, 0.8, 0.3, 0.7)
        elseif isSlotSelected then
            -- Selection highlight when hovering
            love.graphics.setColor(0.4, 0.5, 0.4, 0.7)
        else
            -- Normal background
            love.graphics.setColor(0.25, 0.25, 0.35, 0.7)
        end
        love.graphics.rectangle("fill", pane.x + 10, y - 3, pane.w - 20, 24)
        
        -- Slot border
        love.graphics.setColor(0.4, 0.4, 0.6)
        love.graphics.rectangle("line", pane.x + 10, y - 3, pane.w - 20, 24)
        
        -- Slot input hint
        love.graphics.setColor(1, 1, 0.6)
        local inputHint = "[" .. keyMapping[key] .. "]"
        love.graphics.print(inputHint, pane.x + 15, y)
        
        -- Slot assigned spell
        local displayText
        if isUnlocked then
            if spell then
                love.graphics.setColor(1, 1, 1)
                displayText = spell.name
            else
                love.graphics.setColor(0.6, 0.6, 0.6)
                displayText = "--- Empty ---"
            end
        else
            -- For locked characters, show redacted text
            love.graphics.setColor(0.6, 0.6, 0.6)
            displayText = "??? ?????"
        end
        
        -- Calculate position for the spell name so it's properly spaced from the input hint
        local hintWidth = game.font:getWidth(inputHint)
        love.graphics.print(displayText, pane.x + 25 + hintWidth, y)
    end
    
    -- Draw explanatory text about the slot system
    love.graphics.setColor(0.7, 0.7, 0.8, 0.8)
    local explanationY = pane.y + 40 + 7 * 28 + 15
    
    if isUnlocked then
        love.graphics.printf(
            "Combine keys to cast different spells. For example, pressing 1+2 together will cast the spell assigned to slot 4.",
            pane.x + 15, 
            explanationY,
            pane.w - 30
        )
    else
        love.graphics.printf(
            "???????? ???? ?? ???? ????????? ?????? ???????? ??? ???????? ???? ???? ?? ???? ? ??????",
            pane.x + 15, 
            explanationY,
            pane.w - 30
        )
    end
    
    love.graphics.setScissor()
    
    -- Display assignment error message if present
    if game.assignmentError and game.assignmentError.timer > 0 then
        love.graphics.setColor(1, 0.3, 0.3, math.min(1, game.assignmentError.timer))
        love.graphics.printf(
            game.assignmentError.message,
            screenWidth/2 - 200,
            screenHeight - 60,
            400,
            "center"
        )
    end
    
    -- Reduce the height of the header to make room for the footer
    headerHeight = 40 -- Reduced from 50
    
    -- Calculate footer position (now above the bottom panes to avoid overlap)
    local footerTop = screenHeight - footerHeight
    
    -- Draw footer background
    love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
    love.graphics.rectangle("fill", 0, footerTop, screenWidth, footerHeight)
    
    -- Draw footer separator line
    love.graphics.setColor(0.4, 0.4, 0.7, 0.5)
    love.graphics.rectangle("fill", 20, footerTop, screenWidth - 40, 1)
    
    -- Instructions at the bottom with key highlighting
    local instructions = {
        {text = "Left/Right", color = {1, 0.8, 0.4}},
        {text = " to change wizard, ", color = {0.8, 0.8, 0.9}},
        {text = "Up/Down", color = {1, 0.8, 0.4}},
        {text = " to select spell, ", color = {0.8, 0.8, 0.9}},
        {text = "1-7", color = {1, 0.8, 0.4}},
        {text = " to assign spell to slot", color = {0.8, 0.8, 0.9}}
    }
    
    local x = 20
    local y = footerTop + 15 -- Center text in footer
    
    for _, part in ipairs(instructions) do
        love.graphics.setColor(part.color)
        love.graphics.print(part.text, x, y, 0, 0.9, 0.9)
        x = x + game.font:getWidth(part.text) * 0.9
    end
    
    -- Store pane layout in the game state for future reference
    game.compendiumPanes = panes
end

-- Draw attract mode overlay
function drawAttractModeOverlay()
    local screenWidth = baseWidth
    local screenHeight = baseHeight

    -- Draw a semi-transparent banner at the top
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 0, 0, screenWidth, 40)

    -- Draw "Attract Mode" text
    love.graphics.setColor(1, 1, 1, 0.9)
    local attractText = "ATTRACT MODE - PRESS ANY KEY TO RETURN TO MENU"
    local textWidth = game.font:getWidth(attractText) * 1.5

    -- Make text pulse slightly to draw attention
    local pulse = 0.8 + 0.2 * math.sin(love.timer.getTime() * 3)
    love.graphics.setColor(1, 1, 1, pulse)
    love.graphics.print(
        attractText,
        screenWidth / 2 - textWidth / 2,
        10,
        0, -- rotation
        1.5, -- scale X
        1.5  -- scale Y
    )

    -- Draw AI info text at bottom
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 0, screenHeight - 40, screenWidth, 40)

    -- Show which AI personalities are fighting
    local aiInfoText = "AI DUEL: " .. game.wizards[1].name .. " vs " .. game.wizards[2].name
    local aiTextWidth = game.font:getWidth(aiInfoText)

    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(
        aiInfoText,
        screenWidth / 2 - aiTextWidth / 2,
        screenHeight - 30
    )
end

-- Unified key handler using the Input module
function love.keypressed(key, scancode, isrepeat)
    -- First check if we're in attract mode - any key exits attract mode
    if game.attractModeActive then
        exitAttractMode()
        return true -- Key handled
    end

    -- Forward all key presses to the Input module for normal gameplay
    return Input.handleKey(key, scancode, isrepeat)
end

-- Unified key release handler
function love.keyreleased(key, scancode)
    -- Skip key release handling if in attract mode (already handled in keypressed)
    if game.attractModeActive then
        return true -- Key handled
    end

    -- Forward all key releases to the Input module
    return Input.handleKeyReleased(key, scancode)
end

-- Handle gamepad button presses
function love.gamepadpressed(joystick, button)
    local jid = joystick:getID()
    if not game.p1GamepadID then
        game.p1GamepadID = jid
    elseif not game.p2GamepadID and not game.useAI then
        game.p2GamepadID = jid
        game.p2UsingGamepad = true
    end
    if game.attractModeActive then
        exitAttractMode()
        return true
    end
    return Input.handleGamepadButton(jid, button, true)
end

function love.gamepadreleased(joystick, button)
    local jid = joystick:getID()
    return Input.handleGamepadButton(jid, button, false)
end

-- Handle analog stick movement
function love.gamepadaxis(joystick, axis, value)
    local jid = joystick:getID()
    return Input.handleGamepadAxis(jid, axis, value)
end

-- Track gamepad connections
function love.joystickadded(joystick)
    local jid = joystick:getID()
    if not game.p1GamepadID then
        game.p1GamepadID = jid
    elseif not game.p2GamepadID and not game.useAI then
        game.p2GamepadID = jid
        game.p2UsingGamepad = true
    end
end

function love.joystickremoved(joystick)
    local jid = joystick:getID()
    if game.p1GamepadID == jid then
        game.p1GamepadID = nil
    elseif game.p2GamepadID == jid then
        game.p2GamepadID = nil
        game.p2UsingGamepad = false
    end
end
```

## ./manapool.lua
```lua
-- ManaPool class
-- Represents the shared pool of mana tokens in the center

-- Import modules at module level so they're available to all methods
local AssetCache = require("core.AssetCache")
local Constants = require("core.Constants")
local Pool = require("core.Pool")

local ManaPool = {}
ManaPool.__index = ManaPool

function ManaPool.new(x, y)
    local self = setmetatable({}, ManaPool)
    
    self.x = x
    self.y = y
    self.tokens = {}  -- List of mana tokens
    
    -- Make elliptical shape even flatter and wider
    self.radiusX = 280  -- Wider horizontal radius
    self.radiusY = 60   -- Flatter vertical radius
    
    -- Define orbital rings (valences) for tokens to follow
    self.valences = {
        {radiusX = 180, radiusY = 25, baseSpeed = 0.35},  -- Inner valence
        {radiusX = 230, radiusY = 40, baseSpeed = 0.25},  -- Middle valence
        {radiusX = 280, radiusY = 55, baseSpeed = 0.18}   -- Outer valence
    }
    
    -- Chance for a token to switch valences
    self.valenceJumpChance = 0.002  -- Per frame chance of switching
    
    -- Initialize token trails system
    self.tokenTrails = {}
    self.trailLength = 30  -- Max number of positions to store per token
    
    -- Initialize the token pool if not already done
    if not Pool.pools["token"] then
        Pool.create("token", 50, function() 
            return {} -- Simple factory function that creates an empty table
        end, ManaPool.resetToken) -- Use our custom token reset function
    end
    
    return self
end

-- Token methods for state machine
local TokenMethods = {}

-- Set the token's state with validation
function TokenMethods:setState(newStatus)
    local oldStatus = self.status

    -- Validate state transitions
    if self.status == Constants.TokenStatus.POOLED then
        print("[TOKEN LIFECYCLE] WARNING: Cannot transition from POOLED state!")
        return false
    end

    -- Finalize scale if leaving an animation state that modifies scale
    if (oldStatus == Constants.TokenStatus.APPEARING or oldStatus == Constants.TokenStatus.ORBITING) and
       (newStatus == Constants.TokenStatus.CHANNELED or
        newStatus == Constants.TokenStatus.SHIELDING or
        newStatus == Constants.TokenStatus.FREE) then
        if self.targetScale then
            self.scale = self.targetScale
        else
            self.scale = 0.85 + math.random() * 0.3
        end
    end

    -- Update the token's status
    self.status = newStatus
    
    -- For backwards compatibility, keep the legacy state in sync with the new status
    if newStatus == Constants.TokenStatus.FREE or 
       newStatus == Constants.TokenStatus.CHANNELED or 
       newStatus == Constants.TokenStatus.SHIELDING then
        self.state = newStatus
    elseif newStatus == Constants.TokenStatus.RETURNING or
           newStatus == Constants.TokenStatus.APPEARING or
           newStatus == Constants.TokenStatus.ORBITING then
        self.state = self.originalStatus or Constants.TokenState.FREE -- Keep original state during animation
    elseif newStatus == Constants.TokenStatus.DISSOLVING then
        self.state = Constants.TokenState.DESTROYED
    elseif newStatus == Constants.TokenStatus.POOLED then
        self.state = Constants.TokenState.DESTROYED
    end
    
    return true
end

-- Request token return animation
function TokenMethods:requestReturnAnimation()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.CHANNELED and self.status ~= Constants.TokenStatus.SHIELDING then
        print("[TOKEN LIFECYCLE] WARNING: Can only return tokens from CHANNELED or SHIELDING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Store the original status for later reference
    self.originalStatus = self.status
    
    -- Set animation flags
    self.isAnimating = true
    self.returning = true  -- For backward compatibility
    
    -- Set animation parameters
    self.startX = self.x
    self.startY = self.y
    self.animTime = 0
    self.animDuration = 0.5 -- Half second return animation
    
    -- Store callback to be called when animation completes
    self.animationCallback = function() self:finalizeReturn() end
    
    -- Change state to RETURNING
    self:setState(Constants.TokenStatus.RETURNING)
    
    return true
end

-- Request token destruction animation
function TokenMethods:requestDestructionAnimation()
    -- Validate current state
    if self.status == Constants.TokenStatus.DISSOLVING or self.status == Constants.TokenStatus.POOLED then
        print("[TOKEN LIFECYCLE] Token is already dissolving or pooled")
        return false
    end
    
    -- Set animation flags
    self.isAnimating = true
    self.dissolving = true  -- For backward compatibility
    
    -- Set animation parameters
    self.dissolveTime = 0
    self.dissolveMaxTime = 0.8  -- Dissolution animation duration
    self.dissolveScale = self.scale or 1.0
    self.initialX = self.x
    self.initialY = self.y
    
    -- Store callback to be called when animation completes
    self.animationCallback = function() self:finalizeDestruction() end
    
    -- Change state to DISSOLVING
    self:setState(Constants.TokenStatus.DISSOLVING)
    
    -- Create visual particle effects at the token's position using events
    if not self.exploding and self.gameState then
        self.exploding = true
        
        -- Get token color based on its type
        local colorTable = Constants.getColorForTokenType(self.type)
        
        -- Create an EFFECT event instead of calling VFX directly
        if self.gameState.eventRunner then
            local event = {
                type = "EFFECT",
                source = "token",
                target = Constants.TargetType.SELF, -- Not targeting a wizard
                effectType = Constants.VFXType.IMPACT,
                duration = 0.7,
                vfxParams = {
                    x = self.x,  -- Pass coordinates directly in vfxParams
                    y = self.y,
                    color = colorTable,
                    particleCount = 15,
                    radius = 30,
                    tokenType = self.type
                }
            }
            
            -- Process the event immediately
            self.gameState.eventRunner.processEvents({event}, self, nil)
        else
            print("[TOKEN LIFECYCLE] Warning: No eventRunner in gameState for token VFX")
        end
    end
    
    return true
end

-- Finalize return to pool after animation (first phase)
function TokenMethods:finalizeReturn()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.RETURNING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize return from RETURNING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Reset some animation flags but keep isAnimating true for orbit animation
    self.returning = false  -- For backward compatibility
    
    -- Clear wizard/spell references
    self.wizardOwner = nil
    self.spellSlot = nil
    self.tokenIndex = nil
    
    -- Get the ManaPool instance from the token's game state or another reference
    local manaPool = self.manaPool
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token return!")
        return false
    end
    
    -- Choose a random valence for the token's destination
    local valenceIndex = math.random(1, #manaPool.valences)
    local valence = manaPool.valences[valenceIndex]
    self.valenceIndex = valenceIndex
    
    -- Calculate a random angle for the token's destination
    -- We'll use a random angle rather than the current angle to ensure
    -- tokens don't all follow the same path
    local angle = math.random() * math.pi * 2
    self.orbitAngle = angle
    
    -- Calculate target position based on valence
    local targetX = manaPool.x + math.cos(angle) * valence.radiusX
    local targetY = manaPool.y + math.sin(angle) * valence.radiusY
    
    -- Add slight position variation to the target
    local variationX = math.random(-2, 2)
    local variationY = math.random(-1, 1)
    
    -- Store current position (center of pool) as start for orbit animation
    self.startOrbitX = self.x
    self.startOrbitY = self.y
    
    -- Store target position for orbit animation
    self.targetOrbitX = targetX + variationX
    self.targetOrbitY = targetY + variationY
    
    -- Set up orbit animation parameters
    self.orbitAnimTime = 0
    self.orbitAnimDuration = 0.8  -- Slightly faster than return animation
    
    -- Set an animation callback for when the orbit animation completes
    self.animationCallback = function() self:finalizeOrbit() end
    
    -- Set transitioning to orbit state
    self:setState(Constants.TokenStatus.ORBITING)
    
    -- Randomize orbit direction and speed
    local direction = math.random(0, 1) * 2 - 1  -- -1 or 1
    self.orbitSpeed = valence.baseSpeed * (0.8 + math.random() * 0.4) * direction
    self.originalSpeed = self.orbitSpeed
    
    -- Initialize valence properties
    self.valenceJumpTimer = 2 + math.random() * 8
    self.inValenceTransition = false
    self.valenceTransitionTime = 0
    self.valenceTransitionDuration = 0.8
    self.sourceValenceIndex = valenceIndex
    self.targetValenceIndex = valenceIndex
    self.sourceRadiusX = valence.radiusX
    self.sourceRadiusY = valence.radiusY
    self.targetRadiusX = valence.radiusX
    self.targetRadiusY = valence.radiusY
    self.currentRadiusX = valence.radiusX
    self.currentRadiusY = valence.radiusY
    
    -- Visual variance
    self.scale = 0.85 + math.random() * 0.3
    self.zOrder = math.random()
    
    return true
end

-- Finalize orbit transition (second phase)
function TokenMethods:finalizeOrbit()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.ORBITING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize orbit from ORBITING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Reset animation flags
    self.isAnimating = false
    
    -- Get the ManaPool instance from the token's game state or another reference
    local manaPool = self.manaPool
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token orbit!")
        return false
    end
    
    -- Update position to make sure it's at the target
    self.x = self.targetOrbitX
    self.y = self.targetOrbitY

    -- Ensure scale is finalized
    if self.targetScale then
        self.scale = self.targetScale
    else
        self.scale = 0.85 + math.random() * 0.3
    end
    
    -- Clean up orbit animation properties
    self.startOrbitX = nil
    self.startOrbitY = nil
    self.targetOrbitX = nil
    self.targetOrbitY = nil
    self.orbitAnimTime = nil
    self.orbitAnimDuration = nil
    
    -- Set state to FREE
    self:setState(Constants.TokenStatus.FREE)
    
    -- Set transition flags for smooth animation of orbital motion
    self.transitionTime = 0
    self.transitionDuration = 0.4  -- Shorter orbital transition (was 1.0)
    self.inTransition = true
    
    return true
end

-- Initialize conjured token appearance animation
function TokenMethods:requestAppearAnimation(fromWizard)
    -- Set up animation parameters
    self.isAnimating = true
    
    -- Store the source position (wizard position)
    self.startX = fromWizard.x
    self.startY = fromWizard.y - 40  -- Start a little above the wizard
    
    -- Initialize animation timing
    self.appearAnimTime = 0
    self.appearAnimDuration = 0.7  -- Slightly longer than return animation
    
    -- Set the target scale
    self.targetScale = 0.85 + math.random() * 0.3
    
    -- Start very small
    self.scale = 0.1
    
    -- Initial position is at the wizard
    self.x = self.startX
    self.y = self.startY
    
    -- Prepare callback for when animation completes
    self.animationCallback = function() self:finalizeAppear() end
    
    -- Set status to APPEARING
    self:setState(Constants.TokenStatus.APPEARING)
    
    return true
end

-- Finalize appear animation and transition to orbiting
function TokenMethods:finalizeAppear()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.APPEARING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize appear from APPEARING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Maintain animation flag
    self.isAnimating = true
    
    -- Get the ManaPool instance from the token's game state
    local manaPool = self.manaPool
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token appearance!")
        return false
    end
    
    -- Choose a random valence for the token's destination
    local valenceIndex = math.random(1, #manaPool.valences)
    local valence = manaPool.valences[valenceIndex]
    self.valenceIndex = valenceIndex
    
    -- Calculate a random angle for the token's destination
    local angle = math.random() * math.pi * 2
    self.orbitAngle = angle
    
    -- Calculate target position based on valence
    local targetX = manaPool.x + math.cos(angle) * valence.radiusX
    local targetY = manaPool.y + math.sin(angle) * valence.radiusY
    
    -- Add slight position variation to the target
    local variationX = math.random(-2, 2)
    local variationY = math.random(-1, 1)
    
    -- Store current position (center of pool) as start for orbit animation
    self.startOrbitX = self.x
    self.startOrbitY = self.y
    
    -- Store target position for orbit animation
    self.targetOrbitX = targetX + variationX
    self.targetOrbitY = targetY + variationY
    
    -- Set up orbit animation parameters
    self.orbitAnimTime = 0
    self.orbitAnimDuration = 0.8  -- Slightly faster than return animation
    
    -- Set an animation callback for when the orbit animation completes
    self.animationCallback = function() self:finalizeOrbit() end
    
    -- Set transitioning to orbit state
    self:setState(Constants.TokenStatus.ORBITING)
    
    -- Randomize orbit direction and speed
    local direction = math.random(0, 1) * 2 - 1  -- -1 or 1
    self.orbitSpeed = valence.baseSpeed * (0.8 + math.random() * 0.4) * direction
    self.originalSpeed = self.orbitSpeed
    
    -- Initialize valence properties
    self.valenceJumpTimer = 2 + math.random() * 8
    self.inValenceTransition = false
    self.valenceTransitionTime = 0
    self.valenceTransitionDuration = 0.8
    self.sourceValenceIndex = valenceIndex
    self.targetValenceIndex = valenceIndex
    self.sourceRadiusX = valence.radiusX
    self.sourceRadiusY = valence.radiusY
    self.targetRadiusX = valence.radiusX
    self.targetRadiusY = valence.radiusY
    self.currentRadiusX = valence.radiusX
    self.currentRadiusY = valence.radiusY

    -- Visual variance set during appearing animation
    self.scale = self.targetScale
    self.zOrder = math.random()
    
    return true
end

-- Finalize token destruction and release to pool
function TokenMethods:finalizeDestruction()
    -- Validate current state
    if self.status ~= Constants.TokenStatus.DISSOLVING then
        print("[TOKEN LIFECYCLE] WARNING: Can only finalize destruction from DISSOLVING state, not " .. (self.status or "nil"))
        return false
    end
    
    -- Reset animation flags
    self.isAnimating = false
    self.dissolving = false  -- For backward compatibility
    
    -- Set new state
    self:setState(Constants.TokenStatus.POOLED)
    
    -- Get the token's index in the mana pool
    local found = false
    local manaPool = self.manaPool
    local index = nil
    
    if not manaPool then
        print("[TOKEN LIFECYCLE] ERROR: Cannot find manaPool reference to finalize token destruction!")
        return false
    end
    
    for i, t in ipairs(manaPool.tokens) do
        if t == self then
            index = i
            found = true
            break
        end
    end
    
    if found and index then
        -- Remove the token from the mana pool's token list
        table.remove(manaPool.tokens, index)
    else
        print("[TOKEN LIFECYCLE] WARNING: Token not found in manaPool.tokens during finalization!")
    end
    
    -- Release the token back to the object pool
    Pool.release("token", self)
    
    return true
end

-- Token reset function for the pool
function ManaPool.resetToken(token)
    -- Remove all methods first
    for name, _ in pairs(TokenMethods) do
        token[name] = nil
    end
    
    -- Clear token trails if they exist
    if token.manaPool and token.manaPool.tokenTrails and token.manaPool.tokenTrails[token] then
        token.manaPool.tokenTrails[token] = nil
    end
    
    -- Clear all references and fields
    token.type = nil
    token.image = nil
    token.x = nil
    token.y = nil
    token.state = nil
    token.status = nil  -- New field for the state machine
    token.isAnimating = nil  -- New field to track animation state
    token.animationCallback = nil  -- New field for animation completion callback
    token.originalStatus = nil  -- To store the state before transitions
    token.valenceIndex = nil
    token.orbitAngle = nil
    token.orbitSpeed = nil
    token.pulsePhase = nil
    token.pulseSpeed = nil
    token.rotAngle = nil
    token.rotSpeed = nil
    token.valenceJumpTimer = nil
    token.inValenceTransition = nil
    token.valenceTransitionTime = nil
    token.valenceTransitionDuration = nil
    token.sourceValenceIndex = nil
    token.targetValenceIndex = nil
    token.sourceRadiusX = nil
    token.sourceRadiusY = nil
    token.targetRadiusX = nil
    token.targetRadiusY = nil
    token.currentRadiusX = nil
    token.currentRadiusY = nil
    token.scale = nil
    token.targetScale = nil
    token.zOrder = nil
    
    -- Clear animation-specific fields
    token.startOrbitX = nil
    token.startOrbitY = nil
    token.targetOrbitX = nil
    token.targetOrbitY = nil
    token.orbitAnimTime = nil
    token.orbitAnimDuration = nil
    token.appearAnimTime = nil
    token.appearAnimDuration = nil
    token.startX = nil
    token.startY = nil
    token.originalSpeed = nil
    token.wizardOwner = nil
    token.spellSlot = nil
    token.dissolving = nil
    token.gameState = nil
    token.manaPool = nil  -- New field to reference the mana pool
    token.id = nil  -- New field for tracking tokens
    
    -- Clear animation-related fields
    token.returning = nil
    token.animTime = nil
    token.animDuration = nil
    token.startX = nil
    token.startY = nil
    token.targetX = nil
    token.targetY = nil
    token.tokenIndex = nil
    token.inTransition = nil
    token.transitionTime = nil
    token.transitionDuration = nil
    token.originalState = nil
    token.dissolveTime = nil
    token.dissolveMaxTime = nil
    token.dissolveScale = nil
    token.initialX = nil
    token.initialY = nil
    token.exploding = nil
    
    return token
end

-- Clear all tokens from the mana pool
function ManaPool:clear()
    -- Release all tokens back to the pool
    for _, token in ipairs(self.tokens) do
        Pool.release("token", token)
    end
    
    self.tokens = {}
    self.reservedTokens = {}
    self.tokenTrails = {} -- Clear token trails when clearing the pool
end

-- Standard token addition - creates token directly at its final position
function ManaPool:addToken(tokenType, imagePath)
    -- Pick a random valence for the token
    local valenceIndex = math.random(1, #self.valences)
    local valence = self.valences[valenceIndex]
    
    -- Calculate a random angle along the valence
    local angle = math.random() * math.pi * 2
    
    -- Calculate position based on elliptical path
    local x = self.x + math.cos(angle) * valence.radiusX
    local y = self.y + math.sin(angle) * valence.radiusY
    
    -- Generate slight positional variation to avoid tokens stacking perfectly
    local variationX = math.random(-5, 5)
    local variationY = math.random(-3, 3)
    
    -- Randomize orbit direction (clockwise or counter-clockwise)
    local direction = math.random(0, 1) * 2 - 1  -- -1 or 1
    
    -- Get image from cache, with fallback
    local tokenImage = AssetCache.getImage(imagePath)
    if not tokenImage then
        print("WARNING: Failed to load token image: " .. imagePath .. " - using placeholder")
        -- Create a placeholder image using LÖVE's built-in canvas
        tokenImage = love.graphics.newCanvas(32, 32)
        love.graphics.setCanvas(tokenImage)
        love.graphics.clear(0.8, 0.2, 0.8, 1) -- Bright color to make missing textures obvious
        love.graphics.rectangle("fill", 0, 0, 32, 32)
        love.graphics.setCanvas()
    end
    
    -- Create a new token from the pool
    local token = Pool.acquire("token")
    
    -- Add methods from TokenMethods table
    for name, method in pairs(TokenMethods) do
        token[name] = method
    end
    
    -- Initialize basic properties
    token.type = tokenType
    token.image = tokenImage
    token.x = x + variationX
    token.y = y + variationY
    
    -- Initialize state machine properties
    token.status = Constants.TokenStatus.FREE
    token.state = Constants.TokenState.FREE -- For backwards compatibility
    token.isAnimating = false
    token.manaPool = self -- Reference to this mana pool instance
    token.id = #self.tokens + 1
    
    token.valenceIndex = valenceIndex
    token.orbitAngle = angle
    token.orbitSpeed = valence.baseSpeed * (0.8 + math.random() * 0.4) * direction
    
    -- Visual effects
    token.pulsePhase = math.random() * math.pi * 2
    token.pulseSpeed = 2 + math.random() * 3
    token.rotAngle = math.random() * math.pi * 2
    token.rotSpeed = math.random(-2, 2) * 0.5
    
    -- Valence jump timer
    token.valenceJumpTimer = 2 + math.random() * 8
    
    -- Valence transition properties
    token.inValenceTransition = false
    token.valenceTransitionTime = 0
    token.valenceTransitionDuration = 0.8
    token.sourceValenceIndex = valenceIndex
    token.targetValenceIndex = valenceIndex
    token.sourceRadiusX = valence.radiusX
    token.sourceRadiusY = valence.radiusY
    token.targetRadiusX = valence.radiusX
    token.targetRadiusY = valence.radiusY
    token.currentRadiusX = valence.radiusX
    token.currentRadiusY = valence.radiusY
    
    -- Size variation for visual interest
    token.scale = 0.85 + math.random() * 0.3
    
    -- Depth/z-order variation
    token.zOrder = math.random()
    
    token.originalSpeed = token.orbitSpeed
    
    -- If game state is available, store it for VFX access
    if self.gameState then
        token.gameState = self.gameState
    end
    
    -- Add to the pool's token list
    table.insert(self.tokens, token)
    
    return token
end

-- Add token with appearance animation from wizard
function ManaPool:addTokenWithAnimation(tokenType, imagePath, sourceWizard)
    if not sourceWizard then
        -- Fall back to regular addition if no wizard provided
        return self:addToken(tokenType, imagePath)
    end
    
    -- Get image from cache, with fallback
    local tokenImage = AssetCache.getImage(imagePath)
    if not tokenImage then
        print("WARNING: Failed to load token image: " .. imagePath .. " - using placeholder")
        -- Create a placeholder image using LÖVE's built-in canvas
        tokenImage = love.graphics.newCanvas(32, 32)
        love.graphics.setCanvas(tokenImage)
        love.graphics.clear(0.8, 0.2, 0.8, 1) -- Bright color to make missing textures obvious
        love.graphics.rectangle("fill", 0, 0, 32, 32)
        love.graphics.setCanvas()
    end
    
    -- Create a new token with animation-ready properties
    local token = Pool.acquire("token")
    
    -- Add methods from TokenMethods table
    for name, method in pairs(TokenMethods) do
        token[name] = method
    end
    
    -- Initialize basic properties
    token.type = tokenType
    token.image = tokenImage
    
    -- Position will be set by animation
    token.x = sourceWizard.x
    token.y = sourceWizard.y - 40 -- Start slightly above wizard
    
    -- Initialize state machine properties
    token.status = nil -- Will be set to APPEARING by requestAppearAnimation
    token.state = Constants.TokenState.FREE -- For backwards compatibility
    token.isAnimating = true
    token.manaPool = self  -- Reference to this mana pool instance
    token.id = #self.tokens + 1
    
    -- Visual effects
    token.pulsePhase = math.random() * math.pi * 2
    token.pulseSpeed = 2 + math.random() * 3
    token.rotAngle = math.random() * math.pi * 2
    token.rotSpeed = math.random(-2, 2) * 0.5
    
    -- Scale starts small and grows during animation
    token.scale = 0.1
    
    -- If game state is available, store it for VFX access
    if self.gameState then
        token.gameState = self.gameState
    end
    
    -- Add to the pool's token list
    table.insert(self.tokens, token)
    
    -- Start appearance animation
    token:requestAppearAnimation(sourceWizard)
    
    return token
end

-- Removed token repulsion system, reverting to pure orbital motion

function ManaPool:update(dt)
    -- Update token positions and states
    for i = #self.tokens, 1, -1 do
        local token = self.tokens[i]
        
        -- Skip updating POOLED tokens, they've been reset and their properties are nil
        if token.status == Constants.TokenStatus.POOLED then
            goto continue_token
        end
        
        -- Update token trail position history
        if not self.tokenTrails[token] then
            self.tokenTrails[token] = {}
        end
        
        -- Only add a new trail point if the token has moved significantly
        local lastPosition = self.tokenTrails[token][1]
        local shouldAddTrail = true
        
        if lastPosition then
            -- Calculate distance moved since last trail point
            local dx = token.x - lastPosition.x
            local dy = token.y - lastPosition.y
            local distSquared = dx*dx + dy*dy
            
            -- Only add trail points if moved more than a minimum distance
            shouldAddTrail = distSquared > 4
        end
        
        if shouldAddTrail then
            -- Store new position at the beginning of history array
            table.insert(self.tokenTrails[token], 1, {
                x = token.x, 
                y = token.y, 
                time = love.timer.getTime()
            })
            
            -- Limit trail length
            if #self.tokenTrails[token] > self.trailLength then
                table.remove(self.tokenTrails[token])
            end
        end
        
        -- Update token based on its status in the state machine
        if token.status == Constants.TokenStatus.FREE then
            -- Handle the transition period for newly returned tokens
            if token.inTransition then
                token.transitionTime = token.transitionTime + dt
                local transProgress = math.min(1, token.transitionTime / token.transitionDuration)
                
                -- Ease transition using a smooth curve
                transProgress = transProgress < 0.5 and 4 * transProgress * transProgress * transProgress 
                            or 1 - math.pow(-2 * transProgress + 2, 3) / 2
                
                -- During transition, gradually start orbital motion
                token.orbitAngle = token.orbitAngle + token.orbitSpeed * dt * transProgress
                
                -- Check if transition is complete
                if token.transitionTime >= token.transitionDuration then
                    token.inTransition = false
                end
            else
                -- Normal FREE token behavior after transition
                -- Update orbit angle with variable speed
                token.orbitAngle = token.orbitAngle + token.orbitSpeed * dt
                
                -- Update valence jump timer
                token.valenceJumpTimer = token.valenceJumpTimer - dt
                
                -- Chance to change valence when timer expires
                if token.valenceJumpTimer <= 0 then
                    token.valenceJumpTimer = 2 + math.random() * 8  -- Reset timer
                    
                    -- Random chance to jump to a different valence
                    if math.random() < self.valenceJumpChance * 100 then
                        -- Store current valence for interpolation
                        local oldValenceIndex = token.valenceIndex
                        local oldValence = self.valences[oldValenceIndex]
                        local newValenceIndex = oldValenceIndex
                        
                        -- Ensure we pick a different valence if more than one exists
                        if #self.valences > 1 then
                            while newValenceIndex == oldValenceIndex do
                                newValenceIndex = math.random(1, #self.valences)
                            end
                        end
                        
                        -- Start valence transition
                        local newValence = self.valences[newValenceIndex]
                        local direction = token.orbitSpeed > 0 and 1 or -1
                        
                        -- Set up transition parameters
                        token.inValenceTransition = true
                        token.valenceTransitionTime = 0
                        token.valenceTransitionDuration = 0.8  -- Time to transition between valences
                        token.sourceValenceIndex = oldValenceIndex
                        token.targetValenceIndex = newValenceIndex
                        token.sourceRadiusX = oldValence.radiusX
                        token.sourceRadiusY = oldValence.radiusY
                        token.targetRadiusX = newValence.radiusX
                        token.targetRadiusY = newValence.radiusY
                        
                        -- Update speed for new valence but maintain direction
                        token.orbitSpeed = newValence.baseSpeed * (0.8 + math.random() * 0.4) * direction
                        token.originalSpeed = token.orbitSpeed
                    end
                end
                
                -- Handle valence transition if active
                if token.inValenceTransition then
                    token.valenceTransitionTime = token.valenceTransitionTime + dt
                    local progress = math.min(1, token.valenceTransitionTime / token.valenceTransitionDuration)
                    
                    -- Use easing function for smooth transition
                    progress = progress < 0.5 and 4 * progress * progress * progress 
                              or 1 - math.pow(-2 * progress + 2, 3) / 2
                    
                    -- Interpolate between source and target radiuses
                    token.currentRadiusX = token.sourceRadiusX + (token.targetRadiusX - token.sourceRadiusX) * progress
                    token.currentRadiusY = token.sourceRadiusY + (token.targetRadiusY - token.sourceRadiusY) * progress
                    
                    -- Check if transition is complete
                    if token.valenceTransitionTime >= token.valenceTransitionDuration then
                        token.inValenceTransition = false
                        token.valenceIndex = token.targetValenceIndex
                    end
                end
                
                -- Occasionally vary the speed slightly
                if math.random() < 0.01 then
                    local direction = token.orbitSpeed > 0 and 1 or -1
                    local valence = self.valences[token.valenceIndex]
                    local variation = 0.9 + math.random() * 0.2  -- Subtle variation
                    token.orbitSpeed = valence.baseSpeed * variation * direction
                end
            end
            
            -- Common behavior for all FREE tokens
            -- Update pulse phase
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
            -- Calculate new position based on elliptical orbit - maintain perfect elliptical path
            if token.inValenceTransition then
                -- Use interpolated radii during transition
                token.x = self.x + math.cos(token.orbitAngle) * token.currentRadiusX
                token.y = self.y + math.sin(token.orbitAngle) * token.currentRadiusY
            else
                -- Use valence radii when not transitioning
                local valence = self.valences[token.valenceIndex]
                token.x = self.x + math.cos(token.orbitAngle) * valence.radiusX
                token.y = self.y + math.sin(token.orbitAngle) * valence.radiusY
            end
            
            -- Minimal wobble to maintain clean orbits but add slight visual interest
            local wobbleX = math.sin(token.pulsePhase * 0.7) * 2
            local wobbleY = math.cos(token.pulsePhase * 0.5) * 1
            token.x = token.x + wobbleX
            token.y = token.y + wobbleY
            
            -- Rotate token itself for visual interest, occasionally reversing direction
            if token.rotAngle and token.rotSpeed then
                token.rotAngle = token.rotAngle + token.rotSpeed * dt
                if math.random() < 0.002 then  -- Small chance to reverse rotation
                    token.rotSpeed = -token.rotSpeed
                end
            end
            
        elseif token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
            -- For channeled or shielding tokens, animate movement to/from their spell slot
            
            if token.animTime < token.animDuration then
                -- Token is still being animated to the spell slot
                token.animTime = token.animTime + dt
                local progress = math.min(1, token.animTime / token.animDuration)
                
                -- Ease in-out function for smoother animation
                progress = progress < 0.5 and 4 * progress * progress * progress 
                            or 1 - math.pow(-2 * progress + 2, 3) / 2
                
                -- Calculate current position based on bezier curve for arcing motion
                -- Start point
                local x0 = token.startX
                local y0 = token.startY
                
                -- End point (in the spell slot)
                local wizard = token.wizardOwner
                if wizard then
                    -- Calculate position in the 3D elliptical spell slot orbit
                    -- These values must match those in wizard.lua drawSpellSlots
                    local slotYOffsets = {30, 0, -30}  -- legs, midsection, head
                    local horizontalRadii = {80, 70, 60}  -- From bottom to top
                    local verticalRadii = {20, 25, 30}    -- From bottom to top
                    
                    local slotY = wizard.y + slotYOffsets[token.slotIndex]
                    local radiusX = horizontalRadii[token.slotIndex]
                    local radiusY = verticalRadii[token.slotIndex]
                    
                    local tokenCount = #wizard.spellSlots[token.slotIndex].tokens
                    local anglePerToken = math.pi * 2 / tokenCount
                    local tokenAngle = wizard.spellSlots[token.slotIndex].progress / 
                                       wizard.spellSlots[token.slotIndex].castTime * math.pi * 2 +
                                       anglePerToken * (token.tokenIndex - 1)
                    
                    -- Calculate position using elliptical projection
                    -- Apply the NEAR/FAR offset to the target position
                    local xOffset = 0
                    local isNear = wizard.gameState and wizard.gameState.rangeState == Constants.RangeState.NEAR
                    
                    -- Apply the same NEAR/FAR offset logic as in the wizard's draw function
                    local isLeft = true
                    if wizard.gameState and wizard.gameState.wizards then
                        for _, other in ipairs(wizard.gameState.wizards) do
                            if other ~= wizard then
                                isLeft = wizard.x <= other.x
                                break
                            end
                        end
                    end
                    if isLeft then
                        xOffset = isNear and 60 or 0
                    else
                        xOffset = isNear and -60 or 0
                    end
                    
                    local x3 = wizard.x + xOffset + math.cos(tokenAngle) * radiusX
                    local y3 = slotY + math.sin(tokenAngle) * radiusY
                    
                    -- Control points for bezier (creating an arc)
                    local midX = (x0 + x3) / 2
                    local midY = (y0 + y3) / 2 - 80  -- Arc height
                    
                    -- Quadratic bezier calculation
                    local t = progress
                    local u = 1 - t
                    token.x = u*u*x0 + 2*u*t*midX + t*t*x3
                    token.y = u*u*y0 + 2*u*t*midY + t*t*y3
                    
                    -- Update token rotation during flight
                    token.rotAngle = token.rotAngle + dt * 5  -- Spin faster during flight
                    
                    -- Store target position for the drawing function
                    token.targetX = x3
                    token.targetY = y3
                end
            else
                -- Animation complete - token is now in the spell orbit
                -- Token position will be updated by the wizard's drawSpellSlots function
                token.rotAngle = token.rotAngle + dt * 2  -- Continue spinning in orbit
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.RETURNING then
            -- Token is being animated back to the mana pool
            token.animTime = token.animTime + dt
            local progress = math.min(1, token.animTime / token.animDuration)
            
            -- Ease in-out function for smoother animation
            progress = progress < 0.5 and 4 * progress * progress * progress 
                        or 1 - math.pow(-2 * progress + 2, 3) / 2
            
            -- Calculate current position based on bezier curve for arcing motion
            local x0 = token.startX
            local y0 = token.startY
            local x3 = self.x  -- Center of mana pool
            local y3 = self.y
            
            -- Control points for bezier (creating an arc)
            local midX = (x0 + x3) / 2
            local midY = (y0 + y3) / 2 - 50  -- Arc height
            
            -- Quadratic bezier calculation
            local t = progress
            local u = 1 - t
            token.x = u*u*x0 + 2*u*t*midX + t*t*x3
            token.y = u*u*y0 + 2*u*t*midY + t*t*y3
            
            -- Update token rotation during flight - spin faster
            token.rotAngle = token.rotAngle + dt * 8
            
            -- Check if animation is complete
            if token.animTime >= token.animDuration then
                -- Token has reached the pool - call the animation callback
                if token.animationCallback then
                    token.animationCallback()
                else
                    print("[MANAPOOL] WARNING: No animation callback defined for returning token")
                    -- Fallback for backward compatibility
                    token:setState(Constants.TokenStatus.FREE)
                end
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.APPEARING then
            -- Token is being animated into existence from a wizard to the mana pool
            token.appearAnimTime = token.appearAnimTime + dt
            local progress = math.min(1, token.appearAnimTime / token.appearAnimDuration)
            
            -- Ease in-out function for smoother animation
            progress = progress < 0.5 and 4 * progress * progress * progress 
                        or 1 - math.pow(-2 * progress + 2, 3) / 2
            
            -- Calculate current position based on bezier curve for arcing motion
            local x0 = token.startX
            local y0 = token.startY
            local x3 = self.x  -- Center of mana pool
            local y3 = self.y
            
            -- Calculate higher arc height for appearing tokens
            local height = 80 -- Higher arc for appearing tokens
            
            -- Control points for bezier (creating an arc)
            local midX = (x0 + x3) / 2
            local midY = (y0 + y3) / 2 - height  -- Negative for upward arc
            
            -- Quadratic bezier calculation
            local t = progress
            local u = 1 - t
            token.x = u*u*x0 + 2*u*t*midX + t*t*x3
            token.y = u*u*y0 + 2*u*t*midY + t*t*y3
            
            -- Gradual scaling up with progress
            local startScale = 0.1  -- Start very small
            local endScale = token.targetScale or 1.0
            token.scale = startScale + (endScale - startScale) * progress
            
            -- Update token rotation during flight - spin faster while appearing
            token.rotAngle = token.rotAngle + dt * 10
            
            -- Check if animation is complete
            if token.appearAnimTime >= token.appearAnimDuration then
                -- Token has reached the pool center - transition to orbiting
                token.animationCallback()
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.ORBITING then
            -- Token is in second phase of return, animating from pool center to orbit position
            token.orbitAnimTime = token.orbitAnimTime + dt
            local progress = math.min(1, token.orbitAnimTime / token.orbitAnimDuration)
            
            -- Ease in-out function for smoother animation
            progress = progress < 0.5 and 4 * progress * progress * progress 
                        or 1 - math.pow(-2 * progress + 2, 3) / 2
            
            -- Calculate current position based on bezier curve for arcing motion
            local x0 = token.startOrbitX
            local y0 = token.startOrbitY
            local x3 = token.targetOrbitX
            local y3 = token.targetOrbitY
            
            -- Control points for bezier (creating an arc)
            -- Make the arc go outward in the direction of the target
            local dx = x3 - x0
            local dy = y3 - y0
            local dist = math.sqrt(dx*dx + dy*dy)
            local nx = dx / dist  -- Normalized direction vector
            local ny = dy / dist
            
            -- Control point perpendicular to the path with a height proportional to distance
            local arcHeight = math.min(dist * 0.4, 35)  -- Cap the arc height
            local midX = (x0 + x3) / 2 + ny * arcHeight  -- Perpendicular offset
            local midY = (y0 + y3) / 2 - nx * arcHeight
            
            -- Quadratic bezier calculation
            local t = progress
            local u = 1 - t
            token.x = u*u*x0 + 2*u*t*midX + t*t*x3
            token.y = u*u*y0 + 2*u*t*midY + t*t*y3
            
            -- Update token rotation during flight - spin faster but not as fast as returning
            token.rotAngle = token.rotAngle + dt * 5
            
            -- Check if animation is complete
            if token.orbitAnimTime >= token.orbitAnimDuration then
                -- Token has reached its orbit position - call the animation callback
                if token.animationCallback then
                    token.animationCallback()
                else
                    print("[MANAPOOL] WARNING: No animation callback defined for orbiting token")
                    -- Fallback
                    token:setState(Constants.TokenStatus.FREE)
                end
            end
            
            -- Update common pulse
            if token.pulsePhase and token.pulseSpeed then
                token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
            end
            
        elseif token.status == Constants.TokenStatus.DISSOLVING then
            -- Update dissolution animation
            token.dissolveTime = token.dissolveTime + dt
            
            -- When dissolution is complete, call the animation callback
            if token.dissolveTime >= token.dissolveMaxTime then
                -- Execute the callback to finalize destruction
                if token.animationCallback then
                    token.animationCallback()
                else
                    print("[MANAPOOL] WARNING: No animation callback defined for dissolving token")
                    -- No fallback needed; token will be removed on the next frame
                end
            end
            
        end
        
        -- Update common properties for all tokens (moved inside the token loop)
        if token.pulsePhase and token.pulseSpeed then
            token.pulsePhase = token.pulsePhase + token.pulseSpeed * dt
        end
        
        ::continue_token::
    end
end

function ManaPool:drawToken(token)
    -- Skip drawing POOLED tokens (should not happen if called correctly, but good safeguard)
    if token.status == Constants.TokenStatus.POOLED then
        return
    end
    
    -- Draw trailing effect behind the token first (similar to main menu tokens)
    if self.tokenTrails[token] and #self.tokenTrails[token] > 2 then
        local colorTable = Constants.getColorForTokenType(token.type)
        local stepSize = (#self.tokenTrails[token] > 20) and 2 or 1
        
        for j = #self.tokenTrails[token], 2, -stepSize do
            local pos = self.tokenTrails[token][j]
            local time = love.timer.getTime()
            local timeDiff = time - pos.time
            
            -- Calculate fade based on position in trail (older = more transparent)
            local trailAlpha = 0.2 * (1 - (j / self.trailLength)^1.5)
            
            -- Trail size based on position (older = smaller)
            local trailScale = 12 * (1 - (j / self.trailLength) * 0.6)
            
            -- Adjust trail appearance based on token state
            if token.status == Constants.TokenStatus.APPEARING then
                -- Enhanced trail for appearing tokens (brightest)
                trailAlpha = trailAlpha * 1.8
                trailScale = trailScale * 1.4
            elseif token.status == Constants.TokenStatus.RETURNING then
                -- Enhanced trail for returning tokens
                trailAlpha = trailAlpha * 1.5
                trailScale = trailScale * 1.2
            elseif token.status == Constants.TokenStatus.ORBITING then
                -- Enhanced trail for orbiting tokens
                trailAlpha = trailAlpha * 1.3
                trailScale = trailScale * 1.1
            elseif token.status ~= Constants.TokenStatus.FREE then
                -- Reduce trails for other token states
                trailAlpha = trailAlpha * 0.7
                trailScale = trailScale * 0.7
            end
            
            -- Draw trail particle
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], trailAlpha)
            love.graphics.circle("fill", pos.x, pos.y, trailScale)
        end
    end
    
    -- Draw a larger, more vibrant glow around the token based on its type
    local glowSize = 15 -- Larger glow radius
    local glowIntensity = 0.6  -- Stronger glow intensity
    
    -- Multiple glow layers for more visual interest
    for layer = 1, 2 do
        local layerSize = glowSize * (1.2 - layer * 0.3)
        local layerIntensity = glowIntensity * (layer == 1 and 0.4 or 0.8)
        
        -- Increase glow for tokens in transition (newly returned to pool)
        if token.status == Constants.TokenStatus.FREE and token.inTransition then
            -- Stronger glow that fades over the transition period
            local transitionBoost = 0.6 + 0.8 * (1 - token.transitionTime / token.transitionDuration)
            layerSize = layerSize * (1 + transitionBoost * 0.5)
            layerIntensity = layerIntensity + transitionBoost * 0.5
        end
        
        -- Special visual effects for APPEARING tokens
        if token.status == Constants.TokenStatus.APPEARING then
            -- Intense, bright glow for appearing tokens
            local appearProgress = token.appearAnimTime / token.appearAnimDuration
            layerSize = layerSize * (1.4 + appearProgress * 1.0) -- Extra large glow
            layerIntensity = layerIntensity + appearProgress * 0.6 -- Very bright
        -- Special visual effects for RETURNING tokens
        elseif token.status == Constants.TokenStatus.RETURNING then
            -- Bright, trailing glow for returning tokens
            local returnProgress = token.animTime / token.animDuration
            layerSize = layerSize * (1.2 + returnProgress * 0.8) -- Growing glow
            layerIntensity = layerIntensity + returnProgress * 0.4 -- Brightening
        end
        
        -- Special visual effects for DISSOLVING tokens
        if token.status == Constants.TokenStatus.DISSOLVING then
            -- Fading, expanding glow for dissolving tokens
            local dissolveProgress = token.dissolveTime / token.dissolveMaxTime
            layerSize = layerSize * (1 + dissolveProgress) -- Expanding glow
            layerIntensity = layerIntensity * (1 - dissolveProgress * 0.8) -- Fading
        end
        
        -- Set glow color based on token type with improved contrast and vibrancy
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], layerIntensity)
        
        -- Draw glow with pulsation
        local pulseAmount = 0.7 + 0.3 * math.sin(token.pulsePhase * 0.5)
        
        -- Enhanced pulsation for transitioning tokens
        if token.status == Constants.TokenStatus.FREE and token.inTransition then
            pulseAmount = pulseAmount + 0.3 * math.sin(token.transitionTime * 10)
        end
        
        -- Enhanced pulsation for returning tokens
        if token.status == Constants.TokenStatus.RETURNING then
            pulseAmount = pulseAmount + 0.4 * math.sin(token.animTime * 15)
        end
        
        love.graphics.circle("fill", token.x, token.y, layerSize * pulseAmount * token.scale)
    end
    
    -- Draw a small outer ring for better definition
    if token.status == Constants.TokenStatus.FREE then
        local ringAlpha = 0.4 + 0.2 * math.sin(token.pulsePhase * 0.8)
        
        -- Set ring color based on token type
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], ringAlpha)
        
        love.graphics.circle("line", token.x, token.y, (glowSize + 3) * token.scale)
    end
    
    -- Draw a trailing effect for returning tokens
    if token.status == Constants.TokenStatus.RETURNING then
        local progress = token.animTime / token.animDuration
        local trailAlpha = 0.6 * (1 - progress)
        
        -- Set trail color based on token type
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], trailAlpha)
        
        -- Draw the trail as small circles along the bezier path
        local numTrailPoints = 6
        for i = 0, numTrailPoints do
            local trailProgress = progress - (i / numTrailPoints) * 0.25  -- Trail behind the token
            
            -- Only draw trail points that are within the animation progress
            if trailProgress > 0 and trailProgress < 1 then
                -- Calculate position along the bezier path
                local x0 = token.startX
                local y0 = token.startY
                local x3 = self.x  -- End at center of mana pool
                local y3 = self.y
                
                -- Control points for bezier curve
                local midX = (x0 + x3) / 2
                local midY = (y0 + y3) / 2 - 50  -- Arc height
                
                -- Quadratic bezier calculation
                local t = trailProgress
                local u = 1 - t
                local trailX = u*u*x0 + 2*u*t*midX + t*t*x3
                local trailY = u*u*y0 + 2*u*t*midY + t*t*y3
                
                -- Draw trail point with decreasing size
                local pointSize = (numTrailPoints - i) / numTrailPoints * 8 * token.scale
                love.graphics.circle("fill", trailX, trailY, pointSize)
            end
        end
    end
    
    -- Draw token image based on state
    if token.status == Constants.TokenStatus.FREE then
        -- Free tokens are fully visible
        -- If token is in transition (just returned to pool), add a subtle glow effect
        if token.inTransition then
            local transitionGlow = 0.2 + 0.8 * (1 - token.transitionTime / token.transitionDuration)
            love.graphics.setColor(1, 1, 1 + transitionGlow * 0.5, 1)  -- Slightly blue-white glow during transition
        else
            love.graphics.setColor(1, 1, 1, 1)
        end
    elseif token.status == Constants.TokenStatus.CHANNELED then
        -- Channeled tokens are fully visible
        love.graphics.setColor(1, 1, 1, 1)
    elseif token.status == Constants.TokenStatus.SHIELDING then
        -- Shielding tokens have a slight colored tint based on their type
        local colorTable = Constants.getColorForTokenType(token.type)
        -- Use the color from Constants, but keep alpha = 1 for the tint
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], 1)
    elseif token.status == Constants.TokenStatus.RETURNING then
        -- Returning tokens have a bright, energetic glow
        local returnGlow = 0.3 + 0.7 * math.sin(token.animTime * 15)
        love.graphics.setColor(1, 1, 1, 0.8 + returnGlow * 0.2)
    elseif token.status == Constants.TokenStatus.DISSOLVING then
        -- Dissolving tokens fade out
        -- Calculate progress of the dissolve animation
        local progress = token.dissolveTime / token.dissolveMaxTime
        
        -- Fade out by decreasing alpha
        local alpha = (1 - progress) * 0.8
        
        -- Get token color based on its type for the fade effect
        local colorTable = Constants.getColorForTokenType(token.type)
        love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], alpha)
    else
        -- For legacy compatibility - handle any other states (like "DESTROYED")
        -- Check for dissolving flag for backwards compatibility
        if token.dissolving then
            local progress = token.dissolveTime / token.dissolveMaxTime
            local alpha = (1 - progress) * 0.8
            love.graphics.setColor(1, 1, 1, alpha)
        else
            love.graphics.setColor(1, 1, 1, 1)
        end
    end
    
    -- Draw the token with dynamic scaling
    if token.status == Constants.TokenStatus.DISSOLVING then
        -- For dissolving tokens, add special effects
        local progress = token.dissolveTime / token.dissolveMaxTime
        
        -- Expand and fade out
        local scaleFactor = token.dissolveScale * (1 + progress * 0.5)
        local rotationSpeed = token.rotSpeed or 1.0
        
        -- Speed up rotation as it dissolves
        token.rotAngle = token.rotAngle + rotationSpeed * 5 * progress
        
        -- Draw at original position with expanding effect
        love.graphics.draw(
            token.image, 
            token.initialX, 
            token.initialY, 
            token.rotAngle,
            scaleFactor * (1 - progress * 0.7), scaleFactor * (1 - progress * 0.7),
            token.image:getWidth()/2, token.image:getHeight()/2
        )
    else
        -- Normal tokens
        love.graphics.draw(
            token.image, 
            token.x, 
            token.y, 
            token.rotAngle,  -- Use the rotation angle
            token.scale, token.scale,  -- Use token-specific scale
            token.image:getWidth()/2, token.image:getHeight()/2  -- Origin at center
        )
    end
    
    -- Draw additional effects for non-POOLED tokens only
    if token.status ~= Constants.TokenStatus.POOLED then
        -- Draw shield effect for shielding tokens
        if token.status == Constants.TokenStatus.SHIELDING then
            -- Get token color based on its mana type
            local colorTable = Constants.getColorForTokenType(token.type)
            local shieldBaseAlpha = 0.3 -- Keep the original base alpha
            
            -- Draw a subtle shield aura with slight pulsation
            local pulseScale = 0.9 + math.sin(love.timer.getTime() * 2) * 0.1
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], shieldBaseAlpha)
            love.graphics.circle("fill", token.x, token.y, 15 * pulseScale * token.scale)
            
            -- Draw shield border
            love.graphics.setColor(colorTable[1], colorTable[2], colorTable[3], 0.5) -- Keep original border alpha
            love.graphics.circle("line", token.x, token.y, 15 * pulseScale * token.scale)
        end
    end
end

function ManaPool:draw()
    -- No longer drawing the pool background or valence rings
    -- The pool is now completely invisible, defined only by the positions of the tokens
    
    -- Sort tokens by z-order for better layering
    local sortedTokens = {}
    for i, token in ipairs(self.tokens) do
        table.insert(sortedTokens, {token = token, index = i})
    end
    
    table.sort(sortedTokens, function(a, b)
        -- Safe sorting - handle nil zOrder values
        local zOrderA = a.token.zOrder or 0
        local zOrderB = b.token.zOrder or 0
        return zOrderA > zOrderB
    end)
    
    -- Draw tokens in sorted order, skipping those attached to wizards
    for _, tokenData in ipairs(sortedTokens) do
        local token = tokenData.token
        
        -- Only draw tokens that are NOT CHANNELED or SHIELDING
        if token.status ~= Constants.TokenStatus.CHANNELED and 
           token.status ~= Constants.TokenStatus.SHIELDING then
            self:drawToken(token)
        end
    end
    
    -- No border - the pool is now completely invisible
end

-- Helper function to draw an ellipse
function ManaPool:drawEllipse(x, y, radiusX, radiusY, mode)
    local segments = 64
    local vertices = {}
    
    for i = 1, segments do
        local angle = (i - 1) * (2 * math.pi / segments)
        local px = x + math.cos(angle) * radiusX
        local py = y + math.sin(angle) * radiusY
        table.insert(vertices, px)
        table.insert(vertices, py)
    end
    
    -- Close the shape by adding the first point again
    table.insert(vertices, vertices[1])
    table.insert(vertices, vertices[2])
    
    if mode == "fill" then
        love.graphics.polygon("fill", vertices)
    else
        love.graphics.polygon("line", vertices)
    end
end

function ManaPool:findFreeToken(tokenType)
    -- Find a free token of the specified type without changing its state
    for i, token in ipairs(self.tokens) do
        if token.type == tokenType and token.status == Constants.TokenStatus.FREE then
            return token, i  -- Return token and its index without changing state
        end
    end
    return nil  -- No token available
end

function ManaPool:getToken(tokenType)
    -- Find a free token of the specified type that's not in transition
    for i, token in ipairs(self.tokens) do
        if token.type == tokenType and token.status == Constants.TokenStatus.FREE and
           not token.returning and not token.inTransition then
            -- Mark as being used (using setState for state machine)
            token:setState(Constants.TokenStatus.CHANNELED)
            return token, i  -- Return token and its index
        end
    end
    
    -- Second pass - try with less strict requirements if nothing was found
    for i, token in ipairs(self.tokens) do
        if token.type == tokenType and token.status == Constants.TokenStatus.FREE then
            if token.returning then
                print("[MANAPOOL] WARNING: Using token in return animation - visual glitches may occur")
            elseif token.inTransition then
                print("[MANAPOOL] WARNING: Using token in transition state - visual glitches may occur")
            end
            
            -- Use setState method for state machine transition
            token:setState(Constants.TokenStatus.CHANNELED)
            
            -- Cancel any return animation
            token.returning = false
            token.inTransition = false
            return token, i
        end
    end
    
    return nil  -- No token available
end

function ManaPool:returnToken(tokenIndex)
    -- Return a token to the pool using the new state machine
    if self.tokens[tokenIndex] then
        local token = self.tokens[tokenIndex]
        
        -- Use token's method if available, otherwise fallback to legacy behavior
        if token.requestReturnAnimation then
            token:requestReturnAnimation()
        else
            -- Legacy fallback for tokens that don't have the state machine methods
            print("[MANAPOOL] WARNING: Using legacy return method for token " .. tokenIndex .. " - state machine methods not found")
            
            -- Validate the token state and ownership before return
            if token.returning then
                print("[MANAPOOL] WARNING: Token " .. tokenIndex .. " is already being returned - ignoring duplicate return")
                return
            end
            
            -- Clear any wizard ownership immediately to prevent double-tracking
            token.wizardOwner = nil
            token.spellSlot = nil
            
            -- Ensure token is in a valid state - convert any state to valid transition state
            local originalState = token.state
            if token.state == Constants.TokenState.SHIELDING or token.state == Constants.TokenState.CHANNELED then
            elseif token.state ~= Constants.TokenState.FREE then
                print("[MANAPOOL] WARNING: Returning token " .. tokenIndex .. " from unexpected state: " .. 
                     (token.state or "nil"))
            end
            
            -- Store current position as start position for return animation
            token.startX = token.x
            token.startY = token.y
            
            -- Set up return animation parameters
            token.targetX = self.x  -- Center of mana pool
            token.targetY = self.y
            token.animTime = 0
            token.animDuration = 0.5 -- Half second return animation
            token.returning = true   -- Flag that this token is returning to the pool
            token.originalState = originalState  -- Remember what state it was in before return
        end
    else
        print("[MANAPOOL] WARNING: Attempted to return invalid token index: " .. tokenIndex)
    end
end

-- This method has been replaced by token:finalizeReturn
-- Kept for backward compatibility with code that hasn't been updated yet
function ManaPool:finalizeTokenReturn(token)
    print("[MANAPOOL] WARNING: ManaPool:finalizeTokenReturn is deprecated, use token:finalizeReturn instead")
    
    -- Just call the token's method if available
    if token.finalizeReturn then
        token:finalizeReturn()
    else
        -- Legacy fallback (simplified)
        token.state = Constants.TokenState.FREE
        token.status = Constants.TokenStatus.FREE
        token.returning = false
        token.wizardOwner = nil
        token.spellSlot = nil
        token.tokenIndex = nil
    end
end

return ManaPool```

## ./spellCompiler.lua
```lua
-- spellCompiler.lua
-- Compiles spell definitions using keyword behaviors
--
-- IMPORTANT: This system now uses a pure event-based architecture.
-- All keyword behaviors should create events rather than directly modifying game state.
-- Events are processed by the EventRunner module after all behaviors have been executed.
-- The events should follow the schema defined in docs/combat_events.md.
--
-- Example event structure:
-- {
--   type = "DAMAGE",       -- Required: Type of the event
--   source = "caster",     -- Required: Source of the event (usually "caster")
--   target = "enemy",      -- Required: Target of the event (e.g., "self", "enemy", "both", etc.)
--   amount = 10,           -- Event-specific data
--   damageType = "fire"    -- Event-specific data
-- }

local SpellCompiler = {}

-- Add the EventRunner module for event-based execution
local EventRunner = nil -- Lazy-loaded to avoid circular dependencies

-- Keep track of whether we're currently trying to load EventRunner to detect circular dependencies
local isLoadingEventRunner = false

-- Helper function to merge tables
local function mergeTables(target, source)
    for k, v in pairs(source) do
        if type(v) == "table" and type(target[k]) == "table" then
            -- Recursively merge nested tables
            mergeTables(target[k], v)
        else
            -- For non-table values or if target key doesn't exist as table,
            -- simply overwrite/set the value
            target[k] = v
        end
    end
    return target
end

-- Main compilation function
-- Takes a spell definition and keyword data, returns a compiled spell
function SpellCompiler.compileSpell(spellDef, keywordData)
    -- Debug - check for onBlock in keywords.block
    if spellDef.keywords and spellDef.keywords.block and spellDef.keywords.block.onBlock then
        print("[COMPILER DEBUG] Spell " .. spellDef.id .. " has onBlock handler in keywords.block")
    end
    
    -- Create a new compiledSpell object
    local compiledSpell = {
        -- Copy base spell properties
        id = spellDef.id,
        name = spellDef.name,
        affinity = spellDef.affinity,
        description = spellDef.description,
        attackType = spellDef.attackType,
        castTime = spellDef.castTime,
        cost = spellDef.cost,
        keywords = spellDef.keywords,
        visualShape = spellDef.visualShape, -- Copy visualShape for template override
        vfx = spellDef.vfx,
        sfx = spellDef.sfx,
        -- Create empty behavior table to store merged behavior data
        behavior = {}
    }
    
    -- >>> ADDED: Also copy the getCastTime function if it exists
    if spellDef.getCastTime and type(spellDef.getCastTime) == "function" then
        compiledSpell.getCastTime = spellDef.getCastTime
    end

    -- >>> ADDED: Copy dynamic mana cost function if present
    if spellDef.getCost and type(spellDef.getCost) == "function" then
        compiledSpell.getCost = spellDef.getCost
    end
    
    -- Process keywords if they exist
    if spellDef.keywords then
        print("DEBUG: Processing keywords for spell " .. spellDef.id)
        for keyword, params in pairs(spellDef.keywords) do
            print("DEBUG:   Found keyword: " .. keyword)
            -- Check if the keyword exists in the keyword data
            if keywordData[keyword] and keywordData[keyword].behavior then
                -- Get the behavior definition for this keyword
                local keywordBehavior = keywordData[keyword].behavior
                
                -- Create behavior entry for this keyword with default behavior
                compiledSpell.behavior[keyword] = {}
                
                -- Copy the default behavior parameters
                mergeTables(compiledSpell.behavior[keyword], keywordBehavior)
                
                -- Apply specific parameters from the spell definition
                if type(params) == "table" then
                    -- For table parameters, process them first to capture any functions
                    compiledSpell.behavior[keyword].params = {}
                    
                    -- Copy params to behavior.params, preserving functions
                    for paramName, paramValue in pairs(params) do
                        compiledSpell.behavior[keyword].params[paramName] = paramValue
                    end
                elseif type(params) == "boolean" and params == true then
                    -- For boolean true parameters, just use default params
                    compiledSpell.behavior[keyword].enabled = true
                else
                    -- For any other type, store as a value parameter
                    compiledSpell.behavior[keyword].value = params
                end
                
                -- Bind the execute function from the keyword
                compiledSpell.behavior[keyword].execute = keywordData[keyword].execute
            else
                -- If keyword wasn't found in the keyword data, log an error
                print("Warning: Keyword '" .. keyword .. "' not found in keyword data for spell '" .. compiledSpell.name .. "'")
            end
        end
    end
    
    -- Handle top-level vfx field (convert to vfx keyword if not already present)
    if spellDef.vfx and not (spellDef.keywords and spellDef.keywords.vfx) and keywordData.vfx then
        print("DEBUG: Converting top-level vfx to keyword for spell " .. spellDef.id)
        
        -- Create behavior entry for vfx keyword
        compiledSpell.behavior.vfx = {}
        
        -- Copy the default behavior parameters from the keyword
        mergeTables(compiledSpell.behavior.vfx, keywordData.vfx.behavior)
        
        -- Create params based on vfx value
        compiledSpell.behavior.vfx.params = {
            effect = spellDef.vfx -- Use the vfx string as the effect name
        }
        
        -- Bind the execute function from the vfx keyword
        compiledSpell.behavior.vfx.execute = keywordData.vfx.execute
    end
    
        -- Method to get the event runner module (lazy loading)
    local function getEventRunner()
        if not EventRunner then
            -- Detect circular dependencies
            if isLoadingEventRunner then
                print("CIRCULAR DEPENDENCY DETECTED: Already trying to load EventRunner")
                -- Return dummy EventRunner to break the circular dependency
                return {
                    processEvents = function(events, caster, target, spellSlot)
                        print("CIRCULAR DEPENDENCY: Using dummy EventRunner.processEvents")
                        return {eventsProcessed = 0}
                    end,
                    debugPrintEvents = function(events)
                        print("CIRCULAR DEPENDENCY: Using dummy EventRunner.debugPrintEvents")
                    end
                }
            end
            
            -- Set flag to indicate we're trying to load EventRunner
            isLoadingEventRunner = true
            
            -- Use pcall to avoid crashes from circular dependencies
            local success, result = pcall(function() 
                return require("systems.EventRunner") 
            end)
            
            -- Reset flag after load attempt
            isLoadingEventRunner = false
            
            if success then
                EventRunner = result
            else
                print("WARNING: Failed to load EventRunner: " .. tostring(result))
                -- Return a dummy EventRunner with processEvents to avoid crashes
                return {
                    processEvents = function(events, caster, target, spellSlot)
                        print("FALLBACK: Using dummy EventRunner.processEvents")
                        return {eventsProcessed = 0}
                    end,
                    debugPrintEvents = function(events)
                        print("FALLBACK: Using dummy EventRunner.debugPrintEvents")
                    end
                }
            end
        end
        return EventRunner
    end
    
    -- Add a method to execute all behaviors for this spell
    compiledSpell.executeAll = function(caster, target, results, spellSlot)
        -- LOGGING with safety checks
        if caster and caster.spellSlots and spellSlot and caster.spellSlots[spellSlot] then
            print(string.format("DEBUG_EXECUTE_ALL: Slot %d castTimeModifier=%.4f", 
                spellSlot, caster.spellSlots[spellSlot].castTimeModifier or 0))
        else
            -- Safe fallback logging
            print(string.format("DEBUG_EXECUTE_ALL: Slot %s (safety check failed, some values are nil)", 
                tostring(spellSlot)))
        end

        results = results or {}
        
        -- Check if this spell has shield behavior (block keyword)
        local hasShieldBehavior = compiledSpell.behavior.block ~= nil
        
        -- If this is a shield spell, tag the compiled spell
        if hasShieldBehavior or compiledSpell.isShield then
            compiledSpell.isShield = true
        end
        
        -- When using the event system, we collect events instead of directly mutating state
        local events = {}
        
        -- Execute each behavior
        for keyword, behavior in pairs(compiledSpell.behavior) do
            if behavior.execute then
                local params = behavior.params or {}
                
                -- Execute the behavior to get events
                local behaviorResults = {}
                local results = {currentSlot = spellSlot}  -- Base results with slot info
                
                -- The keyword's execute function is now solely responsible 
                -- for handling its params, including function evaluation.
                if behavior.enabled then
                    -- If it's a boolean-enabled keyword with no params
                    behaviorResults = behavior.execute({}, caster, target, results, events, compiledSpell) -- Pass empty params and the spell
                elseif behavior.value ~= nil then
                    -- If it's a simple value parameter
                    behaviorResults = behavior.execute({value = behavior.value}, caster, target, results, events, compiledSpell)
                else
                    -- Normal case with params table
                    behaviorResults = behavior.execute(params, caster, target, results, events, compiledSpell)
                end
                
                -- Debug output for events immediately after execute
                if keyword == "freeze" then
                    print(string.format("DEBUG: After executing %s keyword, events table has %d entries", 
                        keyword, events and #events or 0))
                end
                
                -- Merge the behavior results into the main results for backward compatibility
                for k, v in pairs(behaviorResults) do
                    results[k] = v
                end
                
                -- Special handling for vfx keyword's effectOverride
                -- This is part of the VFX-R5 refactoring to deprecate manual VFX specification
                if keyword == "vfx" and results.effectOverride then
                    -- Remember the override for when a damage event generates an EFFECT event
                    compiledSpell.effectOverride = results.effectOverride
                    compiledSpell.effectTarget = results.effectTarget
                    compiledSpell.effectDuration = results.effectDuration
                    compiledSpell.vfxParams = results.vfxParams
                end
                
                -- DEBUG ONLY: Log info about block keyword, but don't create duplicate events
                if keyword == "block" then
                    -- Debug the block keyword behavior 
                    print("[COMPILER DEBUG] Processing block keyword in executeAll")
                    
                    -- Check for onBlock in params
                    if params and params.onBlock then
                        print("[COMPILER DEBUG] Found onBlock handler in params")
                    else
                        print("[COMPILER DEBUG] No onBlock handler in params")
                    end
                    
                    -- NOTE: We no longer create a CREATE_SHIELD event here
                    -- The Keywords.block.execute function already creates this event
                    -- Creating it here would cause a duplicate event
                    
                    -- Debug info about shield parameters if available
                    if behaviorResults and behaviorResults.shieldParams then
                        local defenseType = behaviorResults.shieldParams.defenseType or Constants.ShieldType.BARRIER
                        print("[COMPILER DEBUG] Shield type: " .. defenseType)
                    end
                end
            end
        end
        
        -- If this is a shield spell, mark this in the results
        if hasShieldBehavior or compiledSpell.isShield then
            results.isShield = true
        end
        
        -- Check for sustain keyword or block keyword (which marks spells as sustained)
        if compiledSpell.behavior.sustain or 
           (compiledSpell.behavior.block and compiledSpell.behavior.block.marksSpellAsSustained) then
            -- This will be picked up by Wizard:castSpell to handle sustained spells
            results.isSustained = true
            print("DEBUG: Spell " .. compiledSpell.id .. " marked as sustained")
        else
            print("DEBUG: Spell " .. compiledSpell.id .. " not marked as sustained. Checking for sustain/shield keywords...")
            
            -- Debug: Print out the behavior table keys to see if sustain or block is there
            for behaviorKey, _ in pairs(compiledSpell.behavior) do
                print("  Behavior found: " .. behaviorKey)
                
                -- If it's the block keyword, check if it has marksSpellAsSustained
                if behaviorKey == "block" then
                    print("    Block keyword found. marksSpellAsSustained = " .. 
                        tostring(compiledSpell.behavior.block.marksSpellAsSustained))
                end
            end
        end
        
        -- Check for trap keywords and ensure they're in the results
        -- These trap-related fields will be used by the SustainedSpellManager later
        if compiledSpell.behavior.trap_trigger then
            -- Make sure trapTrigger data is in the results
            if not results.trapTrigger then
                results.trapTrigger = compiledSpell.behavior.trap_trigger.params or {}
                print("DEBUG: Adding trapTrigger data to results: " .. tostring(results.trapTrigger))
            end
        end


        if compiledSpell.behavior.trap_effect then
            -- Make sure trapEffect data is in the results
            if not results.trapEffect then
                results.trapEffect = compiledSpell.behavior.trap_effect.params or {}
                print("DEBUG: Adding trapEffect data to results: " .. tostring(results.trapEffect))
            end
        end

        if compiledSpell.behavior.field_status then
            if not results.fieldStatus then
                results.fieldStatus = compiledSpell.behavior.field_status.params or {}
                print("DEBUG: Adding fieldStatus data to results: " .. tostring(results.fieldStatus))
            end
        end
        
        -- Wrap event processing in pcall to avoid crashing the game
        local success, result = pcall(function()
            -- Debug output for events
            if _G.DEBUG_EVENTS then
                local debugRunner = getEventRunner()
                if debugRunner and debugRunner.debugPrintEvents then
                    debugRunner.debugPrintEvents(events)
                end
            end
            
            -- Process the events to apply them to the game state
            local eventResults = {}
            if events and #events > 0 then
                print(string.format("DEBUG_EVENTS: Processing %d events for spell %s", 
                    #events, compiledSpell.id or "unknown"))
                
                -- Print type of first event as sanity check
                if events[1] and events[1].type then
                    print(string.format("DEBUG_EVENTS: First event type is %s", events[1].type))
                end
                
                -- If spell is blocked, convert DAMAGE events to BLOCKED_DAMAGE
                -- This preserves visuals while preventing actual damage application
                if results.blockInfo and results.blockInfo.blockable then
                    print("[COMPILER] Spell blocked - converting DAMAGE to BLOCKED_DAMAGE events")
                    
                    -- Ensure blockInfo has a blockPoint for visuals
                    if not results.blockInfo.blockPoint then
                        print("[COMPILER] WARNING: blockInfo missing blockPoint, setting default 0.75")
                        results.blockInfo.blockPoint = 0.75
                    end
                    
                    -- Enhanced debugging for blockInfo
                    print("[COMPILER] BlockInfo details:")
                    for k, v in pairs(results.blockInfo) do
                        print("  " .. k .. ": " .. tostring(v))
                    end
                    
                    -- Process each event
                    local blockEventsFound = false
                    for i, event in ipairs(events) do
                        if event.type == "DAMAGE" then
                            blockEventsFound = true
                            
                            -- Convert to BLOCKED_DAMAGE event type
                            event.type = "BLOCKED_DAMAGE"
                            
                            -- Add blockInfo for visuals, deep copy to avoid modification issues
                            event.blockInfo = {
                                blockable = results.blockInfo.blockable,
                                blockType = results.blockInfo.blockType,
                                blockPoint = results.blockInfo.blockPoint,
                                blockingSlot = results.blockInfo.blockingSlot
                            }
                            
                            -- Explicitly set blockPoint at both levels for redundancy
                            event.blockPoint = results.blockInfo.blockPoint
                            
                            -- Add shield block tag
                            event.tags = event.tags or {}
                            event.tags.SHIELD_BLOCKED = true
                            
                            print(string.format("[COMPILER] Converted DAMAGE to BLOCKED_DAMAGE event with blockPoint=%.2f", 
                                event.blockPoint))
                        end
                    end
                    
                    -- Warning if no DAMAGE events were found to convert
                    if not blockEventsFound then
                        print("[COMPILER] WARNING: Spell was blocked but no DAMAGE events found to convert")
                    end
                end
                
                -- Get the EventRunner and process events with additional error handling
                local runner = getEventRunner()
                if runner and runner.processEvents then
                    -- Try to process events, but handle any errors gracefully
                    local ok, result = pcall(function()
                        return runner.processEvents(events, caster, target, spellSlot)
                    end)
                    
                    if ok then
                        eventResults = result
                    else
                        print("ERROR processing events: " .. tostring(result))
                        -- Return a default result structure
                        eventResults = { eventsProcessed = 0 }
                    end
                else
                    print("WARNING: EventRunner not available for processing")
                    eventResults = { eventsProcessed = 0 }
                end
            else
                print("WARNING: No events generated for spell " .. (compiledSpell.id or "unknown"))
            end
            
            -- Add event processing results to the main results
            results.events = events
            results.eventsProcessed = eventResults.eventsProcessed
            
            -- Set blocked flag in results if blockInfo present
            if results.blockInfo and results.blockInfo.blockable then
                results.blocked = true
                results.blockType = results.blockInfo.blockType
                
                print("[COMPILER] Spell was blocked by shield - setting blocked flag")
            end
            
            return results
        end)
        
        if success then
            -- Return the combined results if everything went well
            return result
        else
            -- Log the error but still return the original results for fallback
            print("ERROR in event processing: " .. tostring(result))
            print("Falling back to direct results without event processing")
            return results
        end
    end
    
    -- Add method for direct event generation without execution
    -- Useful for testing and debugging
    compiledSpell.generateEvents = function(caster, target, spellSlot)
        local events = {}
        
        -- Execute each behavior to generate events
        for keyword, behavior in pairs(compiledSpell.behavior) do
            if behavior.execute then
                local params = behavior.params or {}
                local localResults = {}
                
                -- Execute the behavior to generate events directly
                -- No state modification occurs
                if behavior.enabled then
                    -- Call the keyword execute function with an empty results table
                    -- The events parameter allows keywords to add events directly via table.insert
                    behavior.execute(params, caster, target, {currentSlot = spellSlot}, events, compiledSpell)
                elseif behavior.value ~= nil then
                    behavior.execute({value = behavior.value}, caster, target, {currentSlot = spellSlot}, events, compiledSpell)
                else
                    behavior.execute(params, caster, target, {currentSlot = spellSlot}, events, compiledSpell)
                end
                
                -- DEBUG ONLY: Log info about block keyword, but don't create duplicate events
                if keyword == "block" then
                    -- Debug the block keyword behavior
                    print("[COMPILER DEBUG] Processing block keyword in generateEvents")
                    
                    -- NOTE: We no longer create a CREATE_SHIELD event here
                    -- The Keywords.block.execute function already creates this event
                    -- Creating it here would cause a duplicate event
                    
                    -- Debug info about shield parameters
                    local shieldParams = localResults.shieldParams or {}
                    local defenseType = shieldParams.defenseType or Constants.ShieldType.BARRIER
                    print("[COMPILER DEBUG] Shield type from generateEvents: " .. defenseType)
                    
                    -- Check if onBlock is in the params (just for debug info)
                    if params and params.onBlock then
                        print("[COMPILER DEBUG] Found onBlock handler in params")
                    end
                end
            end
        end
        
        return events
    end
    
    return compiledSpell
end

-- Function to test compile a spell and display its components
function SpellCompiler.debugCompiled(compiledSpell)
    print("=== Debug Compiled Spell: " .. compiledSpell.name .. " ===")
    print("ID: " .. compiledSpell.id)
    print("Attack Type: " .. compiledSpell.attackType)
    print("Cast Time: " .. compiledSpell.castTime)
    
    print("Cost: ")
    for _, token in ipairs(compiledSpell.cost) do
        print("  - " .. token)
    end
    
    print("Behaviors: ")
    for keyword, behavior in pairs(compiledSpell.behavior) do
        print("  - " .. keyword .. ":")
        if behavior.category then
            print("    Category: " .. behavior.category)
        end
        if behavior.targetType then
            print("    Target Type: " .. behavior.targetType)
        end
        if behavior.params then
            print("    Parameters:")
            for param, value in pairs(behavior.params) do
                if type(value) ~= "function" then
                    print("      " .. param .. ": " .. tostring(value))
                else
                    print("      " .. param .. ": <function>")
                end
            end
        end
    end
    
    print("=====================================================")
end

-- Function to enable/disable debug event output
function SpellCompiler.setDebugEvents(debugEvents)
    _G.DEBUG_EVENTS = debugEvents
    print("Event debugging " .. (debugEvents and "ENABLED" or "DISABLED"))
end

-- Initialize event debugging to disabled by default
_G.DEBUG_EVENTS = false

return SpellCompiler```

## ./spells/elements/fire.lua
```lua
-- spells/elements/fire.lua
-- Contains fire-element spells

local Constants = require("core.Constants")
local expr = require("expr")

local FireSpells = {}

-- Basic Fire Conjuring
FireSpells.conjurefire = {
    id = "conjurefire",
    name = "Conjure Fire",
    affinity = "fire",
    description = "Conjures a Fire mana token. Takes longer to cast the more Fire tokens already present.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "surge",
    castTime = Constants.CastSpeed.FAST,
    cost = {},  -- No mana cost
    keywords = {
        conjure = {
            token = Constants.TokenType.FIRE,
            amount = 1
        },
    },
    
    -- Custom cast time calculation based on existing fire tokens
    getCastTime = function(caster)
        -- Base cast time
        local baseCastTime = Constants.CastSpeed.FAST
        
        -- Count fire tokens in the mana pool
        local fireCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.FIRE and token.state == Constants.TokenState.FREE then
                    fireCount = fireCount + 1
                end
            end
        else
            print("WARN: ConjureFire getCastTime - caster.manaPool is nil!")
        end
        return baseCastTime + (fireCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Firebolt spell
FireSpells.firebolt = {
    id = "firebolt",
    name = "Firebolt",
    affinity = "fire",
    description = "Superheated bolt. Maximum damage at FAR RANGE.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "bolt",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.gameState.rangeState == Constants.RangeState.FAR then
                    return 9
                end
                return 5
            end,
            type = Constants.DamageType.FIRE
        },
    },
    sfx = "fire_whoosh",
}

-- Fireball spell
FireSpells.fireball = {
    id = "fireball",
    name = "Fireball",
    affinity = "fire",
    description = "Fireball that deals damage and burns.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "orb",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = 10,
            burn = {
                amount = 2,
                duration = 2
            }
        },
    }
}

-- Blastwave spell
FireSpells.blastwave = {
    id = "blastwave",
    name = "Blast Wave",
    affinity = "fire",
    description = "Blast of flame. Maximum damage at NEAR RANGE and matched ELEVATION.",
    castTime = Constants.CastSpeed.SLOW,
    attackType = Constants.AttackType.ZONE,
    visualShape = "blast",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDmg = 2
                if target and target.elevation == caster.elevation then
                    baseDmg = baseDmg + 5
                end
                if target and target.gameState.rangeState == Constants.RangeState.NEAR then
                    baseDmg = baseDmg + 12
                end
                return baseDmg
            end,
            type = Constants.DamageType.FIRE,
        },
    },
    sfx = "blastwave",
}

-- Combust Mana spell
FireSpells.combustMana = {
    id = "combustMana",
    name = "Combust Mana",
    affinity = "fire",
    description = "Disrupts opponent channeling, burning one token to Salt.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "affectManaPool",
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE},
    keywords = {
        disruptAndShift = {
            targetType = "salt"
        },
    },
}

-- Blazing Ascent spell
FireSpells.blazingAscent = {
    id = "blazingascent",
    name = "Blazing Ascent",
    affinity = "fire",
    description = "Rockets upward in a burst of fire, dealing damage and becoming AERIAL.",
    attackType = Constants.AttackType.ZONE,
    visualShape = "blast",
    castTime = Constants.CastSpeed.SLOW,
    cost = {"fire", "fire", "star"},
    keywords = {
        damage = {
            amount = function(caster, target)
                -- More damage if already AERIAL (harder to cast while falling)
                return caster.elevation == "AERIAL" and 15 or 10
            end,
            type = "fire"
        },
        elevate = {
            duration = 6.0
        },
        dissipate = {
            token = Constants.TokenType.WATER,
            amount = 1
        },
    },
    sfx = "fire_whoosh",
}

-- Eruption spell
FireSpells.eruption = {
    id = "eruption",
    name = "Molten Ash",
    affinity = "fire",
    description = "Creates a volcanic eruption under the opponent. Only works at NEAR range.",
    attackType = Constants.AttackType.ZONE,
    visualShape = "groundBurst",
    castTime = Constants.CastSpeed.SLOW,
    cost = {"fire", "fire", "salt"},
    unlockSpell = "blazingascent",
    keywords = {
        zoneAnchor = {
            range = function(caster, target)
                return caster.gameState.rangeState
            end,
            elevation = "GROUNDED",
            requireAll = true
        },
        damage = {
            amount = 16,
            type = "fire"
        },
        burn = {
            duration = 4.0,
            tickDamage = 3
        },
    },
    sfx = "volcano_rumble",
    
    onMiss = function(caster, target, slot)
        print(string.format("[MISS] %s's Lava Eruption misses because conditions aren't right!", caster.name))
        return {
            missBackfire = true,
            backfireDamage = 4,
            backfireMessage = "Lava Eruption backfires when cast at wrong range!"
        }
    end,
    
    onSuccess = function(caster, target, slot, results)
        print(string.format("[SUCCESS] %s's Lava Eruption hits %s with full force!", caster.name, target.name))
        return {
            successMessage = "The ground trembles with volcanic fury!",
            extraEffect = "area_burn",
            burnDuration = 2.0
        }
    end
}

-- Battle Shield with multiple effects on block (Fire-based shield)
FireSpells.battleshield = {
    id = "battleshield",
    name = "Flamewreath",
    affinity = "fire", 
    description = "A Barrier of flames that stops Projectile and Zone attacks, burning NEAR attackers.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "barrier",
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.FIRE},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
            
            onBlock = function(defender, attacker, slotIndex, blockInfo)
                print("[SPELL DEBUG] Flamewreath onBlock handler executing!")
                local events = {}
                
                if attacker.elevation == Constants.ElevationState.NEAR then
                    table.insert(events, {
                        type = "APPLY_STATUS",
                        source = "caster",
                        target = "enemy",
                        statusType = Constants.StatusType.BURN,
                        duration = 1.5,
                        tickDamage = 4,
                        targetSlot = "NEAR"
                    })
                end
                
                table.insert(events, {
                    type = "EFFECT",
                    source = "caster",
                    target = "self",
                    effectType = "battle_shield_counter",
                    duration = 0.8,
                    color = {1.0, 0.7, 0.2, 0.8}
                })
                
                print("[SPELL DEBUG] Battle Shield returning " .. #events .. " events")
                return events
            end
        },
    },
    sfx = "fire_shield",
}

-- Desperation Fire - cost decreases as caster health drops
FireSpells.desperationFire = {
    id = "desperationfire",
    name = "Desperation Fire",
    affinity = Constants.TokenType.FIRE,
    description = "A fiery attack whose Fire cost decreases as your health lowers.",
    attackType = Constants.AttackType.PROJECTILE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = { Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.FIRE },
    keywords = {
        damage = { amount = 15, type = Constants.DamageType.FIRE }
    },
    getCost = function(caster, target)
        local fireCost = 3
        if caster and caster.health < 75 then fireCost = 2 end
        if caster and caster.health < 40 then fireCost = 1 end
        if caster and caster.health < 20 then fireCost = 0 end

        local finalCost = {}
        for i = 1, fireCost do
            table.insert(finalCost, Constants.TokenType.FIRE)
        end
        return finalCost
    end,
}

return FireSpells```

## ./spells/elements/generic.lua
```lua
-- spells/elements/generic.lua
-- Contains generic spells with no elemental affinity

local Constants = require("core.Constants")

local GenericSpells = {}

-- Placeholder spell for empty slots
GenericSpells.none = {
    id = "none",
    name = "<None>",
    affinity = "generic",
    description = "Empty spell slot. Cast to do nothing.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "none",
    castTime = Constants.CastSpeed.INSTANT,
    cost = {},  -- No mana cost
    keywords = {
        -- No effect - this is a no-op spell
    },
}

return GenericSpells```

## ./spells/elements/life.lua
```lua
-- spells/elements/life.lua
-- Contains life-element spells

local Constants = require("core.Constants")

local LifeSpells = {}

-- Placeholder for future Life element spells

return LifeSpells```

## ./spells/elements/mind.lua
```lua
-- spells/elements/mind.lua
-- Contains mind-element spells

local Constants = require("core.Constants")

local MindSpells = {}

-- Placeholder for future Mind element spells

-- TODO: add "spell state" tracking to support this (and probably other Mind and Star spells in particular)
MindSpells.thoughtscalp = {
    id = "thoughtscalp",
    name = "Thought Scalp",
    affinity = "mind",
    description = "Picks at opponent's worst fear, dealing slightly more damage every time.",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "slash", -- Constants.VisualShape.SLASH,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MIND},
    keywords = {
      damage = 10
    }
}

return MindSpells```

## ./spells/elements/moon.lua
```lua
-- spells/elements/moon.lua
-- Contains moon-element spells

local Constants = require("core.Constants")
local expr = require("expr")

local MoonSpells = {}

-- Basic Moon Conjuring
MoonSpells.conjuremoonlight = {
    id = "conjuremoonlight",
    name = "Conjure Moonlight",
    affinity = Constants.TokenType.MOON,
    description = "Conjures a Moon mana token. Takes longer to cast the more Moon tokens already present.",
    attackType = "utility",
    visualShape = "affectManaPool",
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.MOON,
            amount = 1
        },
    },
    
    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local moonCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.MOON and token.state == "FREE" then
                    moonCount = moonCount + 1
                end
            end
        end
        return baseCastTime + (moonCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Tidal Force spell
MoonSpells.tidalforce = {
    id = "tidalforce",
    name = "Tidal Force",
    affinity = Constants.TokenType.MOON,
    description = "Chip damage, forces AERIAL enemies out of the air",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.WATER, Constants.TokenType.MOON},
    keywords = {
        damage = {
            amount = 5,
            type = Constants.TokenType.MOON
        },
        ground = {
            conditional = function(caster, target)
                return target and target.elevation == "AERIAL"
            end,
            target = "ENEMY",
        },
    },
    sfx = "tidal_wave",
}

-- Lunar Disjunction spell
MoonSpells.lunardisjunction = {
    id = "lunardisjunction",
    name = "Lunar Disjunction",
    affinity = Constants.TokenType.MOON,
    description = "Cleansing moonlight cancels an opponent's spell and dissolves its mana",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "zap",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON},
    keywords = {
        disjoint = {
            slot = function(caster, target, slot) 
                local slotNum = tonumber(slot) or 0
                if slotNum > 0 and slotNum <= 3 then
                    return slotNum
                else
                    return 0  -- 0 means find the first active slot
                end
            end,
            target = "SLOT_ENEMY"
        },
    },
    sfx = "lunardisjunction_sound",
}

-- Moon Dance spell
MoonSpells.moondance = {
    id = "moondance",
    name = "Moon Dance",
    affinity = Constants.TokenType.MOON,
    description = "Warp space to switch range, deal chip damage, and Freeze xxx enemy Root slot.",
    attackType = "remote",
    visualShape = "warp",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MOON},
    keywords = {
        damage = {
            amount = 6,
            type = Constants.TokenType.MOON
        },
        rangeShift = {
            position = expr.byRange({
                NEAR = "FAR",
                FAR = "NEAR",
                default = "NEAR"
            }),
            target = "SELF" 
        },
        freeze = {
            duration = 3,
            target = "SLOT_ENEMY",
            slot = 1
        }
    }
}

-- Gravity spell
MoonSpells.gravity = {
    id = "gravity",
    name = "Increase Gravity",
    affinity = Constants.TokenType.MOON,
    description = "Grounds AERIAL enemies",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.MOON, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.elevation then
                    return target.elevation == "AERIAL" and 15 or 3
                end
                return 3
            end,
            type = Constants.TokenType.MOON
        },
        ground = {
            conditional = function(caster, target)
                return target and target.elevation == "AERIAL"
            end,
            target = "ENEMY",
        },
        stagger = {
            duration = 2.0
        },
    },
    sfx = "gravity_slam",
}

-- Eclipse spell
MoonSpells.eclipse = {
    id = "eclipse",
    name = "Total Eclipse",
    affinity = Constants.TokenType.MOON,
    description = "Freeze xxx your Heart slot. Conjure Sun.",
    attackType = "utility", 
    visualShape = "eclipse",
    castTime = Constants.CastSpeed.VERY_FAST,
    cost = {Constants.TokenType.MOON, Constants.TokenType.SUN},
    keywords = {
        freeze = {
            duration = 3,
            slot = 2,
            target = "self"
        },
        conjure = {
            token = Constants.TokenType.SUN,
            amount = 1
        },
    },
    sfx = "eclipse_shatter",
}

-- Full Moon Beam spell
MoonSpells.fullmoonbeam = {
    id = "fullmoonbeam",
    name = "Full Moon Beam",
    affinity = Constants.TokenType.MOON,
    description = "Channels moonlight into a beam that deals more damage the longer it's delayed.",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "beam",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.MOON},
    unlockSpell = "lunartides",
    keywords = {
        damage = {
            amount = function(caster, target, slot)
                local baseCastTime = Constants.CastSpeed.FAST
                local accruedModifier = 0
                
                if slot and caster.spellSlots[slot] then
                    local spellSlotData = caster.spellSlots[slot]
                    print(string.format("DEBUG_FMB_SLOT_CHECK: Slot=%d, Active=%s, Progress=%.2f, CastTime=%.1f, Modifier=%.4f, Frozen=%s",
                        slot, tostring(spellSlotData.active), spellSlotData.progress or -1, spellSlotData.castTime or -1, spellSlotData.castTimeModifier or -99, tostring(spellSlotData.frozen)))
                    
                    baseCastTime = spellSlotData.castTime 
                    accruedModifier = spellSlotData.castTimeModifier or 0
                    print(string.format("DEBUG_FMB: Read castTimeModifier=%.4f from spellSlotData", accruedModifier))
                else
                    print(string.format("DEBUG_FMB_WARN: Slot %s or caster.spellSlots[%s] is nil!", tostring(slot), tostring(slot)))
                end
                
                local effectiveCastTime = math.max(0.1, baseCastTime + accruedModifier)
                local damage = math.floor(effectiveCastTime * 2.5)
                
                print(string.format("Full Moon Beam: Base Cast=%.1fs, Modifier=%.1fs, Effective=%.1fs => Damage=%d", 
                    baseCastTime, accruedModifier, effectiveCastTime, damage))
                
                return damage
            end,
            type = Constants.TokenType.MOON
        }
    },
    sfx = "beam_charge",
}

-- Lunar Tides spell
MoonSpells.lunarTides = {
    id = "lunartides",
    name = "Lunar Tides",
    affinity = Constants.TokenType.MOON,
    description = "Manipulates the battle flow based on range and elevation",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    castTime = 7.0,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.ANY, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = expr.byElevation({
                GROUNDED = 8,
                AERIAL = 12,
                default = 8
            }),
            type = Constants.TokenType.MOON,
            target = "ENEMY"
        },
        rangeShift = {
            position = expr.byRange({
                NEAR = "FAR",
                FAR = "NEAR",
                default = "NEAR"
            }),
            target = "SELF"
        },
    },
    sfx = "tide_rush",
}

-- Wings of Moonlight (shield spell)
MoonSpells.wrapinmoonlight = {
    id = "wrapinmoonlight",
    name = "Wings of Moonlight",
    affinity = Constants.TokenType.MOON,
    description = "A runic Ward that stops Projectile and Remote attacks, elevating the caster.",
    attackType = "utility",
    visualShape = "wings",
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.MOON, "any"},
    unlockSpell = "lunardisjunction",
    keywords = {
        block = {
            type = Constants.ShieldType.WARD,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.REMOTE},
            
            onBlock = function(defender, attacker, slot, info)
                print("[SPELL DEBUG] Wings of Moonlight onBlock handler executing!")
                
                local events = {}
                
                table.insert(events, {
                    type = "SET_ELEVATION",
                    source = "caster",
                    target = "self",
                    elevation = Constants.ElevationState.AERIAL,
                    duration = 4.0,
                })
                
                print("[SPELL DEBUG] Wings of Moonlight returning " .. #events .. " events")
                return events
            end
        },
    },
    sfx = "mist_shimmer",
}

-- Gravity Trap spell
MoonSpells.gravityTrap = {
    id = "gravityTrap",
    name = "Icarus Trap",
    affinity = Constants.TokenType.MOON,
    description = "Gravitational trap that triggers when an enemy becomes AERIAL, grounding and damaging them.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "warp",
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.MOON, Constants.TokenType.SUN},
    keywords = {
        sustain = true,
        
        trap_trigger = { 
            condition = "on_opponent_elevate" 
        },
        
        
        trap_effect = {
            damage = { 
                amount = 3, 
                type = Constants.TokenType.MOON,  
                target = "ENEMY" 
            },
            ground = { 
                target = "ENEMY", 
            },
            burn = { 
                duration = 1.5,
                tickDamage = 3,
                tickInterval = 0.5,
                target = "ENEMY"
            },
        },
    },
    sfx = "gravity_trap_set",
}

-- Infinite Procession spell
-- TODO: Improve token-shift keyword to allow _input token_ to be specified
MoonSpells.infiniteprocession = {
    id = "infiniteprocession",
    name = "Infinite Procession",
    affinity = Constants.TokenType.MOON,
    description = "Transmutes MOON tokens into SUN or SUN into MOON.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "affectManaPool",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {},
    keywords = {
        tokenShift = {
            type = expr.more(Constants.TokenType.SUN, Constants.TokenType.MOON),
            amount = 1
        },
    },
    sfx = "conjure_infinite",
}

-- Enhanced Mirror Shield (moon-based shield)
MoonSpells.enhancedmirrorshield = {
    id = "enhancedmirrorshield",
    name = "Celestial Mirror",
    affinity = Constants.TokenType.MOON,
    description = "A powerful reflective barrier that returns damage to attackers with interest",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "mirror",
    castTime = Constants.CastSpeed.VERY_SLOW,
    cost = {Constants.TokenType.MOON, Constants.TokenType.MOON, Constants.TokenType.STAR},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
            
            onBlock = function(defender, attacker, slotIndex, blockInfo)
                if not attacker then return {} end
                
                local events = {}
                
                table.insert(events, {
                    type = "DAMAGE",
                    source = "caster",
                    target = "enemy",
                    amount = 10,
                    damageType = "star",
                    reflectedDamage = true
                })
                
                table.insert(events, {
                    type = "EFFECT",
                    source = "caster",
                    target = "enemy",
                    effectType = "reflect",
                    duration = 0.5
                })
                
                return events
            end
        },
    },
    sfx = "crystal_ring",
}

-- Moon Drain - cost increases with opponent's STAR tokens
MoonSpells.moonDrain = {
    id = "moondrain",
    name = "Moon Drain",
    affinity = Constants.TokenType.MOON,
    description = "Drains opponent. Costs more Moon tokens if opponent is channeling Star mana.",
    attackType = Constants.AttackType.REMOTE,
    castTime = Constants.CastSpeed.FAST,
    cost = { Constants.TokenType.MOON },
    keywords = {
        damage = { amount = 8, type = Constants.DamageType.MOON }
    },
    getCost = function(caster, target)
        local moonTokens = 1
        if target then
            for _, slot in ipairs(target.spellSlots) do
                if slot.active and slot.tokens then
                    for _, tokenData in ipairs(slot.tokens) do
                        if tokenData.token.type == Constants.TokenType.STAR then
                            moonTokens = moonTokens + 1
                        end
                    end
                end
            end
        end

        local finalCost = {}
        for i = 1, math.min(moonTokens, 4) do
            table.insert(finalCost, Constants.TokenType.MOON)
        end
        return finalCost
    end,
}

return MoonSpells```

## ./spells/elements/salt.lua
```lua
-- spells/elements/salt.lua
-- Contains salt-element spells

local Constants = require("core.Constants")

local SaltSpells = {}

-- Conjure Salt spell
SaltSpells.conjuresalt = {
    id = "conjuresalt",
    name = "Conjure Salt",
    affinity = "salt",
    description = "Creates a new Salt mana token",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.SALT,
            amount = 1
        },
    },

    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local saltCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.SALT and token.state == Constants.TokenState.FREE then
                    saltCount = saltCount + 1
                end
            end
        end
        return baseCastTime + (saltCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Glitter Fang spell
SaltSpells.glitterfang = {
    id = "glitterfang",
    name = "Glitter Fang",
    affinity = "salt",
    description = "Very fast, unblockable attack. Only hits NEAR/GROUNDED enemies",
    castTime = Constants.CastSpeed.VERY_FAST,
    attackType = Constants.AttackType.UTILITY,
    cost = {Constants.TokenType.SALT, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = 7,
            type = Constants.DamageType.SALT,
            condition = function(caster, target, slot)
                return target and target.gameState.rangeState == Constants.RangeState.NEAR
                    and target.elevation == Constants.ElevationState.GROUNDED
            end
        },
    },
    sfx = "glitter_fang",
}

SaltSpells.burnToAsh = {
    id = "burnToAsh",
    name = "Burn to Ash",
    affinity = "salt",
    description = "Disrupts opponent channeling, burning one token to Salt.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "zap",
    cost = {Constants.TokenType.FIRE},
    unlockSpell = "combustMana",
    keywords = {
        disruptAndShift = {
            targetType = "salt"
        },
        consume = true,
    }
}

-- Salt Storm spell
SaltSpells.saltstorm = {
    id = "saltstorm",
    name = "Salt Storm",
    affinity = "salt",
    description = "Slow, hard-hitting, shield-breaking area attack.",
    castTime = Constants.CastSpeed.VERY_SLOW,
    attackType = Constants.AttackType.ZONE,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT, Constants.TokenType.SALT},
    unlockSpell = "jaggedearth",
    keywords = {
        damage = {
            amount = 15,
            type = Constants.DamageType.SALT
        },
        zoneMulti = true,
        shieldBreaker = 2,
    },
    sfx = "salt_storm",
}

-- Imprison spell (Salt trap)
SaltSpells.imprison = {
    id = "imprison",
    name = "Imprison",
    affinity = "salt",
    description = "Trap: Deals damage and prevents enemy movement to FAR",
    attackType = "utility",
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        sustain = true,
        
        trap_trigger = { 
            condition = "on_opponent_far" 
        },
        
        
        trap_effect = {
            damage = { 
                amount = 7, 
                type = Constants.DamageType.SALT,  
                target = "ENEMY" 
            },
            rangeShift = { 
                position = Constants.RangeState.NEAR,
            },
        },
    },
    sfx = "gravity_trap_set",
}

-- Jagged Earth spell (Salt trap)
SaltSpells.jaggedearth = {
    id = "jaggedearth",
    name = "Jagged Earth",
    affinity = "salt",
    description = "Trap: Creates a zone of jagged earth that hurts enemies when they become Grounded.",
    castTime = Constants.CastSpeed.SLOW,
    attackType = Constants.AttackType.ZONE,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = 7, 
            type = Constants.DamageType.SALT,
            condition = function(caster, target, slot)
                return target and target.elevation == Constants.ElevationState.GROUNDED
            end
        },
        rangeShift = {  
            position = Constants.RangeState.NEAR,
        },
    },
    sfx = "jagged_earth",
}

-- Salt Circle spell (Ward)
SaltSpells.saltcircle = {
    id = "saltcircle",
    name = "Salt Circle",
    affinity = "salt",
    description = "Ward: Creates a circle of Salt around the caster",
    castTime = Constants.CastSpeed.VERY_FAST,
    attackType = Constants.AttackType.ZONE,
    cost = {Constants.TokenType.SALT},
    keywords = {
        block = {
            type = Constants.ShieldType.WARD,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.REMOTE},
        }
    },
    sfx = "salt_circle",
}

-- Stone Shield spell (Barrier)
SaltSpells.stoneshield = {
    id = "stoneshield",
    name = "Stone Shield",
    affinity = "salt",
    description = "Barrier: Creates a shield of stone around the caster",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},
        }
    },
    sfx = "stone_shield",
}

-- Shield-breaking spell
SaltSpells.shieldbreaker = {
    id = "shieldbreaker",
    name = "Salt Spear",
    affinity = "salt",
    description = "A mineral lance that shatters wards and barriers",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = Constants.VisualShape.ZAP,
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.SALT, Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDamage = 8
                
                local shieldBonus = 0
                if target and target.spellSlots then
                    for _, slot in ipairs(target.spellSlots) do
                        if slot.active and slot.isShield then
                            shieldBonus = shieldBonus + 6
                            break
                        end
                    end
                end
                
                return baseDamage + shieldBonus
            end,
            type = "force"
        },
    },
    shieldBreaker = 3,
    sfx = "shield_break",
    
    onBlock = function(caster, target, slot, blockInfo)
        print(string.format("[SHIELD BREAKER] %s's Shield Breaker is testing the %s shield's strength!", 
            caster.name, blockInfo.blockType))
        
        return {
            specialBlockMessage = "Shield Breaker collides with active shield!",
            damageShield = true,
            continueExecution = false
        }
    end
}

return SaltSpells```

## ./spells/elements/star.lua
```lua
-- spells/elements/star.lua
-- Contains star-element spells

local Constants = require("core.Constants")
local expr = require("expr")
local ManaHelpers = require("systems.ManaHelpers")

local StarSpells = {}

-- Conjure Stars spell
StarSpells.conjurestars = {
    id = "conjurestars",
    name = "Conjure Stars",
    affinity = "star",
    description = "Creates a new Star mana token",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.STAR,
            amount = 1
        },
    },

    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local starCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.STAR and token.state == Constants.TokenState.FREE then
                    starCount = starCount + 1
                end
            end
        end
        return baseCastTime + (starCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Adaptive Surge test spell
StarSpells.adaptive_surge = {
    id = "adaptivesurge",
    name = "Starstuff",
    affinity = "star",
    description = "A spell that adapts its effects based on the current mana pool",
    attackType = Constants.AttackType.PROJECTILE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.STAR, Constants.TokenType.SUN, Constants.TokenType.MOON},
    keywords = {
        damage = {
            amount = expr.countScale(Constants.TokenType.SUN, 5, 2),
            type = expr.more(Constants.TokenType.SUN, Constants.TokenType.MOON)
        },
        burn = expr.ifCond(
            function(caster, target) 
                return ManaHelpers.count(Constants.TokenType.SUN, caster.manaPool) > 
                    ManaHelpers.count(Constants.TokenType.MOON, caster.manaPool)
            end,
            {
                duration = 3.0,
                tickDamage = 2
            },
            nil
        ),
        slow = expr.ifCond(
            function(caster, target) 
                return ManaHelpers.count(Constants.TokenType.MOON, caster.manaPool) >= 
                    ManaHelpers.count(Constants.TokenType.SUN, caster.manaPool)
            end,
            {
                magnitude = 1.0,
                duration = 5.0
            },
            nil
        ),
    },
    sfx = "adaptive_sound",
}

-- Cosmic Rift spell
StarSpells.cosmicRift = {
    id = "cosmicrift",
    name = "Cosmic Rift",
    affinity = "star",
    description = "Opens a rift that damages opponents and disrupts spellcasting",
    attackType = Constants.AttackType.ZONE,
    castTime = 5.5,
    cost = {"star", "star", "star"},
    keywords = {
        damage = {
            amount = 12,
            type = "star"
        },
        slow = {
            magnitude = 2.0,
            duration = 10.0,
            slot = nil
        },
        zoneMulti = true,
    },
    sfx = "space_tear",
}

return StarSpells```

## ./spells/elements/sun.lua
```lua
-- spells/elements/sun.lua
-- Contains sun-element spells

local Constants = require("core.Constants")
local expr = require("expr")

local SunSpells = {}

-- Sunbolt spell
SunSpells.radiantbolt = {
    id = "radiantbolt",
    name = "Radiant Bolt",
    affinity = "sun",
    description = "Bolt of radiation that deals more damage against AERIAL opponents",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "bolt",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN, Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.elevation == Constants.Elevation.AERIAL then
                    return 25
                end
                return 10
            end,
            type = Constants.DamageType.SUN
        },
    },
    sfx = "fire_whoosh",
}

SunSpells.fusionRay = {
    id = "fusionRay",
    name = "Fusion Ray",
    affinity = "sun",
    description = "A powerful beam of sunlight. Burns the user.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "beam",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = 18,
            target = Constants.TargetType.ENEMY
        },
        burn = {
            amount = 1,
            duration = 5,
            target = Constants.TargetType.SELF  
        }
    },
    sfx = "fire_whoosh",
}

-- Meteor spell
SunSpells.meteor = {
    id = "meteor",
    name = "Meteor Dive",
    affinity = "sun",
    description = "Aerial finisher - GROUND self and create a fiery explosion. Only hits GROUNDED enemies.",
    castTime = Constants.CastSpeed.SLOW,
    attackType = Constants.AttackType.ZONE,
    visualShape = "meteor",
    cost = {Constants.TokenType.SUN, Constants.TokenType.FIRE, Constants.TokenType.SUN, Constants.TokenType.FIRE},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.elevation == Constants.ElevationState.GROUNDED and caster.elevation == Constants.ElevationState.AERIAL then
                    return 30
                end
                return 0
            end,
            type = Constants.DamageType.SUN,
        },
        rangeShift = {
            position = Constants.RangeState.NEAR
        },
        ground = {
            target = Constants.TargetType.SELF 
        }
    },
    sfx = "meteor_impact",
}

-- Emberlift spell
SunSpells.emberlift = {
    id = "emberlift",
    name = "Emberlift",
    affinity = "sun",
    description = "Launches caster into the air, shifts RANGE, and conjures a Fire token.",
    castTime = Constants.CastSpeed.FAST,
    attackType = "utility",
    visualShape = "surge",
    cost = {"sun"},
    keywords = {
        conjure = {
            token = Constants.TokenType.FIRE,
            amount = 1
        },
        elevate = {
            duration = 5.0,
            target = "SELF",
        },
        rangeShift = {
            position = expr.byRange({
                NEAR = "FAR",
                FAR = "NEAR",
                default = "NEAR"
            }),
        }
    },
    sfx = "whoosh_up",
}

-- Nova Conjuring (Combine 3 x FIRE into SUN)
SunSpells.novaconjuring = {
    id = "novaconjuring",
    name = "Nova Conjuring",
    affinity = "sun",
    description = "Expends Fire tokens to conjure a Sun token.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = "surge",
    castTime = Constants.CastSpeed.NORMAL,
    cost = {"fire", "fire", "fire"},
    keywords = {
        consume = true,
        conjure = {
            token = {
                Constants.TokenType.SUN,
            },
            amount = 1
        },
    },
    sfx = "conjure_nova",
}

-- Burn the Soul (Inflict Burn on self to conjure a Sun token)
SunSpells.burnTheSoul = {
    id = "burnTheSoul",
    name = "Burn the Soul",
    affinity = "sun",
    description = "Inflict Burn on self to conjure a Sun token.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "surge",
    cost = {},
    keywords = {
        burn = {
            amount = 1,
            duration = 10,
            target = Constants.TargetType.SELF
        },
        conjure = {
            token = Constants.TokenType.SUN,
            amount = 1
        }
    }
}

SunSpells.SpaceRipper = {
    id = "SpaceRipper",
    name = "Space Ripper",
    affinity = "sun",
    description = "Range swap to NEAR. Burn both self and target. Turn SUN to VOID.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.REMOTE,
    visualShape = "warp",
    cost = {Constants.TokenType.SUN},
    keywords = {
        rangeShift = {
            position = Constants.RangeState.NEAR
        },
        burn = {
            amount = 3,
            duration = 3,
            target = Constants.TargetType.ALL
        },
        consume = true,
        conjure = {
            token = Constants.TokenType.VOID,
            amount = 1
        }
    }
}

SunSpells.StingingEyes = {
    id = "StingingEyes",
    name = "Stinging Eyes",
    affinity = "sun",
    description = "Damage based on user's Burn level.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "beam",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDamage = 3
                local selfBurnIntensity = 0
                local bonusPerIntensityPoint = 8 -- How much extra damage per point of self-burn tickDamage

                -- Check if the caster is burning
                if caster.statusEffects and
                   caster.statusEffects.burn and
                   caster.statusEffects.burn.active then
                    selfBurnIntensity = caster.statusEffects.burn.tickDamage or 0
                end

                local totalDamage = baseDamage + (selfBurnIntensity * bonusPerIntensityPoint)

                return totalDamage
            end,
            type = Constants.DamageType.SUN
        },
        burn = {
            amount = function(caster, target)
                -- Check if the caster is burning
                if caster.statusEffects and
                   caster.statusEffects.burn and
                   caster.statusEffects.burn.active then
                    local selfBurnIntensity = caster.statusEffects.burn.tickDamage or 0
                    return selfBurnIntensity
                end
                return 0
            end,
            duration = 1,
            target = Constants.TargetType.ENEMY
        }
    }
}

SunSpells.CoreBolt = {
    id = "CoreBolt",
    name = "Core Bolt",
    affinity = "sun",
    description = "Expend SUN and VOID for a powerful energy bolt.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = "bolt",
    cost = {Constants.TokenType.SUN, Constants.TokenType.VOID, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = 25,
            target = Constants.TargetType.ENEMY
        },
        consume = true,
    },
    sfx = "fire_whoosh",
    blockableBy = {Constants.ShieldType.BARRIER, Constants.ShieldType.WARD}
}
SunSpells.NuclearFurnace = {
    id = "NuclearFurnace",
    name = "Nuclear Furnace",
    affinity = "sun",
    description = "Damage based on user's Burn level. Burn user further. Conjure Fire.",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.ZONE,
    visualShape = "blast",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        damage = {
            amount = function(caster, target)
                local baseDamage = 10
                local selfBurnIntensity = 0
                local bonusPerIntensityPoint = 10 -- How much extra damage per point of self-burn tickDamage

                -- Check if the caster is burning
                if caster.statusEffects and
                   caster.statusEffects.burn and
                   caster.statusEffects.burn.active then
                    selfBurnIntensity = caster.statusEffects.burn.tickDamage or 0
                end

                local attackStrength = baseDamage + (selfBurnIntensity * bonusPerIntensityPoint)

                if caster.elevation ~= target.elevation then
                    attackStrength = attackStrength * 0.5
                end

                if caster.gameState.rangeState ~= Constants.RangeState.NEAR then
                    attackStrength = attackStrength * 0.5
                end

                return attackStrength
            end,
            type = Constants.DamageType.SUN
        },
        conjure = {
            token = Constants.TokenType.FIRE,
            amount = 1
        },
        burn = {
            amount = 2,
            duration = 7,
            target = Constants.TargetType.SELF
        }
    },
    sfx = "fire_whoosh",
    blockableBy = {Constants.ShieldType.BARRIER}
}

-- Force Barrier spell (Sun-based shield)
SunSpells.forcebarrier = {
    id = "forcebarrier",
    name = "Sun Block",
    affinity = "sun",
    description = "A protective barrier that blocks projectile and area attacks",
    castTime = Constants.CastSpeed.SLOW,
    attackType = "utility",
    visualShape = "surge",
    cost = {"sun", "sun"},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE}
        },
    },
    sfx = "shield_up",
}

-- Radiant Field spell applying slow to both wizards
SunSpells.radiantfield = {
    id = "radiantfield",
    name = "Radiant Field",
    affinity = "sun",
    description = "Blinding field that slows both wizards while active.",
    castTime = Constants.CastSpeed.NORMAL,
    attackType = Constants.AttackType.UTILITY,
    visualShape = "blast",
    cost = {Constants.TokenType.SUN, Constants.TokenType.SUN},
    keywords = {
        field_status = {
            statusType = Constants.StatusType.SLOW,
            magnitude = Constants.CastSpeed.ONE_TIER
        }
    },
    sfx = "radiant_field"
}

return SunSpells
```

## ./spells/elements/void.lua
```lua
-- spells/elements/void.lua
-- Contains void-element spells

local Constants = require("core.Constants")

local VoidSpells = {}

-- Hilarious Void "conjuring" spell
VoidSpells.conjurenothing = {
    id = "conjurenothing",
    name = "Conjure Nothing",
    affinity = "void",
    description = "Bring nothing into existence",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.VOID, Constants.TokenType.ANY, Constants.TokenType.ANY},
    keywords = {
        expend = {
            amount = 3
        }
    },
    sfx = "void_conjure",
}

-- TODO: Implement this spell. Might need dynamic costing to be implemented first.
-- Design
VoidSpells.riteofemptiness = {
    id = "riteofemptiness",
    name = "Rite of Emptiness",
    affinity = "void",
    description = "Consumes SALT to create STAR, consumes STAR to create VOID.",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {},
    keywords = {
        --todo
    }
}

VoidSpells.quenchPower = {
    id = "quenchPower",
    name = "Quench Power",
    affinity = "void",
    description = "Consumes Celestial or Material mana to create VOID.",
    attackType = Constants.AttackType.UTILITY,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {},
    keywords = {
        --todo
    }
}

-- One-shot kill combo payoff/mega-nuke
VoidSpells.heartripper = {
    id = "heartripper",
    name = "Heart Ripper",
    affinity = "void",
    description = "A terrible curse that strikes down the target with a single instant-kill hit.",
    attackType = Constants.AttackType.REMOTE,
    castTime = Constants.CastSpeed.VERY_SLOW,
    cost = {Constants.TokenType.VOID, Constants.TokenType.STAR, Constants.TokenType.STAR, Constants.TokenType.SALT, Constants.TokenType.SALT, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = 100,
            type = Constants.TokenType.VOID
        }
    },
    sfx = "heartripper",
}

return VoidSpells```

## ./spells/elements/water.lua
```lua
-- spells/elements/water.lua
-- Contains water-element spells

local Constants = require("core.Constants")
local ManaHelpers = require("systems.ManaHelpers")

local WaterSpells = {}

-- Water Gun spell
WaterSpells.watergun = {
    id = "watergun",
    name = "Water Gun",
    affinity = "water",
    description = "Quick ranged hit, more damage against NEAR opponents",
    castTime = Constants.CastSpeed.FAST,
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = Constants.VisualShape.BOLT,
    cost = {Constants.TokenType.WATER, Constants.TokenType.ANY},
    keywords = {
        damage = {
            amount = function(caster, target)
                if target and target.gameState.rangeState == Constants.RangeState.NEAR then
                    return 15
                end
                return 10
            end,
            type = Constants.DamageType.WATER
        }
    },
    sfx = "fire_whoosh",
}

-- Force blast spell (Steam Vent) - water and fire combo
WaterSpells.forceBlast = {
    id = "forceblast",
    name = "Steam Vent",
    affinity = "water",
    description = "Unleashes a blast of steam that launches opponents into the air",
    attackType = "remote",
    castTime = 4.0,
    cost = {"fire", "water"},
    keywords = {
        damage = {
            amount = 8,
            type = "force"
        },
        elevate = {
            duration = 3.0,
            target = "ENEMY",
        },
    },
    sfx = "force_wind",
}

-- Conjure Water spell
WaterSpells.conjurewater = {
    id = "conjurewater",
    name = "Conjure Water",
    affinity = Constants.TokenType.WATER,
    description = "Conjures a Water mana token. Takes longer to cast the more Water tokens already present.",
    attackType = Constants.AttackType.UTILITY,
    visualShape = Constants.VisualShape.CONJURE_BASE,
    castTime = Constants.CastSpeed.FAST,
    cost = {},
    keywords = {
        conjure = {
            token = Constants.TokenType.WATER,
            amount = 1
        }
    },

    getCastTime = function(caster)
        local baseCastTime = Constants.CastSpeed.FAST
        local waterCount = 0
        if caster.manaPool then
            for _, token in ipairs(caster.manaPool.tokens) do
                if token.type == Constants.TokenType.WATER and token.state == Constants.TokenState.FREE then
                    waterCount = waterCount + 1
                end
            end
        end
        return baseCastTime + (waterCount * Constants.CastSpeed.ONE_TIER)
    end
}

-- Maelstrom spell - damage scales with WATER tokens in the pool
WaterSpells.maelstrom = {
    id = "maelstrom",
    name = "Maelstrom",
    affinity = Constants.TokenType.WATER,
    description = "Remote blast that grows stronger with each Water token in the mana pool",
    attackType = Constants.AttackType.REMOTE,
    visualShape = Constants.VisualShape.WAVE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.WATER, Constants.TokenType.WATER},
    keywords = {
        damage = {
            amount = function(caster, target)
                local count = ManaHelpers.count(Constants.TokenType.WATER, caster.manaPool)
                return 6 + (count * 2)
            end,
            type = Constants.DamageType.WATER
        }
    },
    sfx = "water_surge",
}

-- Riptide Guard shield - switches range when it blocks
WaterSpells.riptideguard = {
    id = "riptideguard",
    name = "Riptide Guard",
    affinity = Constants.TokenType.WATER,
    description = "Barrier that swaps range with the opponent when it blocks an attack",
    attackType = Constants.AttackType.UTILITY,
    visualShape = Constants.VisualShape.WAVE,
    castTime = Constants.CastSpeed.FAST,
    cost = {Constants.TokenType.WATER, Constants.TokenType.WATER},
    keywords = {
        block = {
            type = Constants.ShieldType.BARRIER,
            blocks = {Constants.AttackType.PROJECTILE, Constants.AttackType.ZONE},

            onBlock = function(defender, attacker, slotIndex, info)
                local events = {}
                local gameState = defender.gameState
                local newRange = Constants.RangeState.NEAR
                if gameState and gameState.rangeState == Constants.RangeState.NEAR then
                    newRange = Constants.RangeState.FAR
                end
                table.insert(events, {
                    type = "SET_RANGE",
                    source = "caster",
                    target = "both",
                    position = newRange
                })
                return events
            end
        }
    },
    sfx = "tide_rush",
}

-- Brine Chain spell - salt infused lash that slows
WaterSpells.brinechain = {
    id = "brinechain",
    name = "Brine Chain",
    affinity = Constants.TokenType.WATER,
    description = "Salt-laced lash that slows the enemy. Damage scales with Water tokens in the pool",
    attackType = Constants.AttackType.PROJECTILE,
    visualShape = Constants.VisualShape.ZAP,
    castTime = Constants.CastSpeed.NORMAL,
    cost = {Constants.TokenType.WATER, Constants.TokenType.SALT},
    keywords = {
        damage = {
            amount = function(caster, target)
                local count = ManaHelpers.count(Constants.TokenType.WATER, caster.manaPool)
                return 5 + count
            end,
            type = Constants.DamageType.WATER
        },
        slow = {
            magnitude = 1.0,
            duration = 2.0
        }
    },
    sfx = "water_whip",
}

-- Wave Crash spell - consumes tokens for a powerful strike
WaterSpells.wavecrash = {
    id = "wavecrash",
    name = "Wave Crash",
    affinity = Constants.TokenType.WATER,
    description = "Consumes its channeled tokens to unleash a devastating wave",
    attackType = Constants.AttackType.ZONE,
    visualShape = Constants.VisualShape.WAVE,
    castTime = Constants.CastSpeed.SLOW,
    cost = {Constants.TokenType.WATER, Constants.TokenType.WATER, Constants.TokenType.WATER},
    unlockSpell = "forceblast",
    keywords = {
        damage = {
            amount = function(caster, target)
                local count = ManaHelpers.count(Constants.TokenType.WATER, caster.manaPool)
                return 10 + count * 3
            end,
            type = Constants.DamageType.WATER
        },
        consume = { amount = "all" },
        conjure = {
            token = Constants.TokenType.SALT,
            amount = 1
        }
    },
    sfx = "wave_crash",
}

return WaterSpells
```

## ./spells/init.lua
```lua
-- spells/init.lua
-- Main entry point for the spells module

local Constants = require("core.Constants")
local Keywords = require("keywords")
local SpellCompiler = require("spellCompiler")
local expr = require("expr")
local ManaHelpers = require("systems.ManaHelpers")
local Schema = require("spells.schema")

-- Import all elemental spell collections
local FireSpells = require("spells.elements.fire")
local WaterSpells = require("spells.elements.water")
local SaltSpells = require("spells.elements.salt")
local SunSpells = require("spells.elements.sun")
local MoonSpells = require("spells.elements.moon")
local StarSpells = require("spells.elements.star")
local LifeSpells = require("spells.elements.life")
local MindSpells = require("spells.elements.mind")
local VoidSpells = require("spells.elements.void")
local GenericSpells = require("spells.elements.generic")

-- Combine all spells into a single table
local Spells = {}

-- Add spells from each collection
local function addSpells(spellCollection)
    for id, spell in pairs(spellCollection) do
        Spells[id] = spell
    end
end

-- Add all elemental spell collections
addSpells(FireSpells)
addSpells(WaterSpells)
addSpells(SaltSpells)
addSpells(SunSpells)
addSpells(MoonSpells)
addSpells(StarSpells)
addSpells(LifeSpells)
addSpells(MindSpells)
addSpells(VoidSpells)
addSpells(GenericSpells)

-- Prepare the return table with all spells and utility functions
local SpellsModule = {
    spells = Spells,
    validateSpell = Schema.validateSpell,
    
    -- Public method to compile all spells
    compileAll = function()
        local compiled = {}
        for id, spell in pairs(Spells) do
            Schema.validateSpell(spell, id)
            -- References to SpellCompiler and Keywords need to be passed from game object
            -- This function will be called with the correct context from main.lua
            print("Waiting for SpellCompiler to compile: " .. spell.name)
        end
        return compiled
    end,
    
    -- Public method to get a compiled spell by ID
    getCompiledSpell = function(spellId, spellCompiler, keywords)
        if not Spells[spellId] then
            print("ERROR: Spell not found: " .. spellId)
            return nil
        end
        
        -- Make sure we have the required objects
        if not spellCompiler or not keywords then
            print("ERROR: Missing SpellCompiler or Keywords for compiling spell: " .. spellId)
            return nil
        end
        
        return spellCompiler.compileSpell(Spells[spellId], keywords)
    end
}

-- Validate all spells at module load time to catch errors early
for spellId, spell in pairs(Spells) do
    Schema.validateSpell(spell, spellId)
end

return SpellsModule```

## ./spells/schema.lua
```lua
-- spells/schema.lua
-- Contains schema definition and validation for spells

local Constants = require("core.Constants")

local Schema = {}

-- Schema for spell object:
-- id: Unique identifier for the spell (string)
-- name: Display name of the spell (string)
-- affinity: The element of the spell (string)
-- description: Text description of what the spell does (string)
-- attackType: How the spell is delivered - Constants.AttackType.PROJECTILE, REMOTE, ZONE, UTILITY
--   * PROJECTILE: Physical projectile attacks - can be blocked by barriers and wards
--   * REMOTE:     Magical attacks at a distance - can only be blocked by wards
--   * ZONE:       Area effect attacks - can be blocked by barriers and fields
--   * UTILITY:    Non-offensive spells that affect the caster - cannot be blocked
-- castTime: Duration in seconds to cast the spell (number)
-- cost: Array of token types required (array using Constants.TokenType.FIRE, etc.)
-- getCost: Optional function(caster, target) -> cost table for dynamic costs
-- keywords: Table of effect keywords and their parameters (table)
--   - Available keywords: damage, burn, stagger, elevate, ground, rangeShift, forcePull, 
--     tokenShift, conjure, dissipate, lock, delay, accelerate, dispel, disjoint, freeze,
--     block, reflect, echo, zoneAnchor, zoneMulti
-- visualShape: Visual shape identifier to override default template based on attackType (string, optional)
-- vfx: Visual effect identifier (string, optional)
-- sfx: Sound effect identifier (string, optional)
--
-- Shield Types and Blocking Rules:
-- * barrier: Physical shield that blocks projectiles and zones
-- * ward:    Magical shield that blocks projectiles and remotes
-- * field:   Energy field that blocks remotes and zones

-- Function to validate spell schema - Basic schema validation
function Schema.validateSpell(spell, spellId)
    -- Add a missing ID based on spell name if needed
    if not spell.id and spell.name then
        spell.id = spell.name:lower():gsub(" ", "")
        print("INFO: Added missing ID for spell: " .. spell.name .. " -> " .. spell.id)
    end
    
    -- Check essential properties with better error handling
    if not spell.id then
        print("WARNING: Spell " .. spellId .. " missing required property: id, creating a default")
        spell.id = "spell_" .. spellId
    end
    
    if not spell.name then
        print("WARNING: Spell " .. spellId .. " missing required property: name, creating a default")
        spell.name = "Unnamed Spell " .. spellId
    end

    if not spell.affinity then
        print("WARNING: Spell " .. spellId .. " missing required property: affinity, creating a default")
        spell.affinity = "fire"
    end
    
    if not spell.description then
        print("WARNING: Spell " .. spellId .. " missing required property: description, creating a default")
        spell.description = "No description available for " .. spell.name
    end
    
    if not spell.castTime then
        print("WARNING: Spell " .. spellId .. " missing required property: castTime, setting default")
        spell.castTime = 5.0 -- Default cast time
    end
    
    if type(spell.castTime) ~= "number" then
        print("WARNING: Spell " .. spellId .. " castTime must be a number, fixing")
        spell.castTime = tonumber(spell.castTime) or 5.0
    end
    
    -- Ensure cost is a table if provided, or create an empty table when neither
    -- cost nor getCost are specified. When getCost exists it's considered the
    -- runtime source of truth so we don't warn about a missing cost table.
    if not spell.cost then
        if spell.getCost and type(spell.getCost) == "function" then
            spell.cost = {}
        else
            print("WARNING: Spell " .. spellId .. " missing required property: cost, creating empty cost")
            spell.cost = {}
        end
    elseif type(spell.cost) ~= "table" then
        print("WARNING: Spell " .. spellId .. " cost must be a table, fixing")
        -- Try to convert to a table if possible
        local originalCost = spell.cost
        spell.cost = {}
        if originalCost then
            print("INFO: Converting non-table cost to table for: " .. spell.name)
            table.insert(spell.cost, tostring(originalCost))
        end
    end
    
    -- Check attackType is valid
    if spell.attackType then
        local validTypes = {
            projectile = true,
            remote = true,
            zone = true,
            utility = true
        }
        
        if not validTypes[spell.attackType] then
            print("WARNING: Spell " .. spellId .. " has invalid attackType: " .. spell.attackType .. ", fixing to utility")
            spell.attackType = "utility" -- Default to utility
        end
    else
        -- Default to utility if not specified
        print("WARNING: Spell " .. spellId .. " missing attackType, setting to utility")
        spell.attackType = "utility"
    end
    
    -- Check keywords are valid (if present)
    if spell.keywords then
        if type(spell.keywords) ~= "table" then
            print("WARNING: Spell " .. spellId .. " keywords must be a table, fixing")
            spell.keywords = {}
        else
            -- Keyword validation is done in the Keywords module
        end
    else
        -- Create empty keywords table if missing
        spell.keywords = {}
    end
    
    return true
end

return Schema```

## ./systems/EventRunner.lua
```lua
-- EventRunner.lua
-- Processes spell events and applies them to game state
--
-- IMPORTANT: Visual Effects Pattern
-- =================================
-- This module now uses the VisualResolver for determining which VFX to trigger.
-- The pattern for creating visuals is:
--
-- 1. For typical gameplay events (damage, status, etc.):
--    - Keywords in keywords.lua should include visual metadata in their events
--    - The EFFECT handler in this module will use VisualResolver.pick() to determine visuals
--
-- 2. For specialized effects in other handlers:
--    - Generate an EFFECT event with proper metadata and dispatch it
--    - This ensures consistent visual handling through the VisualResolver
--
-- 3. Legacy direct VFX calls:
--    - Some handlers still use safeCreateVFX() directly (marked with TODO comments)
--    - These will be gradually migrated to use the VisualResolver pattern

local Constants = require("core.Constants")
local VisualResolver = require("systems.VisualResolver")
local Log = require("core.Log")
local EventRunner = {}

-- Constants for event processing order
local PROCESSING_PRIORITY = {
    -- State setting events (first)
    SET_ELEVATION = 10,
    SET_RANGE = 20,
    FORCE_POSITION = 30,
    ZONE_ANCHOR = 40,
    
    -- Resource events (second)
    CONJURE_TOKEN = 100,
    DISSIPATE_TOKEN = 110,
    SHIFT_TOKEN = 120,
    LOCK_TOKEN = 130,
    CONSUME_TOKENS = 140,
    
    -- Spell timeline events (third)
    ACCELERATE_SPELL = 210,
    CANCEL_SPELL = 220,
    FREEZE_SPELL = 230,
    
    -- Defense events (fourth)
    CREATE_SHIELD = 300,
    REFLECT = 310,
    
    -- Status effects (fifth)
    APPLY_STATUS = 400,
    
    -- Damage events (sixth)
    DAMAGE = 500,
    BLOCKED_DAMAGE = 501, -- Same priority as DAMAGE but won't apply health changes
    
    -- Visual effects (before special effects)
    EFFECT = 550,
    
    -- Special effects (last)
    ECHO = 600,
    ZONE_MULTI = 610
}

-- Sort events by their processing priority
local function sortEventsByPriority(events)
    table.sort(events, function(a, b)
        local priorityA = PROCESSING_PRIORITY[a.type] or 999
        local priorityB = PROCESSING_PRIORITY[b.type] or 999
        return priorityA < priorityB
    end)
    return events
end

-- Safe VFX creation helper function
local function safeCreateVFX(vfx, methodName, fallbackType, x, y, params)
    if not vfx then
        Log.debug("DEBUG: VFX system is nil")
        return false
    end
    
    -- Make sure x and y are valid numbers
    if not x or not y or type(x) ~= "number" or type(y) ~= "number" then
        x = 0
        y = 0
        Log.debug("DEBUG: Invalid coordinates for VFX, using (0,0)")
    end
    
    -- Debug the parameters
    Log.debug(string.format("[safeCreateVFX] Method: %s, EffectType: '%s', Coords: (%d, %d)",
        methodName, tostring(fallbackType), x or 0, y or 0))
        
    -- Try to call the specific method
    if type(vfx[methodName]) == "function" then
        -- Method needs to be called as vfx:methodName() for self to be passed properly
        local success, err = pcall(function() 
            if methodName == "createEffect" then
                -- Print the type of vfx and fallbackType for debugging
                Log.debug("[safeCreateVFX] vfx is type: " .. type(vfx) .. ", fallbackType is type: " .. type(fallbackType))
                
                -- IMPORTANT: Need to use dot notation and pass VFX module as first arg for module functions
                -- DO NOT use colon notation (vfx:createEffect) as it passes vfx as self which makes effectName a table
                Log.debug("[safeCreateVFX] Calling vfx.createEffect with effectName: " .. tostring(fallbackType))
                vfx.createEffect(fallbackType, x, y, nil, nil, params)
            else
                -- For other methods
                Log.debug("[safeCreateVFX] Calling vfx." .. methodName)
                vfx[methodName](vfx, x, y, params) 
            end
        end)
        
        if not success then
            Log.debug("DEBUG: Error calling " .. methodName .. ": " .. tostring(err))
            -- Try fallback on error
            if methodName ~= "createEffect" and type(vfx.createEffect) == "function" then
                pcall(function() vfx.createEffect(fallbackType, x, y, nil, nil, params) end)
            end
        end
        return true
    -- Fall back to generic createEffect if available
    elseif type(vfx.createEffect) == "function" then
        local success, err = pcall(function() 
            vfx.createEffect(fallbackType, x, y, nil, nil, params) 
        end)
        
        if not success then
            Log.debug("DEBUG: Error calling createEffect: " .. tostring(err))
        end
        return true
    else
        -- Debug output if no VFX methods are available
        Log.debug("DEBUG: VFX system lacks both " .. methodName .. " and createEffect methods")
        return false
    end
end

-- Process all events and apply them to game state
function EventRunner.processEvents(events, caster, target, spellSlot)
    -- Double check we actually have valid input
    if not events or type(events) ~= "table" then
        print("WARNING: Nil or invalid events list passed to processEvents")
        return {
            eventsProcessed = 0,
            damageDealt = 0,
            statusEffectsApplied = {},
            shieldCreated = false,
            tokensAffected = 0,
            error = "Invalid events list"
        }
    end
    
    -- Verify caster and target are valid
    if not caster then
        print("WARNING: Nil caster passed to processEvents")
        return {
            eventsProcessed = 0,
            error = "Invalid caster"
        }
    end
    
    -- Create a results table to track effects 
    local results = {
        eventsProcessed = 0,
        damageDealt = 0,
        statusEffectsApplied = {},
        shieldCreated = false,
        tokensAffected = 0
    }
    
    -- Sort events by processing priority
    local success, sortedEvents = pcall(function() 
        return sortEventsByPriority(events)
    end)
    
    if not success then
        print("WARNING: Error sorting events: " .. tostring(sortedEvents))
        sortedEvents = events -- Use unsorted events as fallback
    end
    
    -- Process each event
    for _, event in ipairs(sortedEvents) do
        -- Skip invalid events
        if not event or not event.type then
            print("WARNING: Skipping invalid event")
            goto continue
        end
        
        -- Wrap event handling in pcall to prevent crashes
        local success, handled = pcall(function()
            return EventRunner.handleEvent(event, caster, target, spellSlot, results)
        end)
        
        if success and handled then
            results.eventsProcessed = results.eventsProcessed + 1
        elseif not success then
            -- Log error but continue processing other events
            print("ERROR processing event type " .. (event.type or "unknown") .. ": " .. tostring(handled))
        end
        
        ::continue::
    end
    
    return results
end

-- Handle a single event
function EventRunner.handleEvent(event, caster, target, spellSlot, results)
    -- Validate inputs
    if not event or not event.type then
        print("WARNING: Invalid event passed to handleEvent")
        return false
    end
    
    if not caster then
        print("WARNING: Nil caster in handleEvent for event type " .. event.type)
        return false
    end
    
    if not results then
        print("WARNING: Nil results in handleEvent for event type " .. event.type)
        results = {}
    end
    
    -- Get the event handler for this event type
    local handler = EventRunner.EVENT_HANDLERS[event.type]
    if not handler then
        print("WARNING: No handler for event type " .. event.type)
        return false
    end
    
    -- Call the handler with the event and context in protected mode
    local success, result = pcall(function()
        return handler(event, caster, target, spellSlot, results)
    end)
    
    if not success then
        print("ERROR in event handler for " .. event.type .. ": " .. tostring(result))
        return false
    end
    
    return result
end

-- Resolve the actual target entity for an event
-- This function handles both raw string target types (like "enemy_slot") 
-- and Constants.TargetType enum values (like Constants.TargetType.SLOT_ENEMY)
-- Always returns a table like { wizard, slotIndex } or nil
function EventRunner.resolveTarget(event, caster, target)
    -- Validate inputs
    if not event then
        print("WARNING: Nil event in resolveTarget")
        return {wizard = caster, slotIndex = nil} -- Default to caster as fallback
    end
    
    if not caster then
        print("WARNING: Nil caster in resolveTarget")
        return nil
    end
    
    local targetType = event.target
    local slotIndex = event.slotIndex -- Extract slotIndex from event
    
    -- Handle nil target type
    if targetType == nil then
        print("WARNING: Nil target type in event, defaulting to 'self'")
        return {wizard = caster, slotIndex = slotIndex}
    end
    
    -- Normalize target types to handle both string literals and Constants.TargetType values
    local normalizedTargetType = ""
    if type(targetType) == "string" then
        normalizedTargetType = string.lower(targetType)
    else
        print("WARNING: Non-string target type: " .. type(targetType) .. ", defaulting to 'self'")
        return {wizard = caster, slotIndex = slotIndex}
    end
    
    -- Handle Constants.TargetType values (mapping to strings)
    if targetType == Constants.TargetType.SLOT_ENEMY then
        normalizedTargetType = "enemy_slot"
    elseif targetType == Constants.TargetType.SLOT_SELF then
        normalizedTargetType = "self_slot"
    elseif targetType == Constants.TargetType.SELF then
        normalizedTargetType = "self"
    elseif targetType == Constants.TargetType.ENEMY then
        normalizedTargetType = "enemy"
    elseif targetType == Constants.TargetType.POOL_SELF or targetType == Constants.TargetType.POOL_ENEMY then
        -- Pool targets are handled differently, return nil for wizard/slot structure
        -- The handler must specifically check for pool targets
        return nil 
    end
    
    -- Process normalized target types
    if normalizedTargetType == "self" then
        return {wizard = caster, slotIndex = slotIndex}
    elseif normalizedTargetType == "enemy" then
        if not target then
            print("WARNING: Event targets 'enemy' but target is nil, cannot resolve")
            return nil
        end
        return {wizard = target, slotIndex = slotIndex}
    elseif normalizedTargetType == "self_slot" then
        return {wizard = caster, slotIndex = slotIndex}
    elseif normalizedTargetType == "enemy_slot" then
        if not target then
            print(string.format("WARNING: Event targets 'enemy_slot' but target is nil (event: %s)", event and event.type or "nil"))
            return nil
        end
        return {wizard = target, slotIndex = slotIndex}
    else
        -- Default case for unrecognized types
        print("WARNING: Unrecognized target type: " .. tostring(event.target) .. ", defaulting to 'self'")
        return {wizard = caster, slotIndex = slotIndex}
    end
end

-- Event handler functions
EventRunner.EVENT_HANDLERS = {
    -- ===== Damage Events =====
    
    DAMAGE = function(event, caster, target, spellSlot, results)
        -- Resolve target, expecting { wizard, slotIndex } table or nil
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        
        -- Check if target resolution failed OR if the wizard object is missing
        if not targetInfo or not targetInfo.wizard then 
            print("ERROR: DAMAGE handler could not resolve target wizard")
            return false 
        end
        
        -- Get the actual wizard object
        local targetWizard = targetInfo.wizard
        
        -- Check if we should delay damage application for visual synchronization
        local delayDamage = event.delayDamage or false
        
        -- We don't need to check for blocked spells here anymore
        -- The Wizard:castSpell method now returns early for blocked spells
        -- and they never reach the damage events
        
        -- If the damage isn't delayed, apply it immediately
        if not delayDamage then
            -- Apply damage to the target wizard's health
            targetWizard.health = targetWizard.health - event.amount
            
            -- Ensure health doesn't go below zero
            if targetWizard.health < 0 then targetWizard.health = 0 end
            
            -- Set hit flash timer for visual feedback
            targetWizard.hitFlashTimer = 0.125 -- 125ms flash duration
            
            -- Trigger screen shake and hitstop for high-impact hits
            if event.amount >= 15 or (event.tags and event.tags.HIGH_IMPACT) then
                -- Strong hit - significant screenshake and hitstop
                if targetWizard.gameState and targetWizard.gameState.triggerShake then
                    local intensity = math.min(10, 5 + (event.amount / 10))
                    targetWizard.gameState.triggerShake(0.35, intensity) -- Longer, stronger shake
                    targetWizard.gameState.triggerHitstop(0.12) -- Strong hitstop
                    print(string.format("[DAMAGE EVENT] High impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                        0.35, intensity, 0.12))
                end
            elseif event.amount >= 8 then
                -- Medium hit - moderate screenshake and brief hitstop
                if targetWizard.gameState and targetWizard.gameState.triggerShake then
                    targetWizard.gameState.triggerShake(0.25, 6) -- Medium shake
                    targetWizard.gameState.triggerHitstop(0.08) -- Medium hitstop
                    print(string.format("[DAMAGE EVENT] Medium impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                        0.25, 6, 0.08))
                end
            elseif event.amount >= 3 then
                -- Light hit - minimal screenshake, no hitstop
                if targetWizard.gameState and targetWizard.gameState.triggerShake then
                    targetWizard.gameState.triggerShake(0.15, 4) -- Light shake
                    print(string.format("[DAMAGE EVENT] Light impact hit! Triggering shake (%.2f, %.2f)",
                        0.15, 4))
                end
            end
            
            -- Debug log damage application
            print(string.format("[DAMAGE EVENT] Applied %d damage to %s. New health: %d", 
                event.amount, targetWizard.name, targetWizard.health))
        else
            -- Store damage in the event for deferred application
            print(string.format("[DAMAGE EVENT] Delaying %d damage to %s for visual sync", 
                event.amount, targetWizard.name))
        end
            
        -- Debug log visual metadata
        print(string.format("[DAMAGE EVENT] Visual metadata: affinity=%s, attackType=%s, damageType=%s, manaCost=%s", 
            tostring(event.affinity),
            tostring(event.attackType),
            tostring(event.damageType),
            tostring(event.manaCost)))
        print(string.format("[DAMAGE EVENT] More metadata: tags=%s, rangeBand=%s, elevation=%s", 
            event.tags and "present" or "nil",
            tostring(event.rangeBand),
            tostring(event.elevation)))
        
        -- Track damage for results, even if delayed
        results.damageDealt = results.damageDealt + event.amount
        
        -- Generate an EFFECT event for the damage
        -- Check if we have a spell with effectOverride first
        local effectOverride = nil
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
           caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.effectOverride then
            effectOverride = caster.spellSlots[spellSlot].spell.effectOverride
        end
        
        -- Create EFFECT event
        local effectEvent = {
            type = "EFFECT",
            source = "caster",
            target = event.target,
            effectOverride = effectOverride, -- Use override if we have one
            
            -- Copy visual metadata from the damage event
            affinity = event.affinity,
            attackType = event.attackType,
            damageType = event.damageType,
            manaCost = event.manaCost,
            tags = event.tags or { DAMAGE = true },
            rangeBand = event.rangeBand,
            elevation = event.elevation,
            visualShape = event.visualShape, -- Copy visualShape if present
            
            -- Add delayed damage information
            delayedDamage = delayDamage and event.amount or nil,
            delayedDamageTarget = delayDamage and targetWizard or nil,
            
            -- Copy blockInfo if present for shield block visualization
            blockInfo = event.blockInfo
        }
        
        -- If this is a blocked spell, add SHIELD_BLOCKED tag
        if event.blockInfo and event.blockInfo.blockable then
            effectEvent.tags = effectEvent.tags or {}
            effectEvent.tags.SHIELD_BLOCKED = true
            
            -- Add standard blockPoint
            effectEvent.blockPoint = event.blockInfo.blockPoint or 0.75
            
            print("[DAMAGE->EFFECT] Passing blockInfo to EFFECT event for shield block visuals")
        end
        
        -- Debug log the generated EFFECT event
        print(string.format("[DAMAGE->EFFECT] Generated EFFECT event with effectOverride=%s", 
            tostring(effectOverride)))
        print(string.format("[DAMAGE->EFFECT] Transferred metadata: affinity=%s, attackType=%s, damageType=%s", 
            tostring(effectEvent.affinity),
            tostring(effectEvent.attackType),
            tostring(effectEvent.damageType)))
        print(string.format("[DAMAGE->EFFECT] More metadata: tags=%s, rangeBand=%s, elevation=%s", 
            effectEvent.tags and "present" or "nil",
            tostring(effectEvent.rangeBand),
            tostring(effectEvent.elevation)))
        
        -- Process the effect event to create visuals
        EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        
        return true
    end,
    
    -- Handler for blocked damage events - similar to DAMAGE but doesn't apply health changes
    BLOCKED_DAMAGE = function(event, caster, target, spellSlot, results)
        -- Resolve target, expecting { wizard, slotIndex } table or nil
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        
        -- Check if target resolution failed OR if the wizard object is missing
        if not targetInfo or not targetInfo.wizard then 
            print("ERROR: BLOCKED_DAMAGE handler could not resolve target wizard")
            return false 
        end
        
        -- Get the actual wizard object
        local targetWizard = targetInfo.wizard
        
        -- Log the blocked damage (no damage is applied)
        print(string.format("[BLOCKED_DAMAGE] %s's spell blocked by shield! No damage applied to %s (would have been %d)", 
            caster.name, targetWizard.name, event.amount or 0))
            
        -- Track in results that a block occurred
        results.damageBlocked = (results.damageBlocked or 0) + (event.amount or 0)
        
        -- The block shake will be triggered in vfx.lua when the projectile actually hits the shield
        -- instead of when the BLOCKED_DAMAGE event is first generated
        -- We'll add the shield hit info to the event instead
        
        -- Enhanced debugging for BLOCKED_DAMAGE event
        print("[BLOCKED_DAMAGE] Full event details:")
        for k, v in pairs(event) do
            if type(v) == "table" then
                print("  " .. k .. ": [table]")
            else
                print("  " .. k .. ": " .. tostring(v))
            end
        end
        
        -- Verify we have blockInfo
        if not event.blockInfo then
            print("[BLOCKED_DAMAGE] WARNING: Missing blockInfo in BLOCKED_DAMAGE event!")
            -- Create a default blockInfo to ensure visuals still work
            event.blockInfo = {
                blockable = true,
                blockType = event.shieldType or "ward",
                blockPoint = event.blockPoint or 0.75
            }
        end
        
        -- Generate an EFFECT event for the blocked damage visuals
        -- Check if we have a spell with effectOverride first
        local effectOverride = nil
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
           caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.effectOverride then
            effectOverride = caster.spellSlots[spellSlot].spell.effectOverride
        end
        
        -- Create EFFECT event with block info
        local effectEvent = {
            type = "EFFECT",
            source = "caster",
            target = event.target,
            effectOverride = effectOverride,
            
            -- Copy visual metadata from the damage event
            affinity = event.affinity,
            attackType = event.attackType or "projectile", -- Default to projectile if missing
            damageType = event.damageType,
            manaCost = event.manaCost,
            tags = event.tags or { DAMAGE = true, SHIELD_BLOCKED = true },
            rangeBand = event.rangeBand,
            elevation = event.elevation,
            visualShape = event.visualShape or "bolt", -- Default to bolt if missing
            
            -- Copy block info for visual effects - ensure it's always present
            blockInfo = event.blockInfo,
            blockPoint = event.blockPoint or 0.75,
            
            -- Add the amount of damage for screen shake calculation
            amount = event.amount or 10
        }
        
        -- Debug log the generated EFFECT event
        print(string.format("[BLOCKED_DAMAGE->EFFECT] Generated EFFECT event with blockPoint=%.2f", 
            effectEvent.blockPoint))
        print("[BLOCKED_DAMAGE->EFFECT] Full effectEvent details:")
        for k, v in pairs(effectEvent) do
            if type(v) == "table" then
                print("  " .. k .. ": [table]")
            else
                print("  " .. k .. ": " .. tostring(v))
            end
        end
        
        -- Process the effect event to create visuals
        local success, err = pcall(function()
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        end)
        
        if not success then
            print("[BLOCKED_DAMAGE->EFFECT] ERROR: Failed to process effect event: " .. tostring(err))
        end
        
        return true
    end,
    
    -- ===== Status Effect Events =====
    
    APPLY_STATUS = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then 
            print("ERROR: APPLY_STATUS handler could not resolve target wizard")
            return false 
        end
        local targetWizard = targetInfo.wizard
        
        -- Initialize status effects table if it doesn't exist
        targetWizard.statusEffects = targetWizard.statusEffects or {}
        
        -- Build effect data table
        local effectData = {
            active = true,
            duration = event.duration or 0,
            tickDamage = event.tickDamage,
            tickInterval = event.tickInterval,
            magnitude = event.magnitude,
            targetSlot = event.targetSlot,
            elapsed = 0,
            totalTime = 0,
            source = caster
        }

        if event.statusType == Constants.StatusType.STUN then
            -- Explicitly store under "stun" key for easy access
            targetWizard.statusEffects[Constants.StatusType.STUN] = effectData
        else
            -- Generic status effect storage
            targetWizard.statusEffects[event.statusType] = effectData
        end
        
        -- Log the application
        print(string.format("[STATUS] Applied %s to %s (Duration: %.1f, Magnitude: %s, Slot: %s)", 
            event.statusType, targetWizard.name, event.duration or 0, tostring(event.magnitude), tostring(event.targetSlot)))

        -- Track applied status for results
        table.insert(results.statusEffectsApplied, event.statusType)
        
        -- Create status effect VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Assuming createStatusEffect takes the wizard object
            caster.gameState.vfx.createStatusEffect(targetWizard, event.statusType)
        end
        
        return true
    end,
    
    -- ===== Elevation Events =====
    
    SET_ELEVATION = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then 
             print("ERROR: SET_ELEVATION handler could not resolve target wizard")
             return false
        end
        local targetWizard = targetInfo.wizard
        
        -- Set elevation state
        targetWizard.elevation = event.elevation
        
        -- Set duration if provided
        if event.duration then
            targetWizard.elevationEffects = targetWizard.elevationEffects or {}
            targetWizard.elevationEffects[event.elevation] = {
                duration = event.duration,
                expireAction = function()
                    -- When effect expires, return to default elevation (usually GROUNDED)
                    targetWizard.elevation = Constants.ElevationState.GROUNDED
                end
            }
        end
        
        -- No need to manually trigger position animation here -
        -- The wizard's positionAnimation is automatically detected and handled
        -- in WizardVisuals.drawWizard when elevation changes
        
        -- Create elevation change VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Interim Approach: Generate an EFFECT event to handle VFX consistently
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = event.target,
                -- If the event has a custom vfx specified, use it as an override
                effectOverride = (event.vfx and type(event.vfx) == "string") and event.vfx or nil,
                -- Provide elevation metadata for the resolver
                affinity = event.affinity, -- Use affinity from original event
                attackType = Constants.AttackType.UTILITY,    -- Elevation is a utility spell type
                manaCost = event.manaCost or 1,
                tags = { MOVEMENT = true, [event.elevation == Constants.ElevationState.AERIAL and "ELEVATE" or "GROUND"] = true },
                rangeBand = caster.gameState.rangeState,
                elevation = event.elevation,
                visualShape = event.visualShape, -- Preserve visualShape if specified
                duration = 1.0
            }
            
            -- Process the effect event, which will use the VisualResolver internally
            -- This ensures consistent visual handling for all effects
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
            
            -- Note: The above approach is cleaner than calling VisualResolver directly
            -- as it ensures all event parameters are properly passed through
        end
        
        return true
    end,
    
    -- ===== Range Events =====
    
    SET_RANGE = function(event, caster, target, spellSlot, results)
        local targetEntities
        
        -- Range changes always affect both wizards
        if event.target == "both" then
            targetEntities = {caster, target}
        else
            targetEntities = {EventRunner.resolveTarget(event, caster, target)}
        end
        
        -- Update game state with new range
        if caster.gameState then
            -- Store the new range state
            caster.gameState.rangeState = event.position
            
            -- No need to call any extra position animation functions - the wizards'
            -- positionAnimation state is automatically detected and updated in 
            -- WizardVisuals.drawWizard when it sees the range state has changed
        end
        
        -- Create range change VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Generate an EFFECT event for consistent handling through VisualResolver
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = "both", -- Range changes affect both wizards
                effectOverride = Constants.VFXType.RANGE_CHANGE, -- Use explicit override for this special effect
                -- Provide relevant metadata for the resolver
                affinity = event.affinity,
                attackType = Constants.AttackType.UTILITY,
                manaCost = 1,
                tags = { MOVEMENT = true },
                rangeBand = event.position, -- The new range state
                elevation = caster.elevation,
                visualShape = event.visualShape, -- Preserve visualShape if specified
                duration = 1.0,
                -- Extra params specific to range changes
                position = event.position
            }
            
            -- Process the effect event through the standard pipeline
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        end
        
        return true
    end,
    
    FORCE_POSITION = function(event, caster, target, spellSlot, results)
        -- Force opponent to match caster's range
        -- Range is stored in game state, not on individual wizards
        if caster.gameState then
            -- Just a shortcut to quickly force range change - could be expanded if needed
            caster.gameState.rangeState = caster.gameState.rangeState
            
            -- Create position force VFX if available
            if caster.gameState.vfx then
                -- TODO: VFX-R5 - Update this to use VisualResolver pattern
                -- This handler should be refactored to generate an EFFECT event
                -- for consistency, but we'll leave it for now as it's a specialized effect
                local params = {
                    duration = 1.0,
                    source = caster.name,
                    target = target.name
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createPositionForceEffect",
                    Constants.VFXType.FORCE_POSITION,
                    (caster.x + target.x) / 2,  -- Midpoint
                    (caster.y + target.y) / 2,  -- Midpoint
                    params
                )
            end
        end
        
        return true
    end,
    
    -- ===== Resource & Token Events =====
    
    CONJURE_TOKEN = function(event, caster, target, spellSlot, results)
        local manaPool = caster.manaPool
        if not manaPool then return false end
        
        -- Create VFX for token conjuration using the rule-driven approach
        if caster.gameState and caster.gameState.vfx then
            -- Create an EFFECT event to use the VisualResolver pattern
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = "caster", -- Token conjuration affects the caster
                
                -- Check if there's a specific effect for this token type
                effectOverride = nil, -- Will be set conditionally below
                
                -- Token type determines appearance through VisualResolver
                affinity = event.tokenType,
                attackType = Constants.AttackType.UTILITY,
                manaCost = event.amount, -- Scale with the amount of tokens
                
                -- Metadata to determine visuals and behavior
                tags = { CONJURE = true, RESOURCE = true },
                
                -- Token-specific parameters
                tokenType = event.tokenType,
                amount = event.amount
            }
            
            -- Check if there's a specific effect for this token type
            local specificEffect = "conjure" .. event.tokenType
            if Constants.VFXType[specificEffect:upper()] then
                effectEvent.effectOverride = Constants.VFXType[specificEffect:upper()]
            end
            
            -- Let the EFFECT handler process this with VisualResolver
            EventRunner.handleEvent(effectEvent, caster, caster, spellSlot, results)
        end
        
        -- Add tokens to the mana pool with animation
        for i = 1, event.amount do
            local assetPath = "assets/sprites/v2Tokens/" .. event.tokenType .. "-token.png"
            manaPool:addTokenWithAnimation(event.tokenType, assetPath, caster)
            results.tokensAffected = results.tokensAffected + 1
        end
        
        return true
    end,
    
    DISSIPATE_TOKEN = function(event, caster, target, spellSlot, results)
        local manaPool = caster.manaPool
        if not manaPool then return false end
        
        -- Find and remove tokens from the mana pool
        local tokensRemoved = 0
        
        -- Logic to find and mark tokens for removal
        for i, token in ipairs(manaPool.tokens) do
            local isFree = (token.status == Constants.TokenStatus.FREE)
            local matchesType = (event.tokenType == Constants.TokenType.ANY or token.type == event.tokenType)
            
            if isFree and matchesType then
                -- Request destruction animation using state machine
                token:requestDestructionAnimation()
                
                tokensRemoved = tokensRemoved + 1
                results.tokensAffected = results.tokensAffected + 1
                
                -- Stop once we've marked enough tokens
                if tokensRemoved >= event.amount then
                    break
                end
            end
        end
        
        return true
    end,
    
    SHIFT_TOKEN = function(event, caster, target, spellSlot, results)
        local manaPool = caster.manaPool
        if not manaPool then return false end
        
        -- Count how many tokens we successfully shifted
        local tokensShifted = 0
        
        -- Handle random token shifting
        if event.tokenType == Constants.TokenType.RANDOM then
            local tokenTypes = Constants.getAllTokenTypes()
            
            -- Find FREE tokens and shift them to random types
            for i, token in ipairs(manaPool.tokens) do
                if token.status == Constants.TokenStatus.FREE then
                    -- Pick a random token type
                    local randomType = tokenTypes[math.random(#tokenTypes)]
                    local oldType = token.type
                    
                    -- Only change if it's a different type
                    if randomType ~= oldType then
                        token.type = randomType
                        token.image = love.graphics.newImage("assets/sprites/v2Tokens/" .. randomType .. "-token.png")
                        tokensShifted = tokensShifted + 1
                        results.tokensAffected = results.tokensAffected + 1
                    end
                    
                    -- Stop once we've shifted enough tokens
                    if tokensShifted >= event.amount then
                        break
                    end
                end
            end
        else
            -- Find FREE tokens and shift them to the specified type
            for i, token in ipairs(manaPool.tokens) do
                if token.status == Constants.TokenStatus.FREE and token.type ~= event.tokenType then
                    token.type = event.tokenType
                    token.image = love.graphics.newImage("assets/sprites/v2Tokens/" .. event.tokenType .. "-token.png")
                    tokensShifted = tokensShifted + 1
                    results.tokensAffected = results.tokensAffected + 1
                    
                    -- Stop once we've shifted enough tokens
                    if tokensShifted >= event.amount then
                        break
                    end
                end
            end
        end
        
        return true
    end,
    
    LOCK_TOKEN = function(event, caster, target, spellSlot, results)
        -- Target the SHARED mana pool via gameState
        local manaPool = caster.gameState.manaPool 
        if not manaPool then 
            print("ERROR: LOCK_TOKEN handler could not find shared manaPool via caster.gameState")
            return false 
        end
        
        -- Find all FREE tokens matching the type (or 'any')
        local freeTokens = {}
        for i, token in ipairs(manaPool.tokens) do
            if token.status == Constants.TokenStatus.FREE and (event.tokenType == "any" or token.type == event.tokenType) then
                table.insert(freeTokens, token)
            end
        end
        
        -- If no free tokens found, do nothing
        if #freeTokens == 0 then
            return false -- Indicate event didn't successfully apply
        end
        
        -- Lock the specified amount (usually 1) of random free tokens
        local tokensLocked = 0
        local lockAmount = event.amount or 1
        
        while tokensLocked < lockAmount and #freeTokens > 0 do
            -- Select a random token from the list
            local randomIndex = math.random(#freeTokens)
            local tokenToLock = table.remove(freeTokens, randomIndex)
            
            -- Lock the selected token
            if tokenToLock.setState then
                tokenToLock:setState(Constants.TokenStatus.LOCKED)
            end
            tokenToLock.lockTimer = event.duration
            tokensLocked = tokensLocked + 1
            results.tokensAffected = results.tokensAffected + 1
            
            -- Create lock visual effect if VFX system available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = event.duration,
                    tokenType = tokenToLock.type
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createTokenLockEffect",
                    Constants.VFXType.TOKEN_LOCK,
                    tokenToLock.x,
                    tokenToLock.y,
                    params
                )
            end
        end
        
        return tokensLocked > 0 -- Return true if at least one token was locked
    end,
    
    -- ===== Spell Timing Events =====
    
    ACCELERATE_SPELL = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex
        
        -- If slotIndex is not specified, use the current slot
        if not slotIndex or slotIndex == 0 then
            slotIndex = spellSlot
        end
        
        -- Apply acceleration to the slot
        local slot = wizard.spellSlots[slotIndex]
        if slot and slot.active and not slot.isShield then
            slot.progress = slot.progress + event.amount
            
            -- Create acceleration VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = 1.0,
                    amount = event.amount,
                    slotIndex = slotIndex
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createSpellAccelerateEffect",
                    Constants.VFXType.SPELL_ACCELERATE,
                    wizard.x,
                    wizard.y,
                    params
                )
            end
            
            return true
        end
        
        return false
    end,
    
    CANCEL_SPELL = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex
        
        -- If slotIndex is not specified, pick a random active slot
        if not slotIndex or slotIndex == 0 then
            local activeSlots = {}
            for i, slot in ipairs(wizard.spellSlots) do
                if slot.active and not slot.isShield then
                    table.insert(activeSlots, i)
                end
            end
            
            if #activeSlots > 0 then
                slotIndex = activeSlots[math.random(#activeSlots)]
            else
                -- No active slots, nothing to cancel
                return false
            end
        end
        
        -- Apply cancel to the slot
        local slot = wizard.spellSlots[slotIndex]
        if slot and slot.active and not slot.isShield then
            -- Check if mana should be returned to the pool
            if event.returnMana then
                -- Return tokens to the pool (dispel)
                for _, tokenData in ipairs(slot.tokens) do
                    if tokenData.token then
                        tokenData.token:requestReturnAnimation()
                    end
                end
            else
                -- Destroy tokens (disjoint)
                for _, tokenData in ipairs(slot.tokens) do
                    if tokenData.token then
                        tokenData.token:requestDestructionAnimation()
                    end
                end
            end
            
            -- Reset the slot
            wizard:resetSpellSlot(slotIndex)
            
            -- Create cancel VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = 1.0,
                    returnMana = event.returnMana,
                    slotIndex = slotIndex
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createSpellCancelEffect",
                    Constants.VFXType.SPELL_CANCEL,
                    wizard.x,
                    wizard.y,
                    params
                )
            end
            
            return true
        end
        
        return false
    end,
    
    FREEZE_SPELL = function(event, caster, target, spellSlot, results)
        local resolvedTarget = EventRunner.resolveTarget(event, caster, target)
        
        -- Determine the actual wizard and slot index
        local wizardToFreeze = nil
        local slotIndexToFreeze = event.slotIndex or 3 -- Get slot from event, default to 2
        
        if not resolvedTarget then
            print("ERROR: FREEZE_SPELL target resolution failed.")
            return false
        end
        
        -- Check the type of the resolved target
        if type(resolvedTarget) == "table" then
            if resolvedTarget.wizard then 
                -- It's a slot target table: {wizard, slotIndex}
                wizardToFreeze = resolvedTarget.wizard
                -- Use slot index from table if provided, otherwise stick to event/default
                slotIndexToFreeze = resolvedTarget.slotIndex or slotIndexToFreeze 
            elseif resolvedTarget.name then 
                -- It's likely a direct wizard object (check for 'name' as indicator)
                wizardToFreeze = resolvedTarget
            else
                -- It's some other table type (e.g., manaPool), which is invalid for FREEZE
                 print("ERROR: FREEZE_SPELL resolved target is an unexpected table type.")
                 return false
            end
        else
            -- Should not happen if resolveTarget is working, but handle unexpected types
            print("ERROR: FREEZE_SPELL resolved target is not a table (wizard or slot table expected).")
            return false
        end

        -- Final check for wizard object
        if not wizardToFreeze then
            print("ERROR: FREEZE_SPELL could not determine target wizard.")
            return false
        end

        -- Handle case where slot index is nil or 0 (needs default/random logic)
        if not slotIndexToFreeze or slotIndexToFreeze == 0 then
            slotIndexToFreeze = 2 -- Default to middle slot
            
            -- If default slot 2 is not active, find *any* active, non-shield slot
            if not wizardToFreeze.spellSlots[slotIndexToFreeze] or not wizardToFreeze.spellSlots[slotIndexToFreeze].active or wizardToFreeze.spellSlots[slotIndexToFreeze].isShield then
                local activeSlots = {}
                for i, slotData in ipairs(wizardToFreeze.spellSlots) do
                    if slotData.active and not slotData.isShield then
                        table.insert(activeSlots, i)
                    end
                end
                
                if #activeSlots > 0 then
                    slotIndexToFreeze = activeSlots[math.random(#activeSlots)]
                else
                    return false -- No valid target slot
                end
            end
        end
        
        -- Apply freeze to the determined wizard and slot index
        local slot = wizardToFreeze.spellSlots[slotIndexToFreeze]

        if slot and slot.active and not slot.isShield then
            slot.frozen = true
            slot.freezeTimer = event.duration
            
            -- Create freeze VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = event.duration,
                    slotIndex = slotIndexToFreeze
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createSpellFreezeEffect",
                    Constants.VFXType.SPELL_FREEZE,
                    wizardToFreeze.x,
                    wizardToFreeze.y,
                    params
                )
            end
            
            -- Return true and results structure
            results.freezeApplied = true
            results.frozenSlot = slotIndexToFreeze
            results.freezeDuration = event.duration
            return true
        end
        
        return false
    end,
    
    -- NEW HANDLER: Disrupts channeling, shifts token type, returns it to pool
    DISRUPT_AND_SHIFT = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex
        
        -- If slotIndex is 0 or nil, pick a random active slot (including shields)
        if not slotIndex or slotIndex == 0 then
            local activeSlots = {}
            for i, slot in ipairs(wizard.spellSlots) do
                if slot.active then 
                    table.insert(activeSlots, i)
                end
            end
            
            if #activeSlots > 0 then
                slotIndex = activeSlots[math.random(#activeSlots)]
            else
                return false -- No valid target slot
            end
        end
        
        -- Get the target slot
        local slot = wizard.spellSlots[slotIndex]
        if not slot or not slot.active or not slot.tokens or #slot.tokens == 0 then
            return false -- Invalid target slot
        end
        
        -- Select 1 random token from the slot's tokens
        local tokenIndexToRemove = math.random(#slot.tokens)
        local tokenDataToRemove = slot.tokens[tokenIndexToRemove]
        local removedTokenObject = tokenDataToRemove.token
        local originalType = removedTokenObject and removedTokenObject.type or "unknown"

        -- Remove the token data reference from the slot
        table.remove(slot.tokens, tokenIndexToRemove)

        -- Shift the REMOVED token object's type and request return animation
        if removedTokenObject then
            local newType = event.newType or Constants.TokenType.FIRE
            local oldType = removedTokenObject.type
            removedTokenObject.type = newType
            removedTokenObject.image = love.graphics.newImage("assets/sprites/v2Tokens/" .. newType .. "-token.png")
            results.tokensAffected = (results.tokensAffected or 0) + 1
            
            -- Request token return animation
            removedTokenObject:requestReturnAnimation()

            -- Trigger a VFX for the type shift
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    duration = 0.8,
                    oldType = oldType,
                    newType = newType
                }
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createTokenShiftEffect", -- Need to add this VFX method
                    Constants.VFXType.TOKEN_SHIFT,
                    removedTokenObject.x, 
                    removedTokenObject.y,
                    params
                )
            end
        else
            print("WARNING: Could not find token object to shift after removal from slot.")
        end

        -- Call the centralized Law of Completion check on the target wizard
        wizard:checkFizzleOnTokenRemoval(slotIndex, removedTokenObject)
        
        return true -- Event succeeded
    end,
    
    -- CONSUME_TOKENS: Permanently removes the tokens channeled to cast a spell
    CONSUME_TOKENS = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = event.slotIndex or spellSlot
        
        -- Get the target slot
        local slot = wizard.spellSlots[slotIndex]
        if not slot or not slot.active or not slot.tokens or #slot.tokens == 0 then
            return false -- Invalid target slot
        end
        
        -- Track how many tokens we consume
        local tokensConsumed = 0
        
        -- Go through all tokens in the slot and mark them for destruction
        for _, tokenData in ipairs(slot.tokens) do
            if tokenData.token then
                -- Check if we should consume this token based on amount parameter
                local shouldConsume = true
                if event.amount ~= "all" and tokensConsumed >= event.amount then
                    shouldConsume = false
                end
                
                if shouldConsume then
                    -- Request destruction animation
                    tokenData.token:requestDestructionAnimation()
                    
                    tokensConsumed = tokensConsumed + 1
                    results.tokensAffected = (results.tokensAffected or 0) + 1
                end
            end
        end
        
        -- Create VFX for token consumption if available
        if tokensConsumed > 0 and caster.gameState and caster.gameState.vfx then
            local params = {
                slotIndex = slotIndex,
                tokensConsumed = tokensConsumed
            }
            
            safeCreateVFX(
                caster.gameState.vfx,
                "createTokenConsumeEffect",
                Constants.VFXType.TOKEN_CONSUME,
                wizard.x,
                wizard.y,
                params
            )
        end
        
        print(string.format("[CONSUME] Consumed %d tokens from slot %d", tokensConsumed, slotIndex))
        
        return tokensConsumed > 0 -- Success if at least one token was consumed
    end,
    
    -- ===== Defense Events =====
    
    CREATE_SHIELD = function(event, caster, target, spellSlot, results)
        -- For shields, we need to handle events differently because the wizard is always the caster
        -- and the target is always a spell slot on the caster
        local wizard = nil
        local slotIndex = nil
        
        -- Determine which wizard and slot to use
        if event.target == "self_slot" then
            wizard = caster
            slotIndex = event.slotIndex or spellSlot
        elseif event.target == Constants.TargetType.SELF or event.target == "self" then
            -- Handle case when target is just "SELF" (shield spells often use this)
            wizard = caster
            slotIndex = spellSlot
        else
            -- Try the normal target resolution for other cases
            local targetInfo = EventRunner.resolveTarget(event, caster, target)
            if targetInfo and targetInfo.wizard then
                wizard = targetInfo.wizard
                slotIndex = targetInfo.slotIndex or spellSlot
            end
        end
        
        -- Verify we have a valid wizard and slot
        if not wizard or not slotIndex then
            print("ERROR: Invalid wizard or slot for shield creation")
            return false
        end
        
        -- Check that the slot exists and has tokens
        local slot = wizard.spellSlots[slotIndex]
        if not slot or not slot.tokens or #slot.tokens == 0 then 
            print("ERROR: Slot " .. slotIndex .. " invalid or has no tokens for shield")
            return false 
        end
        
        -- Create shield parameters from the event
        local shieldParams = {
            createShield = true,
            defenseType = event.defenseType or Constants.ShieldType.BARRIER,
            type = event.defenseType or Constants.ShieldType.BARRIER, -- Add type as well for compatibility
            blocksAttackTypes = event.blocksAttackTypes or {Constants.AttackType.PROJECTILE},
            reflect = event.reflect or false,
            onBlock = event.onBlock or nil
        }
        
        -- Debug logging for onBlock
        if event.onBlock then
            Log.debug("[EVENT DEBUG] CREATE_SHIELD event contains onBlock handler")
            Log.debug("[EVENT DEBUG] Type of onBlock: " .. type(event.onBlock))
            
            -- Check if it's actually a function
            if type(event.onBlock) == "function" then
                Log.debug("[EVENT DEBUG] onBlock is a valid function")
            else
                Log.debug("[EVENT DEBUG] WARNING: onBlock is not a function!")
            end
        else
            Log.debug("[EVENT DEBUG] CREATE_SHIELD event has no onBlock handler")
        end
        
        -- Check if the wizard has a createShield method
        if type(wizard.createShield) ~= "function" then
            print("ERROR: Wizard " .. wizard.name .. " does not have createShield method")
            
            -- Default implementation if the method is missing
            print("Using fallback shield creation")
            slot.isShield = true
            slot.defenseType = shieldParams.defenseType
            slot.blocksAttackTypes = shieldParams.blocksAttackTypes
            slot.reflect = shieldParams.reflect
            slot.onBlock = shieldParams.onBlock
            
            -- Mark tokens as shielding
            for _, tokenData in ipairs(slot.tokens) do
                if tokenData.token then
                    tokenData.token:setState(Constants.TokenStatus.SHIELDING)
                    Log.debug("DEBUG: Marked token as SHIELDING to prevent return to pool")
                end
            end
        else
            -- Call the wizard's createShield method
            wizard:createShield(slotIndex, shieldParams)
        end
        
        -- Track shield creation in results
        results.shieldCreated = true
        
        return true
    end,
    
    REFLECT = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then 
             print("ERROR: REFLECT handler could not resolve target wizard")
            return false
        end
        local targetWizard = targetInfo.wizard
        
        -- Set reflect property on the wizard
        targetWizard.reflectActive = true
        targetWizard.reflectDuration = event.duration
        
        -- Create reflect VFX if available
        if caster.gameState and caster.gameState.vfx then
            -- Generate an EFFECT event for consistent handling through VisualResolver
            local effectEvent = {
                type = "EFFECT",
                source = "caster",
                target = event.target,
                effectOverride = Constants.VFXType.REFLECT, -- Use explicit override for now
                -- Provide relevant metadata for the resolver
                affinity = event.affinity, 
                attackType = Constants.AttackType.UTILITY,
                manaCost = event.manaCost or 2,
                tags = { DEFENSE = true, SHIELD = true },
                rangeBand = caster.gameState.rangeState,
                elevation = targetWizard.elevation,
                duration = event.duration or 3.0
            }
            
            -- Process the effect event through the standard pipeline
            EventRunner.handleEvent(effectEvent, caster, target, spellSlot, results)
        end
        
        return true
    end,
    
    -- ===== Special Events =====
    
    ECHO = function(event, caster, target, spellSlot, results)
        local targetInfo = EventRunner.resolveTarget(event, caster, target)
        if not targetInfo or not targetInfo.wizard then return false end
        
        local wizard = targetInfo.wizard
        local slotIndex = targetInfo.slotIndex or spellSlot
        
        -- Schedule an echo of the current spell
        local slot = wizard.spellSlots[slotIndex]
        if slot and slot.spell then
            -- Create an echo entry in the wizard's echo queue
            wizard.echoQueue = wizard.echoQueue or {}
            table.insert(wizard.echoQueue, {
                spell = slot.spell,
                delay = event.delay,
                timer = event.delay
            })
            
            -- Create echo VFX if available
            if caster.gameState and caster.gameState.vfx then
                local params = {
                    delay = event.delay,
                    slotIndex = slotIndex,
                    spellName = slot.spell.name
                }
                
                safeCreateVFX(
                    caster.gameState.vfx,
                    "createEchoEffect",
                    Constants.VFXType.SPELL_ECHO,
                    wizard.x,
                    wizard.y,
                    params
                )
            end
            
            return true
        end
        
        return false
    end,
    
    ZONE_ANCHOR = function(event, caster, target, spellSlot, results)
        local targetEntity = EventRunner.resolveTarget(event, caster, target)
        if not targetEntity then return false end
        
        -- Store zone anchor information on the spell itself 
        -- This will be checked during spell resolution
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] then
            local slot = caster.spellSlots[spellSlot]
            slot.zoneAnchored = true
            slot.anchorRange = event.anchorRange
            slot.anchorElevation = event.anchorElevation
            slot.anchorRequireAll = event.requireAll
            
            return true
        end
        
        return false
    end,
    
    ZONE_MULTI = function(event, caster, target, spellSlot, results)
        local targetEntity = EventRunner.resolveTarget(event, caster, target)
        if not targetEntity then return false end
        
        -- Mark this spell as affecting both ranges
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] then
            local slot = caster.spellSlots[spellSlot]
            slot.affectsBothRanges = true
            
            return true
        end
        
        return false
    end,
    
    -- Add a new EFFECT event handler for pure visual effects
    EFFECT = function(event, caster, target, spellSlot, results)
        Log.debug("[EFFECT EVENT] Processing EFFECT event")
        
        -- Detailed event inspection for debugging
        Log.debug("[EFFECT EVENT] Full event details:")
        Log.debug(string.format("  effectOverride=%s", tostring(event.effectOverride)))
        Log.debug(string.format("  effectType=%s", tostring(event.effectType)))
        Log.debug(string.format("  affinity=%s, attackType=%s, damageType=%s",
            tostring(event.affinity),
            tostring(event.attackType),
            tostring(event.damageType)))
        Log.debug(string.format("  source=%s, target=%s",
            tostring(event.source),
            tostring(event.target)))
            
        -- Check if spell has override
        if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
           caster.spellSlots[spellSlot].spell then
            local spell = caster.spellSlots[spellSlot].spell
            Log.debug(string.format("[EFFECT EVENT] Associated spell: name=%s, effectOverride=%s",
                tostring(spell.name), tostring(spell.effectOverride)))
        end
        
        -- Get source and target coordinates for the effect
        local srcX, srcY, tgtX, tgtY = nil, nil, nil, nil
        
        -- CASE 1: If vfxParams contains direct coordinates, use those
        if event.vfxParams and event.vfxParams.x and event.vfxParams.y then
            srcX = event.vfxParams.x
            srcY = event.vfxParams.y
            tgtX = event.vfxParams.targetX or srcX  -- Use target coords if provided, otherwise same as source
            tgtY = event.vfxParams.targetY or srcY
            Log.debug(string.format("[EFFECT EVENT] Using direct coordinates from vfxParams: (%d, %d) -> (%d, %d)",
                srcX, srcY, tgtX, tgtY))
        
        -- CASE 2: Otherwise resolve based on source/target entities
        else
            -- Source coordinates (caster)
            srcX = caster and caster.x or 0
            srcY = caster and caster.y or 0
            
            -- Target coordinates 
            local targetInfo = EventRunner.resolveTarget(event, caster, target)
            if targetInfo and targetInfo.wizard then 
                local targetWizard = targetInfo.wizard
                tgtX = targetWizard.x
                tgtY = targetWizard.y
                Log.debug(string.format("[EFFECT EVENT] Using wizard coordinates: (%d, %d) -> (%d, %d)",
                    srcX, srcY, tgtX or srcX, tgtY or srcY))
            else
                -- If target resolution fails, use same coordinates as source
                tgtX = srcX
                tgtY = srcY
                Log.debug("[EFFECT EVENT] WARNING: Could not resolve target coordinates, using source as target")
            end
        end
        
        -- Check if this spell slot contains a spell with an effectOverride
        local overrideName = nil
        
        -- Check in priority order for effect name
        if event.effectOverride then
            -- First check the event for an effectOverride (highest priority)
            overrideName = event.effectOverride
            Log.debug("[EFFECT EVENT] Using event effectOverride: " .. tostring(overrideName))
        elseif event.effectType then
            -- Then check if there's an effectType directly in the event (legacy VFX keyword)
            overrideName = event.effectType
            Log.debug("[EFFECT EVENT] Using event effectType: " .. tostring(overrideName))
        elseif spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
               caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.effectOverride then
            -- Finally check the spell slot for effectOverride (set by vfx keyword)
            overrideName = caster.spellSlots[spellSlot].spell.effectOverride
            Log.debug("[EFFECT EVENT] Using spell effectOverride: " .. tostring(overrideName))
        end
        
        -- Create visual effect if VFX system is available
        if caster.gameState and caster.gameState.vfx then
            -- Use the override or let VisualResolver pick based on metadata
            local baseEffectName, vfxOpts
            
            -- Debug before VisualResolver.pick
            Log.debug("[EFFECT EVENT] About to call VisualResolver.pick()")
            Log.debug("[EFFECT EVENT] Override strategy: " .. (overrideName and "Using override: " .. tostring(overrideName) or "Using metadata resolution"))
            
            if overrideName then
                -- Manual override - use it directly but still get options from resolver
                event.effectOverride = overrideName -- Ensure the event has the override
                Log.debug("[EFFECT EVENT] Set event.effectOverride = " .. tostring(overrideName))
                baseEffectName, vfxOpts = VisualResolver.pick(event)
            else
                -- Standard resolver path using event metadata
                baseEffectName, vfxOpts = VisualResolver.pick(event)
            end
            
            -- Debug after VisualResolver.pick
            Log.debug(string.format("[EFFECT EVENT] VisualResolver.pick() returned: effectName=%s, options=%s",
                tostring(baseEffectName),
                vfxOpts and "present" or "nil"))
            
            -- Skip VFX if no valid base effect name
            if not baseEffectName then
                Log.debug("[EFFECT EVENT] Warning: No valid effect name provided by VisualResolver")
                return false
            end
            
            -- Merge additional parameters from event
            if not vfxOpts then vfxOpts = {} end
            
            -- Add source/target names and entities for positional tracking
            if caster and caster.name then
                vfxOpts.source = caster.name
                vfxOpts.sourceEntity = caster
                
                -- If this is from a spell with a visualShape, add it to the options
                if spellSlot and caster.spellSlots and caster.spellSlots[spellSlot] and 
                   caster.spellSlots[spellSlot].spell and caster.spellSlots[spellSlot].spell.visualShape then
                    vfxOpts.visualShape = caster.spellSlots[spellSlot].spell.visualShape
                end
                
                -- Make sure to pass the damage amount for determining shake intensity
                vfxOpts.amount = event.amount or vfxOpts.amount or 10
                
                -- Debug entity references
                Log.debug(string.format("[EFFECT EVENT] Setting sourceEntity = %s", tostring(caster)))
            end
            if target and target.name then
                vfxOpts.target = target.name
                vfxOpts.targetEntity = target
                Log.debug(string.format("[EFFECT EVENT] Setting targetEntity = %s", tostring(target)))
            end
            
            -- For SHIELD_BLOCKED events, make sure we have all needed references
            if event.tags and event.tags.SHIELD_BLOCKED then
                Log.debug("[EFFECT EVENT] This is a SHIELD_BLOCKED event")
                vfxOpts.gameState = caster.gameState
            end
            
            -- Handle shield blocked effects
            if event.tags and event.tags.SHIELD_BLOCKED then
                Log.debug("[EFFECT EVENT] Processing shield blocked effect")
                
                -- Pass blockInfo to VFX system
                if event.blockInfo then
                    vfxOpts.blockInfo = event.blockInfo
                    
                    -- Set blockPoint for visual impact
                    vfxOpts.blockPoint = event.blockPoint or 0.75
                    
                    -- Set shield type
                    if event.blockInfo.blockType then
                        vfxOpts.shieldType = event.blockInfo.blockType
                    end
                    
                    Log.debug("[EFFECT EVENT] Shield block visual at " .. tostring(vfxOpts.blockPoint))
                else
                    -- Create fallback blockInfo if missing but event has SHIELD_BLOCKED tag
                    Log.debug("[EFFECT EVENT] WARNING: SHIELD_BLOCKED tag but no blockInfo, creating default blockInfo")
                    vfxOpts.blockInfo = {
                        blockable = true,
                        blockType = event.shieldType or "ward",
                        blockPoint = event.blockPoint or 0.75
                    }
                    vfxOpts.blockPoint = event.blockPoint or 0.75
                    vfxOpts.shieldType = event.shieldType or "ward"
                    
                    -- Ensure SHIELD_BLOCKED flag is present
                    vfxOpts.tags = vfxOpts.tags or {}
                    vfxOpts.tags.SHIELD_BLOCKED = true
                    
                    Log.debug("[EFFECT EVENT] Created fallback shield block visual at " .. tostring(vfxOpts.blockPoint))
                end
            elseif event.blockInfo then
                -- Legacy handling for other events with blockInfo
                Log.debug("[EFFECT EVENT] Found blockInfo in event, passing to VFX system")
                vfxOpts.blockInfo = event.blockInfo
                
                -- Add standard blockPoint ratio for visual impact
                vfxOpts.blockPoint = event.blockInfo.blockPoint or 0.75
                
                -- Ensure shield type is set
                if event.blockInfo.blockType then
                    vfxOpts.shieldType = event.blockInfo.blockType
                end
                
                -- Ensure SHIELD_BLOCKED tag is set in vfxOpts
                vfxOpts.tags = vfxOpts.tags or {}
                vfxOpts.tags.SHIELD_BLOCKED = true
            end
            
            -- Set default duration if not provided
            if not vfxOpts.duration then
                vfxOpts.duration = event.duration or 0.5
            end
            
            -- Check if we need to add delayed damage to the options
            if event.delayedDamage and event.delayedDamageTarget then
                Log.debug(string.format("[EFFECT EVENT] Adding delayed damage %d to effect options", event.delayedDamage))
                vfxOpts.delayedDamage = event.delayedDamage
                vfxOpts.delayedDamageTarget = event.delayedDamageTarget
                
                -- Provide a callback function to apply the damage when the animation completes
                vfxOpts.onComplete = function(effect)
                    -- Apply the delayed damage
                    local target = vfxOpts.delayedDamageTarget
                    local amount = vfxOpts.delayedDamage
                    
                    if target and amount then
                        target.health = target.health - amount
                        if target.health < 0 then target.health = 0 end
                        
                        -- Set hit flash timer for delayed damage visual feedback
                        target.hitFlashTimer = 0.125 -- 125ms flash duration
                        
                        -- Apply screen shake and hitstop for delayed damage too
                        if amount >= 15 or (event.tags and event.tags.HIGH_IMPACT) then
                            -- Strong hit
                            if target.gameState and target.gameState.triggerShake then
                                local intensity = math.min(10, 5 + (amount / 10))
                                target.gameState.triggerShake(0.35, intensity)
                                target.gameState.triggerHitstop(0.12)
                                Log.debug(string.format("[DELAYED DAMAGE] High impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                                    0.35, intensity, 0.12))
                            end
                        elseif amount >= 8 then
                            -- Medium hit
                            if target.gameState and target.gameState.triggerShake then
                                target.gameState.triggerShake(0.25, 6)
                                target.gameState.triggerHitstop(0.08)
                                Log.debug(string.format("[DELAYED DAMAGE] Medium impact hit! Triggering shake (%.2f, %.2f) and hitstop (%.2f)",
                                    0.25, 6, 0.08))
                            end
                        elseif amount >= 3 then
                            -- Light hit
                            if target.gameState and target.gameState.triggerShake then
                                target.gameState.triggerShake(0.15, 4)
                                Log.debug(string.format("[DELAYED DAMAGE] Light impact hit! Triggering shake (%.2f, %.2f)",
                                    0.15, 4))
                            end
                        end
                        
                        Log.debug(string.format("[DELAYED DAMAGE] Applied %d damage to %s. New health: %d",
                            amount, target.name, target.health))
                    end
                end
            end
            
            -- Extra debug info
            Log.debug(string.format("[EFFECT EVENT] Creating effect: '%s' at coords: (%d, %d) -> (%d, %d)",
                tostring(baseEffectName), srcX or 0, srcY or 0, tgtX or srcX, tgtY or srcY))
                
            -- Call VFX.createEffect directly instead of using safeCreateVFX
            -- This pattern matches how we want VFX module to be called in the future
            -- with directional information (source -> target)
            local vfxModule = caster.gameState.vfx
            if vfxModule and vfxModule.createEffect then
                local success, err = pcall(function()
                    vfxModule.createEffect(baseEffectName, srcX, srcY, tgtX, tgtY, vfxOpts)
                end)
                
                if not success then
                    print("ERROR: Failed to create effect: " .. tostring(err))
                    return false
                end
            else
                Log.debug("[EFFECT EVENT] ERROR: VFX.createEffect not available")
                return false
            end
        else
            Log.debug("[EFFECT EVENT] ERROR: VFX system not available")
            return false
        end
        
        return true
    end
}

-- Debug function to print all events
function EventRunner.debugPrintEvents(events)
    Log.debug("===== DEBUG: Event List =====")
    for i, event in ipairs(events) do
        Log.debug(string.format("[%d] %s - Source: %s, Target: %s",
            i, event.type, event.source, event.target))
        
        -- Print additional event-specific fields
        for k, v in pairs(event) do
            if k ~= "type" and k ~= "source" and k ~= "target" then
                Log.debug(string.format("  %s: %s", k, tostring(v)))
            end
        end
    end
    Log.debug("=============================")
end

return EventRunner```

## ./systems/ManaHelpers.lua
```lua
-- systems/ManaHelpers.lua
-- Provides utility functions for working with tokens in the mana pool

local ManaHelpers = {}

-- Count tokens of a specific type in the mana pool
function ManaHelpers.count(tokenType, manaPool)
    local count = 0
    
    -- If the manaPool isn't provided directly, try to find it from the game state
    if not manaPool then return 0 end
    
    local Constants = require("core.Constants")
    
    for _, token in ipairs(manaPool.tokens or {}) do
        if token.type == tokenType and token.state == Constants.TokenState.FREE then
            count = count + 1
        end
    end
    
    return count
end

-- Get the most abundant token type from options
function ManaHelpers.most(tokenTypes, manaPool)
    local maxCount = -1
    local maxType = nil
    
    for _, tokenType in ipairs(tokenTypes) do
        local count = ManaHelpers.count(tokenType, manaPool)
        if count > maxCount then
            maxCount = count
            maxType = tokenType
        end
    end
    
    return maxType
end

-- Get the least abundant token type from options
function ManaHelpers.least(tokenTypes, manaPool)
    local minCount = math.huge
    local minType = nil
    
    for _, tokenType in ipairs(tokenTypes) do
        local count = ManaHelpers.count(tokenType, manaPool)
        if count < minCount and count > 0 then
            minCount = count
            minType = tokenType
        end
    end
    
    -- If no token was found with count > 0, return first type as fallback
    return minType or tokenTypes[1]
end

-- Find whether a specific token type exists in the pool
function ManaHelpers.exists(tokenType, manaPool)
    return ManaHelpers.count(tokenType, manaPool) > 0
end

-- Get a random token type from the mana pool
function ManaHelpers.random(manaPool)
    if not manaPool or not manaPool.tokens or #manaPool.tokens == 0 then 
        return nil
    end
    
    -- Get a list of free token types that are available
    local availableTypes = {}
    local typesPresent = {}
    
    local Constants = require("core.Constants")
    
    for _, token in ipairs(manaPool.tokens) do
        if token.state == Constants.TokenState.FREE and not typesPresent[token.type] then
            table.insert(availableTypes, token.type)
            typesPresent[token.type] = true
        end
    end
    
    -- Return a random token type from available types
    if #availableTypes > 0 then
        return availableTypes[math.random(#availableTypes)]
    end
    
    return nil
end

return ManaHelpers```

## ./systems/ShieldSystem.lua
```lua
-- ShieldSystem.lua
-- Centralized shield management system for Manastorm

local Constants = require("core.Constants")
local ShieldSystem = {}

-- Get appropriate shield color based on defense type
function ShieldSystem.getShieldColor(defenseType)
    local shieldColor = {0.8, 0.8, 0.8}  -- Default gray
    
    if defenseType == Constants.ShieldType.BARRIER then
        shieldColor = {1.0, 1.0, 0.3}    -- Yellow for barriers
    elseif defenseType == Constants.ShieldType.WARD then
        shieldColor = {0.3, 0.3, 1.0}    -- Blue for wards
    elseif defenseType == Constants.ShieldType.FIELD then
        shieldColor = {0.3, 1.0, 0.3}    -- Green for fields
    end
    
    return shieldColor
end

-- Create a shield in the specified slot
function ShieldSystem.createShield(wizard, spellSlot, blockParams)
    -- Check that the slot is valid
    if not wizard.spellSlots[spellSlot] then
        print("[SHIELD ERROR] Invalid spell slot for shield creation: " .. tostring(spellSlot))
        return { shieldCreated = false }
    end
    
    local slot = wizard.spellSlots[spellSlot]
    
    -- DEFENSIVE CHECK: Don't create shield if slot already has one
    if slot.isShield then
        print("[SHIELD ERROR] Slot " .. spellSlot .. " already has a shield! Preventing duplicate creation.")
        return { shieldCreated = false, reason = "duplicate" }
    end
    
    -- Set shield parameters - simplified to use token count as the only source of truth
    slot.isShield = true
    
    -- Look for shield type in both parameters for compatibility
    slot.defenseType = blockParams.defenseType or blockParams.type or Constants.ShieldType.BARRIER
    
    -- Store the original spell completion
    slot.active = true
    slot.progress = slot.castTime -- Mark as fully cast
    
    -- Store the onBlock handler if provided
    slot.onBlock = blockParams.onBlock
    
    -- Debug log for onBlock handler
    if blockParams.onBlock then
        print("[SHIELD DEBUG] Shield creation: onBlock handler saved to slot")
    else
        print("[SHIELD DEBUG] Shield creation: No onBlock handler provided")
    end
    
    -- Remove duplicate onBlock assignment from line 67
    
    -- Set which attack types this shield blocks
    slot.blocksAttackTypes = {}
    -- Support both `blocks` and `blocksAttackTypes` for compatibility
    local blockTypes = blockParams.blocks or blockParams.blocksAttackTypes or {Constants.AttackType.PROJECTILE}
    for _, attackType in ipairs(blockTypes) do
        slot.blocksAttackTypes[attackType] = true
    end
    
    -- Also store as array for compatibility
    slot.blockTypes = blockTypes
    
    -- ALL shields are mana-linked (consume tokens when hit) - simplified model
    
    -- Set reflection capability
    slot.reflect = blockParams.reflect or false
    
    -- Note: onBlock is already set above (line 48)
    
    -- Get TokenManager module
    local TokenManager = require("systems.TokenManager")
    
    -- Mark tokens as shielding using TokenManager
    TokenManager.markTokensAsShielding(slot.tokens)
    
    -- Add additional shield-specific properties to tokens
    for _, tokenData in ipairs(slot.tokens) do
        local token = tokenData.token
        if token then
            -- Add specific shield type info to the token for visual effects
            token.shieldType = slot.defenseType
            -- Slow down the rotation speed for shield tokens
            if token.orbitSpeed then
                token.orbitSpeed = token.orbitSpeed * 0.5  -- 50% slower
            end
        end
    end
    
    -- Get shield color based on type
    local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
    
    -- Create shield effect using event system
    if wizard.gameState and wizard.gameState.eventRunner then
        local shieldEvent = {
            type = "EFFECT",
            source = "shield",
            target = Constants.TargetType.SELF,
            effectType = Constants.VFXType.SHIELD,
            duration = 1.0,
            vfxParams = {
                x = wizard.x,
                y = wizard.y,
                color = {shieldColor[1], shieldColor[2], shieldColor[3], 0.7},
                shieldType = slot.defenseType
            }
        }
        
        -- Process the event immediately
        wizard.gameState.eventRunner.processEvents({shieldEvent}, wizard, nil)
    end
    
    -- Print debug info - simplified to only show token count
    print(string.format("[SHIELD] %s created a %s shield in slot %d with %d tokens",
        wizard.name or "Unknown wizard",
        slot.defenseType,
        spellSlot,
        #slot.tokens))
    
    -- Return result for further processing - simplified for token-based shields only
    return {
        shieldCreated = true,
        defenseType = slot.defenseType,
        blockTypes = blockParams.blocks
    }
end

-- Check if a spell can be blocked by a shield
function ShieldSystem.checkShieldBlock(spell, attackType, defender, attacker)
    -- Default response - not blockable
    local result = {
        blockable = false,
        blockType = nil,
        blockingShield = nil,
        blockingSlot = nil,
        manaLinked = nil,
        processBlockEffect = false
    }
    
    -- Early exit cases
    if not defender or not spell or not attackType then
        print("[SHIELD DEBUG] checkShieldBlock early exit - missing parameter")
        return result
    end
    
    -- Utility spells can't be blocked
    if attackType == Constants.AttackType.UTILITY then
        print("[SHIELD DEBUG] checkShieldBlock early exit - utility spell can't be blocked")
        return result
    end
    
    print("[SHIELD DEBUG] Checking if " .. attackType .. " spell can be blocked by " .. defender.name .. "'s shields")
    
    -- Check each of the defender's spell slots for active shields
    for i, slot in ipairs(defender.spellSlots) do
        -- Skip inactive slots or non-shield slots
        if not slot.active or not slot.isShield then
            goto continue
        end
        
        -- Check if this shield has tokens remaining (token count is the source of truth for shield strength)
        if #slot.tokens <= 0 then
            goto continue
        end
        
        -- Verify this shield can block this attack type
        local canBlock = false
        
        -- Check blocksAttackTypes or blockTypes properties
        if slot.blocksAttackTypes and slot.blocksAttackTypes[attackType] then
            canBlock = true
        elseif slot.blockTypes then
            -- Iterate through blockTypes array to find a match
            for _, blockType in ipairs(slot.blockTypes) do
                if blockType == attackType then
                    canBlock = true
                    break
                end
            end
        end
        
        -- If we found a shield that can block this attack
        if canBlock then
            result.blockable = true
            result.blockType = slot.defenseType
            result.blockingShield = slot
            result.blockingSlot = i
            -- All shields are mana-linked by default
            result.manaLinked = true
            
            -- Handle mana consumption for the block
            if #slot.tokens > 0 then
                result.processBlockEffect = true
                
                -- Get amount of hits based on the spell's shield breaker power (if any)
                local shieldBreakPower = spell.shieldBreaker or 1
                
                -- Determine how many tokens to consume (up to shield breaker power or tokens available)
                local tokensToConsume = math.min(shieldBreakPower, #slot.tokens)
                result.tokensToConsume = tokensToConsume
                
                -- No need to track shield strength separately anymore
                -- Token consumption is handled by removing tokens directly
                
                -- Check if this will destroy the shield (when all tokens are consumed)
                if tokensToConsume >= #slot.tokens then
                    result.destroyShield = true
                end
            end
            
            -- Return after finding the first blocking shield
            return result
        end
        
        ::continue::
    end
    
    -- If we get here, no shield can block this spell
    return result
end

-- Handle the effects of a spell being blocked by a shield
function ShieldSystem.handleShieldBlock(wizard, slotIndex, incomingSpell)
    local slot = wizard.spellSlots[slotIndex]
    if not slot or not slot.active then
        print(string.format("WARNING: handleShieldBlock called on invalid or inactive slot %d for %s", slotIndex, wizard.name))
        return false
    end
    
    -- Additional safety check for shield status
    if not slot.isShield then
        print(string.format("WARNING: handleShieldBlock called on non-shield slot %d for %s", slotIndex, wizard.name))
        return false
    end

    -- Safety check for incomingSpell
    if not incomingSpell then
        print("WARNING: handleShieldBlock called with nil incomingSpell")
        return false
    end

    -- Get defense type with safety check
    local defenseType = slot.defenseType or Constants.ShieldType.BARRIER -- Default to barrier if unknown

    -- Determine how many tokens to remove based on incoming spell's shieldBreaker property
    local shieldBreakPower = (incomingSpell and incomingSpell.shieldBreaker) or 1
    local tokensToConsume = math.min(shieldBreakPower, #slot.tokens)

    -- Get spell name with safety check
    local spellName = incomingSpell.name or "unknown spell"

    print(string.format("[SHIELD BLOCK] %s's %s shield (slot %d) hit by %s (%d break power). Consuming %d token(s).", 
        wizard.name, defenseType, slotIndex, spellName, shieldBreakPower, tokensToConsume))

    -- Consume the tokens
    for i = 1, tokensToConsume do
        -- misnomer since default bahvior changed
        -- TODO: restore logic to actually "consume" tokens if shield has some keyword
        if #slot.tokens > 0 then
            -- Remove token data from the end (doesn't matter which one for shields)
            local removedTokenData = table.remove(slot.tokens)
            local removedTokenObject = removedTokenData and removedTokenData.token
            
            -- Safety check for removed token object
            if removedTokenObject and removedTokenObject.type then
                print(string.format("[TOKEN LIFECYCLE] Shield Token (%s) freed by block -> FREE", 
                    tostring(removedTokenObject.type)))
            else
                print("[TOKEN LIFECYCLE] Shield Token (unknown type) freed by block -> FREE")
            end
                
            -- Mark the consumed token for freeing using TokenManager
            if removedTokenObject then
                -- Get TokenManager
                local TokenManager = require("systems.TokenManager")
                
                -- Create a token array for TokenManager to handle
                local tokenToFree = {
                    {token = removedTokenObject, index = 1}
                }
                
                -- Use TokenManager to free the token
                TokenManager.returnTokensToPool(tokenToFree)
                
                -- Call the wizard's centralized check *after* removing the token
                wizard:checkFizzleOnTokenRemoval(slotIndex, removedTokenObject)
            else
                print("WARNING: Shield block consumed a token reference that had no token object.")
                -- Still need to check fizzle even if token object missing
                wizard:checkFizzleOnTokenRemoval(slotIndex, nil)
            end
        else
            -- Should not happen if tokensToConsume calculation is correct, but break just in case
            print("WARNING: Tried to consume more tokens than available in shield slot.")
            break 
        end
    end
    
    -- Emit shield hit event for visual feedback through VisualResolver
    if wizard.gameState and wizard.gameState.eventRunner then
        local Constants = require("core.Constants")
        local shieldHitEvent = {
            type = "EFFECT",
            source = Constants.TargetType.TARGET,  -- defender is both source & target visually
            target = Constants.TargetType.TARGET,
            effectType = "shield_hit", -- logical tag for VisualResolver
            affinity = defenseType, -- Use defense type as affinity for color mapping
            tags = { SHIELD_HIT = true },
            shieldType = defenseType,
            vfxParams = {
                x = wizard.x,
                y = wizard.y,
            },
            rangeBand = wizard.rangeBand,
            elevation = wizard.elevation,
        }
        
        -- Process the event immediately
        wizard.gameState.eventRunner.processEvents({shieldHitEvent}, wizard, nil)
    end
    
    -- Add support for on-block effects
    -- Add safety check for slot.defenseType
    local defenseType = slot.defenseType or Constants.ShieldType.BARRIER -- Default to barrier if unknown
    print("[SHIELD DEBUG] Checking onBlock handler for " .. wizard.name .. "'s " .. defenseType .. " shield")
    
    if slot.onBlock then
        print("[SHIELD DEBUG] onBlock handler found, executing")
        -- Avoid importing EventRunner directly to prevent circular dependency
        local ok, blockEvents = pcall(slot.onBlock,
                                      wizard,          -- defender (owner of the shield)
                                      incomingSpell and incomingSpell.caster, -- attacker (may be nil)
                                      slotIndex,
                                      { blockType = defenseType })
        if ok and type(blockEvents) == "table" and #blockEvents > 0 then
            print("[SHIELD DEBUG] onBlock returned " .. #blockEvents .. " events, processing")
            -- Lazy load EventRunner only when needed
            local EventRunner = require("systems.EventRunner")
            EventRunner.processEvents(blockEvents, wizard, incomingSpell and incomingSpell.caster, slotIndex)
        elseif not ok then
            print("[SHIELD ERROR] Error executing onBlock handler: " .. tostring(blockEvents))
        else
            print("[SHIELD DEBUG] onBlock successful but no events returned or invalid events format")
            print("[SHIELD DEBUG] Return value: " .. type(blockEvents))
            if type(blockEvents) == "table" then
                print("[SHIELD DEBUG] Table length: " .. #blockEvents)
            end
        end
    else
        print("[SHIELD DEBUG] No onBlock handler found for this shield")
    end
    
    -- The checkFizzleOnTokenRemoval method handles the actual shield breaking (slot reset)
    
    return true
end

-- Update shield visuals and animations
function ShieldSystem.updateShieldVisuals(wizard, dt)
    -- This function will be expanded to handle shield pulse effects
    -- Currently a placeholder for future shield visual updates
    
    -- For each spell slot that contains a shield
    for i, slot in ipairs(wizard.spellSlots) do
        if slot.active and slot.isShield then
            -- Here we could add shield-specific visual updates
            -- Such as pulsing effects, particle emissions, etc.
        end
    end
end

-- Create block VFX for spell being blocked by a shield
-- DEPRECATED: This function is no longer needed as the block effects are now handled
-- directly in the EFFECT event processing with blockInfo. It's kept for backward
-- compatibility but will be removed in a future version.
function ShieldSystem.createBlockVFX(caster, target, blockInfo, spellInfo)
    print("[SHIELD SYSTEM] WARNING: ShieldSystem.createBlockVFX is deprecated")
    print("[SHIELD SYSTEM] Shield block visuals are now handled by the VFX system")
    
    -- No-op function, kept for backward compatibility
    return 
end

return ShieldSystem```

## ./systems/SustainedSpellManager.lua
```lua
-- SustainedSpellManager.lua
-- Centralized management system for sustained spells (shields, traps, etc.)

local Constants = require("core.Constants")
local Log = require("core.Log")
local SustainedSpellManager = {}

-- Track all active sustained spells
-- Each entry contains: {
--   id = unique identifier,
--   wizard = reference to wizard who cast the spell,
--   slotIndex = index of the spell slot,
--   spell = reference to the spell,
--   triggerData = trigger conditions (for traps),
--   effectData = effect to apply when triggered (for traps),
--   type = "shield" or "trap" or "generic"
-- }
SustainedSpellManager.activeSpells = {}

-- Generate a unique ID for a sustained spell
local function generateUniqueId(wizard, slotIndex)
    return wizard.name .. "_" .. slotIndex .. "_" .. os.time() .. "_" .. math.random(1000)
end

-- Apply field status effect to both wizards
local function applyFieldStatus(entry)
    if not entry or not entry.fieldStatus then return end

    local gameState = entry.wizard and entry.wizard.gameState
    if not gameState or not gameState.wizards then return end

    for _, wiz in ipairs(gameState.wizards) do
        wiz.statusEffects = wiz.statusEffects or {}
        wiz.statusEffects[entry.fieldStatus.statusType] = wiz.statusEffects[entry.fieldStatus.statusType] or {}
        local effect = wiz.statusEffects[entry.fieldStatus.statusType]
        effect.active = true
        effect.duration = 0
        effect.tickDamage = entry.fieldStatus.tickDamage
        effect.tickInterval = entry.fieldStatus.tickInterval
        effect.magnitude = entry.fieldStatus.magnitude
        effect.elapsed = 0
        effect.totalTime = 0
    end
end

-- Remove field status effect from both wizards
local function removeFieldStatus(entry)
    if not entry or not entry.fieldStatus then return end

    local gameState = entry.wizard and entry.wizard.gameState
    if not gameState or not gameState.wizards then return end

    for _, wiz in ipairs(gameState.wizards) do
        if wiz.statusEffects and wiz.statusEffects[entry.fieldStatus.statusType] then
            wiz.statusEffects[entry.fieldStatus.statusType].active = false
            wiz.statusEffects[entry.fieldStatus.statusType].duration = 0
            wiz.statusEffects[entry.fieldStatus.statusType].elapsed = 0
            wiz.statusEffects[entry.fieldStatus.statusType].totalTime = 0
        end
    end
end

-- Add a sustained spell to the manager
function SustainedSpellManager.addSustainedSpell(wizard, slotIndex, spellData)
    if not wizard or not slotIndex or not spellData then
        print("[SustainedManager] Error: Missing required parameters")
        return nil
    end
    
    Log.debug("[DEBUG] SustainedSpellManager.addSustainedSpell: Spell data:")
    Log.debug("[DEBUG]   isSustained: " .. tostring(spellData.isSustained))
    Log.debug("[DEBUG]   trapTrigger exists: " .. tostring(spellData.trapTrigger ~= nil))
    Log.debug("[DEBUG]   trapWindow exists: " .. tostring(spellData.trapWindow ~= nil))
    Log.debug("[DEBUG]   trapEffect exists: " .. tostring(spellData.trapEffect ~= nil))
    Log.debug("[DEBUG]   fieldStatus exists: " .. tostring(spellData.fieldStatus ~= nil))
    
    -- Generate a unique ID for this sustained spell
    local uniqueId = generateUniqueId(wizard, slotIndex)
    
    -- Determine the type of sustained spell
    local spellType = Constants.DamageType.GENERIC
    if spellData.isShield then
        spellType = "shield"
    elseif spellData.trapTrigger then
        spellType = "trap"
    elseif spellData.fieldStatus then
        spellType = "field"
    end

    -- If a field already exists, remove it before adding the new one
    if spellType == "field" then
        for id, existing in pairs(SustainedSpellManager.activeSpells) do
            if existing.type == "field" then
                existing.wizard:resetSpellSlot(existing.slotIndex)
                break
            end
        end
    end
    
    -- Create the entry
    local entry = {
        id = uniqueId,
        wizard = wizard,
        slotIndex = slotIndex,
        spell = wizard.spellSlots[slotIndex].spell,
        type = spellType,
        creationTime = os.time()
    }
    
    -- Add trap-specific data if present
    if spellType == "trap" then
        entry.triggerData = spellData.trapTrigger or {}
        entry.effectData = spellData.trapEffect or {}
    end
    
    -- Add shield-specific data if present
    if spellType == "shield" then
        entry.shieldParams = spellData.shieldParams or {}
    end

    -- Add field-specific data if present
    if spellType == "field" then
        entry.fieldStatus = spellData.fieldStatus or {}
    end
    
    -- Store the entry in the activeSpells table
    SustainedSpellManager.activeSpells[uniqueId] = entry

    -- Apply field status immediately
    if spellType == "field" then
        applyFieldStatus(entry)
    end

    -- Log the addition
    print(string.format("[SustainedManager] Added %s '%s' for %s in slot %d",
        spellType, entry.spell.name or "unnamed spell", wizard.name, slotIndex))
    
    return uniqueId
end

-- Remove a sustained spell from the manager
function SustainedSpellManager.removeSustainedSpell(id)
    local entry = SustainedSpellManager.activeSpells[id]
    if not entry then
        print("[SustainedManager] Warning: Tried to remove non-existent sustained spell: " .. id)
        return false
    end
    
    -- Log removal
    print(string.format("[SustainedManager] Removed %s '%s' for %s in slot %d",
        entry.type, entry.spell.name or "unnamed spell", entry.wizard.name, entry.slotIndex))

    if entry.type == "field" then
        removeFieldStatus(entry)
    end

    -- Remove from the active spells table
    SustainedSpellManager.activeSpells[id] = nil
    
    return true
end

-- Update all active sustained spells
function SustainedSpellManager.update(dt)
    -- Count active spells by type
    local shieldCount = 0
    local trapCount = 0
    local fieldCount = 0
    local genericCount = 0
    
    -- Spells to remove after iteration
    local spellsToRemove = {}
    
    -- Update each active spell
    for id, entry in pairs(SustainedSpellManager.activeSpells) do
        -- Debug: check what types of sustained spells we have
        if math.floor(os.time()) % 10 == 0 then -- Only log every 10 seconds to avoid spam
            Log.debug(string.format("[DEBUG] Sustained spell: id=%s, type=%s, spell=%s",
                id, entry.type, entry.spell and entry.spell.name or "unknown"))
        end
        
        -- Count by type
        if entry.type == "shield" then
            shieldCount = shieldCount + 1
        elseif entry.type == "trap" then
            trapCount = trapCount + 1
        elseif entry.type == "field" then
            fieldCount = fieldCount + 1
        else
            genericCount = genericCount + 1
        end
        
        
        -- Process trap trigger conditions if this is a trap
        if entry.type == "trap" and entry.triggerData and not entry.triggered then
            local casterWizard = entry.wizard
            local targetWizard = nil
            
            -- Find target wizard (the other wizard)
            if casterWizard and casterWizard.gameState and casterWizard.gameState.wizards then
                for _, wizard in ipairs(casterWizard.gameState.wizards) do
                    if wizard ~= casterWizard then
                        targetWizard = wizard
                        break
                    end
                end
            end
            
            -- Evaluate trigger conditions
            if targetWizard and entry.triggerData.condition then
                local condition = entry.triggerData.condition
                local conditionMet = false
                
                -- Check elevation trigger condition
                if condition == "on_opponent_elevate" and targetWizard.elevation == Constants.ElevationState.AERIAL then
                    -- Enhancement idea: Track state changes rather than continuous state
                    -- For now, trigger continuously while the opponent is elevated
                    conditionMet = true
                    print(string.format("[SustainedManager] Trap triggered by opponent elevation: %s", targetWizard.elevation))
                end

                if condition == "on_opponent_far" and targetWizard.rangeState == Constants.RangeState.FAR then
                    conditionMet = true
                    print(string.format("[SustainedManager] Trap triggered by opponent being far"))
                end
                
                -- Check cast trigger condition
                if condition == "on_opponent_cast" and targetWizard.justCastSpellThisFrame then
                    conditionMet = true
                    print(string.format("[SustainedManager] Trap triggered by opponent casting spell"))
                end
                
                -- Check other trigger conditions as needed...
                -- Add more conditions here as the trap system expands
                
                -- If any condition is met, mark the trap as triggered
                if conditionMet then
                    entry.triggered = true
                    print(string.format("[SustainedManager] Trap triggered for %s slot %d", 
                        casterWizard.name, entry.slotIndex))
                end
            end
        end
        
        -- Process triggered traps
        if entry.type == "trap" and entry.triggered and not entry.processed then
            -- Mark as processed to avoid duplicate execution
            entry.processed = true
            
            local casterWizard = entry.wizard
            local targetWizard = nil
            
            -- Find target wizard (the other wizard)
            if casterWizard and casterWizard.gameState and casterWizard.gameState.wizards then
                for _, wizard in ipairs(casterWizard.gameState.wizards) do
                    if wizard ~= casterWizard then
                        targetWizard = wizard
                        break
                    end
                end
            end
            
            -- Execute trap effect via EventRunner
            if casterWizard and targetWizard and entry.effectData then
                print(string.format("[SustainedManager] Executing trap effect for %s slot %d", 
                    casterWizard.name, entry.slotIndex))
                
                -- Get Keywords module to execute the effect keywords
                local Keywords = nil
                if casterWizard.gameState and casterWizard.gameState.keywords then
                    Keywords = casterWizard.gameState.keywords
                else
                    print("[SustainedManager] ERROR: Cannot access Keywords module")
                    table.insert(spellsToRemove, id)
                    goto continue
                end
                
                -- Create events list to collect events from each keyword
                local events = {}
                
                -- Iterate through each keyword in the trap effect
                for keyword, params in pairs(entry.effectData) do
                    if Keywords[keyword] and type(Keywords[keyword].execute) == "function" then
                        local results = {}
                        
                        -- Call the keyword's execute function to generate events
                        -- Note: Different keywords expect different parameters, we pass consistent ones
                        -- and let each keyword pick what it needs
                        local updated_results = Keywords[keyword].execute(
                            params,          -- Parameters for the keyword
                            casterWizard,    -- Caster
                            targetWizard,    -- Target
                            results,         -- Results table (legacy)
                            events           -- Events list to populate
                        )
                        
                        -- Merge results for backward compatibility
                        if updated_results then
                            for k, v in pairs(updated_results) do
                                results[k] = v
                            end
                        end
                    else
                        print(string.format("[SustainedManager] WARNING: Keyword '%s' not found or not executable", 
                            tostring(keyword)))
                    end
                end
                
                -- Process generated events with EventRunner
                if #events > 0 then
                    -- Process events - Use pcall for safety
                    local result = { eventsProcessed = 0 }
                    local ok, err = pcall(function()
                        -- Get EventRunner at last possible moment
                        local EventRunner = require("systems.EventRunner")
                        result = EventRunner.processEvents(
                            events,         -- Events to process
                            casterWizard,   -- Caster
                            targetWizard,   -- Target
                            nil             -- No specific spell slot for effect execution
                        )
                    end)
                    
                    if not ok then
                        print("[SustainedManager] ERROR: Failed to process events: " .. tostring(err))
                    end
                    
                    print(string.format("[SustainedManager] Processed %d trap events", 
                        result and result.eventsProcessed or 0))
                else
                    print("[SustainedManager] WARNING: No events generated from trap effect")
                end
                
                -- Clean up the trap after execution
                local TokenManager = require("systems.TokenManager")
                
                -- Get the spell slot
                local slot = entry.wizard.spellSlots[entry.slotIndex]
                if slot then
                    -- Return tokens to the mana pool
                    if #slot.tokens > 0 then
                        TokenManager.returnTokensToPool(slot.tokens)
                        print(string.format("[SustainedManager] Returning %d tokens from triggered trap", 
                            #slot.tokens))
                    end
                    
                    -- Reset the spell slot
                    entry.wizard:resetSpellSlot(entry.slotIndex)
                end
                
                -- Mark for removal from manager
                table.insert(spellsToRemove, id)
            else
                print("[SustainedManager] ERROR: Missing wizard or effect data for trap execution")
                table.insert(spellsToRemove, id)
            end
        end

        ::continue::
    end
    
    -- Remove triggered spells after iteration
    for _, id in ipairs(spellsToRemove) do
        local entry = SustainedSpellManager.activeSpells[id]
        if entry then
            -- Remove the spell from the manager
            SustainedSpellManager.removeSustainedSpell(id)
        end
    end
    
    -- Log active spell counts (reduced frequency to avoid console spam)
    if math.floor(os.time()) % 5 == 0 then  -- Log every 5 seconds
        -- If we have at least one spell, log more details
        if shieldCount + trapCount + fieldCount + genericCount > 0 then
            for id, entry in pairs(SustainedSpellManager.activeSpells) do
                local wizardName = entry.wizard and entry.wizard.name or "unknown"
                local spellName = entry.spell and entry.spell.name or "unknown spell"
                print(string.format("  - %s: %s's %s in slot %d (id: %s)",
                    entry.type, wizardName, spellName, entry.slotIndex, id))
            end
        end
    end
end

return SustainedSpellManager```

## ./systems/TokenManager.lua
```lua
-- TokenManager.lua
-- Centralized management of token acquisition, positioning, and state transitions

local Constants = require("core.Constants")

local TokenManager = {}

-- Acquires tokens for a spell based on its mana cost
-- Returns success (boolean) and tokenData (list of tokens with positioning info)
function TokenManager.acquireTokensForSpell(wizard, slotIndex, manaCost)
    if not wizard or not wizard.manaPool then
        print("[TOKEN MANAGER] Error: Invalid wizard or missing manaPool reference")
        return false, {}
    end
    
    if not manaCost or type(manaCost) ~= "table" then
        print("[TOKEN MANAGER] Error: Invalid mana cost")
        return false, {}
    end
    
    -- Handle empty cost (free spells)
    if next(manaCost) == nil or #manaCost == 0 then
        print("[TOKEN MANAGER] Free spell (no mana cost)")
        return true, {} -- Success with no tokens
    end
    
    local manaPool = wizard.manaPool
    local requiredTokens = {}
    
    -- Check if mana cost is in array format (numbered indices) or key-value format
    local isArrayFormat = #manaCost > 0 or manaCost[1] ~= nil
    
    -- Handle array-style format (legacy format)
    if isArrayFormat then
        print("[TOKEN MANAGER] Processing array-style mana cost with " .. #manaCost .. " components")
        
        -- Process each component in the array
        for i, component in ipairs(manaCost) do
            if type(component) == "table" and component.type and component.amount then
                -- Handle {type="fire", amount=2} format
                local tokenType = component.type
                local count = component.amount
                
                for j = 1, count do
                    local token, tokenIndex = manaPool:findFreeToken(tokenType)
                    if token then
                        table.insert(requiredTokens, {
                            type = tokenType,
                            token = token,
                            index = tokenIndex
                        })
                    else
                        print("[TOKEN MANAGER] Error: Could not find free token of type " .. tokenType)
                        return false, {}
                    end
                end
            elseif type(component) == "string" then
                -- Handle "fire" format (single token) or "any" special case
                local tokenType = component
                
                if tokenType == Constants.TokenType.ANY then
                    -- Special case for "any" - try to find any token type
                    local foundAny = false
                    
                    -- Get all available token types
                    local availableTypes = Constants.getAllTokenTypes()
                    -- Shuffle the types to randomize selection
                    for i = #availableTypes, 2, -1 do
                        local j = math.random(i)
                        availableTypes[i], availableTypes[j] = availableTypes[j], availableTypes[i]
                    end
                    
                    -- Try each token type in random order
                    for _, availableType in ipairs(availableTypes) do
                        local token, tokenIndex = manaPool:findFreeToken(availableType)
                        if token then
                            table.insert(requiredTokens, {
                                type = availableType,
                                token = token,
                                index = tokenIndex
                            })
                            foundAny = true
                            break
                        end
                    end
                    
                    if not foundAny then
                        print("[TOKEN MANAGER] Error: Could not find any free token for '" .. Constants.TokenType.ANY .. "' cost")
                        return false, {}
                    end
                else
                    -- Normal token type
                    local token, tokenIndex = manaPool:findFreeToken(tokenType)
                    
                    if token then
                        table.insert(requiredTokens, {
                            type = tokenType,
                            token = token,
                            index = tokenIndex
                        })
                    else
                        print("[TOKEN MANAGER] Error: Could not find free token of type " .. tokenType)
                        return false, {}
                    end
                end
            elseif type(component) == "number" then
                -- Handle numeric value (random tokens)
                local count = component
                for j = 1, count do
                    local foundRandom = false
                    
                    -- Get all available token types
                    local availableTypes = Constants.getAllTokenTypes()
                    -- Shuffle the types to randomize selection
                    for i = #availableTypes, 2, -1 do
                        local j = math.random(i)
                        availableTypes[i], availableTypes[j] = availableTypes[j], availableTypes[i]
                    end
                    
                    -- Try each token type in random order
                    for _, tokenType in ipairs(availableTypes) do
                        local token, tokenIndex = manaPool:findFreeToken(tokenType)
                        if token then
                            table.insert(requiredTokens, {
                                type = tokenType,
                                token = token,
                                index = tokenIndex
                            })
                            foundRandom = true
                            break
                        end
                    end
                    
                    if not foundRandom then
                        print("[TOKEN MANAGER] Error: Could not find any free token for random cost")
                        return false, {}
                    end
                end
            else
                print("[TOKEN MANAGER] Warning: Unknown cost component type: " .. type(component))
            end
        end
    else
        -- Handle key-value format (new standardized format)
        print("[TOKEN MANAGER] Processing key-value style mana cost")
        
        -- Check if a specific mana cost can be paid from available tokens
        for tokenType, count in pairs(manaCost) do
            -- Skip special metadata fields like description or zone
            if tokenType ~= Constants.SpellMetadata.DESCRIPTION and tokenType ~= Constants.SpellMetadata.ZONE and type(count) == "number" then
                for i = 1, count do
                    -- For "random" token type, pick any available token
                    if tokenType == Constants.TokenType.RANDOM or tokenType == Constants.TokenType.ANY then
                        local foundRandom = false
                        
                        -- Get all available token types
                        local availableTypes = Constants.getAllTokenTypes()
                        -- Shuffle the types to randomize selection
                        for i = #availableTypes, 2, -1 do
                            local j = math.random(i)
                            availableTypes[i], availableTypes[j] = availableTypes[j], availableTypes[i]
                        end
                        
                        -- Try each token type in random order
                        for _, type in ipairs(availableTypes) do
                            local token, tokenIndex = manaPool:findFreeToken(type)
                            if token then
                                table.insert(requiredTokens, {
                                    type = type, 
                                    token = token, 
                                    index = tokenIndex
                                })
                                foundRandom = true
                                break
                            end
                        end
                        
                        if not foundRandom then
                            print("[TOKEN MANAGER] Error: Could not find any free token for '" .. Constants.TokenType.RANDOM .. "' cost")
                            return false, {}
                        end
                    else
                        -- Look for a specific token type
                        local token, tokenIndex = manaPool:findFreeToken(tokenType)
                        if token then
                            table.insert(requiredTokens, {
                                type = tokenType, 
                                token = token, 
                                index = tokenIndex
                            })
                        else
                            print("[TOKEN MANAGER] Error: Could not find free token of type " .. tokenType)
                            return false, {}
                        end
                    end
                end
            end
        end
    end
    
    -- Actually acquire the tokens (change their state)
    local acquiredTokens = {}
    
    for i, reservedToken in ipairs(requiredTokens) do
        -- Get the token and change its state
        local token = manaPool:getToken(reservedToken.type)
        if token then
            -- Set token references and ownership
            token.wizardOwner = wizard
            token.spellSlot = slotIndex
            token.tokenIndex = i
            
            -- Add token to the acquired list with positioning data
            table.insert(acquiredTokens, {
                token = token,
                index = i
            })
        else
            print("[TOKEN MANAGER] Error: Failed to acquire reserved token of type " .. reservedToken.type)
            -- Return all previously acquired tokens
            TokenManager.returnTokensToPool(acquiredTokens)
            return false, {}
        end
    end
    
    -- Position tokens in the spell slot
    TokenManager.positionTokensInSpellSlot(wizard, slotIndex, acquiredTokens)
    
    return true, acquiredTokens
end

-- Positions tokens in a spell slot with proper animation parameters
function TokenManager.positionTokensInSpellSlot(wizard, slotIndex, tokens)
    if not wizard or not slotIndex or not tokens then
        print("[TOKEN MANAGER] Error: Missing parameters for positionTokensInSpellSlot")
        return false
    end
    
    -- Initialize tokens with animation parameters
    local tokenCount = #tokens
    
    -- Calculate the visual parameters for the spell slot
    local slotYOffsets = {30, 0, -30}  -- legs, midsection, head
    local horizontalRadii = {80, 70, 60}
    local verticalRadii = {20, 25, 30}
    
    for i, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Store token's current position as the starting point for animation
        token.startX = token.x
        token.startY = token.y

        -- Ensure the token appears at a consistent scale while channeled
        if token.targetScale then
            token.scale = token.targetScale
        else
            token.scale = Constants.TokenVisuals and Constants.TokenVisuals.CHANNELED_SCALE or 1.0
        end
        
        -- Initialize animation parameters
        token.animTime = 0
        token.animDuration = 0.6  -- Animation duration in seconds
        token.isAnimating = true
        
        -- Set up references for the token
        token.wizardOwner = wizard
        token.spellSlot = slotIndex
        token.slotIndex = slotIndex
        token.tokenIndex = tokenData.index
        
        -- Calculate target position in the spell slot based on 3D positioning
        local targetY = wizard.y + slotYOffsets[slotIndex]
        local targetX = wizard.x
        
        -- Animation data
        token.targetX = targetX
        token.targetY = targetY
        
        -- 3D perspective data for rotation
        token.radiusX = horizontalRadii[slotIndex]
        token.radiusY = verticalRadii[slotIndex]
        
        -- Set proper token state
        if token.setState then
            token:setState(Constants.TokenStatus.CHANNELED)
        else
            -- Fallback for backward compatibility
            token.state = Constants.TokenState.CHANNELED
        end
        
        ::continue_token::
    end
    
    return true
end

-- Prepares tokens for use in a shield
function TokenManager.prepareTokensForShield(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to prepareTokensForShield")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Set flag that this token will become a shield
        token.willBecomeShield = true
        
        ::continue_token::
    end
    
    return true
end

-- Marks tokens as being used in a shield (called after shield creation)
function TokenManager.markTokensAsShielding(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to markTokensAsShielding")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Set proper token state using state machine if available
        if token.setState then
            token:setState(Constants.TokenStatus.SHIELDING)
        else
            -- Fallback for backward compatibility
            token.state = Constants.TokenState.SHIELDING
        end
        
        -- Clear the willBecomeShield flag since it's now a shield
        token.willBecomeShield = nil
        
        ::continue_token::
    end
    
    return true
end

-- Returns tokens to the mana pool
function TokenManager.returnTokensToPool(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to returnTokensToPool")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Use token state machine if available
        if token.requestReturnAnimation then
            token:requestReturnAnimation()
        else
            -- Fallback for backward compatibility
            token.returning = true
            token.startX = token.x
            token.startY = token.y
            token.animTime = 0
            token.animDuration = 0.5
            
            -- Clear references
            token.wizardOwner = nil
            token.spellSlot = nil
        end
        
        ::continue_token::
    end
    
    return true
end

-- Destroys tokens (for disjunction effects)
function TokenManager.destroyTokens(tokens)
    if not tokens then
        print("[TOKEN MANAGER] Error: No tokens provided to destroyTokens")
        return false
    end
    
    for _, tokenData in ipairs(tokens) do
        local token = tokenData.token
        
        -- Skip if token is invalid
        if not token then
            goto continue_token
        end
        
        -- Clear token trails if available
        if token.manaPool and token.manaPool.tokenTrails and token.manaPool.tokenTrails[token] then
            token.manaPool.tokenTrails[token] = nil
        end
        
        -- Use token state machine if available
        if token.requestDestructionAnimation then
            token:requestDestructionAnimation()
        else
            -- Fallback for backward compatibility
            token.state = Constants.TokenState.DESTROYED
        end
        
        ::continue_token::
    end
    
    return true
end

-- Checks if a spell should fizzle when a token is removed
function TokenManager.checkFizzleCondition(wizard, slotIndex, removedToken)
    if not wizard or not slotIndex then
        print("[TOKEN MANAGER] Error: Missing parameters for checkFizzleCondition")
        return false
    end
    
    local slot = wizard.spellSlots[slotIndex]
    if not slot or not slot.active then
        return false
    end
    
    -- If slot has no tokens left, reset it
    if not slot.tokens or #slot.tokens == 0 then
        print("[TOKEN MANAGER] Spell in slot " .. slotIndex .. " fizzled - no tokens left")
        wizard:resetSpellSlot(slotIndex)
        return true
    end
    
    -- Check if spell has lost a required token type (Law of Completion)
    if slot.spell and slot.spell.manaCost then
        local remainingTokensByType = {}
        
        -- Count remaining tokens by type
        for _, tokenData in ipairs(slot.tokens) do
            local tokenType = tokenData.token and tokenData.token.type or nil
            if tokenType then
                remainingTokensByType[tokenType] = (remainingTokensByType[tokenType] or 0) + 1
            end
        end
        
        -- Check against the required mana cost
        for tokenType, count in pairs(slot.spell.manaCost) do
            -- Skip special metadata fields
            if tokenType ~= Constants.SpellMetadata.DESCRIPTION and tokenType ~= Constants.SpellMetadata.ZONE then
                -- Handle random token type
                if tokenType == Constants.TokenType.RANDOM then
                    local totalRemaining = 0
                    for _, typeCount in pairs(remainingTokensByType) do
                        totalRemaining = totalRemaining + typeCount
                    end
                    
                    if totalRemaining < count then
                        print("[TOKEN MANAGER] Spell in slot " .. slotIndex .. " fizzled - not enough tokens for '" .. Constants.TokenType.RANDOM .. "' cost")
                        wizard:resetSpellSlot(slotIndex)
                        return true
                    end
                else
                    -- Check specific token type
                    local remaining = remainingTokensByType[tokenType] or 0
                    if remaining < count then
                        print("[TOKEN MANAGER] Spell in slot " .. slotIndex .. " fizzled - not enough " .. tokenType .. " tokens")
                        wizard:resetSpellSlot(slotIndex)
                        return true
                    end
                end
            end
        end
    end
    
    return false
end

-- Returns all tokens in a specific spell slot
function TokenManager.getTokensInSlot(wizard, slotIndex)
    if not wizard or not slotIndex or not wizard.spellSlots[slotIndex] then
        return {}
    end
    
    local slot = wizard.spellSlots[slotIndex]
    return slot.tokens or {}
end

-- Filters a list of tokens by type
function TokenManager.getTokensByType(tokens, tokenType)
    if not tokens or not tokenType then
        return {}
    end
    
    local filteredTokens = {}
    
    for _, tokenData in ipairs(tokens) do
        if tokenData.token and tokenData.token.type == tokenType then
            table.insert(filteredTokens, tokenData)
        end
    end
    
    return filteredTokens
end

-- Validates if a token is in the expected state
function TokenManager.validateTokenState(token, expectedState)
    if not token then
        return false, "Token is nil"
    end
    
    if not expectedState then
        return false, "Expected state is nil"
    end
    
    -- Check state using the status field
    return token.status == expectedState, 
           "Token state is " .. (token.status or "unknown") .. ", expected " .. expectedState
end

return TokenManager```

## ./systems/UnlockSystem.lua
```lua
-- systems/UnlockSystem.lua
-- Simple character unlock logic

local UnlockSystem = {}

--- Check if a spell unlocks any characters
-- Currently unlocks Silex when a Salt spell is cast
-- @param spell table Executed spell definition
-- @param caster table Wizard casting the spell
function UnlockSystem.checkSpellUnlock(spell, caster)
    if not spell or not caster then return end
    if spell.affinity == "salt" and game and not game.unlockedCharacters.Silex then
        game.unlockedCharacters.Silex = true
        print("[UNLOCK] Silex has been unlocked!")
        if caster.spellCastNotification then
            caster.spellCastNotification.text = "Unlocked Silex!"
            caster.spellCastNotification.timer = 2.0
        else
            caster.spellCastNotification = {
                text = "Unlocked Silex!",
                timer = 2.0,
                x = caster.x,
                y = caster.y + 70,
                color = {1,1,0,1}
            }
        end
    end

    -- Unlock additional spells
    if spell.unlockSpell and game and not game.unlockedSpells[spell.unlockSpell] then
        game.unlockedSpells[spell.unlockSpell] = true
        print("[UNLOCK] Spell unlocked: " .. spell.unlockSpell)
    end
end

return UnlockSystem
```

## ./systems/VisualResolver.lua
```lua
-- systems/VisualResolver.lua
-- Resolves events to appropriate visual effects based on event metadata

local Constants = require("core.Constants")

local VisualResolver = {}

-- Map visualShape strings to base VFX template names
-- This is the primary mapping table for determining visual template from spell shape
local TEMPLATE_BY_SHAPE = {
    
    -- Projectile-like effects
    ["beam"] = Constants.VFXType.BEAM_BASE,
    ["zap"] = Constants.VFXType.ZAP_BASE,
    ["bolt"] = Constants.VFXType.BOLT_BASE,
    ["orb"] = Constants.VFXType.ORB_BASE,
    ["wave"] = Constants.VFXType.WAVE_BASE,
    
    -- Area/zone effects
    ["blast"] = Constants.VFXType.BLAST_BASE,  -- Updated to new BLAST_BASE template
    ["cone"] = Constants.VFXType.BLAST_BASE,   -- Alternative name for same template
    ["groundBurst"] = Constants.VFXType.ZONE_BASE,
    ["meteor"] = Constants.VFXType.METEOR,
    
    -- Remote/direct effects
    ["warp"] = Constants.VFXType.WARP_BASE,
    
    -- Utility effects
    ["surge"] = Constants.VFXType.SURGE_BASE,
    ["affectManaPool"] = Constants.VFXType.UTIL_BASE,
    
    -- Shield-like effects
    ["wings"] = Constants.VFXType.SHIELD_OVERLAY,
    ["mirror"] = Constants.VFXType.SHIELD_OVERLAY,
    
    -- Special effects with unique templates
    ["eclipse"] = "eclipse_base"
}

-- Map attack types to base VFX template names
-- This is used as a fallback when visualShape is not specified
local BASE_BY_ATTACK = {
    [Constants.AttackType.PROJECTILE] = Constants.VFXType.PROJ_BASE,
    [Constants.AttackType.REMOTE] = Constants.VFXType.REMOTE_BASE,
    [Constants.AttackType.ZONE] = Constants.VFXType.ZONE_BASE,
    [Constants.AttackType.UTILITY] = Constants.VFXType.UTIL_BASE
}

-- Map affinities (token types) to colors
local COLOR_BY_AFF = {
    [Constants.TokenType.FIRE] = Constants.getColorForTokenType(Constants.TokenType.FIRE),
    [Constants.TokenType.WATER] = Constants.getColorForTokenType(Constants.TokenType.WATER),
    [Constants.TokenType.SALT] = Constants.getColorForTokenType(Constants.TokenType.SALT),
    [Constants.TokenType.SUN] = Constants.getColorForTokenType(Constants.TokenType.SUN),
    [Constants.TokenType.MOON] = Constants.getColorForTokenType(Constants.TokenType.MOON),
    [Constants.TokenType.STAR] = Constants.getColorForTokenType(Constants.TokenType.STAR),
    [Constants.TokenType.LIFE] = Constants.getColorForTokenType(Constants.TokenType.LIFE),
    [Constants.TokenType.MIND] = Constants.getColorForTokenType(Constants.TokenType.MIND),
    [Constants.TokenType.VOID] = Constants.getColorForTokenType(Constants.TokenType.VOID)
}

-- Map specific tags to overlay visual effects
local TAG_ADDONS = {
    DAMAGE = Constants.VFXType.DAMAGE_OVERLAY,
    BURN = Constants.VFXType.EMBER_OVERLAY,
    DOT = Constants.VFXType.DOT_OVERLAY,
    CONJURE = Constants.VFXType.SPARKLE_OVERLAY,
    RESOURCE = Constants.VFXType.RESOURCE_OVERLAY,
    MOVEMENT = Constants.VFXType.MOVEMENT_OVERLAY,
    ELEVATE = Constants.VFXType.RISE_OVERLAY,
    GROUND = Constants.VFXType.FALL_OVERLAY,
    SHIELD = Constants.VFXType.SHIELD_OVERLAY,
    DEFENSE = Constants.VFXType.BARRIER_OVERLAY
}

-- Map affinities to motion styles
local AFFINITY_MOTION = {
    [Constants.TokenType.FIRE] = Constants.MotionStyle.RISE,
    [Constants.TokenType.WATER] = Constants.MotionStyle.SWIRL,
    [Constants.TokenType.SALT] = Constants.MotionStyle.FALL,
    [Constants.TokenType.SUN] = Constants.MotionStyle.PULSE,
    [Constants.TokenType.MOON] = Constants.MotionStyle.RIPPLE,
    [Constants.TokenType.STAR] = Constants.MotionStyle.DIRECTIONAL,
    [Constants.TokenType.LIFE] = Constants.MotionStyle.RISE,
    [Constants.TokenType.MIND] = Constants.MotionStyle.SWIRL,
    [Constants.TokenType.VOID] = Constants.MotionStyle.STATIC
}

-- Default values
local DEFAULT_BASE = Constants.VFXType.IMPACT_BASE
local DEFAULT_COLOR = Constants.Color.SMOKE
local DEFAULT_MOTION = Constants.MotionStyle.RADIAL

-- Helper function for debug output without requiring vfx module dependency
function VisualResolver.debug(message)
    print("[VisualResolver] " .. message)
end

-- Main resolver function: Maps event data to visual parameters
-- Returns (baseTemplateName, options) as two separate values
function VisualResolver.pick(event)
    VisualResolver.debug("==========================================")
    VisualResolver.debug("VisualResolver.pick() called with event:")
    VisualResolver.debug("Event type: " .. (event and event.type or "nil"))
    VisualResolver.debug("Event source: " .. (event and event.source or "nil"))
    VisualResolver.debug("Event target: " .. (event and event.target or "nil"))
    VisualResolver.debug("==========================================")
    
    -- Validate event
    if not event or type(event) ~= "table" then
        VisualResolver.debug("Invalid event provided to pick()")
        return DEFAULT_BASE, { color = DEFAULT_COLOR, scale = 1.0, motion = DEFAULT_MOTION, addons = {} }
    end
    
    -- Debug output for visualShape if present
    if event.visualShape then
        VisualResolver.debug("Event contains visualShape: " .. tostring(event.visualShape))
    end
    
    -- Step 1: Determine base template with priority: effectOverride > legacy > shield_hit > visualShape > attackType > default
    local baseTemplate = DEFAULT_BASE
    local selectionPath = "DEFAULT" -- Track which path determined the template
    
    -- PRIORITY 1: Handle manual override: If the event has an effectOverride, use it directly
    -- This handles the manual vfx specifications from the vfx keyword
    if event.effectOverride then
        baseTemplate = event.effectOverride
        selectionPath = "EFFECT_OVERRIDE"
        
        VisualResolver.debug("Using explicit effect override: " .. event.effectOverride)
        VisualResolver.debug("Effect override source event details:")
        VisualResolver.debug("  - Event type: " .. (event.type or "nil"))
        VisualResolver.debug("  - Affinity: " .. (event.affinity or "nil"))
        VisualResolver.debug("  - Attack type: " .. (event.attackType or "nil"))
        VisualResolver.debug("  - Tags: " .. (event.tags and "present" or "nil"))
        
        -- Use the specified effect but still use the new parameter system
        return baseTemplate, {
            color = COLOR_BY_AFF[event.affinity] or DEFAULT_COLOR,
            scale = 1.0,
            motion = AFFINITY_MOTION[event.affinity] or DEFAULT_MOTION,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation
        }
    end
    
    -- PRIORITY 2: Also handle the case where we get the effect directly within an event.effect property
    -- This is needed for the showcase examples in spells.lua
    if event.effect and type(event.effect) == "string" then
        baseTemplate = event.effect
        selectionPath = "EVENT_EFFECT"
        
        VisualResolver.debug("Using effect from direct event.effect property: " .. event.effect)
        return baseTemplate, {
            color = COLOR_BY_AFF[event.affinity] or DEFAULT_COLOR,
            scale = 1.0, 
            motion = AFFINITY_MOTION[event.affinity] or DEFAULT_MOTION,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation
        }
    end
    
    -- PRIORITY 3: Handle shield hit event (from shield system)
    if event.effectType == "shield_hit" then
        baseTemplate = "shield_hit_base"
        selectionPath = "SHIELD_HIT"
        
        VisualResolver.debug("Handling shield hit effect")
        
        -- Determine shield color based on shield type
        local color = DEFAULT_COLOR
        
        if event.shieldType == Constants.ShieldType.BARRIER then
            color = {1.0, 1.0, 0.3, 0.8}  -- Yellow for barriers
        elseif event.shieldType == Constants.ShieldType.WARD then 
            color = {0.3, 0.3, 1.0, 0.8}  -- Blue for wards
        elseif event.shieldType == Constants.ShieldType.FIELD then
            color = {0.3, 1.0, 0.3, 0.8}  -- Green for fields
        end
        
        -- Build options with shield-specific values
        local opts = {
            color = color,
            scale = 1.2,  -- Slightly larger scale for impact emphasis
            motion = Constants.MotionStyle.PULSE,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation,
            -- VFX system will use vfxParams.x/y first, so we don't need to duplicate
        }
        
        VisualResolver.debug(string.format(
            "Resolved shield hit event to base=%s via %s, color=%s, scale=%.2f, motion=%s",
            baseTemplate,
            selectionPath,
            table.concat(color, ","),
            opts.scale,
            opts.motion
        ))
        
        return baseTemplate, opts
    end
    
    -- PRIORITY 4: Legacy manual VFX: If the event has manualVfx flag and effectType
    if event.manualVfx and event.effectType then
        baseTemplate = event.effectType
        selectionPath = "LEGACY_MANUAL"
        
        VisualResolver.debug("Using legacy manual effect via effectType: " .. event.effectType)
        -- Use the specified effect but still use the new parameter system
        return baseTemplate, {
            color = COLOR_BY_AFF[event.affinity] or DEFAULT_COLOR,
            scale = 1.0,
            motion = AFFINITY_MOTION[event.affinity] or DEFAULT_MOTION,
            addons = {},
            rangeBand = event.rangeBand,
            elevation = event.elevation
        }
    end
    
    -- PRIORITY 5: Use visualShape to look up template in TEMPLATE_BY_SHAPE
    if event.visualShape then
        local visualShape = event.visualShape
        local template = TEMPLATE_BY_SHAPE[visualShape]
        
        if template then
            baseTemplate = template
            selectionPath = "VISUAL_SHAPE"
            VisualResolver.debug("Using visualShape mapping: " .. visualShape .. " -> " .. baseTemplate)
        else
            -- For unknown visualShapes, log warning and fall back to attackType
            VisualResolver.debug("Unknown visualShape: " .. visualShape .. ", falling back to attackType")
        end
    end
    
    -- PRIORITY 6: If no visualShape match, use attack type mapping
    if selectionPath == "DEFAULT" and event.attackType and BASE_BY_ATTACK[event.attackType] then
        baseTemplate = BASE_BY_ATTACK[event.attackType]
        selectionPath = "ATTACK_TYPE"
        VisualResolver.debug("Using attackType mapping: " .. event.attackType .. " -> " .. baseTemplate)
    end
    
    -- If we still have no valid template, use the default
    if selectionPath == "DEFAULT" then
        VisualResolver.debug("No mapping found, using DEFAULT_BASE: " .. DEFAULT_BASE)
    end
    
    -- Step 2: Determine color from affinity
    local color = DEFAULT_COLOR
    if event.affinity and COLOR_BY_AFF[event.affinity] then
        color = COLOR_BY_AFF[event.affinity]
    end
    
    -- Step 3: Calculate scale based on mana cost
    local manaValue = event.manaCost or 1
    local scale = 0.8 + (0.15 * manaValue)
    if scale > 2.0 then scale = 2.0 end  -- Cap at 2.0x scale
    
    -- Step 4: Determine motion style from affinity
    local motion = DEFAULT_MOTION
    if event.affinity and AFFINITY_MOTION[event.affinity] then
        motion = AFFINITY_MOTION[event.affinity]
    end
    
    -- Step 5: Build addons list from tags
    local addons = {}
    if event.tags and type(event.tags) == "table" then
        for tag, _ in pairs(event.tags) do
            if TAG_ADDONS[tag] then
                table.insert(addons, TAG_ADDONS[tag])
            end
        end
    end
    
    -- Build and return the options table
    local opts = {
        color = color,
        scale = scale,
        motion = motion,
        addons = addons,
        rangeBand = event.rangeBand,
        elevation = event.elevation
    }
    
    VisualResolver.debug(string.format(
        "Resolved event to base=%s via %s, color=%s, scale=%.2f, motion=%s, addons=%d",
        baseTemplate,
        selectionPath,
        table.concat(color, ","),
        scale,
        motion,
        #addons
    ))
    
    -- Additional debug for tag processing
    if event.tags and type(event.tags) == "table" then
        local tagList = ""
        for tag, _ in pairs(event.tags) do
            tagList = tagList .. tag .. ", "
        end
        VisualResolver.debug("Event tags: " .. tagList)
        
        local addonList = ""
        for _, addon in ipairs(addons) do
            addonList = addonList .. addon .. ", "
        end
        VisualResolver.debug("Resolved addons: " .. (addonList ~= "" and addonList or "none"))
    else
        VisualResolver.debug("Event has no tags")
    end
    
    VisualResolver.debug("==========================================")
    return baseTemplate, opts
end

-- Helper function to test the resolver with sample events
function VisualResolver.test()
    local testEvents = {
        -- Test 1: Fire projectile spell (using attackType)
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            manaCost = 2,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 2: Water remote spell with higher cost (using attackType)
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.WATER,
            attackType = Constants.AttackType.REMOTE,
            manaCost = 4,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.AERIAL
        },
        -- Test 3: Moon-based shield (using attackType)
        {
            type = "CREATE_SHIELD",
            affinity = Constants.TokenType.MOON,
            attackType = Constants.AttackType.UTILITY,
            manaCost = 3,
            tags = { SHIELD = true, DEFENSE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 4: Manually specified effect (vfx keyword)
        {
            type = "EFFECT",
            effectOverride = Constants.VFXType.FIREBOLT,
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            manaCost = 2,
            tags = { VFX = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 5: Legacy manual VFX
        {
            type = "EFFECT",
            effectType = Constants.VFXType.METEOR,
            manualVfx = true,
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            manaCost = 3,
            tags = { VFX = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.AERIAL
        },
        -- Test 6: REMOTE attack with "beam" visualShape override
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.MOON,
            attackType = Constants.AttackType.REMOTE,
            visualShape = "beam",
            manaCost = 3,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 7: Projectile attack with "blast" visualShape override
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            visualShape = "blast",
            manaCost = 3,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 8: Testing "orb" visualShape
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.STAR,
            attackType = Constants.AttackType.ZONE, -- This would normally use ZONE_BASE
            visualShape = "orb",                    -- But visualShape overrides to PROJ_BASE
            manaCost = 2,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 9: Testing "warp" visualShape
        {
            type = "EFFECT",
            affinity = Constants.TokenType.VOID,
            attackType = Constants.AttackType.PROJECTILE, -- This would normally use PROJ_BASE
            visualShape = "warp",                         -- But visualShape overrides to UTIL_BASE
            manaCost = 1,
            tags = { MOVEMENT = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 10: Testing "mirror" visualShape
        {
            type = "CREATE_SHIELD",
            affinity = Constants.TokenType.WATER,
            attackType = Constants.AttackType.UTILITY,
            visualShape = "mirror",
            manaCost = 2,
            tags = { SHIELD = true, DEFENSE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 11: Testing "eclipse" visualShape
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.VOID,
            attackType = Constants.AttackType.ZONE,
            visualShape = "eclipse",
            manaCost = 5,
            tags = { DAMAGE = true, DOT = true },
            rangeBand = Constants.RangeState.FAR,
            elevation = Constants.ElevationState.AERIAL
        },
        -- Test 12: Testing unknown visualShape (should fall back to attackType)
        {
            type = "DAMAGE",
            affinity = Constants.TokenType.FIRE,
            attackType = Constants.AttackType.PROJECTILE,
            visualShape = "unknown_shape",  -- Not in TEMPLATE_BY_SHAPE
            manaCost = 2,
            tags = { DAMAGE = true },
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        },
        -- Test 13: Shield hit effect
        {
            type = "SHIELD_HIT",
            effectType = "shield_hit",
            shieldType = Constants.ShieldType.BARRIER,
            rangeBand = Constants.RangeState.NEAR,
            elevation = Constants.ElevationState.GROUNDED
        }
    }
    
    print("===== VisualResolver Test =====")
    for i, event in ipairs(testEvents) do
        print("\nTest " .. i .. ": " .. event.type .. " event with " .. (event.affinity or "unknown") .. " affinity")
        if event.visualShape then
            print("visualShape: " .. event.visualShape)
        end
        if event.attackType then
            print("attackType: " .. event.attackType)
        end
        
        local base, opts = VisualResolver.pick(event)
        print("Base template: " .. base)
        print("Color: " .. table.concat(opts.color, ","))
        print("Scale: " .. opts.scale)
        print("Motion: " .. opts.motion)
        print("Addons: " .. (#opts.addons > 0 and table.concat(opts.addons, ", ") or "none"))
        print("Range: " .. (opts.rangeBand or "none"))
        print("Elevation: " .. (opts.elevation or "none"))
    end
    print("\n================================")
end

-- Execute test function if called directly
-- Only run if arg exists and this file is being run directly
if arg and arg[0] and type(arg[0]) == "string" and arg[0]:find("VisualResolver.lua") then
    VisualResolver.test()
end

return VisualResolver```

## ./systems/WizardVisuals.lua
```lua
-- WizardVisuals.lua
-- Centralized visualization system for Wizard entities in Manastorm

local WizardVisuals = {}
local Constants = require("core.Constants")
local ShieldSystem = require("systems.ShieldSystem")
local VFX = require("vfx") -- Added for accessing rune assets

-- Particle asset helpers for cast arc effects
local function getParticleImages()
    return {
        pixel = VFX.getAsset and VFX.getAsset("pixel") or nil,
        twinkle1 = VFX.getAsset and VFX.getAsset("twinkle1") or nil,
        twinkle2 = VFX.getAsset and VFX.getAsset("twinkle2") or nil
    }
end

-- Get appropriate status effect color
function WizardVisuals.getStatusEffectColor(effectType)
    local effectColors = {
        aerial = {0.7, 0.7, 1.0, 0.8},
        stun = {1.0, 1.0, 0.1, 0.8},
        shield = {0.5, 0.7, 1.0, 0.8},
        burn = {1.0, 0.4, 0.1, 0.8}
    }
    
    return effectColors[effectType] or {0.8, 0.8, 0.8, 0.8} -- Default to gray
end

-- Helper function to draw an ellipse
function WizardVisuals.drawEllipse(x, y, radiusX, radiusY, mode)
    local segments = 32
    local vertices = {}
    
    for i = 1, segments do
        local angle = (i - 1) * (2 * math.pi / segments)
        local px = x + math.cos(angle) * radiusX
        local py = y + math.sin(angle) * radiusY
        table.insert(vertices, px)
        table.insert(vertices, py)
    end
    
    -- Close the shape by adding the first point again
    table.insert(vertices, vertices[1])
    table.insert(vertices, vertices[2])
    
    if mode == "fill" then
        love.graphics.polygon("fill", vertices)
    else
        love.graphics.polygon("line", vertices)
    end
end

-- Helper function to draw an elliptical arc
function WizardVisuals.drawEllipticalArc(x, y, radiusX, radiusY, startAngle, endAngle, segments)
    segments = segments or 16
    
    -- Calculate the angle increment
    local angleRange = endAngle - startAngle
    local angleIncrement = angleRange / segments
    
    -- Create points for the arc
    local points = {}
    
    for i = 0, segments do
        local angle = startAngle + angleIncrement * i
        local px = x + math.cos(angle) * radiusX
        local py = y + math.sin(angle) * radiusY
        table.insert(points, px)
        table.insert(points, py)
    end
    
    -- Draw the arc as a line
    love.graphics.line(points)
end

-- Easing function for smoother animations
function WizardVisuals.easeOutCubic(t)
    return 1 - math.pow(1 - t, 3)
end

-- Simple particle object for arc spark effects
local function spawnArcSpark(slot, x, y, angle, color)
    slot._arcParticles = slot._arcParticles or {}
    local images = getParticleImages()
    local imgChoices = {images.pixel, images.twinkle1, images.twinkle2}
    local img = imgChoices[math.random(#imgChoices)]
    if not img then return end

    local speed = 40 + math.random() * 40
    local particle = {
        x = x,
        y = y,
        vx = math.cos(angle) * speed + (math.random() - 0.5) * 20,
        vy = math.sin(angle) * speed + (math.random() - 0.5) * 20,
        life = 0.35,
        maxLife = 0.35,
        img = img,
        color = {color[1], color[2], color[3], 1}
    }
    table.insert(slot._arcParticles, particle)
end

-- Update arc spark particles for a wizard
function WizardVisuals.updateArcParticles(wizard, dt)
    for _, slot in ipairs(wizard.spellSlots) do
        if slot._arcParticles then
            local i = 1
            while i <= #slot._arcParticles do
                local p = slot._arcParticles[i]
                p.life = p.life - dt
                if p.life <= 0 then
                    table.remove(slot._arcParticles, i)
                else
                    p.x = p.x + p.vx * dt
                    p.y = p.y + p.vy * dt
                    i = i + 1
                end
            end
        end
    end
end

-- Draw status effects with durations using horizontal bars
function WizardVisuals.drawStatusEffects(wizard)
    -- Get screen dimensions
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    
    -- Get position offsets
    local xOffset = wizard.currentXOffset or 0
    local yOffset = wizard.currentYOffset or 0
    
    -- Properties for status effect bars
    local barWidth = 130
    local barHeight = 12
    local barSpacing = 18
    local barPadding = 15  -- Additional padding between effect bars
    
    -- Position status bars above the spellbook area
    local baseY = screenHeight - 150  -- Higher up from the spellbook
    local effectCount = 0
    
    -- Position bars above the wizard with the same offsets as the sprite
    local x = wizard.x + xOffset
    
    local Constants = require("core.Constants")
    
    -- Draw AERIAL duration if active
    if wizard.elevation == Constants.ElevationState.AERIAL and wizard.elevationTimer > 0 then
        effectCount = effectCount + 1
        local y = baseY - (effectCount * (barHeight + barPadding))
        
        -- Calculate progress (1.0 to 0.0 as time depletes)
        local maxDuration = 5.0  -- Assuming 5 seconds is max aerial duration
        local progress = wizard.elevationTimer / maxDuration
        progress = math.min(1.0, progress)  -- Cap at 1.0
        
        -- Get color for aerial state
        local color = WizardVisuals.getStatusEffectColor("aerial")
        
        -- Draw background bar (darker)
        love.graphics.setColor(color[1] * 0.5, color[2] * 0.5, color[3] * 0.5, color[4] * 0.5)
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth, barHeight, 4, 4)
        
        -- Draw progress bar
        love.graphics.setColor(color[1], color[2], color[3], color[4])
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth * progress, barHeight, 4, 4)
        
        -- Draw label
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print(Constants.ElevationState.AERIAL, x - 25, y - 2)
        
        -- Add some particle effects for AERIAL state
        if wizard.gameState and wizard.gameState.vfx and math.random() < 0.02 then
            local particleX = x + math.random(-barWidth/2, barWidth/2)
            local particleY = y + math.random(-10, 10)
            
            wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, particleX, particleY, nil, nil, {
                duration = 0.3,
                color = {0.5, 0.5, 1.0, 0.7},
                particleCount = 3,
                radius = 5
            })
        end
    end
    
    -- Draw STUN duration if active
    if wizard.statusEffects.stun and wizard.statusEffects.stun.active then
        effectCount = effectCount + 1
        local y = baseY - (effectCount * (barHeight + barPadding))

        -- Calculate progress (1.0 to 0.0 as time depletes)
        local stun = wizard.statusEffects.stun
        local maxDuration = stun.duration
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        local progress = maxDuration > 0 and remaining / maxDuration or 0

        -- Get color for stun state
        local color = WizardVisuals.getStatusEffectColor(Constants.StatusType.STUN)
        
        -- Draw background bar (darker)
        love.graphics.setColor(color[1] * 0.5, color[2] * 0.5, color[3] * 0.5, color[4] * 0.5)
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth, barHeight, 4, 4)
        
        -- Draw progress bar
        love.graphics.setColor(color[1], color[2], color[3], color[4])
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth * progress, barHeight, 4, 4)
        
        -- Draw label
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print("STUNNED", x - 30, y - 2)
        
        -- Add some particle effects for STUN state
        if wizard.gameState and wizard.gameState.vfx and math.random() < 0.05 then
            local particleX = x + math.random(-barWidth/2, barWidth/2)
            local particleY = y + math.random(-5, 5)
            
            wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, particleX, particleY, nil, nil, {
                duration = 0.2,
                color = {1.0, 1.0, 0.0, 0.7},
                particleCount = 2,
                radius = 5
            })
        end
    end
    
    -- Draw BURN effect if active
    if wizard.statusEffects[Constants.StatusType.BURN] and wizard.statusEffects[Constants.StatusType.BURN].active then
        effectCount = effectCount + 1
        local y = baseY - (effectCount * (barHeight + barPadding))

        -- Get burn effect data
        local burnEffect = wizard.statusEffects[Constants.StatusType.BURN]
        
        -- Calculate progress (1.0 to 0.0 as time depletes)
        local progress = 1.0
        if burnEffect.duration > 0 then
            progress = (burnEffect.duration - burnEffect.totalTime) / burnEffect.duration
            progress = math.max(0.0, math.min(1.0, progress))  -- Clamp between 0 and 1
        end
        
        -- Get tick progress for pulsing effect
        local tickProgress = burnEffect.elapsed / burnEffect.tickInterval
        local pulseEffect = math.sin(tickProgress * math.pi) * 0.2  -- Pulse effect strongest right before tick
        
        -- Get color for burn state
        local color = WizardVisuals.getStatusEffectColor(Constants.StatusType.BURN)
        
        -- Draw background bar (darker)
        love.graphics.setColor(color[1] * 0.5, color[2] * 0.5, color[3] * 0.5, color[4] * 0.5)
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth, barHeight, 4, 4)
        
        -- Draw progress bar with pulse effect
        love.graphics.setColor(
            color[1] * (1 + pulseEffect), 
            color[2] * (1 + pulseEffect), 
            color[3] * (1 + pulseEffect), 
            color[4]
        )
        love.graphics.rectangle("fill", x - barWidth/2, y, barWidth * progress, barHeight, 4, 4)
        
        -- Draw label with damage per tick
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print("BURN "..burnEffect.tickDamage, x - 30, y - 2)
        
        -- Add some particle effects for BURN state
        if wizard.gameState and wizard.gameState.vfx and math.random() < 0.1 then
            local particleX = wizard.x + math.random(-20, 20)
            local particleY = wizard.y + math.random(-30, 10)
            
            wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, particleX, particleY, nil, nil, {
                duration = 0.3,
                color = {1.0, 0.4, 0.1, 0.6},
                particleCount = 3,
                radius = 8
            })
        end
    end
end

-- Draw spell slots with token orbits
function WizardVisuals.drawSpellSlots(wizard, layer)
    -- Draw 3 orbiting spell slots as elliptical paths at different vertical positions
    -- Position the slots at legs, midsection, and head levels
    -- Get position offsets to apply the same offsets as the wizard
    local xOffset = wizard.currentXOffset or 0
    local yOffset = wizard.currentYOffset or 0
    local slotYOffsets = {30, 0, -30}  -- From bottom to top
    
    -- Horizontal and vertical radii for each elliptical path
    local horizontalRadii = {80, 70, 60}   -- Wider at the bottom, narrower at the top
    local verticalRadii = {20, 25, 30}     -- Flatter at the bottom, rounder at the top
    
    -- Get the ManaPool instance (ensure gameState and manaPool exist)
    local manaPool = wizard.gameState and wizard.gameState.manaPool
    if not manaPool then
        print("ERROR: ManaPool instance not found in WizardVisuals.drawSpellSlots")
        return
    end

    for i, slot in ipairs(wizard.spellSlots) do
        -- Position parameters for each slot, applying both offsets
        local slotY = wizard.y + slotYOffsets[i] + yOffset
        local slotX = wizard.x + xOffset
        local radiusX = horizontalRadii[i]
        local radiusY = verticalRadii[i]
        
        -- Calculate base position and animation values for all tokens
        -- This is crucial for both normal and shield tokens to get consistent positions
        if slot.active and #slot.tokens > 0 then
            -- For normal spells, angle based on cast progress
            -- For shields, use time-based constant rotation
            local baseAngle
            if slot.isShield then
                -- Shield rotation is time-based and continuous
                baseAngle = love.timer.getTime() * 0.3  -- Slightly faster to make orbiting more visible
            else
                -- Normal spell rotation is based on cast progress
                baseAngle = slot.progress / slot.castTime * math.pi * 2
            end
            
            -- Pre-calculate token positions for ALL tokens in this slot
            -- This ensures consistent positioning regardless of front/back rendering order
            local tokenCount = #slot.tokens
            local anglePerToken = math.pi * 2 / tokenCount
            
            -- First pass: calculate positions and draw based on layer
            for j, tokenData in ipairs(slot.tokens) do
                local token = tokenData.token
                
                -- Skip invalid or transitioning tokens
                if not token or 
                   token.status == Constants.TokenStatus.RETURNING or 
                   token.status == Constants.TokenStatus.DISSOLVING then
                    -- No goto needed here, just continue to next token
                else
                    -- Calculate angle for each token based on its index
                    local tokenAngle = baseAngle + anglePerToken * (j - 1)
                    
                    -- Store the token's orbit angle (for continuity)
                    token.orbitAngle = tokenAngle
                    
                    -- Calculate position - used for both rendering and token state
                    -- Note: If the token is animating towards the slot (CHANNELED state, animTime < animDuration),
                    -- its x, y might be updated by ManaPool:update. We should use the calculated orbit position
                    -- for layer determination, but let ManaPool:drawToken use the token's current x,y.
                    local orbitX = slotX + math.cos(tokenAngle) * radiusX
                    local orbitY = slotY + math.sin(tokenAngle) * radiusY
                    
                    -- If token isn't fully animated to the slot yet, keep its animating position
                    -- but use the calculated orbit position for determining front/back
                    if token.status == Constants.TokenStatus.CHANNELED and token.animTime < token.animDuration then
                        -- Position is being animated, use orbitAngle for layering check only
                    else
                        -- Token is in orbit, update its position directly
                        token.x = orbitX
                        token.y = orbitY
                    end
                    
                    -- Determine if token is in the front or back half based on its *intended* orbit angle
                    local normalizedAngle = token.orbitAngle % (math.pi * 2)
                    local tokenLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"

                    -- Draw the token if its layer matches the requested layer
                    if tokenLayer == layer then
                         -- Check if the token is actually supposed to be drawn (not animating away)
                        if token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
                             manaPool:drawToken(token)
                        end
                    end
                end
            end
        end
        
        -- Draw the elliptical orbit paths (only need to do this once, e.g., during the 'back' pass)
        if layer == "back" then 
            -- Clear stale casting arc data if this slot is not currently in an active casting phase
            if not slot.active or (slot.castTime or 0) == 0 or slot.progress >= (slot.castTime or 0) then
                slot._castArcActive = false
            end

            local shouldDrawOrbit = false
            local orbitColor = {0.5, 0.5, 0.5, 0.4} -- Default inactive/dim color
            local drawProgressArc = false
            local progressArcColor = {1.0, 1.0, 1.0, 0.9} -- Default progress color
            local stateText = nil -- Text like "FROZEN", "TRAP"
            local stateTextColor = {1, 1, 1, 0.8}

            -- First, check for keyed spell highlight on an inactive slot
            if wizard.currentKeyedSpell and not slot.active then
                local wouldUseThisSlot = true
                for j = 1, i-1 do
                    if not wizard.spellSlots[j].active then
                        wouldUseThisSlot = false
                        break
                    end
                end
                
                if wouldUseThisSlot then
                    local affinity = wizard.currentKeyedSpell.affinity
                    orbitColor = affinity and Constants.getColorForTokenType(affinity) or {0.8, 0.8, 0.2}
                    orbitColor[4] = 0.7 -- Set alpha
                    shouldDrawOrbit = true
                    -- Skip further checks for this slot if it's just a highlight
                    goto DrawOrbitAndArc -- Use goto to jump past active slot logic
                end
            end

            -- Handle active slots (casting or sustained/finished)
            if slot.active then
                -- Determine if the spell is currently in its casting phase
                local isActuallyCasting = (slot.castTime or 0) > 0 and slot.progress < slot.castTime

                if isActuallyCasting then
                    -- CASTING PHASE: Show affinity-colored progress arc only
                    drawProgressArc = true
                    shouldDrawOrbit = false -- Hide the full orbit during cast

                    local affinity = slot.spell and slot.spell.affinity
                    local baseArcColor = affinity and Constants.getColorForTokenType(affinity) or {1.0, 0.7, 0.3} -- Default yellowish
                    local brightness = 0.9 + math.sin(love.timer.getTime() * 5) * 0.1
                    progressArcColor = {
                        baseArcColor[1] * brightness, 
                        baseArcColor[2] * brightness, 
                        baseArcColor[3] * brightness, 
                        0.9
                    }

                    -- Store arc information so the complementary half can be rendered in the "front" pass
                    slot._castArcActive = true
                    slot._castArcColor = {progressArcColor[1], progressArcColor[2], progressArcColor[3], progressArcColor[4]}
                    slot._castArcProgress = (slot.castTime or 1) > 0 and (slot.progress / slot.castTime) or 0

                else
                    -- POST-CASTING PHASE (or instant spell): Show full orbit based on state
                    drawProgressArc = false
                    slot._castArcActive = false -- Clear cached arc
                    shouldDrawOrbit = true 

                    if slot.isShield then
                        -- New shield rendering logic based on type
                        local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
                        -- Use slot.defenseType directly instead of looking at the spell keywords, which are not always available
                        local shieldType = slot.defenseType
                        local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3
                        local alpha = 0.7 + pulseAmount * 0.3 -- Pulsing alpha

                        -- Compare against Constants instead of string literals
                        if shieldType == Constants.ShieldType.BARRIER then
                            -- Do NOT draw the horizontal orbit for Barrier; only vertical hedge lines
                            shouldDrawOrbit = false
                            -- Vertical cylinder lines are handled later in their dedicated block
                        
                        elseif shieldType == Constants.ShieldType.WARD then
                            shouldDrawOrbit = false -- Don't draw the standard orbit for Ward
                            local numRunes = 5
                            local runeYOffset = 0 -- Position runes above the orbit
                            local runeScale = 1.0

                            -- Get runes with more robust handling
                            local runeAssets
                            -- First try using the public getAsset function 
                            if VFX.getAsset then
                                runeAssets = VFX.getAsset("runes")
                            end
                            
                            -- Fall back to direct access if needed
                            if not runeAssets and VFX.assets then
                                runeAssets = VFX.assets.runes
                            end
                            
                            -- Last resort: create a dummy fallback for this frame
                            if not runeAssets or #runeAssets == 0 then
                                print("[WIZARD VISUALS] Warning: Unable to get rune assets, using fallback")
                                shouldDrawOrbit = true
                            end
                            
                            if runeAssets and #runeAssets > 0 then
                                -- Determine rune color based on spell affinity if available
                                local baseColor
                                if slot.spell and slot.spell.affinity then
                                    -- Use spell affinity color for more visual variety
                                    baseColor = Constants.getColorForTokenType(slot.spell.affinity)
                                else
                                    -- Fall back to shield type color
                                    baseColor = shieldColor
                                end
                                
                                -- Enhanced contrast and visibility
                                local runeColor = {
                                    math.min(1.0, baseColor[1] * (1.2 + pulseAmount * 0.8)),
                                    math.min(1.0, baseColor[2] * (1.2 + pulseAmount * 0.8)),
                                    math.min(1.0, baseColor[3] * (1.2 + pulseAmount * 0.8)),
                                    0.95 + pulseAmount * 0.05  -- Higher base alpha for better visibility
                                }

                                for r = 1, numRunes do
                                    -- Deterministic seed so both passes pick the same rune image
                                    local seed = i * 10 + r + math.floor(love.timer.getTime())
                                    math.randomseed(seed)
                                    local runeIndex = math.random(1, #runeAssets)
                                    math.randomseed(os.time() + os.clock()*1000000)

                                    local runeImg = runeAssets[runeIndex]
                                    local angle = (r / numRunes) * math.pi * 2 + love.timer.getTime() * 0.7
                                    local runeX = slotX + math.cos(angle) * radiusX
                                    local runeY = slotY + math.sin(angle) * radiusY + runeYOffset

                                    -- Determine if rune is front or back half
                                    local normalizedAngle = (angle % (math.pi * 2))
                                    local runeLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"

                                    if runeLayer == layer then
                                        -- Dark outline for better contrast against backgrounds
                                        love.graphics.setColor(0, 0, 0, runeColor[4] * 0.8)
                                        for dx = -1, 1 do
                                            for dy = -1, 1 do
                                                if dx ~= 0 or dy ~= 0 then
                                                    love.graphics.draw(
                                                        runeImg,
                                                        runeX + dx, runeY + dy,
                                                        0,
                                                        runeScale, runeScale,
                                                        runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                                    )
                                                end
                                            end
                                        end
                                        
                                        -- Bright glow pass for visibility
                                        local prevBlendSrc, prevBlendDst = love.graphics.getBlendMode()
                                        love.graphics.setBlendMode("add")
                                        love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4] * 0.8)
                                        love.graphics.draw(
                                            runeImg,
                                            runeX, runeY,
                                            0,
                                            runeScale * 1.6, runeScale * 1.6,
                                            runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                        )
                                        love.graphics.setBlendMode(prevBlendSrc, prevBlendDst)

                                        -- Main rune sprite with full opacity
                                        love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4])
                                        love.graphics.draw(
                                            runeImg,
                                            runeX, runeY,
                                            0,
                                            runeScale, runeScale,
                                            runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                        )
                                    end
                                end
                            else
                                -- Fallback: Draw the orbit if runes aren't loaded
                                shouldDrawOrbit = true
                                orbitColor = { shieldColor[1] * (1 + pulseAmount), shieldColor[2] * (1 + pulseAmount), shieldColor[3] * (1 + pulseAmount), alpha }
                            end

                        else
                            -- Fallback for unknown shield types or missing data: Draw original pulsating orbit
                            shouldDrawOrbit = true
                            orbitColor = { shieldColor[1] * (1 + pulseAmount), shieldColor[2] * (1 + pulseAmount), shieldColor[3] * (1 + pulseAmount), alpha }
                        end
                        
                        -- The old shield orbit drawing logic is now replaced by the type-specific drawing above
                        -- or handled by the fallback cases setting shouldDrawOrbit = true.

                    elseif slot.frozen then
                        orbitColor = {0.5, 0.5, 1.0, 0.7} -- Blue for frozen
                        stateText = "FROZEN"
                        stateTextColor = {0.7, 0.7, 1.0, 0.8}
                        -- Flickering ice effect
                        if math.random() < 0.03 then
                            if wizard.gameState and wizard.gameState.vfx then
                                local angle = math.random() * math.pi * 2
                                local sparkleX = slotX + math.cos(angle) * radiusX * 0.7
                                local sparkleY = slotY + math.sin(angle) * radiusY * 0.7
                                wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, sparkleX, sparkleY, nil, nil, {
                                    duration = 0.3, color = {0.6, 0.6, 1.0, 0.5}, particleCount = 3, radius = 5
                                })
                            end
                        end

                    elseif slot.spell and slot.spell.behavior and slot.spell.behavior.trap_trigger then
                        orbitColor = {0.7, 0.3, 0.9, 0.7} -- Purple for traps
                        stateText = "TRAP"
                        stateTextColor = {0.7, 0.3, 0.9, 0.8}
                        -- Trap sigil effect
                        -- this is the "explosions" bit on the caster rn - replace with overhead rune
                        if math.random() < 0.05 then
                            if wizard.gameState and wizard.gameState.vfx then
                                local angle = math.random() * math.pi * 2
                                local sparkleX = slotX + math.cos(angle) * radiusX * 0.6
                                local sparkleY = slotY + math.sin(angle) * radiusY * 0.6
                                wizard.gameState.vfx.createEffect(Constants.VFXType.IMPACT, sparkleX, sparkleY, nil, nil, {
                                    duration = 0.3, color = {0.7, 0.2, 0.9, 0.5}, particleCount = 2, radius = 4
                                })
                            end
                        end

                    elseif slot.spell and slot.spell.behavior and slot.spell.behavior.field_status then
                        orbitColor = {0.3, 1.0, 0.3, 0.7}
                        stateText = "FIELD"
                        stateTextColor = {0.3, 1.0, 0.3, 0.8}
                        
                    elseif slot.spell and slot.spell.behavior and slot.spell.behavior.sustain then
                        orbitColor = {0.9, 0.9, 0.9, 0.7} -- Light grey for sustained
                        stateText = "SUSTAIN"
                        stateTextColor = {0.9, 0.9, 0.9, 0.8}
                        -- Add potential sustain VFX here if desired

                    else 
                        -- Completed normal spell (not shield/frozen/trap/sustain)
                        -- Keep orbit briefly visible with affinity color (or maybe dim grey?)
                        local affinity = slot.spell and slot.spell.affinity
                        orbitColor = affinity and Constants.getColorForTokenType(affinity) or {0.9, 0.4, 0.2}
                        orbitColor[4] = 0.5 -- Make it slightly dimmer after completion
                    end
                end
            end -- End of active slot handling
            
            ::DrawOrbitAndArc::
            
            -- Draw the orbit ellipse if needed
            if shouldDrawOrbit then
                -- Store information so the corresponding bottom half can be drawn in the "front" pass
                slot._orbitShouldDraw = true
                slot._orbitColor = {orbitColor[1], orbitColor[2], orbitColor[3], orbitColor[4]}

                love.graphics.setColor(orbitColor[1], orbitColor[2], orbitColor[3], orbitColor[4])
                -- Draw ONLY the TOP half of the ellipse (π to 2π) during the "back" pass so it appears behind the wizard
                WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, math.pi, math.pi * 2, 32)

                -- Periodic sparks along the full orbit for sustained spells
                if slot.isShield or (slot.spell and slot.spell.behavior and slot.spell.behavior.sustain) then
                    local now = love.timer.getTime()
                    slot._nextOrbitSpark = slot._nextOrbitSpark or 0
                    if now >= slot._nextOrbitSpark then
                        local angle = math.random() * math.pi * 2
                        local px = slotX + math.cos(angle) * radiusX
                        local py = slotY + math.sin(angle) * radiusY
                        spawnArcSpark(slot, px, py, angle, orbitColor)
                        slot._nextOrbitSpark = now + 0.3 + math.random() * 0.3
                    end
                end
            else
                -- Make sure we do not accidentally reuse stale data on the next frame
                slot._orbitShouldDraw = false
            end

            -- NEW: Draw Barrier vertical cylinder lines if applicable
            if slot.active and slot.isShield then
                 -- Use the slot's defenseType value directly rather than trying to check the spell
                 if slot.defenseType == Constants.ShieldType.BARRIER then
                    -- Recalculate color/alpha or retrieve if stored (recalculating is safer here)
                    local shieldColor = ShieldSystem.getShieldColor(slot.defenseType) 
                    local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3
                    local alpha = 0.7 + pulseAmount * 0.3 

                    local cylinderHeight = 20 -- Height of the barrier effect
                    local numLines = 72 -- Number of vertical lines to simulate the cylinder
                    local lineAlpha = alpha * 0.6 -- Make vertical lines slightly more transparent

                    love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                    local prevWidth = love.graphics.getLineWidth()
                    love.graphics.setLineWidth(1.5) -- thicker

                    for k = 1, numLines do
                        local angle = (k / numLines) * math.pi * 2
                        local normalizedAngle = angle % (math.pi * 2)
                        -- Draw only BACK half lines in the back pass (π → 2π)
                        if normalizedAngle > math.pi then
                            local px = slotX + math.cos(angle) * radiusX
                            local py = slotY + math.sin(angle) * radiusY

                            -- Glow pass (thicker, additive blend)
                            local prevSrc, prevDst = love.graphics.getBlendMode()
                            love.graphics.setBlendMode("add")
                            love.graphics.setLineWidth(4)
                            love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha * 0.35)
                            love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                            love.graphics.setBlendMode(prevSrc, prevDst)

                            -- Main line
                            love.graphics.setLineWidth(1.5)
                            love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                            love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                        end
                    end
                    love.graphics.setLineWidth(prevWidth) -- restore
                 end
            end
            
            -- Draw progress arc if needed (only during casting phase)
            if drawProgressArc then
                -- Compute end angle once
                local endAngle = ((slot.castTime or 1) > 0) and (slot.progress / slot.castTime) * (math.pi * 2) or 0

                -- Draw only the TOP half (π → 2π) of the arc for the back layer
                if endAngle > math.pi then
                    local segStart = math.max(math.pi, 0) -- will always be π
                    local segEnd = endAngle
                    love.graphics.setColor(progressArcColor[1], progressArcColor[2], progressArcColor[3], progressArcColor[4])
                    -- Glow pass
                    local prevSrc, prevDst = love.graphics.getBlendMode()
                    love.graphics.setBlendMode("add")
                    local prevWidth = love.graphics.getLineWidth()
                    love.graphics.setLineWidth(3)
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, segStart, segEnd, 32)
                    love.graphics.setBlendMode(prevSrc, prevDst)
                    love.graphics.setLineWidth(prevWidth)
                    -- Main arc
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, segStart, segEnd, 32)

                    -- Spawn multiple sparkles at the arc head for more dramatic effect
                    if not slot._lastArcSpark or love.timer.getTime() - slot._lastArcSpark > 0.02 then
                        local hx = slotX + math.cos(endAngle) * radiusX
                        local hy = slotY + math.sin(endAngle) * radiusY
                        -- Spawn 3-5 particles per frame for much more generous particle effect
                        local particleCount = 3 + math.random(0, 2)
                        for p = 1, particleCount do
                            spawnArcSpark(slot, hx, hy, endAngle, progressArcColor)
                        end
                        slot._lastArcSpark = love.timer.getTime()
                    end
                end
            end

            -- Draw state text (TRAP, FROZEN, SUSTAIN) above the orbit if applicable
            if stateText then
                love.graphics.setColor(stateTextColor[1], stateTextColor[2], stateTextColor[3], stateTextColor[4])
                local textWidth = love.graphics.getFont():getWidth(stateText)
                love.graphics.print(stateText, 
                    slotX - textWidth / 2, -- Center text
                    slotY - verticalRadii[i] - 15) -- Position above the orbit
            end

            -- Re-draw tokens so they sit on top of the just-drawn orbit / arc graphics (maintains depth vs wizard)
            if slot.active and #slot.tokens > 0 then
                for j, tokenData in ipairs(slot.tokens) do
                    local token = tokenData.token
                    if token and token.status ~= Constants.TokenStatus.RETURNING and token.status ~= Constants.TokenStatus.DISSOLVING then
                        -- token.orbitAngle was set earlier in the first pass through tokens
                        local normalizedAngle = (token.orbitAngle or 0) % (math.pi * 2)
                        local tokenLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"

                        if tokenLayer == layer then
                            if token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
                                manaPool:drawToken(token)
                            end
                        end
                    end
                end
            end
        end -- End of drawing orbits only on 'back' pass

        -- NEW: Draw the BOTTOM half of the orbit ellipse during the "front" layer pass
        if layer == "front" then
            if slot._orbitShouldDraw and slot._orbitColor then
                local oc = slot._orbitColor
                love.graphics.setColor(oc[1], oc[2], oc[3], oc[4])
                WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, 0, math.pi, 32)
            end

            -- Draw bottom half of casting progress arc if there is one
            if slot._castArcActive and slot._castArcColor then
                local endAngle = (slot._castArcProgress or 0) * (math.pi * 2)
                local segEnd = math.min(endAngle, math.pi)
                if segEnd > 0.01 then -- Avoid drawing if not progressed into bottom half yet
                    local cac = slot._castArcColor
                    love.graphics.setColor(cac[1], cac[2], cac[3], cac[4])
                    local prevSrc, prevDst = love.graphics.getBlendMode()
                    love.graphics.setBlendMode("add")
                    local prevWidth = love.graphics.getLineWidth()
                    love.graphics.setLineWidth(3)
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, 0, segEnd, 32)
                    love.graphics.setBlendMode(prevSrc, prevDst)
                    love.graphics.setLineWidth(prevWidth)
                    WizardVisuals.drawEllipticalArc(slotX, slotY, radiusX, radiusY, 0, segEnd, 32)

                    if not slot._lastArcSpark or love.timer.getTime() - slot._lastArcSpark > 0.02 then
                        local hx = slotX + math.cos(endAngle) * radiusX
                        local hy = slotY + math.sin(endAngle) * radiusY
                        -- Spawn 3-5 particles per frame for much more generous particle effect
                        local particleCount = 3 + math.random(0, 2)
                        for p = 1, particleCount do
                            spawnArcSpark(slot, hx, hy, endAngle, cac)
                        end
                        slot._lastArcSpark = love.timer.getTime()
                    end
                end
            end

            -- Draw WARD runes that belong to the FRONT half
            if slot.active and slot.isShield and slot.defenseType == Constants.ShieldType.WARD then
                local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
                local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3

                local numRunes = 5
                local runeYOffset = 0
                local runeScale = 1.0

                local runeAssets
                if VFX.getAsset then
                    runeAssets = VFX.getAsset("runes")
                end
                if not runeAssets and VFX.assets then
                    runeAssets = VFX.assets.runes
                end

                if runeAssets and #runeAssets > 0 then
                    -- Determine rune color based on spell affinity if available
                    local baseColor
                    if slot.spell and slot.spell.affinity then
                        -- Use spell affinity color for more visual variety
                        baseColor = Constants.getColorForTokenType(slot.spell.affinity)
                    else
                        -- Fall back to shield type color
                        baseColor = shieldColor
                    end
                    
                    -- Enhanced contrast and visibility
                    local runeColor = {
                        math.min(1.0, baseColor[1] * (1.2 + pulseAmount * 0.8)),
                        math.min(1.0, baseColor[2] * (1.2 + pulseAmount * 0.8)),
                        math.min(1.0, baseColor[3] * (1.2 + pulseAmount * 0.8)),
                        0.95 + pulseAmount * 0.05  -- Higher base alpha for better visibility
                    }

                    for r = 1, numRunes do
                        local seed = i * 10 + r + math.floor(love.timer.getTime())
                        math.randomseed(seed)
                        local runeIndex = math.random(1, #runeAssets)
                        math.randomseed(os.time() + os.clock()*1000000)

                        local runeImg = runeAssets[runeIndex]
                        local angle = (r / numRunes) * math.pi * 2 + love.timer.getTime() * 0.7
                        local runeX = slotX + math.cos(angle) * radiusX
                        local runeY = slotY + math.sin(angle) * radiusY + runeYOffset

                        local normalizedAngle = angle % (math.pi * 2)
                        if normalizedAngle >= 0 and normalizedAngle <= math.pi then -- Front half
                            -- Dark outline for better contrast against backgrounds
                            love.graphics.setColor(0, 0, 0, runeColor[4] * 0.8)
                            for dx = -1, 1 do
                                for dy = -1, 1 do
                                    if dx ~= 0 or dy ~= 0 then
                                        love.graphics.draw(
                                            runeImg,
                                            runeX + dx, runeY + dy,
                                            0,
                                            runeScale, runeScale,
                                            runeImg:getWidth() / 2, runeImg:getHeight() / 2
                                        )
                                    end
                                end
                            end
                            
                            -- Bright glow pass for visibility
                            local prevBlendSrc, prevBlendDst = love.graphics.getBlendMode()
                            love.graphics.setBlendMode("add")
                            love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4] * 0.8)
                            love.graphics.draw(runeImg, runeX, runeY, 0, runeScale * 1.6, runeScale * 1.6, runeImg:getWidth()/2, runeImg:getHeight()/2)
                            love.graphics.setBlendMode(prevBlendSrc, prevBlendDst)

                            -- Main rune sprite with full opacity
                            love.graphics.setColor(runeColor[1], runeColor[2], runeColor[3], runeColor[4])
                            love.graphics.draw(runeImg, runeX, runeY, 0, runeScale, runeScale, runeImg:getWidth()/2, runeImg:getHeight()/2)
                        end
                    end
                end
            end

            -- Draw Barrier vertical hedge lines for the FRONT half
            if slot.active and slot.isShield and slot.defenseType == Constants.ShieldType.BARRIER then
                local shieldColor = ShieldSystem.getShieldColor(slot.defenseType)
                local pulseAmount = 0.2 + math.abs(math.sin(love.timer.getTime() * 2)) * 0.3
                local alpha = 0.7 + pulseAmount * 0.3
                local cylinderHeight = 20
                local numLines = 72
                local lineAlpha = alpha * 0.6

                love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                local prevWidthF = love.graphics.getLineWidth()
                love.graphics.setLineWidth(1.5)

                for k = 1, numLines do
                    local angle = (k / numLines) * math.pi * 2
                    local normalizedAngle = angle % (math.pi * 2)
                    -- FRONT half is 0 → π
                    if normalizedAngle <= math.pi then
                        local px = slotX + math.cos(angle) * radiusX
                        local py = slotY + math.sin(angle) * radiusY

                        -- Glow pass
                        local prevSrc, prevDst = love.graphics.getBlendMode()
                        love.graphics.setBlendMode("add")
                        love.graphics.setLineWidth(4)
                        love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha * 0.35)
                        love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                        love.graphics.setBlendMode(prevSrc, prevDst)

                        -- Main line
                        love.graphics.setLineWidth(1.5)
                        love.graphics.setColor(shieldColor[1], shieldColor[2], shieldColor[3], lineAlpha)
                        love.graphics.line(px, py - cylinderHeight / 2, px, py + cylinderHeight / 2)
                    end
                end
                love.graphics.setLineWidth(prevWidthF)
            end

            -- Re-draw tokens again in front layer to ensure they sit atop orbit/arc
            if slot.active and #slot.tokens > 0 then
                for j, tokenData in ipairs(slot.tokens) do
                    local token = tokenData.token
                    if token and token.status ~= Constants.TokenStatus.RETURNING and token.status ~= Constants.TokenStatus.DISSOLVING then
                        local normalizedAngle = (token.orbitAngle or 0) % (math.pi * 2)
                        local tokenLayer = (normalizedAngle >= 0 and normalizedAngle <= math.pi) and "front" or "back"
                        if tokenLayer == layer then
                            if token.status == Constants.TokenStatus.CHANNELED or token.status == Constants.TokenStatus.SHIELDING then
                                manaPool:drawToken(token)
                            end
                        end
                    end
                end
            end

            -- Draw spark particles for this slot
            if slot._arcParticles and #slot._arcParticles > 0 then
                for _, p in ipairs(slot._arcParticles) do
                    local alpha = (p.life / p.maxLife)
                    love.graphics.setColor(p.color[1], p.color[2], p.color[3], alpha)
                    love.graphics.draw(p.img, p.x, p.y, 0, 1, 1, p.img:getWidth()/2, p.img:getHeight()/2)
                end
            end
        end
    end -- End of loop through spell slots
end

-- Main function to draw the wizard
function WizardVisuals.drawWizard(wizard)
    -- Calculate target position adjustments based on elevation and range state
    local targetYOffset = 0
    local targetXOffset = 0
    
    -- Vertical adjustment for AERIAL state - increased for more dramatic effect
    if wizard.elevation == Constants.ElevationState.AERIAL then
        targetYOffset = -50  -- Lift the wizard up more significantly when AERIAL
    end
    
    -- Horizontal adjustment for NEAR/FAR state
    local isNear = wizard.gameState and wizard.gameState.rangeState == Constants.RangeState.NEAR
    local centerX = love.graphics.getWidth() / 2
    
    -- Determine relative position compared to the other combatant
    local isLeft = true
    if wizard.gameState and wizard.gameState.wizards then
        for _, other in ipairs(wizard.gameState.wizards) do
            if other ~= wizard then
                isLeft = wizard.x <= other.x
                break
            end
        end
    end

    -- Push wizards closer to center in NEAR mode, further in FAR mode
    if isLeft then
        targetXOffset = isNear and 60 or 0 -- Move right when NEAR
    else
        targetXOffset = isNear and -60 or 0 -- Move left when NEAR
    end
    
    -- Check if position needs to change and start animation if needed
    if not wizard.positionAnimation.active and
       ((wizard.currentXOffset or 0) ~= targetXOffset or 
        (wizard.currentYOffset or 0) ~= targetYOffset) then
        -- Start animation
        wizard.positionAnimation.active = true
        wizard.positionAnimation.startX = wizard.currentXOffset or 0
        wizard.positionAnimation.startY = wizard.currentYOffset or 0
        wizard.positionAnimation.targetX = targetXOffset
        wizard.positionAnimation.targetY = targetYOffset
        wizard.positionAnimation.progress = 0
    end
    
    -- Calculate and apply current offsets (animated or target)
    local xOffset, yOffset
    if wizard.positionAnimation.active then
        -- Use interpolated position with easing
        local progress = WizardVisuals.easeOutCubic(wizard.positionAnimation.progress)
        xOffset = wizard.positionAnimation.startX + 
                 (wizard.positionAnimation.targetX - wizard.positionAnimation.startX) * progress
        yOffset = wizard.positionAnimation.startY + 
                 (wizard.positionAnimation.targetY - wizard.positionAnimation.startY) * progress
    else
        -- Use target position directly
        xOffset = targetXOffset
        yOffset = targetYOffset
    end
    
    -- Determine the wizard sprite color based on state
    local wizardColor = {1, 1, 1, 1} -- Default white color
    
    if wizard.hitFlashTimer > 0 then
        -- Store the default wizard color
        wizard.flashBlendMode = "add" -- Will use additive blending for flash
        
        -- Use bright white (values > 1 for over-brightness effect)
        wizardColor = {2.0, 2.0, 2.0, 1} -- Super bright white
        
        -- Flash effect is now implemented with additive blending
    elseif wizard.statusEffects.stun and wizard.statusEffects.stun.active then
        -- Apply a yellow/white flash for stunned wizards
        local flashIntensity = 0.5 + math.sin(love.timer.getTime() * 10) * 0.5
        wizardColor = {1, 1, flashIntensity, 1}
    end
    
    -- Set initial color for ground indicator
    love.graphics.setColor(1, 1, 1, 1)
    
    -- Draw elevation effect (GROUNDED only - AERIAL clouds moved after wizard)
    if wizard.elevation == Constants.ElevationState.GROUNDED then
        -- Draw ground indicator below wizard, applying the x offset
        love.graphics.setColor(0.6, 0.6, 0.6, 0.5)
        love.graphics.ellipse("fill", wizard.x + xOffset, wizard.y + 40, 40, 10)  -- Simple shadow/ground indicator
    end
    
    -- Store current offsets for other functions to use
    wizard.currentXOffset = xOffset
    wizard.currentYOffset = yOffset

    -- Draw spell slots and tokens behind the wizard
    WizardVisuals.drawSpellSlots(wizard, "back")
    
    -- Draw the wizard sprite
    if wizard.sprite then
        -- Flip sprite based on whether this wizard is on the left or right
        local isLeft = true
        if wizard.gameState and wizard.gameState.wizards then
            for _, other in ipairs(wizard.gameState.wizards) do
                if other ~= wizard then
                    isLeft = wizard.x <= other.x
                    break
                end
            end
        end
        local flipX = isLeft and 1 or -1
        local adjustedScale = wizard.scale * flipX

        -- Determine which sprite to draw based on positional animation sets
        local spriteToDraw
        local posKey = wizard:getPositionalKey()
        local castSprite = wizard:getCastFrameForKey(posKey)
        local idleFrames = wizard:getIdleFramesForKey(posKey)

        if wizard.castFrameTimer > 0 and castSprite then
            spriteToDraw = castSprite
        elseif idleFrames and #idleFrames > 0 then
            spriteToDraw = idleFrames[wizard.currentIdleFrame]
        else
            spriteToDraw = wizard.sprite
        end

        -- Ensure spriteToDraw is not nil before attempting to draw
        if not spriteToDraw then
            print("Error: No sprite to draw for wizard " .. wizard.name)
            -- Draw a placeholder rectangle as a last resort
            love.graphics.setColor(1, 0, 0, 1) -- Red error color
            love.graphics.rectangle("fill", wizard.x + xOffset - 20, wizard.y + yOffset - 30, 40, 60)
            love.graphics.setColor(1, 1, 1, 1) -- Reset color
            return
        end

        -- Draw shadow first (when not AERIAL)
        if wizard.elevation == Constants.ElevationState.GROUNDED then
            love.graphics.setColor(0, 0, 0, 0.2)
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + 40, -- Shadow on ground
                0, -- No rotation
                adjustedScale * 0.8, -- Slightly smaller shadow
                wizard.scale * 0.3, -- Flatter shadow
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )
        end

        -- Draw the actual wizard with the appropriate color based on state

        -- For hit flash, we use a special blend mode and draw the sprite twice
        if wizard.hitFlashTimer > 0 then
            -- First draw the normal sprite
            love.graphics.setColor(1, 1, 1, 1)
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + yOffset,
                0, -- No rotation
                adjustedScale * 2, -- Double scale
                wizard.scale * 2, -- Double scale
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )

            -- Save current blend mode
            local prevBlendMode = love.graphics.getBlendMode()

            -- Set additive blend mode for glow effect
            love.graphics.setBlendMode("add")

            -- Draw the bright overlay
            love.graphics.setColor(wizardColor[1], wizardColor[2], wizardColor[3], wizardColor[4])

            -- Then overdraw with bright additive color
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + yOffset,
                0, -- No rotation
                adjustedScale * 2, -- Double scale
                wizard.scale * 2, -- Double scale
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )

            -- Restore previous blend mode
            love.graphics.setBlendMode(prevBlendMode)
        else
            -- Normal drawing
            love.graphics.setColor(wizardColor[1], wizardColor[2], wizardColor[3], wizardColor[4])
            love.graphics.draw(
                spriteToDraw,
                wizard.x + xOffset,
                wizard.y + yOffset,
                0, -- No rotation
                adjustedScale * 2, -- Double scale
                wizard.scale * 2, -- Double scale
                spriteToDraw:getWidth() / 2,
                spriteToDraw:getHeight() / 2
            )
        end -- End of if wizard.hitFlashTimer > 0 block
        
        -- Reset color back to default after drawing wizard
        love.graphics.setColor(1, 1, 1, 1)

        -- Draw AERIAL cloud effect after wizard for proper layering
        if wizard.elevation == Constants.ElevationState.AERIAL then
            love.graphics.setColor(0.8, 0.8, 1.0, 0.3)

            -- Draw more numerous, smaller animated cloud particles
            for i = 1, 8 do
                -- Calculate wobble in both x and y directions
                local time = love.timer.getTime()
                local angle = (i / 8) * math.pi * 2 + time
                local xWobble = math.sin(time * 2 + i * 1.5) * 15
                local yWobble = math.cos(time * 1.8 + i * 1.7) * 10

                -- Vary sizes for more natural look
                local width = 20 + math.sin(time + i) * 5
                local height = 6 + math.cos(time + i) * 2

                love.graphics.ellipse(
                    "fill",
                    wizard.x + xOffset + xWobble,
                    wizard.y + yOffset + 40 + yWobble,
                    width,
                    height
                )
            end
        end
    else
        -- Fallback if sprite not loaded - draw a colored circle
        love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255)
        love.graphics.circle("fill", wizard.x + xOffset, wizard.y + yOffset, 30)
    end
    
    -- Draw block visual effect if active
    if wizard.blockVFX and wizard.blockVFX.active then
        wizard.blockVFX.timer = wizard.blockVFX.timer - love.timer.getDelta()
        
        if wizard.blockVFX.timer <= 0 then
            wizard.blockVFX.active = false
        else
            -- Pulse effect for shield block
            local pulseSize = 50 * (1 - wizard.blockVFX.timer / 0.5)
            local alpha = wizard.blockVFX.timer / 0.5
            
            love.graphics.setColor(0.2, 0.8, 1.0, alpha)
            love.graphics.circle("line", wizard.blockVFX.x + xOffset, wizard.blockVFX.y + yOffset, pulseSize)
        end
    end
    
    -- Draw spell slots and tokens in front of the wizard
    WizardVisuals.drawSpellSlots(wizard, "front")
    
    -- Draw status effects
    WizardVisuals.drawStatusEffects(wizard)
    
    -- Draw casting notification if present
    if wizard.spellCastNotification then
        -- Update timer
        wizard.spellCastNotification.timer = wizard.spellCastNotification.timer - love.timer.getDelta()
        
        if wizard.spellCastNotification.timer <= 0 then
            wizard.spellCastNotification = nil
        else
            -- Draw the notification text
            love.graphics.setColor(
                wizard.spellCastNotification.color[1],
                wizard.spellCastNotification.color[2],
                wizard.spellCastNotification.color[3],
                wizard.spellCastNotification.timer / 2.0  -- Fade out
            )
            
            love.graphics.print(
                wizard.spellCastNotification.text,
                wizard.spellCastNotification.x - 40 + xOffset,  -- Center text approximately
                wizard.spellCastNotification.y + yOffset
            )
        end
    end
end

return WizardVisuals```

## ./tools/check_magic_strings.lua
```lua
-- check_magic_strings.lua
-- CI tool to detect magic strings that should be using Constants

-- List of patterns to search for in the codebase
local magicStringPatterns = {
    -- Token Types
    '"fire"', "'fire'", '"water"', "'water'", '"salt"', "'salt'", '"sun"', "'sun'",
    '"moon"', "'moon'", '"star"', "'star'", '"life"', "'life'", '"mind"', "'mind'", '"void"', "'void'",
    '"random"', "'random'",
    '"any"', "'any'",
    
    -- Token States
    '"FREE"', "'FREE'", '"CHANNELED"', "'CHANNELED'",
    '"SHIELDING"', "'SHIELDING'", '"LOCKED"', "'LOCKED'",
    '"DESTROYED"', "'DESTROYED'",
    
    -- Range States
    '"NEAR"', "'NEAR'", '"FAR"', "'FAR'",
    
    -- Elevation States
    '"GROUNDED"', "'GROUNDED'", '"AERIAL"', "'AERIAL'",
    
    -- Shield Types
    '"barrier"', "'barrier'", '"ward"', "'ward'",
    '"field"', "'field'",
    
    -- Attack Types
    '"projectile"', "'projectile'", '"remote"', "'remote'",
    '"zone"', "'zone'", '"utility"', "'utility'",
    
    -- Target Types
    '"SELF"', "'SELF'", '"ENEMY"', "'ENEMY'",
    
    -- Damage Types
    '"generic"', "'generic'", '"mixed"', "'mixed'"
}

-- Files to exclude from checking (e.g., test files, documentation)
local excludedPaths = {
    "spec/",
    "test_",
    "docs/",
    "tools/",
    "check_magic_strings.lua",
    "Constants.lua",
    "assets/",
    "vfx/",
    -- Exclude legacy/data files that will be difficult to update
    "spells.lua", -- Legacy data
    "test_spells.lua" -- Test file
}

-- Check if a file should be excluded
local function isExcluded(filepath)
    for _, pattern in ipairs(excludedPaths) do
        if filepath:find(pattern) then
            return true
        end
    end
    return false
end

-- Scan a file for magic strings
local function scanFile(filepath)
    if isExcluded(filepath) then
        return {}
    end
    
    local file = io.open(filepath, "r")
    if not file then
        print("Warning: Could not open file: " .. filepath)
        return {}
    end
    
    local content = file:read("*all")
    file:close()
    
    local issues = {}
    local lineNumber = 1
    
    -- Process file line by line
    for line in content:gmatch("[^\r\n]+") do
        for _, pattern in ipairs(magicStringPatterns) do
            -- Simple pattern matching for demonstration
            if line:find(pattern) then
                -- Check if it's not in a comment or string explanation
                if not line:match("^%s*%-%-") then
                    -- Ignore if it's part of a Constants reference
                    if not line:find("Constants%.") then
                        -- Ignore if it's in a comment at end of line
                        if not line:match("%-%-.*" .. pattern) then
                            -- Ignore if it appears to be in a block definition context (for legacy compatibility)
                            if not line:match("supportedTypes%s*=%s*{.*" .. pattern .. ".*}") and
                               not line:match("cost%s*=%s*{.*" .. pattern .. ".*}") and
                               not line:match("return%s+.*" .. pattern) then
                                table.insert(issues, {
                                    line = lineNumber,
                                    pattern = pattern,
                                    content = line:gsub("^%s+", ""):sub(1, 80) -- Trim and truncate for display
                                })
                            end
                        end
                    end
                end
            end
        end
        lineNumber = lineNumber + 1
    end
    
    return issues
end

-- Recursively scan directory for .lua files
local function scanDirectory(dirPath)
    local issues = {}
    local files = {}
    
    -- In a real implementation, use io.popen to list files
    -- For now, let's just hardcode a list of main files to check
    files = {
        "main.lua",
        "wizard.lua",
        "manapool.lua",
        "spellCompiler.lua",
        "ui.lua",
        "vfx.lua",
        "systems/ManaHelpers.lua",
        "systems/WizardVisuals.lua",
        "systems/ShieldSystem.lua",
        "systems/TokenManager.lua",
        "systems/VisualResolver.lua",
        "systems/EventRunner.lua",
        "systems/SustainedSpellManager.lua",
        "ai/OpponentAI.lua"
    }
    
    for _, filename in ipairs(files) do
        local filepath = dirPath .. "/" .. filename
        local fileIssues = scanFile(filepath)
        
        if #fileIssues > 0 then
            issues[filepath] = fileIssues
        end
    end
    
    return issues
end

-- Main function
local function main()
    local startDir = arg[1] or "."
    local allIssues = scanDirectory(startDir)
    
    -- Count total issues
    local totalIssues = 0
    for _, fileIssues in pairs(allIssues) do
        totalIssues = totalIssues + #fileIssues
    end
    
    -- Print results
    print("Magic String Check Results")
    print("=========================")
    print("Found " .. totalIssues .. " potential magic string issues")
    
    for filepath, fileIssues in pairs(allIssues) do
        print("\n" .. filepath .. " (" .. #fileIssues .. " issues):")
        for _, issue in ipairs(fileIssues) do
            print(string.format("  Line %d: %s => %s", 
                issue.line, issue.pattern, issue.content))
        end
    end
    
    -- Set exit code for CI
    os.exit(totalIssues > 0 and 1 or 0)
end

main()```

## ./tools/fix_vfx_events.lua
```lua
-- fix_vfx_events.lua
-- Script to update spells to properly use the event system for VFX

local Spells = require("spells").spells
local Keywords = require("keywords")
local Constants = require("core.Constants")
local SpellCompiler = require("spellCompiler")

-- Color formatting for console output
local colors = {
    reset = "\27[0m",
    red = "\27[31m",
    green = "\27[32m",
    yellow = "\27[33m",
    blue = "\27[34m",
    magenta = "\27[35m",
    cyan = "\27[36m"
}

-- Convert a spell's top-level VFX property to a vfx keyword
local function updateSpellVfx(spell)
    if not spell then return false end
    
    -- Skip spells that already use the vfx keyword properly
    if spell.keywords and spell.keywords.vfx then
        print(colors.green .. "✓ " .. spell.name .. " already using vfx keyword" .. colors.reset)
        return false
    end
    
    -- Skip utility spells without VFX if they're not meant to have visuals
    if spell.attackType == Constants.AttackType.UTILITY and not spell.vfx then
        print(colors.yellow .. "⚠ Skipping utility spell without VFX: " .. spell.name .. colors.reset)
        return false
    end
    
    -- If the spell has a top-level VFX property but no vfx keyword,
    -- add the vfx keyword using the top-level VFX value
    if spell.vfx then
        -- Create the keywords table if it doesn't exist
        spell.keywords = spell.keywords or {}
        
        -- Different handling based on attack type to determine target
        local targetType = Constants.TargetType.ENEMY
        if spell.attackType == Constants.AttackType.UTILITY then
            -- For utility spells, target self
            targetType = Constants.TargetType.SELF
        elseif spell.vfx:find("conjure") then
            -- For conjuration effects, target the pool
            targetType = "POOL_SELF"
        end
        
        -- Get the proper VFX type from Constants if possible
        local effectType = spell.vfx
        for typeName, typeValue in pairs(Constants.VFXType) do
            if typeValue == spell.vfx then
                effectType = typeValue
                break
            end
        end
        
        -- Add the vfx keyword with appropriate parameters
        spell.keywords.vfx = {
            effect = effectType,
            target = targetType
        }
        
        print(colors.green .. "✓ Added vfx keyword to " .. spell.name .. 
              " with effect=" .. effectType .. ", target=" .. targetType .. colors.reset)
        return true
    end
    
    -- Check for special cases like ground/elevate that have built-in VFX
    local hasBuiltInVfx = false
    if spell.keywords then
        for keyword, _ in pairs(spell.keywords) do
            if keyword == "ground" or keyword == "elevate" then
                hasBuiltInVfx = true
                break
            end
        end
    end
    
    if hasBuiltInVfx then
        print(colors.blue .. "ℹ " .. spell.name .. " uses keywords with built-in VFX" .. colors.reset)
        return false
    end
    
    -- If we get here, the spell has no VFX defined and should probably have one
    print(colors.red .. "✗ " .. spell.name .. " has no VFX defined" .. colors.reset)
    return false
end

-- Main function to update all spells
local function updateAllSpells()
    print(colors.cyan .. "=== Updating Spells VFX Events ===" .. colors.reset)
    
    local stats = {
        total = 0,
        updated = 0,
        alreadyCorrect = 0,
        skipped = 0,
        noVfx = 0
    }
    
    -- Process all spells
    for spellId, spell in pairs(Spells) do
        stats.total = stats.total + 1
        
        local updated = updateSpellVfx(spell)
        if updated then
            stats.updated = stats.updated + 1
        elseif spell.keywords and spell.keywords.vfx then
            stats.alreadyCorrect = stats.alreadyCorrect + 1
        elseif spell.attackType == Constants.AttackType.UTILITY and not spell.vfx then
            stats.skipped = stats.skipped + 1
        else
            stats.noVfx = stats.noVfx + 1
        end
    end
    
    -- Print summary statistics
    print(colors.cyan .. "\n=== Summary ===" .. colors.reset)
    print("Total spells: " .. stats.total)
    print(colors.green .. "Already using vfx keyword: " .. stats.alreadyCorrect .. colors.reset)
    print(colors.green .. "Updated to use vfx keyword: " .. stats.updated .. colors.reset)
    print(colors.yellow .. "Skipped (utility without VFX): " .. stats.skipped .. colors.reset)
    print(colors.red .. "Still missing VFX: " .. stats.noVfx .. colors.reset)
    
    return stats
end

-- Run the update process
local stats = updateAllSpells()

-- Return stats for use in automated systems
return stats```

## ./tools/generate_docs.lua
```lua
#!/usr/bin/env lua
-- Script to generate keyword documentation

-- Add manastorm root directory to lua path
package.path = package.path .. ";../?.lua"

-- Import the documentation generator
local DocGenerator = require("docs.keywords")

-- Generate the documentation
DocGenerator.writeDocumentation("../docs/KEYWORDS.md")

print("Documentation generation complete!")```

## ./tools/generate_vfx_report.lua
```lua
-- generate_vfx_report.lua
-- Script to generate a detailed report of spell VFX usage

local Spells = require("spells").spells
local Keywords = require("keywords")
local Constants = require("core.Constants")
local SpellCompiler = require("spellCompiler")

-- Function to determine the correct VFX type for a spell based on its properties
local function determineCorrectVfx(spell)
    -- If the spell already uses vfx keyword, assume it's correct
    if spell.keywords and spell.keywords.vfx then
        local effect = spell.keywords.vfx.effect
        -- Handle both string and Constants.VFXType references
        if type(effect) == "string" then
            return effect
        else
            return tostring(effect) -- Convert constant to string
        end
    end
    
    -- If the spell has a top-level vfx property, use that
    if spell.vfx then
        return spell.vfx
    end
    
    -- Check for keywords with built-in VFX
    if spell.keywords then
        -- Check ground keyword
        if spell.keywords.ground then
            local groundVfx = spell.keywords.ground.vfx
            if groundVfx then
                return groundVfx
            else
                return "tidal_force_ground" -- Default for ground
            end
        end
        
        -- Check elevate keyword
        if spell.keywords.elevate then
            local elevateVfx = spell.keywords.elevate.vfx
            if elevateVfx then
                return elevateVfx
            else
                return "emberlift" -- Default for elevate
            end
        end
    end
    
    -- Otherwise, determine based on spell type and element
    local spellElement = spell.affinity
    local attackType = spell.attackType
    
    -- Mapping of element + attack type to suggested VFX
    local elementAttackMap = {
        -- Fire element
        fire = {
            projectile = "firebolt",
            remote = "firebolt",
            zone = "meteor",
            utility = "conjurefire"
        },
        -- Moon element
        moon = {
            projectile = "lunardisjunction",
            remote = "fullmoonbeam",
            zone = "mistveil",
            utility = "conjuremoonlight"
        },
        -- Sun element
        sun = {
            projectile = "firebolt",
            remote = "meteor",
            zone = "blazing_ascent",
            utility = "nova_conjure"
        },
        -- Water element
        water = {
            projectile = "tidal_force",
            remote = "tidal_force",
            zone = "tidal_force_ground",
            utility = "mistveil"
        },
        -- Generic fallbacks
        generic = {
            projectile = "firebolt",
            remote = "impact",
            zone = "impact",
            utility = "impact"
        }
    }
    
    -- Get the element-specific map or fall back to generic
    local elementMap = elementAttackMap[spellElement] or elementAttackMap.generic
    
    -- Get the attack-specific VFX or fall back to impact
    return elementMap[attackType] or "impact"
end

-- Function to get the proper formatting for VFX values
local function formatVfxValue(value)
    if not value then return "N/A" end
    
    -- Check if it's a Constants.VFXType value
    for typeName, typeValue in pairs(Constants.VFXType) do
        if typeValue == value then
            return string.format("Constants.VFXType.%s", typeName)
        end
    end
    
    -- If it's just a string, return it with quotes
    return string.format('"%s"', value)
end

-- Function to check if a spell has events in the test
local function hasEffectEvents(spell)
    -- Skip if no spell
    if not spell then return false end
    
    -- Dummy objects for testing
    local dummyCaster = {
        name = "Test Caster",
        elevation = Constants.ElevationState.GROUNDED,
        gameState = { rangeState = Constants.RangeState.NEAR },
        spellSlots = { {}, {}, {} },
        manaPool = { tokens = {} }
    }
    
    local dummyTarget = {
        name = "Test Target",
        elevation = Constants.ElevationState.GROUNDED,
        gameState = { rangeState = Constants.RangeState.NEAR },
        spellSlots = { {}, {}, {} },
        manaPool = { tokens = {} }
    }
    
    -- Compile the spell
    local compiledSpell = SpellCompiler.compileSpell(spell, Keywords)
    if not compiledSpell then return false end
    
    -- Generate events but don't execute them
    local events = compiledSpell.generateEvents(dummyCaster, dummyTarget, 1)
    
    -- Check for EFFECT events
    for _, event in ipairs(events or {}) do
        if event.type == "EFFECT" then
            return true
        end
    end
    
    return false
end

-- Main function to generate the report
local function generateReport()
    print("Generating VFX report...")
    
    -- Table headers for markdown
    local report = "# Spells VFX Audit Report\n\n"
    report = report .. "This report shows the current VFX setup for each spell and recommendations for improvement.\n\n"
    report = report .. "| Spell Name | Element | Attack Type | Current VFX | Using VFX Keyword | Generates EFFECT Events | Recommended VFX | Status |\n"
    report = report .. "|------------|---------|-------------|-------------|-------------------|------------------------|-----------------|--------|\n"
    
    -- Process all spells and add to report
    local stats = {
        total = 0,
        correct = 0,
        needsKeyword = 0,
        noVfx = 0
    }
    
    -- Sort spells by name
    local sortedSpells = {}
    for _, spell in pairs(Spells) do
        table.insert(sortedSpells, spell)
    end
    
    table.sort(sortedSpells, function(a, b) return a.name < b.name end)
    
    -- Process sorted spells
    for _, spell in ipairs(sortedSpells) do
        stats.total = stats.total + 1
        
        local currentVfx = spell.vfx or "None"
        local usesVfxKeyword = (spell.keywords and spell.keywords.vfx) and "Yes" or "No"
        local hasEvents = hasEffectEvents(spell) and "Yes" or "No"
        local recommendedVfx = determineCorrectVfx(spell)
        
        -- Determine status
        local status
        if hasEvents == "Yes" then
            status = "✅ Correct"
            stats.correct = stats.correct + 1
        elseif usesVfxKeyword == "No" and currentVfx ~= "None" then
            status = "⚠️ Needs VFX Keyword"
            stats.needsKeyword = stats.needsKeyword + 1
        elseif currentVfx == "None" and spell.attackType ~= "utility" then
            status = "❌ Missing VFX"
            stats.noVfx = stats.noVfx + 1
        else
            status = "⚠️ Review"
            stats.needsKeyword = stats.needsKeyword + 1
        end
        
        -- Add row to report
        report = report .. string.format("| %s | %s | %s | %s | %s | %s | %s | %s |\n",
            spell.name,
            spell.affinity or "N/A",
            spell.attackType or "N/A",
            currentVfx,
            usesVfxKeyword,
            hasEvents,
            recommendedVfx,
            status
        )
    end
    
    -- Add statistics section
    report = report .. "\n## Summary Statistics\n\n"
    report = report .. string.format("- **Total Spells:** %d\n", stats.total)
    report = report .. string.format("- **Correctly Implemented:** %d (%.1f%%)\n", 
        stats.correct, (stats.correct / stats.total) * 100)
    report = report .. string.format("- **Needs VFX Keyword:** %d (%.1f%%)\n", 
        stats.needsKeyword, (stats.needsKeyword / stats.total) * 100)
    report = report .. string.format("- **Missing VFX:** %d (%.1f%%)\n", 
        stats.noVfx, (stats.noVfx / stats.total) * 100)
    
    -- Implementation recommendations
    report = report .. "\n## Implementation Recommendations\n\n"
    report = report .. "1. **Replace top-level VFX properties with VFX keywords:**\n"
    report = report .. "   ```lua\n"
    report = report .. "   -- Before:\n"
    report = report .. "   vfx = \"firebolt\",\n\n"
    report = report .. "   -- After:\n"
    report = report .. "   keywords = {\n"
    report = report .. "       -- other keywords...\n"
    report = report .. "       vfx = { effect = Constants.VFXType.FIREBOLT, target = Constants.TargetType.ENEMY }\n"
    report = report .. "   },\n"
    report = report .. "   ```\n\n"
    
    report = report .. "2. **Add VFX keywords to spells missing visual effects:**\n"
    report = report .. "   - Use Constants.VFXType for standard effect names\n"
    report = report .. "   - Match the effect type to the spell's element and attack pattern\n"
    report = report .. "   - Consider spell's role when selecting the visual effect\n\n"
    
    report = report .. "3. **Run the automated fix tool:**\n"
    report = report .. "   ```bash\n"
    report = report .. "   lua tools/fix_vfx_events.lua\n"
    report = report .. "   ```\n\n"
    
    report = report .. "4. **Test with the VFX events test:**\n"
    report = report .. "   ```bash\n"
    report = report .. "   lua tools/test_vfx_events.lua\n"
    report = report .. "   ```\n"
    
    print("Report generated successfully!")
    return report
end

-- Generate the report
local report = generateReport()

-- Write report to file
local reportPath = "/Users/russell/Manastorm/docs/VFX_Audit_Report.md"
local file = io.open(reportPath, "w")
if file then
    file:write(report)
    file:close()
    print("Report written to: " .. reportPath)
else
    print("Error: Could not write report to file")
end

-- Return success
return true```

## ./tools/test_particle_manager.lua
```lua
-- test_particle_manager.lua
-- A script to test ParticleManager integration with vfx.lua

local Pool = require("core.Pool")
local ParticleManager = require("vfx.ParticleManager")
local VFX = require("vfx")

-- Initialize the VFX system
VFX.init()

-- Count the total particles created and returned to pool
local function testParticlePooling()
    print("\n=== TESTING PARTICLE POOLING ===")
    
    -- Get initial stats
    local initialStats = ParticleManager.getStats()
    print(string.format("Initial pool: %d total (%d active, %d available)", 
        initialStats.poolSize, initialStats.active, initialStats.available))
    
    -- Create effects with different types
    local effects = {}
    
    print("\nCreating test effects...")
    
    -- Test a projectile effect
    local projectile = VFX.createEffect("proj_base", 100, 100, 500, 300, {
        color = {1, 0, 0, 1}, -- Red
    })
    table.insert(effects, projectile)
    print("Created projectile effect with " .. #projectile.particles .. " particles")
    
    -- Test an impact effect
    local impact = VFX.createEffect("impact_base", 300, 300, 300, 300, {
        color = {0, 1, 0, 1}, -- Green
    })
    table.insert(effects, impact)
    print("Created impact effect with " .. #impact.particles .. " particles")
    
    -- Test a cone effect
    local cone = VFX.createEffect("blast_base", 200, 400, 500, 200, {
        color = {0, 0, 1, 1}, -- Blue
    })
    table.insert(effects, cone)
    print("Created cone effect with " .. #cone.particles .. " particles")
    
    -- Test a beam effect
    local beam = VFX.createEffect("beam_base", 100, 400, 600, 400, {
        color = {1, 1, 0, 1}, -- Yellow
    })
    table.insert(effects, beam)
    print("Created beam effect with " .. #beam.particles .. " particles")
    
    -- Test an aura effect
    local aura = VFX.createEffect("zone_base", 400, 300, 400, 300, {
        color = {1, 0, 1, 1}, -- Purple
    })
    table.insert(effects, aura)
    print("Created aura effect with " .. #aura.particles .. " particles")
    
    -- Test a remote effect
    local remote = VFX.createEffect("remote_base", 300, 100, 300, 100, {
        color = {0, 1, 1, 1}, -- Cyan
    })
    table.insert(effects, remote)
    print("Created remote effect with " .. #remote.particles .. " particles")
    
    -- Test a surge effect
    local surge = VFX.createEffect("surge_base", 500, 500, 500, 500, {
        color = {1, 0.5, 0, 1}, -- Orange
    })
    table.insert(effects, surge)
    print("Created surge effect with " .. #surge.particles .. " particles")
    
    -- Test a conjure effect
    local conjure = VFX.createEffect("conjure_base", 200, 500, 200, 500, {
        color = {0.5, 0.5, 1, 1}, -- Light blue
    })
    table.insert(effects, conjure)
    print("Created conjure effect with " .. #conjure.particles .. " particles")
    
    -- Get stats after creating effects
    local afterCreateStats = ParticleManager.getStats()
    print(string.format("\nAfter creating effects: %d total (%d active, %d available)", 
        afterCreateStats.poolSize, afterCreateStats.active, afterCreateStats.available))
    
    -- Count total particles created
    local totalParticles = 0
    for _, effect in ipairs(effects) do
        totalParticles = totalParticles + #effect.particles
    end
    print("Total particles created: " .. totalParticles)
    
    -- Release all effects and their particles
    print("\nReleasing all effects and particles...")
    for i, effect in ipairs(effects) do
        print("Releasing effect " .. i .. " with " .. #effect.particles .. " particles")
        -- First release all particles
        for _, particle in ipairs(effect.particles) do
            ParticleManager.releaseParticle(particle)
        end
        -- Then release the effect
        Pool.release("vfx_effect", effect)
    end
    
    -- Get final stats
    local finalStats = ParticleManager.getStats()
    print(string.format("\nFinal pool: %d total (%d active, %d available)", 
        finalStats.poolSize, finalStats.active, finalStats.available))
    
    -- Verify all particles were returned to the pool
    if finalStats.active == 0 and finalStats.available == finalStats.poolSize then
        print("\n✓ SUCCESS: All particles were returned to the pool!")
    else
        print("\n✗ FAILURE: Not all particles were returned to the pool.")
        print("  Expected active=0, got " .. finalStats.active)
        print("  Expected available=" .. finalStats.poolSize .. ", got " .. finalStats.available)
    end
end

-- Run the test
testParticlePooling()

return {
    testParticlePooling = testParticlePooling
}```

## ./tools/test_vfx_events.lua
```lua
-- test_vfx_events.lua
-- Test script to verify all spells generate VFX events correctly

local SpellCompiler = require("spellCompiler")
local Spells = require("spells").spells
local Keywords = require("keywords")
local Constants = require("core.Constants")

-- Create dummy caster/target/slot objects for testing
local dummyCaster = {
    name = "Test Caster",
    elevation = Constants.ElevationState.GROUNDED,
    gameState = {
        rangeState = Constants.RangeState.NEAR
    },
    spellSlots = {
        { active = false },
        { active = false },
        { active = false }
    },
    manaPool = {
        tokens = {}
    }
}

local dummyTarget = {
    name = "Test Target",
    elevation = Constants.ElevationState.GROUNDED,
    gameState = {
        rangeState = Constants.RangeState.NEAR
    },
    spellSlots = {
        { active = false },
        { active = false },
        { active = false }
    },
    manaPool = {
        tokens = {}
    }
}

local dummySlot = 1

-- Main test function
local function runTest()
    print("=== VFX Events Test ===")
    print("Testing all spells for EFFECT events...")
    
    local results = {
        total = 0,
        passed = 0,
        failed = 0,
        skipped = 0,
        utilityNoVfx = 0
    }
    
    local failures = {}
    
    -- Process all spells
    for spellId, spell in pairs(Spells) do
        results.total = results.total + 1
        
        -- Skip certain spells known to have no visuals
        if spell.skipVfxTest then
            results.skipped = results.skipped + 1
            print(string.format("[SKIP] %s (marked to skip VFX test)", spell.name))
            goto continue
        end
        
        -- Compile the spell
        local compiledSpell = SpellCompiler.compileSpell(spell, Keywords)
        if not compiledSpell then
            table.insert(failures, string.format("Failed to compile spell: %s", spell.name))
            results.failed = results.failed + 1
            goto continue
        end
        
        -- Generate events but don't execute them
        local events = compiledSpell.generateEvents(dummyCaster, dummyTarget, dummySlot)
        
        -- Check for at least one EFFECT event
        local hasEffectEvent = false
        if events then
            for _, event in ipairs(events) do
                if event.type == "EFFECT" then
                    hasEffectEvent = true
                    break
                end
            end
        end
        
        -- Handle utility spells without VFX specially 
        if not hasEffectEvent and spell.attackType == Constants.AttackType.UTILITY and not spell.vfx then
            print(string.format("[INFO] Utility spell with no VFX: %s", spell.name))
            results.utilityNoVfx = results.utilityNoVfx + 1
            goto continue
        end
        
        -- Check if the spell has a VFX defined at the top level
        local hasTopLevelVfx = (spell.vfx ~= nil)
        
        -- Check if the spell has keywords that should generate VFX
        local hasVfxKeyword = false
        if spell.keywords and spell.keywords.vfx then
            hasVfxKeyword = true
        end
        
        -- Check for keywords that have built-in VFX
        local hasBuiltInVfx = false
        if spell.keywords then
            for keyword, _ in pairs(spell.keywords) do
                if keyword == "ground" or keyword == "elevate" then
                    hasBuiltInVfx = true
                    break
                end
            end
        end
        
        -- Test result
        if hasEffectEvent then
            print(string.format("[PASS] %s generates EFFECT events", spell.name))
            results.passed = results.passed + 1
        else
            -- Log what's missing
            local missing = ""
            if not hasTopLevelVfx and not hasVfxKeyword and not hasBuiltInVfx then
                missing = "both top-level VFX and VFX keyword"
            elseif not hasVfxKeyword then
                missing = "VFX keyword (has top-level VFX)"
            else
                missing = "proper event generation"
            end
            
            table.insert(failures, string.format("%s: Missing %s", spell.name, missing))
            results.failed = results.failed + 1
        end
        
        ::continue::
    end
    
    -- Print test results
    print("\n=== Test Results ===")
    print(string.format("Total spells tested: %d", results.total))
    print(string.format("Passed: %d (%.1f%%)", results.passed, (results.passed / results.total) * 100))
    print(string.format("Failed: %d (%.1f%%)", results.failed, (results.failed / results.total) * 100))
    print(string.format("Skipped: %d", results.skipped))
    print(string.format("Utility spells without VFX: %d", results.utilityNoVfx))
    
    -- Print failures if any
    if #failures > 0 then
        print("\n=== Failed Spells ===")
        for _, failure in ipairs(failures) do
            print(failure)
        end
    end
    
    return results.failed == 0
end

-- Run the test
local success = runTest()
print(string.format("\nTest %s!", success and "PASSED" and "FAILED"))

-- Return success status (for automated testing)
return success```

## ./ui.lua
```lua
-- UI helper module

-- Load core modules
local Constants = require("core.Constants")

local UI = {}

-- Spellbook visibility state
UI.spellbookVisible = {
    player1 = false,
    player2 = false
}

-- Delayed health damage display state
UI.healthDisplay = {
    player1 = {
        currentHealth = 100,        -- Current display health (smoothly animated)
        targetHealth = 100,         -- Actual health to animate towards
        pendingDamage = 0,          -- Damage that's pending animation (yellow bar)
        lastDamageTime = 0,         -- Time when last damage was taken
        pendingDrainDelay = 0.5,    -- Delay before yellow bar starts draining
        drainRate = 30              -- How fast the yellow bar drains (health points per second)
    },
    player2 = {
        currentHealth = 100,
        targetHealth = 100,
        pendingDamage = 0,
        lastDamageTime = 0,
        pendingDrainDelay = 0.5,
        drainRate = 30
    }
}

function UI.drawHelpText(font)
    -- Set font and color
    love.graphics.setFont(font)
    
    -- Draw a semi-transparent background for the debug panel
    love.graphics.setColor(0.1, 0.1, 0.2, 0.7)
    local panelWidth = 600
    local y = _G.game.baseHeight - 130 -- Use _G.game.baseHeight directly
    love.graphics.rectangle("fill", 5, y + 30, panelWidth, 95, 5, 5)
    
    -- Draw a border
    love.graphics.setColor(0.3, 0.3, 0.5, 0.8)
    love.graphics.rectangle("line", 5, y + 30, panelWidth, 95, 5, 5)
    
    -- Draw header
    love.graphics.setColor(1, 1, 0.7, 0.9)
    love.graphics.print("DEBUG MODE", 15, y + 35)
    
    -- Show debug controls with brighter text
    love.graphics.setColor(0.9, 0.9, 0.9, 0.9)
    love.graphics.print("Debug Controls: T (Add tokens), R (Toggle range), A/S (Toggle elevations), ESC (Quit)", 15, y + 55)
    love.graphics.print("VFX Test Keys: 1 (Firebolt), 2 (Meteor), 3 (Mist Veil), 4 (Emberlift), 5 (Full Moon Beam)", 15, y + 75)
    love.graphics.print("Conjure Test Keys: 6 (Fire), 7 (Moonlight), 8 (Volatile)", 15, y + 95)
    
    -- No longer calling UI.drawSpellbookButtons() here as it's now handled in the main loop
end

-- Toggle spellbook visibility for a player
-- Each player can now independently toggle their spellbook without affecting the other
function UI.toggleSpellbook(player)
    if player == 1 then
        UI.spellbookVisible.player1 = not UI.spellbookVisible.player1
    elseif player == 2 then
        UI.spellbookVisible.player2 = not UI.spellbookVisible.player2
    end
end

-- Draw skeuomorphic spellbook components for both players
function UI.drawSpellbookButtons()
    local screenWidth = _G.game.baseWidth -- Use _G.game.baseWidth directly
    local screenHeight = _G.game.baseHeight -- Use _G.game.baseHeight directly
    
    -- Draw Player 1's spellbook (Ashgar - pinned to left side)
    UI.drawPlayerSpellbook(1, 0, screenHeight - 70)
    
    -- Draw Player 2's spellbook (Selene - pinned to right side)
    UI.drawPlayerSpellbook(2, screenWidth - 250, screenHeight - 70)
end

-- Draw an individual player's spellbook component
function UI.drawPlayerSpellbook(playerNum, x, y)
    local width = 250  -- Balanced width
    local height = 50
    local player = (playerNum == 1) and "Ashgar" or "Selene"
    local keyLabel = (playerNum == 1) and "B" or "M"
    local keyPrefix = (playerNum == 1) and {"Q", "W", "E"} or {"I", "O", "P"}
    local wizard = _G.game.wizards[playerNum]
    local color = {wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255}
    
    -- Draw book background with slight gradient
    love.graphics.setColor(0.2, 0.2, 0.3, 0.9)
    love.graphics.rectangle("fill", x, y, width, height)
    love.graphics.setColor(0.25, 0.25, 0.35, 0.9)
    love.graphics.rectangle("fill", x, y, width, height/2)
    
    -- Draw book binding/spine effect
    love.graphics.setColor(color[1], color[2], color[3], 0.9)
    love.graphics.rectangle("fill", x, y, 6, height)
    
    -- Draw book edge
    love.graphics.setColor(0.8, 0.8, 0.8, 0.3)
    love.graphics.rectangle("line", x, y, width, height)
    
    -- Draw dividers between sections
    love.graphics.setColor(0.4, 0.4, 0.5, 0.4)
    love.graphics.line(x + 120, y + 5, x + 120, y + height - 5)
    
    -- Center everything vertically in pane
    local centerY = y + height/2
    local runeSize = 14
    local groupSpacing = 35  -- Original spacing between keys
    
    -- GROUP 1: SPELL INPUT KEYS
    -- Add a subtle background for the key group
    love.graphics.setColor(0.2, 0.2, 0.3, 0.3)
    love.graphics.rectangle("fill", x + 15, centerY - 20, 95, 40, 5, 5)  -- Maintain original padding for keys
    
    -- Calculate positions for centered spell input keys
    local inputStartX = x + 30  -- Original position for better centering
    local inputY = centerY
    
    for i = 1, 3 do
        -- Draw rune background
        love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
        love.graphics.circle("fill", inputStartX + (i-1)*groupSpacing, inputY, runeSize)
        
        if wizard.activeKeys[i] then
            -- Active rune with glow effect
            -- Multiple layers for glow
            for j = 3, 1, -1 do
                local alpha = 0.3 * (4-j) / 3
                local size = runeSize + j * 2
                love.graphics.setColor(1, 1, 0.3, alpha)
                love.graphics.circle("fill", inputStartX + (i-1)*groupSpacing, inputY, size)
            end
            
            -- Bright center
            love.graphics.setColor(1, 1, 0.7, 0.9)
            love.graphics.circle("fill", inputStartX + (i-1)*groupSpacing, inputY, runeSize * 0.7)
            
            -- Properly centered rune symbol
            local keyText = keyPrefix[i]
            local keyTextWidth = love.graphics.getFont():getWidth(keyText)
            local keyTextHeight = love.graphics.getFont():getHeight()
            love.graphics.setColor(0.2, 0.2, 0.3, 0.9)
            love.graphics.print(keyText, 
                inputStartX + (i-1)*groupSpacing - keyTextWidth/2, 
                inputY - keyTextHeight/2)
        else
            -- Inactive rune
            love.graphics.setColor(0.5, 0.5, 0.6, 0.6)
            love.graphics.circle("line", inputStartX + (i-1)*groupSpacing, inputY, runeSize)
            
            -- Properly centered inactive symbol
            local keyText = keyPrefix[i]
            local keyTextWidth = love.graphics.getFont():getWidth(keyText)
            local keyTextHeight = love.graphics.getFont():getHeight()
            love.graphics.setColor(0.6, 0.6, 0.7, 0.6)
            love.graphics.print(keyText, 
                inputStartX + (i-1)*groupSpacing - keyTextWidth/2, 
                inputY - keyTextHeight/2)
        end
    end
    
    -- Removed "Input Keys" label for cleaner UI
    
    -- GROUP 2: CAST BUTTON & FREE BUTTON
    -- Create a shared container/background for both action buttons - more compact
    local actionSectionWidth = 90
    local actionX = x + 125
    
    -- Draw a shared background container for both action buttons
    love.graphics.setColor(0.18, 0.18, 0.25, 0.5)
    love.graphics.rectangle("fill", actionX, centerY - 18, actionSectionWidth, 36, 5, 5)  -- More compact
    
    -- Calculate positions for both buttons with tighter spacing
    local castX = actionX + actionSectionWidth/3 - 5
    local freeX = actionX + actionSectionWidth*2/3 + 5
    local castKey = (playerNum == 1) and "F" or "J"
    local freeKey = (playerNum == 1) and "G" or "H"
    
    -- CAST BUTTON
    -- Subtle highlighting background
    love.graphics.setColor(0.3, 0.2, 0.1, 0.3)
    love.graphics.rectangle("fill", castX - 17, centerY - 16, 34, 32, 5, 5)  -- More compact
    
    -- Draw cast button background
    love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
    love.graphics.circle("fill", castX, inputY, runeSize)
    
    -- Cast button border
    love.graphics.setColor(0.8, 0.4, 0.1, 0.8)  -- Orange-ish for cast button
    love.graphics.circle("line", castX, inputY, runeSize)
    
    -- Cast button symbol
    local castTextWidth = love.graphics.getFont():getWidth(castKey)
    local castTextHeight = love.graphics.getFont():getHeight()
    love.graphics.setColor(1, 0.8, 0.3, 0.9)
    love.graphics.print(castKey, 
        castX - castTextWidth/2, 
        inputY - castTextHeight/2)
    
    -- Removed "Cast" label for cleaner UI
    
    -- FREE BUTTON
    -- Subtle highlighting background
    love.graphics.setColor(0.1, 0.3, 0.3, 0.3)
    love.graphics.rectangle("fill", freeX - 17, centerY - 16, 34, 32, 5, 5)  -- More compact
    
    -- Draw free button background
    love.graphics.setColor(0.15, 0.15, 0.25, 0.8)
    love.graphics.circle("fill", freeX, inputY, runeSize)
    
    -- Free button border
    love.graphics.setColor(0.2, 0.6, 0.8, 0.8)  -- Blue-ish for free button
    love.graphics.circle("line", freeX, inputY, runeSize)
    
    -- Free button symbol
    local freeTextWidth = love.graphics.getFont():getWidth(freeKey)
    local freeTextHeight = love.graphics.getFont():getHeight()
    love.graphics.setColor(0.5, 0.8, 1.0, 0.9)
    love.graphics.print(freeKey, 
        freeX - freeTextWidth/2, 
        inputY - freeTextHeight/2)
    
    -- Removed "Free" label for cleaner UI
    
    -- GROUP 3: KEYED SPELL POPUP (appears above the spellbook when a spell is keyed)
    if wizard.currentKeyedSpell then
        -- Make the popup exactly match the width of the spellbook
        local popupWidth = width
        local popupHeight = 30
        local popupX = x  -- Align with spellbook
        local popupY = y - popupHeight - 10  -- Position above the spellbook with slightly larger gap
        
        -- Get spell name and calculate its width for centering
        local spellName = wizard.currentKeyedSpell.name
        local spellNameWidth = love.graphics.getFont():getWidth(spellName)
        
        -- Draw popup background with a slight "connected" look
        -- Use the same color as the spellbook for visual cohesion
        love.graphics.setColor(0.2, 0.2, 0.3, 0.9)
        
        -- Main popup body (rounded rectangle)
        love.graphics.rectangle("fill", popupX, popupY, popupWidth, popupHeight, 5, 5)
        
        -- Connection piece (small triangle pointing down)
        love.graphics.polygon("fill", 
            x + width/2 - 8, popupY + popupHeight,  -- Left point
            x + width/2 + 8, popupY + popupHeight,  -- Right point
            x + width/2, popupY + popupHeight + 8   -- Bottom point
        )
        
        -- Add a subtle border with the wizard's color
        love.graphics.setColor(color[1], color[2], color[3], 0.5)
        love.graphics.rectangle("line", popupX, popupY, popupWidth, popupHeight, 5, 5)
        
        -- Subtle gradient for the background (matches the spellbook aesthetic)
        love.graphics.setColor(0.25, 0.25, 0.35, 0.7)
        love.graphics.rectangle("fill", popupX, popupY, popupWidth, popupHeight/2, 5, 5)
        
        -- Simple glow effect for the text
        for i = 3, 1, -1 do
            local alpha = 0.1 * (4-i) / 3
            local size = i * 2
            love.graphics.setColor(1, 1, 0.5, alpha)
            love.graphics.rectangle("fill", 
                x + width/2 - spellNameWidth/2 - size, 
                popupY + popupHeight/2 - 7 - size/2, 
                spellNameWidth + size*2, 
                14 + size,
                5, 5
            )
        end
        
        -- Spell name centered in the popup
        love.graphics.setColor(1, 1, 0.5, 0.9)
        love.graphics.print(spellName, 
            x + width/2 - spellNameWidth/2, 
            popupY + popupHeight/2 - 7
        )
    end
    
    -- GROUP 4: SPELLBOOK HELP (bottom-right corner) - more compact design
    local helpX = x + width - 15
    local helpY = y + height - 10
    
    -- Draw key hint - make it slightly bigger
    local helpSize = 8  -- Increased size
    love.graphics.setColor(0.4, 0.4, 0.6, 0.5)
    love.graphics.circle("fill", helpX, helpY, helpSize)
    
    -- Properly centered key symbol - BIGGER
    local smallFont = love.graphics.getFont()
    local keyTextWidth = smallFont:getWidth(keyLabel)
    local keyTextHeight = smallFont:getHeight()
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(keyLabel, 
        helpX - keyTextWidth/3, 
        helpY - keyTextHeight/3,
        0, 0.7, 0.7)  -- Significantly larger
    
    -- LARGER "?" indicator placed HIGHER above the button
    love.graphics.setColor(0.7, 0.7, 0.8, 0.8)  -- Brighter
    local helpLabel = "?"
    local helpLabelWidth = smallFont:getWidth(helpLabel)
    -- Position the ? significantly higher up
    love.graphics.print(helpLabel, 
        helpX - helpLabelWidth/3, 
        helpY - helpSize - smallFont:getHeight() - 2,  -- Position much higher above the button
        0, 0.7, 0.7)  -- Make it larger
    
    -- Highlight when active - just color tint, no white outline
    if (playerNum == 1 and UI.spellbookVisible.player1) or 
       (playerNum == 2 and UI.spellbookVisible.player2) then
        love.graphics.setColor(color[1], color[2], color[3], 0.4)
        love.graphics.rectangle("fill", x, y, width, height)
        -- Removed white outline rectangle
    end
end

function UI.drawSpellInfo(wizards)
    -- Function to format mana cost for display
    local function formatCost(cost)
        if not cost or #cost == 0 then
            return "Free"
        end
        
        -- Handle both old and new cost formats
        local regularTokens = {}
        local anyTokens = {}
        
        -- Check if this is the new array-style format (simple array of strings)
        local isNewFormat = type(cost[1]) == "string"
        
        if isNewFormat then
            -- Collect each token individually, separating ANY tokens
            for _, tokenType in ipairs(cost) do
                if tokenType:lower() == Constants.TokenType.ANY then
                    table.insert(anyTokens, tokenType)
                else
                    table.insert(regularTokens, tokenType)
                end
            end
        else
            -- Old format with type and count properties
            for _, component in ipairs(cost) do
                local typeText = component.type
                local isAnyToken = false
                
                if type(typeText) == "table" then
                    typeText = table.concat(typeText, "/")
                end
                
                if typeText:lower() == Constants.TokenType.ANY then
                    isAnyToken = true
                end
                
                -- Add the token the appropriate number of times
                for i = 1, component.count do
                    if isAnyToken then
                        table.insert(anyTokens, typeText)
                    else
                        table.insert(regularTokens, typeText)
                    end
                end
            end
        end
        
        -- Combine regular tokens and any tokens (any tokens always last)
        local allTokens = {}
        for _, token in ipairs(regularTokens) do
            table.insert(allTokens, token)
        end
        for _, token in ipairs(anyTokens) do
            table.insert(allTokens, token)
        end
        
        -- Build the final cost text
        if #allTokens == 0 then
            return "Free"
        else
            return table.concat(allTokens, ", ")
        end
    end
    
    -- Draw the fighting game style health bars
    UI.drawHealthBars(wizards)
    
    -- Note: spellbook modals are now drawn separately to ensure proper z-ordering
    -- Spell notification is now handled by the wizard's castSpell function
end

-- Function to draw spellbook modals (now separated to ensure proper z-ordering)
function UI.drawSpellbookModals(wizards)
    -- Local function to format costs for spellbook display
    local function formatCost(cost)
        if not cost or type(cost) ~= "table" or #cost == 0 then
            return "Free"
        end
        
        -- Handle both old and new cost formats
        local regularTokens = {}
        local anyTokens = {}
        
        -- Check if this is the new array-style format (simple array of strings)
        local isNewFormat = type(cost[1]) == "string"
        
        if isNewFormat then
            -- Collect each token individually, separating ANY tokens
            for _, tokenType in ipairs(cost) do
                if tokenType:lower() == Constants.TokenType.ANY then
                    table.insert(anyTokens, tokenType)
                else
                    table.insert(regularTokens, tokenType)
                end
            end
        else
            -- Old format with type and count properties
            for _, component in ipairs(cost) do
                local typeText = component.type
                local isAnyToken = false
                
                if type(typeText) == "table" then
                    typeText = table.concat(typeText, "/")
                end
                
                if typeText:lower() == Constants.TokenType.ANY then
                    isAnyToken = true
                end
                
                -- Add the token the appropriate number of times
                for i = 1, component.count do
                    if isAnyToken then
                        table.insert(anyTokens, typeText)
                    else
                        table.insert(regularTokens, typeText)
                    end
                end
            end
        end
        
        -- Combine regular tokens and any tokens (any tokens always last)
        local allTokens = {}
        for _, token in ipairs(regularTokens) do
            table.insert(allTokens, token)
        end
        for _, token in ipairs(anyTokens) do
            table.insert(allTokens, token)
        end
        
        -- Build the final cost text
        if #allTokens == 0 then
            return "Free"
        else
            return table.concat(allTokens, ", ")
        end
    end
    
    -- Draw spellbook popups if visible
    if UI.spellbookVisible.player1 then
        UI.drawSpellbookModal(wizards[1], wizards[2], 1, formatCost)
    end

    if UI.spellbookVisible.player2 then
        UI.drawSpellbookModal(wizards[2], wizards[1], 2, formatCost)
    end
end

-- Draw dramatic fighting game style health bars
function UI.drawHealthBars(wizards)
    local screenWidth = _G.game.baseWidth -- Use _G.game.baseWidth directly
    local barHeight = 40
    local centerGap = 60 -- Space between bars in the center
    local barWidth = (screenWidth - centerGap) / 2
    local padding = 0 -- No padding from screen edges
    local y = 5
    
    -- Player 1 (Ashgar) health bar (left side, right-to-left depletion)
    local p1 = wizards[1]
    local display1 = UI.healthDisplay.player1
    
    -- Get the animated health percentage (from the delayed damage system)
    local p1HealthPercent = display1.currentHealth / 100
    local p1PendingDamagePercent = display1.pendingDamage / 100
    
    -- Background and border
    love.graphics.setColor(0.15, 0.15, 0.15, 0.8)
    love.graphics.rectangle("fill", padding, y, barWidth, barHeight)
    love.graphics.setColor(0.3, 0.3, 0.3, 0.8)
    love.graphics.rectangle("line", padding, y, barWidth, barHeight)
    
    -- Health fill with gradient
    local ashgarGradient = {
        {0.8, 0.2, 0.2},  -- Red base color
        {1.0, 0.3, 0.1}   -- Brighter highlight
    }
    
    -- Calculate the total visible health (current + pending)
    local totalVisibleHealth = p1HealthPercent
    
    -- Draw gradient health bar for current health (excluding pending damage part)
    for i = 0, barWidth * p1HealthPercent, 1 do
        local gradientPos = i / (barWidth * p1HealthPercent)
        local r = ashgarGradient[1][1] + (ashgarGradient[2][1] - ashgarGradient[1][1]) * gradientPos
        local g = ashgarGradient[1][2] + (ashgarGradient[2][2] - ashgarGradient[1][2]) * gradientPos
        local b = ashgarGradient[1][3] + (ashgarGradient[2][3] - ashgarGradient[1][3]) * gradientPos
        love.graphics.setColor(r, g, b, 0.9)
        love.graphics.line(padding + i, y + 2, padding + i, y + barHeight - 2)
    end
    
    -- Add a single halfway marker at 50% health, anchored to the bottom
    love.graphics.setColor(0.2, 0.2, 0.2, 0.5)
    local halfwayX = padding + (barWidth / 2)
    local markerHeight = barHeight / 2  -- The marker extends halfway up the bar
    love.graphics.line(halfwayX, y + barHeight - markerHeight, halfwayX, y + barHeight)
    
    -- Get actual health from the wizard for comparison
    local p1ActualHealthPercent = p1.health / 100
    
    -- Health lost "after damage" effect (fading darker region)
    -- This is displayed UNDER everything else, so draw it first
    local permanentDamageAmount = 1.0 - p1ActualHealthPercent
    if permanentDamageAmount > 0 then
        love.graphics.setColor(0.5, 0.1, 0.1, 0.3)
        love.graphics.rectangle("fill", 
            padding + barWidth * p1ActualHealthPercent, 
            y, 
            barWidth * permanentDamageAmount, 
            barHeight)
    end
    
    -- Pending damage effect (yellow bar segment)
    -- This shows the section of health that will drain away
    if p1PendingDamagePercent > 0 then
        -- Calculate where the pending damage begins and ends
        local pendingStart = p1HealthPercent  -- Where current health ends
        local pendingEnd = math.min(p1HealthPercent + p1PendingDamagePercent, p1ActualHealthPercent)
        local pendingWidth = pendingEnd - pendingStart
        
        -- Only draw if there's actual width to display
        if pendingWidth > 0 then
            -- Draw yellow segment for pending damage (as it's actually depleting)
            love.graphics.setColor(1.0, 0.9, 0.2, 0.8)
            
            -- Draw the pending section as yellow bars to match the health bar style
            for i = 0, barWidth * pendingWidth, 1 do
                local x = padding + barWidth * pendingStart + i
                love.graphics.line(x, y + 2, x, y + barHeight - 2)
            end
            
            -- Add some shading effects to the pending damage zone
            love.graphics.setColor(1.0, 1.0, 0.5, 0.2)
            love.graphics.rectangle("fill", 
                padding + barWidth * pendingStart, 
                y, 
                barWidth * pendingWidth, 
                barHeight/3)
        end
    end
    
    -- Gleaming highlight
    local time = love.timer.getTime()
    local hilight = math.abs(math.sin(time))
    love.graphics.setColor(1, 1, 1, 0.2 * hilight)
    love.graphics.rectangle("fill", padding, y, barWidth * p1HealthPercent, barHeight/3)
    
    -- Name printed directly on the health bar
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(p1.name, padding + 20, y + barHeight/2 - 8, 0, 1.2, 1.2)
    
    -- Health percentage only in debug mode
    if love.keyboard.isDown("`") then
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print(math.floor(p1HealthPercent * 100) .. "%", padding + barWidth - 40, y + 7)
    end
    
    
    -- Player 2 (Selene) health bar (right side, left-to-right depletion)
    local p2 = wizards[2]
    local display2 = UI.healthDisplay.player2
    
    -- Get the animated health percentage (from the delayed damage system)
    local p2HealthPercent = display2.currentHealth / 100
    local p2PendingDamagePercent = display2.pendingDamage / 100
    local p2X = screenWidth - barWidth
    
    -- Background and border
    love.graphics.setColor(0.15, 0.15, 0.15, 0.8)
    love.graphics.rectangle("fill", p2X, y, barWidth, barHeight)
    love.graphics.setColor(0.3, 0.3, 0.3, 0.8)
    love.graphics.rectangle("line", p2X, y, barWidth, barHeight)
    
    -- Health fill with gradient
    local seleneGradient = {
        {0.1, 0.3, 0.8},  -- Blue base color
        {0.2, 0.5, 1.0}   -- Brighter highlight
    }
    
    -- Calculate the total visible health
    local totalVisibleHealth = p2HealthPercent
    
    -- Draw gradient health bar (left-to-right depletion)
    for i = 0, barWidth * p2HealthPercent, 1 do
        local gradientPos = i / (barWidth * p2HealthPercent)
        local r = seleneGradient[1][1] + (seleneGradient[2][1] - seleneGradient[1][1]) * gradientPos
        local g = seleneGradient[1][2] + (seleneGradient[2][2] - seleneGradient[1][2]) * gradientPos
        local b = seleneGradient[1][3] + (seleneGradient[2][3] - seleneGradient[1][3]) * gradientPos
        love.graphics.setColor(r, g, b, 0.9)
        love.graphics.line(p2X + barWidth - i, y + 2, p2X + barWidth - i, y + barHeight - 2)
    end
    
    -- Add a single halfway marker at 50% health, anchored to the bottom
    love.graphics.setColor(0.2, 0.2, 0.2, 0.5)
    local halfwayX = p2X + (barWidth / 2)
    local markerHeight = barHeight / 2  -- The marker extends halfway up the bar
    love.graphics.line(halfwayX, y + barHeight - markerHeight, halfwayX, y + barHeight)
    
    -- Get actual health from the wizard for comparison
    local p2ActualHealthPercent = p2.health / 100
    
    -- Health lost "after damage" effect (fading darker region)
    -- This is displayed UNDER everything else, so draw it first
    local permanentDamageAmount = 1.0 - p2ActualHealthPercent
    if permanentDamageAmount > 0 then
        love.graphics.setColor(0.1, 0.1, 0.5, 0.3)
        love.graphics.rectangle("fill", p2X, y, barWidth * permanentDamageAmount, barHeight)
    end
    
    -- Pending damage effect (yellow bar segment)
    if p2PendingDamagePercent > 0 then
        -- Calculate where the pending damage begins and ends
        -- For player 2, the bar fills from right to left
        local pendingStart = 1.0 - p2HealthPercent  -- Where current health ends (from left)
        local pendingEnd = math.min(pendingStart + p2PendingDamagePercent, 1.0 - p2ActualHealthPercent)
        local pendingWidth = pendingEnd - pendingStart
        
        -- Only draw if there's actual width to display
        if pendingWidth > 0 then
            -- Draw yellow segment for pending damage (as it's actually depleting)
            love.graphics.setColor(1.0, 0.9, 0.2, 0.8)
            
            -- Draw the pending section as yellow bars to match the health bar style
            for i = 0, barWidth * pendingWidth, 1 do
                local x = p2X + barWidth * pendingStart + i
                love.graphics.line(x, y + 2, x, y + barHeight - 2)
            end
            
            -- Add some shading effects to the pending damage zone
            love.graphics.setColor(1.0, 1.0, 0.5, 0.2)
            love.graphics.rectangle("fill", 
                p2X + barWidth * pendingStart, 
                y, 
                barWidth * pendingWidth, 
                barHeight/3)
        end
    end
    
    -- Gleaming highlight
    love.graphics.setColor(1, 1, 1, 0.2 * hilight)
    love.graphics.rectangle("fill", p2X + barWidth * (1 - p2HealthPercent), y, barWidth * p2HealthPercent, barHeight/3)
    
    -- Name printed directly on the health bar
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(p2.name, p2X + barWidth - 80, y + barHeight/2 - 8, 0, 1.2, 1.2)
    
    -- Health percentage only in debug mode
    if love.keyboard.isDown("`") then
        love.graphics.setColor(1, 1, 1, 0.9)
        love.graphics.print(math.floor(p2HealthPercent * 100) .. "%", p2X + 10, y + 7)
    end
end

-- Update the health display animation
function UI.updateHealthDisplays(dt, wizards)
    local currentTime = love.timer.getTime()
    
    for i, wizard in ipairs(wizards) do
        local display = UI.healthDisplay["player" .. i]
        local actualHealth = wizard.health
        
        -- If actual health is different from our target, register new damage
        if actualHealth < display.targetHealth then
            -- Calculate how much new damage was taken
            local newDamage = display.targetHealth - actualHealth
            
            -- Add to pending damage
            display.pendingDamage = display.pendingDamage + newDamage
            
            -- Update target health to match actual health
            display.targetHealth = actualHealth
            
            -- Reset the damage timer to restart the delay
            display.lastDamageTime = currentTime
        end
        
        -- Check if we should start draining the pending damage
        if display.pendingDamage > 0 and (currentTime - display.lastDamageTime) > display.pendingDrainDelay then
            -- Calculate how much to drain based on time passed
            local drainAmount = display.drainRate * dt
            
            -- Don't drain more than what's pending
            drainAmount = math.min(drainAmount, display.pendingDamage)
            
            -- Reduce pending damage and update current health
            display.pendingDamage = display.pendingDamage - drainAmount
            display.currentHealth = display.currentHealth - drainAmount
            
            -- Ensure we don't go below target health
            if display.currentHealth < display.targetHealth then
                display.currentHealth = display.targetHealth
                display.pendingDamage = 0
            end
            
            -- Debug output to help track the animation
            -- print(string.format("Player %d: Health %.1f, Pending %.1f, Target %.1f", 
            --     i, display.currentHealth, display.pendingDamage, display.targetHealth))
        end
    end
end

function UI.drawSpellbookModal(wizard, opponentWizard, playerNum, formatCost)
    local screenWidth = _G.game.baseWidth -- Use _G.game.baseWidth directly
    
    -- Determine position based on player number
    local modalX, keyPrefix
    if playerNum == 1 then
        modalX = 0  -- Pinned to left edge
        keyPrefix = {"Q", "W", "E", "QW", "QE", "WE", "QWE"}
    else
        modalX = screenWidth - 400  -- Pinned to right edge
        keyPrefix = {"I", "O", "P", "IO", "IP", "OP", "IOP"}
    end
    
    -- Define the key combinations and their corresponding keyNames
    local keyMappings = {
        {index = 1, keyName = "1"}, -- Q or I
        {index = 2, keyName = "2"}, -- W or O
        {index = 3, keyName = "3"}, -- E or P
        {index = 4, keyName = "12"}, -- QW or IO
        {index = 5, keyName = "13"}, -- QE or IP
        {index = 6, keyName = "23"}, -- WE or OP
        {index = 7, keyName = "123"} -- QWE or IOP
    }
    
    -- Count spells to calculate modal height dynamically
    local spellCount = 0
    for _, mapping in ipairs(keyMappings) do
        if wizard.spellbook[mapping.keyName] then
            spellCount = spellCount + 1
        end
    end
    
    -- Calculate modal height based on fixed components plus variable spell entries
    -- Components: title(30) + controls(120) + heading(25) + spellEntries(45 each) + no extra padding
    -- We end the component right after the last entry, letting the standard spacing between entries provide the visual margin
    local modalHeight = 175 + (spellCount * 45)
    
    -- Modal background - fully opaque to properly obscure what's behind it
    love.graphics.setColor(0.1, 0.1, 0.2, 1.0)  -- Fully opaque
    love.graphics.rectangle("fill", modalX, 50, 400, modalHeight)
    love.graphics.setColor(0.4, 0.4, 0.6, 1.0)  -- Fully opaque border
    love.graphics.rectangle("line", modalX, 50, 400, modalHeight)
    
    -- Modal title - simplified to just wizard name
    love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.9)
    love.graphics.rectangle("fill", modalX, 50, 400, 30)
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(wizard.name, modalX + 190, 60)
    
    -- Close button with appropriate hotkey instead of X
    local closeKey = (playerNum == 1) and "B" or "M"
    love.graphics.setColor(0.3, 0.3, 0.5, 0.8)
    love.graphics.rectangle("fill", modalX + 370, 50, 30, 30)
    love.graphics.setColor(1, 1, 1, 0.9)
    love.graphics.print(closeKey, modalX + 380, 60)
    
    -- Controls help section at the top of the modal
    love.graphics.setColor(0.2, 0.2, 0.4, 0.8)
    love.graphics.rectangle("fill", modalX + 10, 90, 380, 100)
    love.graphics.setColor(1, 1, 1, 0.9)
    
    if playerNum == 1 then
        love.graphics.print("Controls:", modalX + 20, 95)
        love.graphics.print("QWE: Key different spell inputs", modalX + 30, 115)
        love.graphics.print("F: Cast the currently keyed spell", modalX + 30, 135)
        love.graphics.print("G: Free all active spells and return mana", modalX + 30, 155)
        love.graphics.print("B: Toggle spellbook visibility", modalX + 30, 175)
    else
        love.graphics.print("Controls:", modalX + 20, 95)
        love.graphics.print("IOP: Key different spell inputs", modalX + 30, 115)
        love.graphics.print("J: Cast the currently keyed spell", modalX + 30, 135)
        love.graphics.print("H: Free all active spells and return mana", modalX + 30, 155)
        love.graphics.print("M: Toggle spellbook visibility", modalX + 30, 175)
    end
    
    -- Spells section
    local y = 200
    
    -- Spells heading
    love.graphics.setColor(1, 1, 0.7, 0.9)
    love.graphics.rectangle("fill", modalX + 10, y, 380, 25)
    love.graphics.setColor(0.2, 0.2, 0.4, 0.9)
    love.graphics.print("Spellbook", modalX + 170, y + 5)
    y = y + 30
    
    -- Track which spell entry is currently being hovered over (via keys)
    local activeSpellIndex = nil
    local keyCombo = ""
    
    -- Check which exact keys are being held down
    if playerNum == 1 then
        if love.keyboard.isDown("q") then keyCombo = keyCombo .. "1" end
        if love.keyboard.isDown("w") then keyCombo = keyCombo .. "2" end
        if love.keyboard.isDown("e") then keyCombo = keyCombo .. "3" end
    else
        if love.keyboard.isDown("i") then keyCombo = keyCombo .. "1" end
        if love.keyboard.isDown("o") then keyCombo = keyCombo .. "2" end
        if love.keyboard.isDown("p") then keyCombo = keyCombo .. "3" end
    end
    
    -- Store information about each spell entry for later use
    local spellEntries = {}
    
    -- Display all spells in a single unified list
    for i, mapping in ipairs(keyMappings) do
        local spell = wizard.spellbook[mapping.keyName]
        if spell then
            -- Check if this is the currently keyed spell
            local isCurrentSpell = wizard.currentKeyedSpell and wizard.currentKeyedSpell.name == spell.name
            
            -- Check if this exact key combo is being held
            local isExactMatch = (mapping.keyName == keyCombo)
            if isExactMatch then
                activeSpellIndex = i
            end
            
            -- Use a different background color to highlight the currently keyed spell
            if isCurrentSpell then
                -- Glowing highlight effect for the active spell
                -- Draw multiple layers with decreasing alpha for a glow effect
                for i = 3, 1, -1 do
                    local alpha = 0.15 * (4-i) / 3
                    local padding = i * 2
                    love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, alpha)
                    love.graphics.rectangle("fill", 
                        modalX + 10 - padding, 
                        y - padding, 
                        380 + padding*2, 
                        40 + padding*2, 
                        5, 5)
                end
                
                -- Brighter inner background for current spell
                love.graphics.setColor(0.25, 0.25, 0.35, 0.9)
            else
                -- Standard background for other spells
                love.graphics.setColor(0.2, 0.2, 0.3, 0.7)
            end
            
            -- Draw the spell entry background
            love.graphics.rectangle("fill", modalX + 10, y, 380, 40)
            
            -- Add a subtle border for the currently keyed spell
            if isCurrentSpell then
                love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.7)
                love.graphics.rectangle("line", modalX + 10, y, 380, 40)
            end
            
            -- Draw spell name with brighter color if it's the current spell
            if isCurrentSpell then
                love.graphics.setColor(1, 1, 0.8, 1.0)  -- Brighter color for active spell
            else
                love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.9)
            end
            love.graphics.print(keyPrefix[mapping.index] .. ": " .. spell.name, modalX + 20, y + 5)
            
            -- Draw spell details with appropriate color
            if isCurrentSpell then
                love.graphics.setColor(0.9, 0.9, 0.9, 1.0)  -- Brighter text for active spell
            else
                love.graphics.setColor(0.8, 0.8, 0.8, 0.8)
            end
            
            -- Convert cast time to "x" characters instead of numbers
            local castTimeVisual = string.rep("x", spell.castTime)

            -- Determine cost, evaluating getCost if present
            local costTable = spell.cost
            local isDynamic = false
            if spell.getCost and type(spell.getCost) == "function" then
                local ok, result = pcall(spell.getCost, wizard, opponentWizard)
                if ok and type(result) == "table" then
                    costTable = result
                    isDynamic = true
                else
                    print("ERROR evaluating getCost for " .. spell.name .. ": " .. tostring(result))
                end
            end

            local costText = formatCost(costTable)
            if isDynamic then
                costText = costText .. "*"
            end

            love.graphics.print("Cost: " .. costText .. "   Cast Time: " .. castTimeVisual, modalX + 30, y + 25)
            
            -- Store the spell entry information for later use (for description popup)
            table.insert(spellEntries, {
                spell = spell,
                y = y,
                isExactMatch = isExactMatch,
                isCurrentSpell = isCurrentSpell
            })
            
            y = y + 45  -- Restore original spacing between spell entries
        end
    end
    
    -- Draw description popup for the active spell (if any)
    if activeSpellIndex and spellEntries[activeSpellIndex] then
        local activeEntry = spellEntries[activeSpellIndex]
        local activeSpell = activeEntry.spell
        
        if activeSpell.description then
            -- Draw a popup box above the spell entry
            local popupWidth = 360
            local popupHeight = 50  -- Height for description text
            local popupX = modalX + 20  -- Align within the spellbook modal
            local popupY = activeEntry.y - popupHeight - 10  -- Position above the spell entry
            
            -- Draw popup background
            love.graphics.setColor(0.15, 0.15, 0.25, 0.95)  -- Darker background for contrast
            love.graphics.rectangle("fill", popupX, popupY, popupWidth, popupHeight, 5, 5)
            
            -- Add a subtle border with the wizard's color
            love.graphics.setColor(wizard.color[1]/255, wizard.color[2]/255, wizard.color[3]/255, 0.7)
            love.graphics.rectangle("line", popupX, popupY, popupWidth, popupHeight, 5, 5)
            
            -- Add a connecting triangle in the same color
            love.graphics.polygon("fill", 
                popupX + popupWidth/2 - 8, popupY + popupHeight,  -- Left point
                popupX + popupWidth/2 + 8, popupY + popupHeight,  -- Right point
                popupX + popupWidth/2, popupY + popupHeight + 8   -- Bottom point
            )
            
            -- Draw the description text
            love.graphics.setColor(1, 1, 1, 0.9)
            love.graphics.printf(activeSpell.description, popupX + 10, popupY + 15, popupWidth - 20, "center")
        end
    end
end

return UI```

## ./vfx.lua
```lua
-- VFX.lua
-- Visual effects module for spell animations and combat effects

local VFX = {
    -- Tables to hold effect type updaters and drawers
    updaters = {},
    drawers = {}
}
VFX.__index = VFX

-- Import dependencies
local Pool = require("core.Pool")
local Constants = require("core.Constants")
local AssetCache = require("core.AssetCache")
local ParticleManager = require("vfx.ParticleManager")
local initializeParticlesModule = require("vfx.initializeParticles")

-- Table to store active effects
VFX.activeEffects = {}

-- Helper function to lazily load assets on demand
local function getAssetInternal(assetId)
    -- Check if asset path exists
    local path = VFX.assetPaths[assetId]
    if not path then 
        print("[VFX] Warning: No path defined for asset: " .. tostring(assetId))
        return nil 
    end
    
    -- Initialize assets table if it doesn't exist
    VFX.assets = VFX.assets or {}
    
    -- Check if already loaded (simple cache within VFX module)
    if VFX.assets[assetId] then 
        return VFX.assets[assetId] 
    end
    
    -- Special handling for runes array
    if assetId == "runes" then
        -- Check if runes are already loaded
        if VFX.assets.runes and #VFX.assets.runes > 0 then
            return VFX.assets.runes
        end
        
        -- Initialize runes array if needed
        VFX.assets.runes = VFX.assets.runes or {}
        
        -- If array exists but is empty, load runes
        if #VFX.assets.runes == 0 then
            for i, runePath in ipairs(path) do
                print("[VFX] Loading rune asset on demand: rune" .. i)
                local runeImg = AssetCache.getImage(runePath)
                if runeImg then
                    table.insert(VFX.assets.runes, runeImg)
                else
                    print("[VFX] Warning: Failed to load rune asset: " .. runePath)
                end
            end
        end
        
        -- Log if runes were loaded successfully
        if #VFX.assets.runes > 0 then
            print("[VFX] Successfully loaded " .. #VFX.assets.runes .. " rune assets")
        else 
            print("[VFX] Warning: No rune assets were loaded!")
        end
        
        return VFX.assets.runes
    end
    
    -- Load on demand using AssetCache
    print("[VFX] Lazily loading asset: " .. assetId)
    VFX.assets[assetId] = AssetCache.getImage(path)
    return VFX.assets[assetId]
end

-- Initialize the VFX system
function VFX.init()
    -- Store a reference to the global game object for use in effects
    VFX.gameState = _G.game -- Access the global game variable
    
    -- Define asset paths (but don't load them yet - lazy loading)
    VFX.assetPaths = {
        -- Fire effects
        fireParticle = "assets/sprites/fire-particle.png",
        fireGlow = "assets/sprites/fire-glow.png",
        
        -- Force effects
        forceWave = "assets/sprites/force-wave.png",
        
        -- Moon effects
        moonGlow = "assets/sprites/moon-glow.png",
        
        -- Generic effects
        sparkle = "assets/sprites/sparkle.png",
        impactRing = "assets/sprites/impact-ring.png",
        
        -- Bolt effects
        boltFrames = {
            "assets/sprites/bolt/bolt1.png",
            "assets/sprites/bolt/bolt2.png",
            "assets/sprites/bolt/bolt3.png"
        },
        
        -- Orb effects
        orbFrames = {
            "assets/sprites/orb/orb1.png",
            "assets/sprites/orb/orb2.png",
            "assets/sprites/orb/orb3.png",
            "assets/sprites/orb/orb4.png",
            "assets/sprites/orb/orb5.png"
        },
        
        -- Warp effects
        warpFrames = {
            "assets/sprites/warp/warp1.png",
            "assets/sprites/warp/warp2.png",
            "assets/sprites/warp/warp3.png"
        },

        -- Zap effects
        zapFrames = {
            "assets/sprites/zap/zap1.png",
            "assets/sprites/zap/zap2.png",
            "assets/sprites/zap/zap3.png"
        },

        -- Pixel primitive
        pixel = "assets/sprites/1px.png",

        -- Twinkle assets
        twinkle1 = "assets/sprites/3px-twinkle1.png",
        twinkle2 = "assets/sprites/3px-twinkle2.png",
        -- Rune assets for Ward shields (paths only)
        runes = {}
    }
    
    -- Define rune paths
    for i = 1, 9 do
        table.insert(VFX.assetPaths.runes, string.format("assets/sprites/runes/rune%d.png", i))
    end
    
    -- Initialize empty assets table (will be filled on demand)
    VFX.assets = {}
    
    -- Public function to get assets - expose the internal getAsset function
    VFX.getAsset = getAssetInternal
    
    -- Initialize particle pools
    Pool.create("vfx_particle", 100, function() return {} end, VFX.resetParticle)
    
    -- Preload critical assets immediately
    -- This ensures essential effects like ward shields work even on first use
    print("[VFX] Eagerly preloading critical assets...")
    
    -- Preload rune assets for ward shields
    VFX.assets.runes = {}
    for i, runePath in ipairs(VFX.assetPaths.runes) do
        print("[VFX] Preloading essential asset: rune" .. i)
        local runeImg = AssetCache.getImage(runePath)
        if runeImg then
            table.insert(VFX.assets.runes, runeImg)
        else
            print("[VFX] Warning: Failed to preload rune asset: " .. runePath)
        end
    end
    
    -- Preload sparkle asset (used in many effects)
    print("[VFX] Preloading essential asset: sparkle")
    VFX.assets.sparkle = AssetCache.getImage(VFX.assetPaths.sparkle)
    
    -- Preload bolt frames for the bolt effects
    print("[VFX] Preloading bolt frame assets")
    VFX.assets.boltFrames = {}
    for i, boltPath in ipairs(VFX.assetPaths.boltFrames) do
        print("[VFX] Preloading bolt frame " .. i)
        local boltImg = AssetCache.getImage(boltPath)
        if boltImg then
            table.insert(VFX.assets.boltFrames, boltImg)
        else
            print("[VFX] Warning: Failed to preload bolt frame asset: " .. boltPath)
        end
    end
    
    -- Preload orb frames for the orb effects
    print("[VFX] Preloading orb frame assets")
    VFX.assets.orbFrames = {}
    for i, orbPath in ipairs(VFX.assetPaths.orbFrames) do
        print("[VFX] Preloading orb frame " .. i)
        local orbImg = AssetCache.getImage(orbPath)
        if orbImg then
            table.insert(VFX.assets.orbFrames, orbImg)
        else
            print("[VFX] Warning: Failed to preload orb frame asset: " .. orbPath)
        end
    end
    
    -- Preload warp frames for the warp effects
    print("[VFX] Preloading warp frame assets")
    VFX.assets.warpFrames = {}
    for i, warpPath in ipairs(VFX.assetPaths.warpFrames) do
        print("[VFX] Preloading warp frame " .. i)
        local warpImg = AssetCache.getImage(warpPath)
        if warpImg then
            table.insert(VFX.assets.warpFrames, warpImg)
        else
            print("[VFX] Warning: Failed to preload warp frame asset: " .. warpPath)
        end
    end

    -- Preload zap frames for the zap effects
    print("[VFX] Preloading zap frame assets")
    VFX.assets.zapFrames = {}
    for i, zapPath in ipairs(VFX.assetPaths.zapFrames) do
        print("[VFX] Preloading zap frame " .. i)
        local zapImg = AssetCache.getImage(zapPath)
        if zapImg then
            table.insert(VFX.assets.zapFrames, zapImg)
        else
            print("[VFX] Warning: Failed to preload zap frame asset: " .. zapPath)
        end
    end
    
    -- Effect definitions keyed by effect name
    VFX.effects = {
        -- Base templates for the rules-driven VFX system
        proj_base = {
            type = "proj_base",
            duration = 1.0,
            particleCount = 30,           -- Increased from 20 for richer visuals
            startScale = 0.5,
            endScale = 0.8,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            trailLength = 15,             -- Slightly longer trail
            impactSize = 1.2,
            sound = nil,                  -- No default sound
            coreDensity = 0.6,            -- Controls density of center particles (0-1)
            trailDensity = 0.4,           -- Controls density of trail particles (0-1)
            turbulence = 0.5,             -- Random motion factor (0-1)
            arcHeight = 60,               -- Base arc height for trajectories
            particleLifespan = 0.6,       -- How long individual particles last (as fraction of total duration)
            leadingIntensity = 1.5        -- Brightness multiplier for the leading edge
        },

        bolt_base = {
            type = "bolt_base",  -- Template name as type
            duration = 1.0,               -- Slower to showcase enhanced particle effects
            particleCount = 20,           -- Fewer particles since we're using sprites
            startScale = 0.4,
            endScale = 0.7,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            trailLength = 18,             -- Longer trail for lightning-like effect
            impactSize = 1.3,             -- Slightly larger impact
            sound = nil,                  -- No default sound
            coreDensity = 0.3,            -- Less dense core, since we're using sprites
            trailDensity = 0.4,           -- Less dense trail, since we're using sprites
            turbulence = 0.8,             -- More random motion for lightning effect
            arcHeight = 0,                -- Zero arc height for straight-line trajectory
            straightLine = true,          -- New: Flag for straight-line movement
            particleLifespan = 0.5,       -- Shorter particle lifespan for quick flashes
            leadingIntensity = 1.8,       -- Brighter leading edge
            flickerRate = 12,             -- Rate at which particles flicker (Hz)
            flickerIntensity = 0.3,       -- Intensity of the flicker effect (0-1)
            useSprites = true,            -- Flag to indicate this effect uses sprite frames
            spriteFrameRate = 15,         -- Frames per second for sprite animation
            spriteRotationOffset = 0.78,  -- Radians to rotate the sprite by default (≈45 degrees)
            spriteScale = 0.85,           -- Base scale factor for the sprite
            spriteTint = true,            -- Whether to apply color tinting to sprites
            useSourcePosition = true,     -- Track source (caster) position
            useTargetPosition = true,     -- Track target position
            criticalAssets = {"boltFrames"} -- Mark bolt frames as critical assets to preload
        },

        zap_base = {
            type = "zap_base",
            duration = 0.6,
            color = Constants.Color.GRAY,
            segmentLength = 20,
            useSourcePosition = true,
            useTargetPosition = true,
            criticalAssets = {"zapFrames"}
        },

        orb_base = {
            type = "orb_base",  -- Template name as type
            duration = 1.8,               -- Significantly slower than bolt for dramatic arc
            particleCount = 35,           -- More particles for richer trail effect
            startScale = 0.6,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 65,                  -- Radius for particle effects and impact
            trailLength = 25,             -- Longer trail for graceful arc
            impactSize = 1.5,             -- Larger impact than bolt
            sound = nil,                  -- No default sound
            coreDensity = 0.5,            -- Balanced particle density
            trailDensity = 0.6,           -- Dense trail for visible arc path
            turbulence = 0.3,             -- Less turbulence for smoother flight
            arcHeight = 120,              -- High arc for lobbed trajectory
            straightLine = false,         -- Uses curved arc path
            particleLifespan = 0.8,       -- Longer particle lifespan for persistent trail
            leadingIntensity = 1.4,       -- Moderate leading edge intensity
            flickerRate = 8,              -- Slower flicker for mystical effect
            flickerIntensity = 0.2,       -- Subtle flicker
            useSprites = true,            -- Flag to indicate this effect uses sprite frames
            spriteFrameRate = 8,          -- Slower frame rate for floating effect
            spriteRotationOffset = 0,     -- No rotation offset for orbs
            spriteScale = 1.0,            -- Larger scale than bolts
            spriteTint = true,            -- Whether to apply color tinting to sprites
            useSourcePosition = true,     -- Track source (caster) position
            useTargetPosition = true,     -- Track target position
            useCurvedPath = true,         -- Enable curved path explicitly
            criticalAssets = {"orbFrames"} -- Mark orb frames as critical assets to preload
        },

        warp_base = {
            type = "warp_base",           -- Template name as type
            duration = 1.0,                -- Standard duration
            particleCount = 25,            -- Particles for additional effects
            startScale = 0.5,
            endScale = 1.0,
            color = Constants.Color.GRAY, -- Default color, will be overridden
            radius = 80,                   -- Radius for particle effects
            impactSize = 1.5,              -- Slightly larger impact
            sound = nil,                   -- No default sound
            pulseRate = 6.0,               -- Rate of pulsing effect
            useSprites = true,             -- Flag to indicate this effect uses sprite frames
            spriteFrameRate = 10,          -- Frames per second for sprite animation
            spriteScale = 1.0,             -- Base scale factor for the sprite
            spriteTint = true,             -- Whether to apply color tinting to sprites
            rotateSprite = true,           -- Whether to rotate the sprite
            rotationSpeed = 1.2,           -- Rotation speed in radians per second
            drawAtTarget = true,           -- Draw directly at target position
            usePulse = true,               -- Use pulsing effect
            pulseAmount = 0.2,             -- Amount of pulse (scale variation)
            glowIntensity = 0.7,           -- Intensity of the glow effect
            particleDensity = 0.6,         -- How dense the particles should be
            useTargetPosition = true,      -- Track the target's position
            criticalAssets = {"warpFrames"} -- Mark warp frames as critical assets to preload
        },

        beam_base = {
            type = "beam_base",           -- Template name as type
            duration = 1.2,
            particleCount = 25,
            beamWidth = 30,
            startScale = 0.3,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            pulseRate = 3,
            sound = nil,
            useSourcePosition = true,     -- Track source (caster) position
            useTargetPosition = true      -- Track target position
        },

        blast_base = {
            type = "blast_base",          -- Template name as type
            duration = 1.3,               -- Even longer duration for more dramatic impact
            particleCount = 95,           -- More particles for density and impact
            startScale = 0.45,            -- Larger starting scale
            endScale = 1.35,              -- Larger end scale for dramatic growth
            color = Constants.Color.GRAY, -- Default color, will be overridden
            coneAngle = 45,               -- Narrower cone angle (45° instead of 70°)
            coneLength = 320,             -- Much longer range for dramatic reach
            waveCount = 5,                -- More waves for increased visual impact
            waveSpeed = 350,              -- Faster wave propagation
            nearRangeIntensity = 2.2,     -- Stronger intensity multiplier at NEAR range
            matchedElevationIntensity = 1.7, -- Stronger multiplier for matched elevation
            useSourcePosition = true,     -- Track source (caster) position
            motionStyle = Constants.MotionStyle.DIRECTIONAL, -- Directional movement for particles
            waveCrest = true,             -- Enable wave crest visual effect
            waveCrestSize = 2.2,          -- Even larger wave crests
            turbulence = 0.35,            -- Slightly reduced turbulence for more focused beam
            leadingEdgeGlow = true,       -- Add bright leading edge to waves
            particleSizeVariance = 0.6,   -- Greater size variance for particles
            wavePersistence = 0.9,        -- How long waves remain visible (new parameter)
            trailingGlowStrength = 0.8,   -- Strength of glow trail behind waves (new parameter)
            sound = nil,                  -- No default sound
            intensityFalloff = 0.65,      -- Control how quickly intensity drops with distance
            focusedCore = true            -- Concentrate particles in center of cone (new parameter)
        },

        zone_base = {
            type = "zone_base",           -- Template name as type
            duration = 1.0,
            particleCount = 30,
            startScale = 0.4,
            endScale = 1.0,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 80,
            pulseRate = 3,
            sound = nil
        },

        util_base = {
            type = "util_base",           -- Template name as type
            duration = 0.8,
            particleCount = 15,
            startScale = 0.3,
            endScale = 0.7,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 60,
            pulseRate = 4,
            sound = nil
        },

        surge_base = {
            type = "surge_base",          -- Template name as type
            duration = 1.5,                -- Longer duration for buff visual
            particleCount = 90,            -- Extra particles for dramatic burst
            startScale = 1.0,              -- Pixel-sized primitives
            endScale = 0.2,               -- Fade to tiny specks
            color = Constants.Color.YELLOW_HERO,   -- Default color, will be overridden
            height = 200,                  -- Higher fountain effect
            spread = 45,                   -- Narrower spread for more focused fountain
            riseFactor = 1.4,              -- How quickly particles rise (new parameter)
            gravity = 180,                 -- Gravity effect for natural arc (new parameter)
            centerGlow = true,             -- Create glowing core at caster (new parameter)
            centerGlowSize = 50,           -- Size of the center glow
            centerGlowIntensity = 1.3,     -- Intensity of center glow
            spiralMotion = true,           -- Add spiral motion to particles (new parameter)
            spiralTightness = 2.5,         -- How tight the spiral is (new parameter)
            particleSizeVariance = 0.6,    -- Varied particle sizes
            riseAcceleration = 1.2,        -- Particles accelerate as they rise (new parameter)
            bloomEffect = true,            -- Add bloom/glow to particles (new parameter)
            bloomIntensity = 0.8,          -- Intensity of bloom effect (new parameter)
            sparkleChance = 0.4,           -- Chance for sparkle effect on particles (new parameter)
            useSprites = false,            -- Use primitive pixel sprites
            spriteFrameRate = 8,           -- Frame rate for sprite animation
            pulsateParticles = true,       -- Pulsate particle size (new parameter)
            sound = "surge",               -- Sound effect
            criticalAssets = {"pixel", "twinkle1", "twinkle2"} -- Required assets
        },

        wave_base = {
            type = "wave_base",          -- Template name as type
            duration = 1.2,
            particleCount = 120,
            startScale = 0.5,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            trailLength = 20,
            impactSize = 1.4,
            coreDensity = 0.4,
            trailDensity = 0.6,
            turbulence = 0.75,
            arcHeight = 40,
            particleLifespan = 0.7,
            leadingIntensity = 1.6,
            useSprites = false,
            criticalAssets = {"pixel", "twinkle1", "twinkle2"}
        },

        conjure_base = {
            type = "conjure_base",        -- Template name as type
            duration = 0.8,
            particleCount = 35,
            startScale = 0.3,
            endScale = 0.9,
            color = Constants.Color.GRAY,  -- Default color, will be overridden by VisualResolver
            radius = 70,
            height = 120,
            pulseRate = 3,
            sound = nil,
            defaultParticleAsset = "sparkle"
        },

        impact_base = {
            type = "impact_base",         -- Template name as type
            duration = 0.5,
            particleCount = 20,
            startScale = 0.6,
            endScale = 0.3,
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 40,
            sound = nil
        },

        remote_base = {
            type = "remote_base",         -- Template name as type
            duration = 0.7,
            particleCount = 35,
            startScale = 0.2,
            endScale = 1.0,              -- Larger ending scale for a flash effect
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 60,                 -- Larger radius than impact
            pulseRate = 2,               -- Add pulse for dynamic flash effect
            intensityMultiplier = 1.8,   -- Brighter than normal effects
            useTargetPosition = true,    -- Always use target position, not source
            trackTargetOffsets = true,   -- Track target's current position including offsets
            sound = nil
        },

        shield_hit_base = {
            type = "shield_hit_base",     -- Template name as type
            duration = 0.8,  -- Slightly longer impact duration
            particleCount = 30, -- More particles
            startScale = 0.5,
            endScale = 1.3,  -- Larger end scale
            color = Constants.Color.GRAY,  -- Default color, will be overridden
            radius = 70,     -- Increased radius
            sound = "shield", -- Use shield sound
            criticalAssets = {"impactRing", "sparkle"} -- Assets needed for shield hit
        },
        
        -- Existing effects
        -- General impact effect (used for many spell interactions)
        impact = {
            type = "impact",              -- Effect name as type
            duration = 0.5,  -- Half second by default
            particleCount = 15,
            startScale = 0.8,
            endScale = 0.2,
            color = Constants.Color.GRAY,
            radius = 30,
            sound = nil  -- No default sound
        },

        meteor = {
            type = "meteor",              -- Effect name as type
            duration = 1.4,
            particleCount = 45,
            startScale = 0.6,
            endScale = 1.2,
            color = Constants.Color.RED_HERO,  -- Crimson red for meteor
            radius = 90,         -- Impact explosion radius
            height = 300,        -- Height from which meteor falls
            spread = 20,         -- Spread of the meteor cluster
            fireTrail = true,    -- Enable fire trail for particles
            impactExplosion = true, -- Create explosion effect on impact
            sound = "meteor_impact",
            defaultParticleAsset = "fireParticle"
        },

        force_blast = {
            type = "force_blast",         -- Effect name as type
            duration = 1.0,
            particleCount = 30,
            startScale = 0.4,
            endScale = 1.5,
            color = Constants.Color.YELLOW_HERO,
            radius = 90,
            sound = "force_wind"
        },

        free_mana = {
            type = "free_mana",           -- Effect name as type
            duration = 1.2,
            particleCount = 40,
            startScale = 0.4,
            endScale = 0.8,
            color = Constants.Color.WHITE,
            radius = 100,
            pulseRate = 4,
            sound = "release"
        },

        shield = {
            type = "shield",              -- Effect name as type
            duration = 1.0,
            particleCount = 25,
            startScale = 0.5,
            endScale = 1.2,
            color = Constants.Color.BLUE_HERO,
            radius = 60,
            pulseRate = 3,
            sound = "shield",
            criticalAssets = {"sparkle", "runes", "impactRing"}, -- Assets needed for shields
            shieldType = nil -- Will be set at runtime based on the spell
        },

        -- Emberlift spell effects
        emberlift = {
            type = "emberlift",           -- Effect name as type
            duration = 1.2,
            particleCount = 60,            -- More particles for richer effect
            startScale = 0.3,              -- Larger starting scale
            endScale = 0.08,               -- Smaller end scale for fade-out
            color = Constants.Color.RED_HERO,
            height = 160,                  -- Height for fountain effect
            spread = 45,                   -- Spread for the fountain
            riseFactor = 1.4,              -- How quickly particles rise
            gravity = 180,                 -- Gravity effect for natural arc
            centerGlow = true,             -- Create glowing core at caster
            centerGlowSize = 50,           -- Size of the center glow
            centerGlowIntensity = 1.3,     -- Intensity of center glow
            spiralMotion = true,           -- Add spiral motion to particles
            spiralTightness = 2.5,         -- How tight the spiral is
            particleSizeVariance = 0.6,    -- Varied particle sizes
            riseAcceleration = 1.2,        -- Particles accelerate as they rise
            bloomEffect = true,            -- Add bloom/glow to particles
            bloomIntensity = 0.8,          -- Intensity of bloom effect
            sparkleChance = 0.4,           -- Chance for sparkle effect on particles
            useSprites = true,             -- Use sprite images
            spriteFrameRate = 8,           -- Frame rate for sprite animation
            pulsateParticles = true,       -- Pulsate particle size
            sound = "surge",
            criticalAssets = {"sparkle", "fireParticle"}
        },

        range_change = {
            type = "range_change",         -- Effect name as type
            duration = 1.1,
            particleCount = 50,
            startScale = 0.3,
            endScale = 0.7,
            color = Constants.Color.YELLOW_HERO,
            height = 120,
            spread = 60,
            riseFactor = 1.2,
            gravity = 150,
            centerGlow = true,
            centerGlowSize = 40,
            spiralMotion = true,
            spiralTightness = 2.0,
            particleSizeVariance = 0.5,
            useSprites = true,
            spriteFrameRate = 8,
            sound = "range_shift"
        },

        -- Note: conjurefire will fall through to use the default conjure_base template
    }
    
    -- TODO: Initialize sound effects
    
    -- Create effect pool - each effect is a container object
    Pool.create("vfx_effect", 10, function() return { particles = {} } end, VFX.resetEffect)

    -- Run the diagnostic to ensure the particle pool is healthy
    VFX.runParticlePoolDiagnostic()

    -- Return the VFX table itself
    return VFX
end

-- Reset function for particle objects
function VFX.resetParticle(particle)
    -- Clear all fields
    for k, _ in pairs(particle) do
        particle[k] = nil
    end
    return particle
end

-- Update particle based on motion style
function VFX.updateParticle(particle, effect, dt, particleProgress)
    local Constants = require("core.Constants")
    
    -- If no motion style specified, use default behavior
    local motionStyle = particle.motion or Constants.MotionStyle.RADIAL
    
    -- Time since particle became active
    particle.startTime = (particle.startTime or 0) + dt
    local time = particle.startTime
    
    -- Get base position
    local baseX = particle.baseX or effect.sourceX
    local baseY = particle.baseY or effect.sourceY
    
    -- Apply motion based on style
    if motionStyle == Constants.MotionStyle.RADIAL then
        -- Standard radial outward motion (default)
        -- This behavior is already handled in most effect update functions
        -- Just update existing motion with time factor
        
    elseif motionStyle == Constants.MotionStyle.SWIRL then
        -- Tangential swirl using sine/cosine
        -- Start with the existing direction, then add rotational motion
        local angle = particle.angle or math.atan2(particle.targetY - baseY, particle.targetX - baseX)
        local baseDistance = math.sqrt((particle.targetX - baseX)^2 + (particle.targetY - baseY)^2)
        local distance = baseDistance * particleProgress
        local swirlFactor = 2.0 -- Controls the swirl tightness
        local rotationSpeed = 4.0 -- Controls how fast particles orbit
        
        -- Orbit around the path while moving outward
        local swirlAngle = angle + math.sin(time * rotationSpeed) * swirlFactor
        particle.x = baseX + math.cos(swirlAngle) * distance
        particle.y = baseY + math.sin(swirlAngle) * distance
        
    elseif motionStyle == Constants.MotionStyle.HEX then
        -- Approximated hex grid movement using snapped angles
        -- Move along hex angles (0, 60, 120, 180, 240, 300 degrees)
        local baseAngle = particle.angle or 0
        local hexAngle = math.floor(baseAngle / (math.pi/3)) * (math.pi/3)
        local jitterAmount = 0.2 * math.sin(time * 5) -- Small jitter
        local speed = particle.speed or 100 -- Default speed if not set
        local distance = speed * particleProgress
        
        particle.x = baseX + math.cos(hexAngle + jitterAmount) * distance
        particle.y = baseY + math.sin(hexAngle + jitterAmount) * distance
        
    elseif motionStyle == Constants.MotionStyle.STATIC then
        -- Minimal movement with subtle breathing effect
        local breatheFactor = 0.1 * math.sin(time * 3)
        
        -- Slight offset from original position
        local offsetX = (particle.targetX - baseX) * 0.2 * particleProgress
        local offsetY = (particle.targetY - baseY) * 0.2 * particleProgress
        
        -- Apply breathing effect
        particle.x = baseX + offsetX + math.cos(particle.angle or 0) * breatheFactor
        particle.y = baseY + offsetY + math.sin(particle.angle or 0) * breatheFactor
        
    elseif motionStyle == Constants.MotionStyle.RISE then
        -- Particles float upward
        local speed = particle.speed or 100 -- Default speed if not set
        local horizontalSpeed = speed * 0.3
        local verticalSpeed = speed
        
        particle.x = baseX + math.cos(particle.angle or 0) * horizontalSpeed * particleProgress
        particle.y = baseY - verticalSpeed * particleProgress -- Subtract to move up
        
    elseif motionStyle == Constants.MotionStyle.FALL then
        -- Particles fall downward
        local speed = particle.speed or 100 -- Default speed if not set
        local horizontalSpeed = speed * 0.3
        local verticalSpeed = speed
        local gravity = 100 -- Acceleration factor
        
        particle.x = baseX + math.cos(particle.angle or 0) * horizontalSpeed * particleProgress
        particle.y = baseY + (verticalSpeed * particleProgress + 0.5 * gravity * particleProgress * particleProgress)
        
    elseif motionStyle == Constants.MotionStyle.PULSE then
        -- Particles pulse outward and inward
        local pulseDistance = math.sin(time * 4) * 0.5 + 0.5 -- 0 to 1 pulsing
        local targetDistance = math.sqrt((particle.targetX - baseX)^2 + (particle.targetY - baseY)^2)
        local distance = targetDistance * pulseDistance * particleProgress
        
        particle.x = baseX + math.cos(particle.angle or 0) * distance
        particle.y = baseY + math.sin(particle.angle or 0) * distance
        
        -- Also pulse alpha
        particle.alpha = 0.4 + pulseDistance * 0.6
        
    elseif motionStyle == Constants.MotionStyle.RIPPLE then
        -- Wave-like ripple effect
        local angle = particle.angle or math.atan2(particle.targetY - baseY, particle.targetX - baseX)
        local baseDistance = math.sqrt((particle.targetX - baseX)^2 + (particle.targetY - baseY)^2)
        local distance = baseDistance * particleProgress
        
        -- Add wave effect perpendicular to the radial direction
        local waveAmplitude = 10 * math.sin(distance * 0.1 + time * 5)
        local perpX = -math.sin(angle) * waveAmplitude
        local perpY = math.cos(angle) * waveAmplitude
        
        particle.x = baseX + math.cos(angle) * distance + perpX
        particle.y = baseY + math.sin(angle) * distance + perpY
        
    elseif motionStyle == Constants.MotionStyle.DIRECTIONAL then
        -- Directional movement along a specific path
        -- This simply follows the default trajectory but with less randomness
        local dirX = (particle.targetX or baseX + 100) - baseX
        local dirY = (particle.targetY or baseY) - baseY
        local length = math.sqrt(dirX^2 + dirY^2)
        
        if length > 0 then
            dirX = dirX / length
            dirY = dirY / length
            
            -- Move with consistent speed
            local speed = particle.speed or 100 -- Default speed if not set
            particle.x = baseX + dirX * speed * particleProgress * time
            particle.y = baseY + dirY * speed * particleProgress * time
        end
    end
    
    -- Handle special visual effects for certain motion styles
    if motionStyle == Constants.MotionStyle.PULSE then
        -- Special scaling for pulse motion
        local pulseScale = 0.8 + 0.4 * math.sin(time * 4)
        particle.scale = (effect.startScale + (effect.endScale - effect.startScale) * particleProgress) * pulseScale
    end
end

-- Reset function for effect objects
function VFX.resetEffect(effect)
    -- Only release particles if effect has particles field
    if effect.particles then
        -- Use ParticleManager to safely release all particles
        ParticleManager.releaseAllParticles(effect.particles)
    end

    -- Clear all fields except particles
    effect.name = nil
    effect.type = nil
    effect.sourceX = nil
    effect.sourceY = nil
    effect.targetX = nil
    effect.targetY = nil
    effect.duration = nil
    effect.timer = nil
    effect.progress = nil
    effect.isComplete = nil
    effect.particleCount = nil
    effect.startScale = nil
    effect.endScale = nil
    effect.color = nil
    effect.trailPoints = nil
    effect.sound = nil
    effect.radius = nil
    effect.beamWidth = nil
    effect.height = nil
    effect.pulseRate = nil
    effect.trailLength = nil
    effect.impactSize = nil
    effect.spreadRadius = nil
    effect.options = nil
    effect.coreDensity = nil
    effect.trailDensity = nil
    effect.turbulence = nil
    effect.arcHeight = nil
    effect.particleLifespan = nil
    effect.leadingIntensity = nil
    effect.flickerRate = nil
    effect.flickerIntensity = nil
    effect.useSprites = nil
    effect.spriteFrameRate = nil
    effect.spriteRotationOffset = nil
    effect.spriteScale = nil
    effect.spriteTint = nil
    effect.straightLine = nil
    effect.rotateSprite = nil
    effect.rotationSpeed = nil
    effect.drawAtTarget = nil
    effect.usePulse = nil
    effect.pulseAmount = nil
    effect.glowIntensity = nil
    effect.particleDensity = nil
    effect.beamProgress = nil
    effect.beamLength = nil
    effect.beamAngle = nil
    effect.impactCreated = nil
    effect.manaPoolX = nil
    effect.manaPoolY = nil
    effect.sourceGlow = nil
    effect.poolGlow = nil
    effect.motion = nil
    effect.rangeBand = nil
    effect.elevation = nil
    effect.addons = nil
    effect.spread = nil
    effect.visualProgress = nil
    effect.blockTimerStarted = nil
    effect.blockTimer = nil
    effect.blockInfo = nil
    effect.blockLogged = nil
    effect.impactParticlesCreated = nil

    -- Reset particles array but don't delete it
    effect.particles = {}

    return effect
end

-- Helper function to ensure all effect parameters are valid
function VFX.sanitizeEffectParameters(effectName, sourceX, sourceY, targetX, targetY, options)
    -- Sanitize effect name
    if not effectName or effectName == "" then
        effectName = "impact_base" -- Safe default
        print("[VFX] Warning: Missing effect name, using impact_base as fallback")
    end
    
    -- Sanitize coordinates
    sourceX = sourceX or 0
    sourceY = sourceY or 0
    targetX = targetX or sourceX
    targetY = targetY or sourceY
    
    -- Sanitize options
    options = options or {}
    
    -- Ensure critical fields are present
    options.duration = options.duration or 0.5
    options.scale = options.scale or 1.0
    options.particleCount = options.particleCount or 10
    
    -- For blocked projectiles
    if options.blockInfo then
        options.blockPoint = options.blockPoint or 0.75
    end
    
    -- Always set default color if missing
    if not options.color then
        options.color = {1.0, 1.0, 1.0, 1.0} -- White fallback
    end
    
    -- Return sanitized values
    return effectName, sourceX, sourceY, targetX, targetY, options
end

-- Create a new effect instance
function VFX.createEffect(effectName, sourceX, sourceY, targetX, targetY, options)
    -- Sanitize all parameters to prevent nil errors
    effectName, sourceX, sourceY, targetX, targetY, options = 
        VFX.sanitizeEffectParameters(effectName, sourceX, sourceY, targetX, targetY, options)
    local Constants = require("core.Constants")
    
    -- Enhanced debugging for VFX-R5 implementation
    print("\n====== VFX CREATION CALL ======")
    print("[VFX] CALL STACK: " .. debug.traceback())
    print("[VFX] effectName: " .. tostring(effectName))
    print("[VFX] sourceX: " .. tostring(sourceX) .. " sourceY: " .. tostring(sourceY))
    if targetX and targetY then
        print("[VFX] targetX: " .. tostring(targetX) .. " targetY: " .. tostring(targetY))
    end
    if options then
        print("[VFX] Options:")
        for k, v in pairs(options) do
            if type(v) == "table" then
                print("  " .. k .. ": [table]")
            else
                print("  " .. k .. ": " .. tostring(v))
            end
        end
    end
    print("================================\n")
    
    -- Handle both string and Constants.VFXType format
    local effectNameStr
    
    -- Validate and normalize effectName 
    if type(effectName) ~= "string" then
        print("Error in VFX.createEffect: Effect name must be a string or Constants.VFXType value, got: " .. tostring(effectName))
        -- Fall back to a default effect
        effectNameStr = Constants.VFXType.IMPACT
    else
        effectNameStr = effectName
    end
    
    -- Regular debug output
    print("[VFX] Creating effect: " .. effectNameStr)
    print("[VFX] sourceX: " .. sourceX .. " sourceY: " .. sourceY)
    if targetX and targetY then
        print("[VFX] targetX: " .. targetX .. " targetY: " .. targetY)
    end
    
    -- Process options
    local opts = options or {}
    
    -- Process options.addons if provided (for future work)
    if opts.addons and #opts.addons > 0 then
        for _, addon in ipairs(opts.addons) do
            print("[VFX] TODO addon: " .. tostring(addon))
            -- In future work, we would create or modify effects based on addons
            -- Example: Apply a fire overlay to a projectile, add a sparkle effect, etc.
        end
    end
    
    -- Try to get the effect template first to check for critical assets
    local template = VFX.effects[effectNameStr:lower()]
    if template then
        -- Template exists, check for critical assets
        if template.criticalAssets then
            for _, assetId in ipairs(template.criticalAssets) do
                -- Try to get the asset, will trigger loading if not available
                local asset = VFX.getAsset(assetId)
                if not asset or (assetId == "runes" and #asset == 0) then
                    -- Asset failed to load, try emergency loading
                    print("[VFX] Critical asset missing: " .. assetId .. ", attempting emergency load")
                    
                    -- Emergency loading of critical asset
                    if assetId == "runes" and VFX.assetPaths and VFX.assetPaths.runes then
                        print("[VFX] Emergency loading of rune assets")
                        local AssetCache = require("core.AssetCache")
                        VFX.assets.runes = VFX.assets.runes or {}
                        for i, runePath in ipairs(VFX.assetPaths.runes) do
                            local runeImg = AssetCache.getImage(runePath)
                            if runeImg then
                                table.insert(VFX.assets.runes, runeImg)
                            end
                        end
                    elseif VFX.assetPaths and VFX.assetPaths[assetId] then
                        print("[VFX] Emergency loading of asset: " .. assetId)
                        local AssetCache = require("core.AssetCache")
                        VFX.assets[assetId] = AssetCache.getImage(VFX.assetPaths[assetId])
                    end
                end
            end
        end
    else
        -- Backward compatibility for effects without templates that may need runes
        -- (e.g., mistveil, effects with "ward" in the name)
        if effectNameStr:lower():find(Constants.ShieldType.WARD) or effectNameStr:lower() == "mistveil" then
            -- Ensure runes are loaded for ward-related effects
            local runeAssets = VFX.getAsset("runes")
            if not runeAssets or #runeAssets == 0 then
                print("[VFX] Warning: Ward effect requested but rune assets not available.")
                -- Force-load runes
                if VFX.assetPaths and VFX.assetPaths.runes then
                    local AssetCache = require("core.AssetCache")
                    VFX.assets.runes = {}
                    for i, runePath in ipairs(VFX.assetPaths.runes) do
                        print("[VFX] Emergency loading of rune asset: " .. i)
                        local runeImg = AssetCache.getImage(runePath)
                        if runeImg then
                            table.insert(VFX.assets.runes, runeImg)
                        end
                    end
                end
            end
        end
    end
    
    -- Get or reuse effect template - use :lower() safely now that we've verified it's a string
    if not template then -- Only if we didn't already get it above
        template = VFX.effects[effectNameStr:lower()]
        if not template then
            print("Warning: Effect not found: " .. effectNameStr)
            -- Fall back to impact effect if available
            template = VFX.effects[Constants.VFXType.IMPACT]
            if not template then
                return nil -- Give up if no fallback is available
            end
            print("[VFX] Falling back to '" .. Constants.VFXType.IMPACT .. "' effect")
        end
    end
    
    -- Create a new effect instance from pool
    local effect = Pool.acquire("vfx_effect")
    effect.name = effectName
    effect.type = template.type
    effect.sourceX = sourceX
    effect.sourceY = sourceY
    effect.targetX = targetX or sourceX
    effect.targetY = targetY or sourceY
    
    -- Store source and target entities for position tracking if provided in options
    if options and options.sourceEntity then
        effect.sourceEntity = options.sourceEntity
        
        -- Initialize with source position including offsets if available
        if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
            effect.sourceX = effect.sourceEntity.x + effect.sourceEntity.currentXOffset
            effect.sourceY = effect.sourceEntity.y + effect.sourceEntity.currentYOffset
        end
    end
    
    if options and options.targetEntity then
        effect.targetEntity = options.targetEntity
        
        -- Initialize with target position including offsets if available
        if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
            effect.targetX = effect.targetEntity.x + effect.targetEntity.currentXOffset
            effect.targetY = effect.targetEntity.y + effect.targetEntity.currentYOffset
        end
    end
    
    -- Flag for effects that should use target's actual position including offsets
    effect.trackTargetOffsets = (options and options.trackTargetOffsets) or (template and template.trackTargetOffsets) or false
    
    -- Flag for effects that should use source position tracking
    effect.useSourcePosition = (options and options.useSourcePosition) or (template and template.useSourcePosition) or false
    
    -- Flag for effects that should use target position tracking
    effect.useTargetPosition = (options and options.useTargetPosition) or (template and template.useTargetPosition) or false
    
    -- Timing
    -- Prioritize duration from options (EventRunner), then template, then fallback.
    if options and options.duration then
        effect.duration = options.duration
    elseif template.duration then
        effect.duration = template.duration
    else
        effect.duration = 0.5 -- Absolute fallback if no duration anywhere
        print("[VFX] Warning: Effect " .. effectNameStr .. " has no duration in options or template. Defaulting to 0.5s.")
    end
    effect.timer = 0
    effect.progress = 0
    effect.isComplete = false
    
    -- Visual properties (copied from template)
    effect.particleCount = template.particleCount
    effect.startScale = template.startScale
    effect.endScale = template.endScale
    effect.color = {template.color[1], template.color[2], template.color[3], template.color[4]}
    
    -- Store shield block information if provided (for projectile block visuals)
    if options and options.blockInfo then
        print("[VFX] Effect has blockInfo - will show shield block visuals")
        effect.blockInfo = options.blockInfo
        effect.options = effect.options or {}
        effect.options.blockPoint = options.blockPoint or 0.75 -- Default to 75% of the way
        effect.options.shieldType = options.blockInfo.blockType or (options.shieldType or "ward")
        
        -- Enhanced debugging for shield block effects
        print(string.format("[VFX] Created blocked effect '%s' with blockPoint=%.2f and shieldType=%s", 
            effectName, effect.options.blockPoint, effect.options.shieldType or "unknown"))
    elseif options and options.blockPoint then
        -- Fallback for cases where blockPoint is provided without blockInfo
        print("[VFX] Effect has blockPoint but no blockInfo - creating minimal blockInfo")
        effect.options = effect.options or {}
        effect.options.blockPoint = options.blockPoint
        effect.options.shieldType = options.shieldType or "ward"
        effect.blockInfo = {
            blockable = true,
            blockType = options.shieldType or "ward",
            blockPoint = options.blockPoint
        }
        
        -- Enhanced debugging for fallback shield block effects
        print(string.format("[VFX] Created fallback blocked effect '%s' with blockPoint=%.2f", 
            effectName, effect.options.blockPoint))
    elseif options and options.tags and options.tags.SHIELD_BLOCKED then
        -- Ultra fallback for SHIELD_BLOCKED tag without proper blockInfo
        print("[VFX] Effect has SHIELD_BLOCKED tag but no blockInfo or blockPoint - creating default blockInfo")
        effect.options = effect.options or {}
        effect.options.blockPoint = 0.75
        effect.options.shieldType = options.shieldType or "ward"
        effect.blockInfo = {
            blockable = true,
            blockType = options.shieldType or "ward",
            blockPoint = 0.75
        }
        
        -- Enhanced debugging for ultra fallback shield block effects
        print(string.format("[VFX] Created ultra fallback blocked effect '%s' with default blockPoint=0.75", 
            effectName))
    end
    
    -- Apply options modifiers
    if opts.color then
        -- Override color with the provided color
        effect.color = {opts.color[1], opts.color[2], opts.color[3], opts.color[4] or 1.0}
    end
    
    if opts.scale then
        -- Apply scale factor to particle counts, sizes, radii, etc.
        local scaleFactor = opts.scale
        if effect.particleCount then
            effect.particleCount = math.floor(effect.particleCount * scaleFactor)
        end
        if effect.startScale then
            effect.startScale = effect.startScale * scaleFactor
        end
        if effect.endScale then
            effect.endScale = effect.endScale * scaleFactor
        end
        if effect.radius then effect.radius = effect.radius * scaleFactor end
        if effect.beamWidth then effect.beamWidth = effect.beamWidth * scaleFactor end
        if effect.height then effect.height = effect.height * scaleFactor end
        if effect.spread then effect.spread = effect.spread * scaleFactor end
    end
    
    -- Store motion style and positional info
    effect.motion = opts.motion
    effect.rangeBand = opts.rangeBand
    effect.elevation = opts.elevation
    effect.addons = opts.addons
    
    -- Effect specific properties
    effect.particles = {}
    effect.trailPoints = {}
    
    -- Sound
    effect.sound = template.sound
    
    -- Additional properties based on effect type
    effect.radius = template.radius
    effect.beamWidth = template.beamWidth
    effect.height = template.height
    effect.pulseRate = template.pulseRate
    effect.trailLength = template.trailLength
    effect.impactSize = template.impactSize
    effect.spreadRadius = template.spreadRadius
    effect.spread = template.spread
    effect.coreDensity = template.coreDensity
    effect.trailDensity = template.trailDensity
    effect.turbulence = template.turbulence
    effect.arcHeight = template.arcHeight
    effect.particleLifespan = template.particleLifespan
    effect.leadingIntensity = template.leadingIntensity
    effect.flickerRate = template.flickerRate
    effect.flickerIntensity = template.flickerIntensity
    effect.useSprites = template.useSprites
    effect.spriteFrameRate = template.spriteFrameRate
    effect.spriteRotationOffset = template.spriteRotationOffset
    effect.spriteScale = template.spriteScale
    effect.spriteTint = template.spriteTint
    effect.straightLine = template.straightLine
    effect.rotateSprite = template.rotateSprite
    effect.rotationSpeed = template.rotationSpeed
    effect.drawAtTarget = template.drawAtTarget
    effect.usePulse = template.usePulse
    effect.pulseAmount = template.pulseAmount
    effect.glowIntensity = template.glowIntensity
    effect.particleDensity = template.particleDensity
    
    -- Optional overrides
    effect.options = options or {}
    
    -- Initialize particles based on effect type
    VFX.initializeParticles(effect)
    
    -- Play sound effect if available
    if effect.sound and VFX.sounds and VFX.sounds[effect.sound] then
        -- Will play sound when implemented
    end
    
    -- Add to active effects list
    table.insert(VFX.activeEffects, effect)
    
    return effect
end

-- Initialize particles based on effect type
-- Helper function to ensure particle has all required properties
function VFX.ensureParticleDefaults(particle)
    -- Safety defaults for mandatory properties
    particle.delay = particle.delay or 0
    particle.active = particle.active or false
    particle.startTime = particle.startTime or 0
    particle.scale = particle.scale or 1.0
    particle.alpha = particle.alpha or 1.0
    particle.rotation = particle.rotation or 0
    particle.isCore = particle.isCore or false
    return particle
end

function VFX.initializeParticles(effect)
    return initializeParticlesModule(effect)
end
-- Update all active effects
function VFX.update(dt)
    local i = 1
    
    -- Safety check
    if not VFX.activeEffects then 
        VFX.activeEffects = {}
        return
    end
    
    while i <= #VFX.activeEffects do
        local effect = VFX.activeEffects[i]
        
        -- Skip invalid effects
        if not effect then
            table.remove(VFX.activeEffects, i)
            goto next_effect
        end
        
        -- Update effect timer
        -- Make sure we have valid values
        effect.timer = effect.timer or 0
        effect.duration = effect.duration or 0.5
        
        -- Update timer
        effect.timer = effect.timer + dt
        
        -- Update positions based on tracked entities
        -- First check source position updates
        if effect.useSourcePosition and effect.sourceEntity then
            -- Check for wizard-specific position offsets
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                -- Update source position with offsets
                effect.sourceX = effect.sourceEntity.x + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceEntity.y + effect.sourceEntity.currentYOffset
            end
        end
        
        -- Then check target position updates
        if effect.useTargetPosition and effect.targetEntity then
            -- Check for wizard-specific position offsets
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                -- Update target position with offsets
                effect.targetX = effect.targetEntity.x + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetEntity.y + effect.targetEntity.currentYOffset
            end
        end
        
        -- Only calculate progress if duration is valid
        if effect.duration > 0 then
            effect.progress = math.min(effect.timer / effect.duration, 1.0)
        else
            effect.progress = effect.timer -- Fallback when duration is 0
            print("[VFX] Warning: Effect has invalid duration: " .. tostring(effect.duration))
        end
        
        -- Handle shield block effects with improved safeguards
        local isBlocked = effect.options and effect.options.blockPoint

        -- Mark effect as blocked if necessary
        if isBlocked and not effect.isBlocked then
            effect.isBlocked = true
            print("[VFX] Setting effect.isBlocked = true for projectile")
        end

        -- Debug to verify blocked effect tracking
        if isBlocked and effect.timer == dt then  -- First update frame
            print(string.format("[VFX] Tracking blocked effect '%s' with blockPoint=%.2f",
                effect.name or "unknown", effect.options.blockPoint))
        end
        
        if isBlocked then
            -- Ensure these fields exist to prevent runtime errors
            if not effect.type then effect.type = effect.name or "projectile" end
            if not effect.options then effect.options = {} end
            if not effect.options.blockPoint then effect.options.blockPoint = 0.75 end
            
            -- NEW: Instead of immediately setting progress to blockPoint, use a visual progress tracker
            -- This allows the projectile to follow a natural trajectory
            if not effect.visualProgress then
                -- Initialize visualProgress at the beginning (first frame)
                effect.visualProgress = 0
                print("[VFX] Initializing blocked projectile trajectory")
            end
            
            -- Update visualProgress for smooth animation - speed up slightly for gameplay feel
            effect.visualProgress = effect.visualProgress + dt * (1/effect.duration) * 1.2
            
            -- Clamp visualProgress at the block point
            effect.visualProgress = math.min(effect.visualProgress, effect.options.blockPoint)
            
            -- Determine if effect should be blocked - check if visualProgress reached blockPoint
            local shouldStartBlock = not effect.blockTimerStarted and effect.visualProgress >= effect.options.blockPoint - 0.01
            
            -- Start the block effect when we reach the block point
            if shouldStartBlock then
                -- Mark the start of block timing
                effect.blockTimerStarted = true
                effect.blockTimer = 0
                
                -- Lock progress at block point to show projectile stopping
                effect.visualProgress = effect.options.blockPoint
                
                -- Enhanced debugging
                print(string.format("[VFX] Effect '%s' blocked at %.2f, starting shield impact sequence", 
                    effect.name or "unknown", effect.options.blockPoint))
                
                -- Create shield impact effect
                -- Trigger shield impact visuals for projectile-type effects
                -- Accept both generic projectile templates (proj_base/bolt_base)
                if not effect.impactParticlesCreated and
                   (effect.type == "proj_base" or effect.type == "bolt_base" or effect.type == "orb_base" or
                    effect.type == "projectile") then
                    effect.impactParticlesCreated = true
                    
                    -- Calculate impact position 
                    local progress = effect.options.blockPoint
                    local impactX = effect.sourceX + (effect.targetX - effect.sourceX) * progress
                    local impactY = effect.sourceY + (effect.targetY - effect.sourceY) * progress
                    
                    -- Create a separate shield hit effect
                    print(string.format("[VFX] Creating shield hit effect at (%.1f, %.1f)", impactX, impactY))
                    
                    -- Determine shield color based on shield type
                    local shieldColor = {1.0, 1.0, 0.3, 0.7}  -- Default yellow
                    if effect.options.shieldType == "ward" then
                        shieldColor = {0.3, 0.3, 1.0, 0.7}  -- Blue for wards 
                    elseif effect.options.shieldType == "field" then
                        shieldColor = {0.3, 1.0, 0.3, 0.7}  -- Green for fields
                    end
                    
                    -- Make the impact more dramatically visible to the player
                    -- Use impact_base or a fallback effect
                    local impactEffect = "impact_base"
                    
                    -- Impact flash effect
                    local flashParams = {
                        duration = 0.3,
                        scale = (effect.startScale or 1.0) * 1.5,
                        color = {shieldColor[1], shieldColor[2], shieldColor[3], 0.9},
                        particleCount = 1
                    }
                    VFX.createEffect(impactEffect, impactX, impactY, impactX, impactY, flashParams)
                    
                    -- Particle burst effect 
                    local burstParams = {
                        duration = 0.8,
                        scale = (effect.startScale or 1.0) * 1.2,
                        color = shieldColor,
                        particleCount = 30
                    }
                    VFX.createEffect(impactEffect, impactX, impactY, impactX, impactY, burstParams)
                    
                    -- No need to add particles to current effect
                    print("[VFX] Created shield impact effects")

                    -- Clean up the projectile immediately after impact
                    ParticleManager.releaseAllParticles(effect.particles or {})
                    effect.particles = {}
                    effect.blockTimerStarted = nil
                    effect.progress = 1.0
                    
                    -- Trigger screen shake at the exact moment of shield impact
                    print("[VFX] Attempting to trigger screen shake for shield block")
                    
                    -- Get the game state reference from the effect options if available
                    local gameState = nil
                    
                    -- First try to use the directly passed gameState if available
                    if effect.options and effect.options.gameState then
                        print("[VFX] Found gameState directly in options")
                        gameState = effect.options.gameState
                    -- Next try through sourceEntity
                    elseif effect.options and effect.options.sourceEntity and effect.options.sourceEntity.gameState then
                        print("[VFX] Found gameState through sourceEntity")
                        gameState = effect.options.sourceEntity.gameState
                    -- Next try through targetEntity
                    elseif effect.options and effect.options.targetEntity and effect.options.targetEntity.gameState then
                        print("[VFX] Found gameState through targetEntity")
                        gameState = effect.options.targetEntity.gameState
                    -- Finally try the global game object
                    else
                        -- Try to find it through the global game object
                        print("[VFX] No entity references found, looking for global game object")
                        if _G.game then
                            print("[VFX] Found global game object via _G.game")
                            gameState = _G.game
                        elseif game then -- Try directly referencing the global variable 
                            print("[VFX] Found global game object via direct access")
                            gameState = game
                        -- As a last resort, use the VFX module's stored reference
                        elseif VFX.gameState then
                            print("[VFX] Using VFX.gameState reference")
                            gameState = VFX.gameState
                        end
                    end
                    
                    -- Check if we have game state and trigger methods
                    if gameState then
                        print("[VFX] GameState found. Has triggerShake: " .. tostring(gameState.triggerShake ~= nil))
                    else
                        print("[VFX] No gameState found for triggering shake!")
                    end
                    
                    -- Determine impact amount for shake intensity (from effect or default)
                    local amount = effect.options.amount or 10
                    local intensity = math.min(4, 2 + (amount / 20))
                    local shakeDuration = 0.2
                    
                    -- Trigger shake if we have access to the game state
                    if gameState and gameState.triggerShake then
                        -- Trigger a light shake for shield blocks via gameState
                        print(string.format("[VFX] About to call gameState.triggerShake(%.2f, %.2f)", shakeDuration, intensity))
                        gameState.triggerShake(shakeDuration, intensity)
                        print(string.format("[VFX] Shield block impact! Triggered light shake (%.2f, %.2f) at blockPoint=%.2f", 
                            shakeDuration, intensity, effect.options.blockPoint or 0))
                    elseif VFX.triggerShake then
                        -- Use the VFX module's direct function reference
                        print(string.format("[VFX] About to call VFX.triggerShake(%.2f, %.2f)", shakeDuration, intensity))
                        VFX.triggerShake(shakeDuration, intensity)
                        print(string.format("[VFX] Shield block impact! Triggered light shake via VFX.triggerShake"))
                    else
                        -- Last resort: Try to use the global function directly
                        if _G.triggerShake then
                            print(string.format("[VFX] About to call global triggerShake(%.2f, %.2f)", shakeDuration, intensity))
                            _G.triggerShake(shakeDuration, intensity)
                            print("[VFX] Called global triggerShake function")
                        else
                            print("[VFX] Could not trigger shake - no valid triggerShake function found")
                        end
                    end
                end
            end
            
            -- Once block is triggered, increment a block timer
            if effect.blockTimerStarted then
                effect.blockTimer = effect.blockTimer + dt
                -- Keep the effect alive until the block timer elapses
                if effect.blockTimer > 1.2 then
                    -- After the hold period, mark the effect complete
                    effect.progress = 1.0
                    print(string.format("[VFX] Blocked effect '%s' cleanup - forcing completion", effect.name or "unknown"))
                else
                    -- Lock both visual and logical progress at the block point so the effect isn't removed early
                    effect.visualProgress = effect.options.blockPoint
                    effect.progress = math.min(effect.progress, effect.options.blockPoint)
                end
            end
        end
        
        -- Update target position if tracking offsets and we have a target entity
        if effect.trackTargetOffsets and effect.targetEntity then
            -- Include wizard offsets in target position
            local targetWizard = effect.targetEntity
            if targetWizard and targetWizard.x and targetWizard.y then
                local xOffset = targetWizard.currentXOffset or 0
                local yOffset = targetWizard.currentYOffset or 0
                
                -- Update the effect's target position to follow the wizard
                effect.targetX = targetWizard.x + xOffset
                effect.targetY = targetWizard.y + yOffset
            end
        end
        
        -- Update effect based on type using the dispatcher
        local effectType = effect.type
        local updater = VFX.updaters[effectType]
        if updater then
            -- Add safety pcall to prevent crashes
            local success, err = pcall(function()
                updater(effect, dt)
            end)

            if not success then
                print(string.format("[VFX] Error updating effect type '%s': %s", tostring(effectType), tostring(err)))
            end
        else
            -- Fallback or warning for unhandled types
            print("[VFX] Warning: No updater found for VFX type: " .. tostring(effectType))
        end
        
        -- Remove effect if complete
        if effect.progress >= 1.0 then
            -- Execute onComplete callback if it exists
            if effect.options and effect.options.onComplete then
                print("[VFX] Executing onComplete callback for effect: " .. (effect.name or "unnamed"))
                local success, err = pcall(function()
                    effect.options.onComplete(effect)
                end)
                
                if not success then
                    print("[VFX] Error in onComplete callback: " .. tostring(err))
                end
            end
            
            -- Release the effect and its particles back to their pools
            local removedEffect = table.remove(VFX.activeEffects, i)
            Pool.release("vfx_effect", removedEffect)
        else
            i = i + 1
        end
        
        ::next_effect::
        -- Continue label for the loop
    end
end

-- Draw all active effects
function VFX.draw()
    for _, effect in ipairs(VFX.activeEffects) do
        local effectType = effect.type
        local drawer = VFX.drawers[effectType]
        if drawer then
            -- Preserve current graphics state so individual effect draw calls
            -- cannot permanently modify color or blend mode
            local prevR, prevG, prevB, prevA = love.graphics.getColor()
            local prevBlendSrc, prevBlendDst = love.graphics.getBlendMode()

            -- Add safety pcall to prevent crashes
            local success, err = pcall(function()
                drawer(effect)
            end)

            -- Restore graphics state
            love.graphics.setColor(prevR, prevG, prevB, prevA)
            love.graphics.setBlendMode(prevBlendSrc, prevBlendDst)

            if not success then
                print(string.format("[VFX] Error drawing effect type '%s': %s", tostring(effectType), tostring(err)))
            end
        else
            -- Fallback or warning for unhandled types
            print("[VFX] Warning: No drawer found for VFX type: " .. tostring(effectType))
        end
    end
end
-- Helper function for HSV to RGB conversion (for volatile conjuring rainbow effect)
function HSVtoRGB(h, s, v)
    local r, g, b
    
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    
    i = i % 6
    
    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end
    
    return r, g, b
end

-- Show Pool stats in debug mode
function VFX.showPoolStats()
    print("\n=== VFX POOLS STATS ===")
    print(string.format("Active Effects: %d", #VFX.activeEffects))
    print(string.format("Particle Pool Size: %d (Available: %d, Active: %d)",
        Pool.size("vfx_particle"), Pool.available("vfx_particle"), Pool.activeCount("vfx_particle")))
    print(string.format("Effect Pool Size: %d (Available: %d, Active: %d)",
        Pool.size("vfx_effect"), Pool.available("vfx_effect"), Pool.activeCount("vfx_effect")))

    -- Check for potential issues
    local particlePoolActiveCount = Pool.activeCount("vfx_particle")
    local activeParticlesCount = 0

    -- Count actual particles in active effects
    for _, effect in ipairs(VFX.activeEffects) do
        if effect.particles then
            activeParticlesCount = activeParticlesCount + #effect.particles
        end
    end

    -- Report if there's a mismatch
    if particlePoolActiveCount > activeParticlesCount then
        print(string.format("WARNING: Pool reports %d active particles but only %d found in effects",
            particlePoolActiveCount, activeParticlesCount))
        print("This suggests particles are not being properly released back to the pool")
    elseif particlePoolActiveCount < activeParticlesCount then
        print(string.format("WARNING: Found %d particles in effects but pool only reports %d active",
            activeParticlesCount, particlePoolActiveCount))
        print("This suggests particles are being created without using Pool.acquire")
    end

    -- Check particle creation and usage rate
    local creates = Pool.stats.creates["vfx_particle"] or 0
    local acquires = Pool.stats.acquires["vfx_particle"] or 0

    if creates > 0 and acquires > 0 then
        local reuseRate = (acquires - creates) / acquires * 100
        print(string.format("Particle Reuse Rate: %.1f%% (Lower is worse)", reuseRate))

        if reuseRate < 50 then
            print("WARNING: Low particle reuse rate suggests pool is too small or particles aren't being released properly")
        end
    end
end

-- Create an effect with async callback support
-- Currently just a stub - in the future, this could use coroutines or callbacks for complex effects
function VFX.createEffectAsync(effectName, sourceX, sourceY, targetX, targetY, options)
    -- Create the effect normally
    local effect = VFX.createEffect(effectName, sourceX, sourceY, targetX, targetY, options)
    
    -- Return a "promise-like" table with callback support
    return {
        effect = effect,  -- Store a reference to the actual effect
        
        -- Method to register a callback for when the effect completes
        onComplete = function(callback)
            print("[VFX] Async VFX callback registered (stub)")
            -- In a full implementation, this would store the callback and call it 
            -- when the effect completes (tracked via effect.progress reaching 1.0)
            return effect
        end
    }
end

-- Diagnostic function to run on game startup to detect and fix particle pool issues
function VFX.runParticlePoolDiagnostic()
    print("\n=== VFX PARTICLE POOL DIAGNOSTIC ===")
    local stats = ParticleManager.getStats()
    print(string.format("Particle Pool: %d total (%d active, %d available)",
        stats.poolSize, stats.active, stats.available))

    -- Check for active particles that aren't in use
    if stats.active > 0 and #VFX.activeEffects == 0 then
        print("WARNING: Pool reports active particles but no active effects exist")
        print("This suggests particles weren't released properly in a previous session")

        -- Force reset the pool
        print("Resetting particle pool to fix the issue...")
        Pool.clear("vfx_particle")

        -- Recreate with initial size
        Pool.create("vfx_particle", 100, function() return {} end, VFX.resetParticle)

        print("Pool reset complete")
    end

    -- Test particle acquisition and release
    print("Testing particle acquisition and release...")
    local testParticle = ParticleManager.createParticle()
    if testParticle then
        print("Successfully acquired test particle from pool")
        if ParticleManager.releaseParticle(testParticle) then
            print("Successfully released test particle back to pool")
        else
            print("ERROR: Failed to release test particle")
        end
    else
        print("ERROR: Failed to acquire test particle from pool")
    end

    print("Diagnostic complete!")
end

-- Import effect modules
local ProjectileEffect = require("vfx.effects.projectile")
local ImpactEffect = require("vfx.effects.impact")
local BeamEffect = require("vfx.effects.beam")
local ConeEffect = require("vfx.effects.cone")
local AuraEffect = require("vfx.effects.aura")
local ConjureEffect = require("vfx.effects.conjure")
local SurgeEffect = require("vfx.effects.surge")
local RemoteEffect = require("vfx.effects.remote")
local MeteorEffect = require("vfx.effects.meteor")
local ZapEffect = require("vfx.effects.zap")

-- Initialize the updaters table with update functions
-- Map each template name/type to the appropriate handler
VFX.updaters["proj_base"] = ProjectileEffect.update  -- Generic projectile template
VFX.updaters["bolt_base"] = ProjectileEffect.update  -- Bolt uses projectile logic
VFX.updaters["orb_base"] = ProjectileEffect.update   -- Orb uses projectile logic
VFX.updaters["zap_base"] = ZapEffect.update        -- Zap lightning effect
VFX.updaters["impact_base"] = ImpactEffect.update    -- Impact effect template
VFX.updaters["beam_base"] = BeamEffect.update        -- Beam effect template
VFX.updaters["blast_base"] = ConeEffect.update       -- Blast uses cone logic
VFX.updaters["zone_base"] = AuraEffect.update        -- Zone uses aura logic
VFX.updaters["util_base"] = AuraEffect.update        -- Utility uses aura logic
VFX.updaters["surge_base"] = SurgeEffect.update      -- Surge fountain template
VFX.updaters["wave_base"] = ProjectileEffect.update  -- Flowing wave uses projectile logic
VFX.updaters["conjure_base"] = ConjureEffect.update  -- Conjuration template
VFX.updaters["remote_base"] = RemoteEffect.update    -- Remote effect template
VFX.updaters["warp_base"] = RemoteEffect.update      -- Warp uses remote logic
VFX.updaters["shield_hit_base"] = ImpactEffect.update -- Shield hit template

-- Specific effect templates
VFX.updaters["meteor"] = MeteorEffect.update         -- Meteor effect
VFX.updaters["impact"] = ImpactEffect.update         -- Generic impact
VFX.updaters["force_blast"] = ImpactEffect.update    -- Force blast uses impact logic
VFX.updaters["free_mana"] = AuraEffect.update        -- Free mana uses aura logic
VFX.updaters["shield"] = AuraEffect.update           -- Shield uses aura logic
VFX.updaters["emberlift"] = SurgeEffect.update       -- Emberlift uses surge logic
VFX.updaters["range_change"] = SurgeEffect.update    -- Range change uses surge logic

-- Add backward compatibility for critical legacy code paths
-- These keys will be removed in a future update
VFX.updaters[Constants.AttackType.PROJECTILE] = ProjectileEffect.update

-- Initialize the drawers table with draw functions
VFX.drawers["proj_base"] = ProjectileEffect.draw    -- Generic projectile template
VFX.drawers["bolt_base"] = ProjectileEffect.draw    -- Bolt uses projectile logic
VFX.drawers["orb_base"] = ProjectileEffect.draw     -- Orb uses projectile logic
VFX.drawers["zap_base"] = ZapEffect.draw          -- Zap lightning effect
VFX.drawers["impact_base"] = ImpactEffect.draw      -- Impact effect template
VFX.drawers["beam_base"] = BeamEffect.draw          -- Beam effect template
VFX.drawers["blast_base"] = ConeEffect.draw         -- Blast uses cone logic
VFX.drawers["zone_base"] = AuraEffect.draw          -- Zone uses aura logic
VFX.drawers["util_base"] = AuraEffect.draw          -- Utility uses aura logic
VFX.drawers["surge_base"] = SurgeEffect.draw        -- Surge fountain template
VFX.drawers["wave_base"] = ProjectileEffect.draw    -- Flowing wave uses projectile logic
VFX.drawers["conjure_base"] = ConjureEffect.draw    -- Conjuration template
VFX.drawers["remote_base"] = RemoteEffect.draw      -- Remote effect template
VFX.drawers["warp_base"] = RemoteEffect.draw        -- Warp uses remote logic
VFX.drawers["shield_hit_base"] = ImpactEffect.draw  -- Shield hit template

-- Specific effect templates
VFX.drawers["meteor"] = MeteorEffect.draw           -- Meteor effect
VFX.drawers["impact"] = ImpactEffect.draw           -- Generic impact
VFX.drawers["force_blast"] = ImpactEffect.draw      -- Force blast uses impact logic
VFX.drawers["free_mana"] = AuraEffect.draw          -- Free mana uses aura logic
VFX.drawers["shield"] = AuraEffect.draw             -- Shield uses aura logic
VFX.drawers["emberlift"] = SurgeEffect.draw         -- Emberlift uses surge logic
VFX.drawers["range_change"] = SurgeEffect.draw      -- Range change uses surge logic

-- Add backward compatibility for critical legacy code paths
-- These keys will be removed in a future update
VFX.drawers[Constants.AttackType.PROJECTILE] = ProjectileEffect.draw

return VFX```

## ./vfx/ParticleManager.lua
```lua
-- ParticleManager.lua
-- Centralized system for managing VFX particles using the Pool system

local Pool = require("core.Pool")
local Constants = require("core.Constants")
local ParticleManager = {}

-- Create a new particle from the pool
function ParticleManager.createParticle()
    local particle = Pool.acquire("vfx_particle")
    -- Initialize with default values to avoid nil errors
    particle.x = 0
    particle.y = 0
    particle.scale = 1.0
    particle.alpha = 1.0
    particle.rotation = 0
    particle.active = false
    
    return particle
end

-- Release a particle back to the pool
function ParticleManager.releaseParticle(particle)
    if not particle then return false end
    return Pool.release("vfx_particle", particle)
end

-- Safe clean up function for particles in an effect
function ParticleManager.cleanupEffectParticles(particles, condition)
    local i = 1
    local removedCount = 0
    
    while i <= #particles do
        local particle = particles[i]
        
        -- Check if this particle should be removed based on the provided condition function
        if condition(particle) then
            -- Release the particle back to the pool
            ParticleManager.releaseParticle(particle)
            table.remove(particles, i)
            removedCount = removedCount + 1
        else
            i = i + 1
        end
    end
    
    return removedCount
end

-- Release all particles in an array
function ParticleManager.releaseAllParticles(particles)
    -- Go backward through the array to avoid index issues during removal
    for i = #particles, 1, -1 do
        local particle = particles[i]
        if particle then
            ParticleManager.releaseParticle(particle)
        end
        particles[i] = nil
    end
end

-- Clone particle data (copy from one particle to another)
function ParticleManager.cloneParticleData(sourceParticle, targetParticle)
    -- Copy all fields
    for k, v in pairs(sourceParticle) do
        targetParticle[k] = v
    end
    return targetParticle
end

-- Create a meteor particle
function ParticleManager.createMeteorParticle(effect, offsetX, offsetY)
    local particle = ParticleManager.createParticle()
    
    -- Set meteor-specific properties
    particle.type = "meteor"
    particle.offsetX = offsetX
    particle.offsetY = offsetY
    particle.startX = effect.targetX + offsetX  -- Start above the target
    particle.startY = effect.targetY - effect.height + offsetY
    particle.endX = effect.targetX + offsetX * 0.3  -- End at target with reduced offset
    particle.endY = effect.targetY + offsetY * 0.1
    particle.x = particle.startX
    particle.y = particle.startY
    particle.rotation = math.random() * math.pi * 2
    particle.rotationSpeed = (math.random() - 0.5) * 4
    particle.baseScale = 0.3 + math.random() * 0.3
    particle.scale = 0.3 + math.random() * 0.3
    particle.alpha = 1.0
    particle.timeCreated = effect.timer or 0
    particle.lifespan = (effect.duration or 1.4) * (0.7 + math.random() * 0.6)
    particle.assetId = "fireParticle"
    particle.color = effect.color
    
    return particle
end

-- Create a meteor trail particle
function ParticleManager.createMeteorTrailParticle(effect, parentParticle)
    local particle = ParticleManager.createParticle()
    
    -- Set trail-specific properties
    particle.type = "trail"
    particle.x = parentParticle.x + math.random(-5, 5)
    particle.y = parentParticle.y + math.random(-5, 5)
    particle.scale = parentParticle.scale * 0.6
    particle.baseScale = parentParticle.scale * 0.6
    particle.alpha = 0.7
    particle.baseAlpha = 0.7
    particle.timeCreated = effect.timer
    particle.lifespan = 0.2 + math.random() * 0.2
    particle.assetId = "fireParticle"
    particle.color = effect.color
    
    return particle
end

-- Create a meteor impact particle
function ParticleManager.createMeteorImpactParticle(effect, angle)
    local particle = ParticleManager.createParticle()

    -- Set impact-specific properties
    particle.type = "impact"
    particle.angle = angle
    particle.x = effect.targetX
    particle.y = effect.targetY
    particle.maxDist = 40 + math.random() * 20
    particle.scale = 0.3 + math.random() * 0.2
    particle.baseScale = 0.3 + math.random() * 0.2
    particle.alpha = 0.7
    particle.baseAlpha = 0.7
    particle.timeCreated = effect.timer
    particle.lifespan = 0.4 + math.random() * 0.2
    particle.assetId = "sparkle"
    particle.color = effect.color

    return particle
end

-- Create a projectile trail particle
function ParticleManager.createProjectileTrailParticle(effect, headX, headY)
    local particle = ParticleManager.createParticle()

    -- Set trail-specific properties
    particle.x = headX
    particle.y = headY
    particle.xVel = math.random(-30, 30)
    particle.yVel = math.random(-30, 30)
    particle.size = math.random(5, 15) * (effect.size or 1.0)
    particle.alpha = math.random() * 0.5 + 0.5
    particle.life = 0
    particle.maxLife = math.random() * 0.3 + 0.1
    particle.color = effect.color or {1, 1, 1}

    return particle
end

-- Create an impact particle
function ParticleManager.createImpactParticle(effect, angle, delay)
    local particle = ParticleManager.createParticle()

    -- Set impact-specific properties
    particle.baseX = effect.targetX
    particle.baseY = effect.targetY
    particle.x = effect.targetX
    particle.y = effect.targetY
    particle.angle = angle
    particle.delay = delay or 0
    particle.active = false
    particle.animType = "expand"
    particle.maxDist = effect.radius * (0.5 + math.random() * 0.5)
    particle.baseScale = 0.5 + math.random() * 0.5
    particle.scale = particle.baseScale
    particle.alpha = 1.0

    return particle
end

-- Create an aura particle
function ParticleManager.createAuraParticle(effect, angle, orbitId)
    local particle = ParticleManager.createParticle()

    -- Set aura-specific properties
    local distance = effect.radius * (0.6 + math.random() * 0.4)
    local orbitalSpeed = 0.5 + math.random() * 1.5

    particle.angle = angle
    particle.distance = distance
    particle.orbitalSpeed = orbitalSpeed
    particle.scale = effect.startScale
    particle.baseScale = effect.startScale
    particle.alpha = 0 -- Start invisible and fade in
    particle.baseAlpha = 1.0
    particle.rotation = 0
    particle.delay = (angle / (2 * math.pi)) * 0.5
    particle.active = false
    particle.orbitId = orbitId or math.random(1, effect.orbitCount or 2)
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY

    return particle
end

-- Create a beam particle
function ParticleManager.createBeamParticle(effect, position, offset)
    local particle = ParticleManager.createParticle()

    -- Set beam-specific properties
    particle.position = position -- 0 to 1 along beam
    particle.offset = offset -- Perpendicular to beam
    particle.scale = effect.startScale * (0.7 + math.random() * 0.6)
    particle.alpha = 0.8
    particle.rotation = math.random() * math.pi * 2
    particle.delay = math.random() * 0.3
    particle.active = false

    return particle
end

-- Create a cone particle
function ParticleManager.createConeParticle(effect, angle, distance, isWaveParticle, waveIndex)
    local particle = ParticleManager.createParticle()

    -- Common properties
    particle.angle = angle
    particle.rotation = angle -- Align rotation with direction
    particle.delay = math.random() * 0.3 -- Staggered start
    particle.active = false
    particle.motion = effect.motionStyle or Constants.MotionStyle.DIRECTIONAL
    particle.intensityMultiplier = 1.0

    -- Set position at source
    particle.x = effect.sourceX
    particle.y = effect.sourceY

    -- Additional properties for motion
    particle.startTime = 0
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY

    -- Wave-specific properties
    if isWaveParticle then
        particle.isWave = true
        particle.waveIndex = waveIndex
        particle.waveTime = waveIndex / (effect.waveCount or 3) -- Staggered wave timing

        -- Calculate wave speed and distance based on wave index
        local speedMultiplier = 1.0 + (waveIndex - 1) * 0.15
        particle.distance = (effect.coneLength or 320) * 0.95 -- Waves extend almost to max distance
        particle.speed = (effect.waveSpeed or 350) * speedMultiplier
        particle.scale = effect.startScale * (1.5 + waveIndex * 0.1)
        particle.alpha = 0.9

        -- Special effects
        if effect.wavePersistence then
            particle.persistenceFactor = effect.wavePersistence
        end

        if effect.trailingGlowStrength then
            particle.trailGlow = effect.trailingGlowStrength
        end
    else
        -- Regular fill particles
        particle.distance = distance
        particle.speed = math.random(100, 250)

        -- Size variance
        local sizeVariance = effect.particleSizeVariance or 0.6
        particle.scale = effect.startScale * (0.7 + math.random() * sizeVariance)
        particle.alpha = 0.6 + math.random() * 0.4
        particle.isWave = false
    end

    -- Target destination for the particle
    particle.targetX = effect.sourceX + math.cos(angle) * particle.distance
    particle.targetY = effect.sourceY + math.sin(angle) * particle.distance

    return particle
end

-- Create a remote effect particle
function ParticleManager.createRemoteParticle(effect, angle, distance, speed)
    local particle = ParticleManager.createParticle()

    -- Calculate center position
    local centerX = effect.targetX
    local centerY = effect.targetY

    -- Set remote-specific properties
    particle.x = centerX
    particle.y = centerY
    particle.targetX = centerX + math.cos(angle) * distance
    particle.targetY = centerY + math.sin(angle) * distance
    particle.speed = speed
    particle.scale = effect.startScale * (0.5 + math.random() * 0.5) -- Varied scales
    particle.alpha = 0.7 + math.random() * 0.3 -- Slightly varied alpha
    particle.rotation = angle
    particle.delay = math.random() * 0.4
    particle.active = false
    particle.motion = effect.motion
    particle.angle = angle
    particle.distance = distance

    return particle
end

-- Create a conjure particle
function ParticleManager.createConjureParticle(effect, startX, startY, dirX, dirY, speed, delay)
    local particle = ParticleManager.createParticle()

    -- Set conjure-specific properties
    particle.x = startX
    particle.y = startY
    particle.speedX = dirX * speed
    particle.speedY = dirY * speed
    particle.scale = effect.startScale
    particle.alpha = 0 -- Start transparent and fade in
    particle.rotation = math.random() * math.pi * 2
    particle.rotSpeed = math.random(-3, 3)
    particle.delay = delay
    particle.active = false
    particle.finalPulse = false
    particle.finalPulseTime = 0

    return particle
end

-- Create a surge particle
function ParticleManager.createSurgeParticle(effect)
    local particle = ParticleManager.createParticle()

    -- Get effect properties
    local particleSizeVariance = effect.particleSizeVariance or 0.6
    local useSprites = effect.useSprites

    -- Start at the source position
    particle.x = effect.sourceX
    particle.y = effect.sourceY

    -- Parameters for helix motion
    particle.baseRadius = 6 + math.random() * 8
    particle.startAngle = math.random() * math.pi * 2
    particle.spinSpeed = 3 + math.random() * 2
    particle.verticalSpeed = (effect.height or 160) / (effect.duration or 1)

    -- Visual properties with variance
    local sizeVariance = 1.0 + (math.random() * 2 - 1) * particleSizeVariance
    particle.scale = effect.startScale * sizeVariance
    particle.baseScale = particle.scale -- Store for pulsation

    particle.alpha = 0.9 + math.random() * 0.1
    particle.rotation = math.random() * math.pi * 2
    particle.rotationSpeed = math.random(-4, 4) -- Random rotation speed

    -- Assign primitive sprite type for rendering
    local spriteOptions = {"pixel", "twinkle1", "twinkle2"}
    particle.spriteType = spriteOptions[math.random(#spriteOptions)]

    -- Staggered appearance
    particle.delay = math.random() * 0.4
    particle.active = false

    -- Add sprite animation if enabled
    if useSprites then
        particle.useSprite = true
        particle.frameIndex = 1
        particle.frameTimer = 0
        particle.frameRate = effect.spriteFrameRate or 8
    end

    -- Special properties based on effect template settings
    if effect.spiralMotion then
        particle.spiral = true
        particle.spiralFrequency = 5 + math.random() * 3
        particle.spiralAmplitude = 10 + math.random() * 20
        particle.spiralPhase = math.random() * math.pi * 2
        particle.spiralTightness = effect.spiralTightness or 2.5
    end

    if effect.pulsateParticles and math.random() < 0.7 then
        particle.pulsate = true
        particle.pulseRate = 3 + math.random() * 5
        particle.pulseAmount = 0.2 + math.random() * 0.3
    end

    -- Chance for special sparkle particles
    if effect.sparkleChance and math.random() < effect.sparkleChance then
        particle.sparkle = true
        particle.sparkleIntensity = 0.7 + math.random() * 0.3
    end

    -- Add bloom glow effect
    if effect.bloomEffect then
        particle.bloom = true
        particle.bloomIntensity = (effect.bloomIntensity or 0.8) * (0.7 + math.random() * 0.6)
    end

    return particle
end

-- Create a projectile core particle
function ParticleManager.createProjectileCoreParticle(effect, baseAngle, turbulence)
    local particle = ParticleManager.createParticle()

    -- Random position near the projectile core
    local spreadFactor = 4 * turbulence
    local offsetX = math.random(-spreadFactor, spreadFactor)
    local offsetY = math.random(-spreadFactor, spreadFactor)

    -- Set initial state
    particle.x = effect.sourceX + offsetX
    particle.y = effect.sourceY + offsetY
    particle.scale = effect.startScale * (0.9 + math.random() * 0.5) -- Slightly larger scales
    particle.alpha = 1.0
    particle.rotation = math.random() * math.pi * 2

    -- Create leading-edge cluster with minimal delay
    particle.delay = math.random() * 0.05
    particle.active = false
    particle.isCore = true -- Mark as core particle for special rendering
    particle.motion = effect.motion -- Store motion style

    -- Motion properties
    particle.startTime = 0
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY
    particle.targetX = effect.targetX
    particle.targetY = effect.targetY

    -- Add less randomness to motion for more focused projectile
    local angleVar = (math.random() - 0.5) * 0.2 * turbulence
    particle.angle = baseAngle + angleVar
    particle.speed = math.random(200, 260) -- Significantly faster speeds

    -- Life cycle control
    particle.lifespan = (effect.particleLifespan or 0.6) * effect.duration
    particle.timeOffset = math.random() * 0.1
    particle.turbulence = turbulence

    return particle
end

-- Create a projectile trail particle (using core system, not the same as createProjectileTrailParticle)
function ParticleManager.createProjectileFullTrailParticle(effect, baseAngle, turbulence, trailIndex, trailCount)
    local particle = ParticleManager.createParticle()

    -- Trail particles start closer to the core
    local spreadRadius = 6 * (effect.trailDensity or 0.4) * turbulence -- Tighter spread
    local spreadAngle = math.random() * math.pi * 2
    local spreadDist = math.random() * spreadRadius

    -- Set initial state - more directional alignment
    particle.x = effect.sourceX + math.cos(spreadAngle) * spreadDist
    particle.y = effect.sourceY + math.sin(spreadAngle) * spreadDist
    particle.scale = effect.startScale * (0.7 + math.random() * 0.2) -- Slightly smaller
    particle.alpha = 0.7 -- Lower alpha for less visibility
    particle.rotation = math.random() * math.pi * 2

    -- Much shorter staggered delay for trail particles
    particle.delay = (trailIndex / trailCount) * 0.15 -- Cut delay in half for faster response
    particle.active = false
    particle.isCore = false -- Mark as trail particle
    particle.motion = effect.motion

    -- Motion properties
    particle.startTime = 0
    particle.baseX = effect.sourceX
    particle.baseY = effect.sourceY
    particle.targetX = effect.targetX
    particle.targetY = effect.targetY

    -- Reduce trail spread angle for more directional appearance
    local angleVar = (math.random() - 0.5) * 0.3 * turbulence -- Half the angle variance
    particle.angle = baseAngle + angleVar
    particle.speed = math.random(150, 200) -- Faster than before, closer to core speed

    -- Trail particles have shorter lifespans for smoother fade
    particle.lifespan = (effect.particleLifespan or 0.6) * effect.duration * 0.8
    particle.timeOffset = math.random() * 0.2
    particle.turbulence = turbulence

    -- Which segment of the trail this particle belongs to
    particle.trailSegment = math.random()

    return particle
end

-- Get particle stats
function ParticleManager.getStats()
    return {
        poolSize = Pool.size("vfx_particle"),
        available = Pool.available("vfx_particle"),
        active = Pool.activeCount("vfx_particle")
    }
end

-- Print particle stats to console
function ParticleManager.printStats()
    local stats = ParticleManager.getStats()
    print(string.format("[PARTICLE MANAGER] Pool: %d total (%d active, %d available)", 
        stats.poolSize, stats.active, stats.available))
end

return ParticleManager
```

## ./vfx/effects/aura.lua
```lua
-- aura.lua
-- Aura VFX module for handling aura/circle effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for aura effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for aura effects
local function updateAura(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.radius = effect.radius or 50 -- Default radius
    effect.pulseRate = effect.pulseRate or 5 -- Default pulse rate
    effect.angularSpeed = effect.angularSpeed or 1.5 -- Default angular speed
    effect.orbitCount = effect.orbitCount or 2 -- Default orbit count
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update orbital particles
    for i, particle in ipairs(effect.particles) do
        -- Skip invalid particles
        if not particle then
            goto next_particle
        end
        
        -- Initialize particle properties if missing
        particle.delay = particle.delay or 0
        particle.active = particle.active or false
        particle.angle = particle.angle or 0
        particle.radius = particle.radius or effect.radius
        particle.orbitId = particle.orbitId or 1
        
        -- Check if particle should be active based on delay
        if effect.timer > particle.delay then
            particle.active = true
        end
        
        if particle.active then
            -- Calculate particle progress
            local particleProgress = math.min((effect.timer - particle.delay) / (effect.duration - particle.delay), 1.0)
            
            -- Update orbital position
            particle.angle = particle.angle + dt * (effect.angularSpeed or 1.5)
            
            -- Different orbits have different radii and move in opposite directions
            local orbitRadius = effect.radius * (0.8 + 0.4 * (particle.orbitId / (effect.orbitCount or 2)))
            
            -- Alternate direction for different orbits
            if particle.orbitId % 2 == 0 then
                particle.angle = particle.angle - dt * (effect.angularSpeed or 1.5) * 2
            end
            
            -- Update particle position
            particle.x = effect.sourceX + math.cos(particle.angle) * orbitRadius
            particle.y = effect.sourceY + math.sin(particle.angle) * orbitRadius
            
            -- Calculate fade based on progress
            -- Start visible, peak at 50%, then fade out
            local fadeProgress = 1.0 - math.abs(particleProgress - 0.5) * 2
            particle.alpha = fadeProgress * (particle.baseAlpha or 1.0)
            
            -- Pulse size
            local pulse = math.sin(effect.timer * (effect.pulseRate or 5) + particle.angle) * 0.3 + 0.7
            particle.scale = (particle.baseScale or 0.3) * pulse
        end
        
        ::next_particle::
    end
end

-- Draw function for aura effects
local function drawAura(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default position
    effect.sourceY = effect.sourceY or 0 -- Default position
    effect.radius = effect.radius or 50 -- Default radius
    effect.pulseRate = effect.pulseRate or 5 -- Default pulse rate
    
    local particleImage = getAssetInternal("sparkle")
    
    -- Draw base aura circle
    local pulseAmount = math.sin(effect.timer * effect.pulseRate) * 0.2
    local baseAlpha = 0.3 * (1 - (math.abs(effect.progress - 0.5) * 2)^2) -- Peak at middle of effect
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], baseAlpha)
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, effect.radius * (1 + pulseAmount))
    love.graphics.setColor(effect.color[1] * 1.3, effect.color[2] * 1.3, effect.color[3] * 1.3, baseAlpha * 1.5)
    love.graphics.circle("line", effect.sourceX, effect.sourceY, effect.radius * (1 + pulseAmount))
    
    -- Draw particles with additive blending for brighter core
    local prevMode = {love.graphics.getBlendMode()}
    love.graphics.setBlendMode("add")
    
    -- Draw central glow
    local centerGlowSize = effect.radius * 0.4
    local centerPulse = math.sin(effect.timer * effect.pulseRate * 1.5) * 0.2 + 0.8
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], baseAlpha * 1.2)
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * centerPulse)
    
    -- Draw bright center
    love.graphics.setColor(1, 1, 1, baseAlpha * 1.5)
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.3 * centerPulse)
    
    -- Restore blend mode
    love.graphics.setBlendMode(prevMode[1], prevMode[2])
    
    -- Draw individual particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        ::next_draw_particle::
    end
end

-- Initialize function for aura effects
local function initializeAura(effect)
    -- For aura effects, create particles that orbit the character using ParticleManager
    for i = 1, effect.particleCount do
        local angle = (i / effect.particleCount) * math.pi * 2
        local orbitId = math.ceil(i / (effect.particleCount / (effect.orbitCount or 2)))

        -- Create particle using specialized helper
        local particle = ParticleManager.createAuraParticle(effect, angle, orbitId)

        -- Add motion information
        particle.motion = effect.motion -- Store motion style on particle

        -- Add additional properties for special motion
        particle.startTime = 0

        -- Calculate distance and orbitalSpeed for legacy code compatibility
        local distance = particle.distance or (effect.radius * 0.8)
        local orbitalSpeed = particle.orbitalSpeed or 1.5

        particle.targetX = effect.sourceX + math.cos(angle) * distance
        particle.targetY = effect.sourceY + math.sin(angle) * distance
        particle.speed = orbitalSpeed * 30

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeAura,
    update = updateAura,
    draw = drawAura
}```

## ./vfx/effects/beam.lua
```lua
-- beam.lua
-- Beam VFX module for handling beam/laser effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for beam effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for beam effects
local function updateBeam(effect, dt)
    -- Initialize effect default values if not already set
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.beamWidth = effect.beamWidth or 15 -- Default beam width
    effect.sourceX = effect.sourceX or 0 -- Default source position
    effect.sourceY = effect.sourceY or 0 -- Default source position
    effect.targetX = effect.targetX or 400 -- Default target position
    effect.targetY = effect.targetY or 0 -- Default target position
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Enhanced beam update with shield block handling
    local Constants = require("core.Constants")

    -- Update beam properties based on current source and target positions
    -- This ensures the beam adjusts if the wizards move due to range/elevation changes
    effect.beamLength = math.sqrt((effect.targetX - effect.sourceX)^2 + (effect.targetY - effect.sourceY)^2)
    effect.beamAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)

    -- Determine which progress value to use (normal vs. visualProgress for blocked beams)
    local baseProgress = effect.visualProgress or effect.progress

    -- Apply pulsing effect
    effect.pulseTimer = (effect.pulseTimer or 0) + dt * 10
    effect.pulseFactor = 0.7 + 0.3 * math.sin(effect.pulseTimer)

    -- Handle beam progress for blocked beams
    local blockPoint = effect.blockPoint or 1.0

    -- Handle shield block specific effects
    if effect.isBlocked and not effect.impactEffectCreated and baseProgress >= blockPoint then
        -- Create shield impact effect
        effect.impactEffectCreated = true

        -- Calculate impact position
        local impactX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * blockPoint)
        local impactY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * blockPoint)

        print(string.format("[BEAM] Creating shield impact effect at (%.1f, %.1f)", impactX, impactY))

        -- Get the VFX module (should be loaded by now)
        if not VFX then VFX = require("vfx") end

        -- Determine shield color based on shield type
        local shieldColor = {1.0, 1.0, 0.3, 0.7}  -- Default yellow
        local shieldType = effect.blockType or (effect.options and effect.options.shieldType)
        if shieldType == "ward" then
            shieldColor = {0.3, 0.3, 1.0, 0.7}  -- Blue for wards
        elseif shieldType == "field" then
            shieldColor = {0.3, 1.0, 0.3, 0.7}  -- Green for fields
        end

        -- Create shield impact effect
        if VFX.createEffect then
            -- Impact flash effect
            local flashParams = {
                duration = 0.3,
                scale = (effect.startScale or 1.0) * 1.5,
                color = {shieldColor[1], shieldColor[2], shieldColor[3], 0.9},
                particleCount = 8
            }
            VFX.createEffect("impact_base", impactX, impactY, impactX, impactY, flashParams)

            -- Particle burst effect
            local burstParams = {
                duration = 0.8,
                scale = (effect.startScale or 1.0) * 1.2,
                color = shieldColor,
                particleCount = 30
            }
            VFX.createEffect("impact_base", impactX, impactY, impactX, impactY, burstParams)
        end

        -- Trigger screen shake for beam impact
        local gameState = nil

        -- Try to find the game state through various references
        if effect.options and effect.options.gameState then
            gameState = effect.options.gameState
        elseif effect.options and effect.options.sourceEntity and effect.options.sourceEntity.gameState then
            gameState = effect.options.sourceEntity.gameState
        elseif effect.options and effect.options.targetEntity and effect.options.targetEntity.gameState then
            gameState = effect.options.targetEntity.gameState
        elseif _G.game then
            gameState = _G.game
        elseif VFX.gameState then
            gameState = VFX.gameState
        end

        -- Determine impact amount for shake intensity
        local amount = effect.options and effect.options.amount or 12  -- Beams are powerful
        local intensity = math.min(5, 2.5 + (amount / 20))  -- Slightly more intense than projectiles
        local shakeDuration = 0.25  -- Longer duration for beam

        -- Trigger shake if we have access to game state
        if gameState and gameState.triggerShake then
            gameState.triggerShake(shakeDuration, intensity)
            print(string.format("[BEAM] Shield block impact! Triggered shake (%.2f, %.2f) at blockPoint=%.2f",
                shakeDuration, intensity, blockPoint))
        elseif VFX.triggerShake then
            VFX.triggerShake(shakeDuration, intensity)
        end
    end

    -- If beam is blocked, it should stop at the block point
    if effect.isBlocked and baseProgress > blockPoint then
        effect.beamProgress = blockPoint
    else
        effect.beamProgress = baseProgress
    end
    
    -- Update beam particles
    if effect.particles then
        -- Update existing particles
        local i = 1
        while i <= #effect.particles do
            local particle = effect.particles[i]
            
            -- Skip invalid particles
            if not particle then
                table.remove(effect.particles, i)
                goto next_particle
            end
            
            -- Initialize any missing particle properties
            particle.life = particle.life or 0
            particle.maxLife = particle.maxLife or 0.5
            particle.alpha = particle.alpha or 1.0
            particle.scale = particle.scale or 1.0
            particle.startScale = particle.startScale or particle.scale
            
            -- Update particle lifetime
            particle.life = particle.life + dt
            
            -- Remove expired particles
            if particle.life >= particle.maxLife then
                table.remove(effect.particles, i)
            else
                -- Update particle position and alpha
                local lifeProgress = particle.life / particle.maxLife
                
                -- Update alpha (fade out)
                particle.alpha = 1.0 - lifeProgress
                
                -- Update scale (grow slightly then shrink)
                particle.scale = particle.startScale * (1.0 + lifeProgress * 0.5 - lifeProgress * lifeProgress)
                
                -- Move to next particle
                i = i + 1
            end
            
            ::next_particle::
        end
        
        -- Add many new particles for dense swarm effect
        local particleRate = 3.0 -- Much higher rate for particle swarm
        
        -- Generate multiple particles per frame
        local particlesThisFrame = math.floor(particleRate)
        if math.random() < (particleRate - particlesThisFrame) then
            particlesThisFrame = particlesThisFrame + 1
        end
        
        for i = 1, particlesThisFrame do
            -- Add particles at source with variety
            local sourceParticle = {
                x = effect.sourceX + math.random(-8, 8),
                y = effect.sourceY + math.random(-8, 8),
                scale = math.random(1, 3),
                startScale = math.random(1, 3),
                alpha = 1.0,
                life = 0,
                maxLife = math.random() * 0.3 + 0.15,
                active = true,
                spriteType = ({"pixel", "twinkle1", "twinkle2"})[math.random(3)]
            }
            table.insert(effect.particles, sourceParticle)
            
            -- Add particles along the beam path
            if effect.beamProgress > 0.1 then
                local beamPos = math.random() * effect.beamProgress
                local beamX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * beamPos)
                local beamY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * beamPos)
                
                -- Perpendicular offset for beam width
                local perpAngle = effect.beamAngle + math.pi/2
                local perpOffset = (math.random() - 0.5) * effect.beamWidth
                
                local beamParticle = {
                    x = beamX + math.cos(perpAngle) * perpOffset,
                    y = beamY + math.sin(perpAngle) * perpOffset,
                    scale = math.random(1, 2),
                    startScale = math.random(1, 2),
                    alpha = 1.0,
                    life = 0,
                    maxLife = math.random() * 0.2 + 0.1,
                    active = true,
                    spriteType = ({"pixel", "twinkle1", "twinkle2"})[math.random(3)]
                }
                table.insert(effect.particles, beamParticle)
            end
            
            -- Add particles at impact point (if beam has traveled that far)
            if effect.beamProgress > 0.5 then
                local impactX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * effect.beamProgress)
                local impactY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * effect.beamProgress)
                
                local impactParticle = {
                    x = impactX + math.random(-12, 12),
                    y = impactY + math.random(-12, 12),
                    scale = math.random(2, 4),
                    startScale = math.random(2, 4),
                    alpha = 1.0,
                    life = 0,
                    maxLife = math.random() * 0.25 + 0.15,
                    active = true,
                    spriteType = ({"pixel", "twinkle1", "twinkle2"})[math.random(3)]
                }
                table.insert(effect.particles, impactParticle)
            end
        end
    end
end

-- Draw function for beam effects
local function drawBeam(effect)
    -- Preserve the current line width and blend mode so we can restore them after drawing
    local prevLineWidth = love.graphics.getLineWidth()
    local prevBlendMode = {love.graphics.getBlendMode()}
    
    -- Make sure essential properties exist
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default position
    effect.sourceY = effect.sourceY or 0 -- Default position
    effect.beamLength = effect.beamLength or 400 -- Default length
    effect.beamAngle = effect.beamAngle or 0 -- Default angle
    effect.beamProgress = effect.beamProgress or effect.progress or 1.0 -- Default progress
    effect.beamWidth = effect.beamWidth or 15 -- Default width
    effect.pulseFactor = effect.pulseFactor or 1.0 -- Default pulse
    
    local particleImage = getAssetInternal("sparkle")
    local onePxImage = getAssetInternal("pixel")
    local twinkle1Image = getAssetInternal("twinkle1")
    local twinkle2Image = getAssetInternal("twinkle2")
    
    -- Use current beam properties (which have been updated in updateBeam)
    local beamLength = effect.beamLength * effect.beamProgress
    
    -- Draw particle-based beam core instead of line shapes
    local beamEndX = effect.sourceX + math.cos(effect.beamAngle) * beamLength
    local beamEndY = effect.sourceY + math.sin(effect.beamAngle) * beamLength
    
    -- Calculate beam width with pulse
    local pulseValue = effect.pulseFactor or 1.0
    local beamWidth = (effect.beamWidth or 15) * pulseValue
    
    -- Draw beam using dense particle chains
    local particlesAlongBeam = math.floor(beamLength / 3) -- One particle every 3 pixels
    
    for i = 0, particlesAlongBeam do
        local t = i / math.max(1, particlesAlongBeam)
        local coreX = effect.sourceX + (beamEndX - effect.sourceX) * t
        local coreY = effect.sourceY + (beamEndY - effect.sourceY) * t
        
        -- Perpendicular angle for beam width spread
        local perpAngle = effect.beamAngle + math.pi/2
        
        -- Draw outer glow particles
        local outerParticles = math.floor(beamWidth / 4)
        for j = 1, outerParticles do
            local offset = (j / outerParticles - 0.5) * beamWidth * 1.5
            local px = coreX + math.cos(perpAngle) * offset
            local py = coreY + math.sin(perpAngle) * offset
            
            love.graphics.setColor(
                effect.color[1] * 0.4, 
                effect.color[2] * 0.4, 
                effect.color[3] * 0.4, 
                0.3 * (1 - math.abs(offset) / (beamWidth * 0.75))
            )
            
            local sprite = onePxImage or twinkle1Image
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1.5 + math.random() * 0.5, 1.5 + math.random() * 0.5,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Save current blend mode and set to additive for core
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw inner core particles with additive blending
        local innerParticles = math.floor(beamWidth / 6)
        for j = 1, innerParticles do
            local offset = (j / innerParticles - 0.5) * beamWidth * 0.7
            local px = coreX + math.cos(perpAngle) * offset
            local py = coreY + math.sin(perpAngle) * offset
            
            love.graphics.setColor(
                math.min(1.0, effect.color[1] * 1.3), 
                math.min(1.0, effect.color[2] * 1.3), 
                math.min(1.0, effect.color[3] * 1.3), 
                0.7 * (1 - math.abs(offset) / (beamWidth * 0.35))
            )
            
            local sprite = (j % 2 == 0) and twinkle1Image or twinkle2Image
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1.2 + math.random() * 0.3, 1.2 + math.random() * 0.3,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Draw brightest center particles
        local centerParticles = math.floor(beamWidth / 10) + 1
        for j = 1, centerParticles do
            local offset = (j / centerParticles - 0.5) * beamWidth * 0.3
            local px = coreX + math.cos(perpAngle) * offset
            local py = coreY + math.sin(perpAngle) * offset
            
            love.graphics.setColor(1, 1, 1, 0.9 * (1 - math.abs(offset) / (beamWidth * 0.15)))
            
            local sprite = twinkle2Image or onePxImage
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1 + math.random() * 0.2, 1 + math.random() * 0.2,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw source glow using particle swarm
    local sourceParticleCount = 15
    local sourceRadius = beamWidth * 0.7
    
    for i = 1, sourceParticleCount do
        local angle = (i / sourceParticleCount) * math.pi * 2 + love.timer.getTime() * 3
        local radius = sourceRadius * (0.4 + math.random() * 0.6)
        local px = effect.sourceX + math.cos(angle) * radius
        local py = effect.sourceY + math.sin(angle) * radius
        
        love.graphics.setColor(
            effect.color[1], 
            effect.color[2], 
            effect.color[3], 
            (0.5 + math.random() * 0.3) * pulseValue
        )
        
        local sprite = (i % 3 == 0) and twinkle1Image or ((i % 3 == 1) and onePxImage or twinkle2Image)
        if sprite then
            love.graphics.draw(
                sprite, px, py, 0,
                1 + math.random() * 0.5, 1 + math.random() * 0.5,
                sprite:getWidth()/2, sprite:getHeight()/2
            )
        end
    end
    
    -- Draw impact glow using particle swarm
    local impactParticleCount = 18
    local impactRadius = beamWidth * 0.9
    
    for i = 1, impactParticleCount do
        local angle = (i / impactParticleCount) * math.pi * 2 + love.timer.getTime() * 4
        local radius = impactRadius * (0.3 + math.random() * 0.7)
        local px = beamEndX + math.cos(angle) * radius
        local py = beamEndY + math.sin(angle) * radius
        
        love.graphics.setColor(
            effect.color[1], 
            effect.color[2], 
            effect.color[3], 
            (0.6 + math.random() * 0.4) * pulseValue
        )
        
        local sprite = (i % 3 == 0) and twinkle2Image or ((i % 3 == 1) and twinkle1Image or onePxImage)
        if sprite then
            love.graphics.draw(
                sprite, px, py, 0,
                1.2 + math.random() * 0.8, 1.2 + math.random() * 0.8,
                sprite:getWidth()/2, sprite:getHeight()/2
            )
        end
    end
    
    -- Draw particles using primitive sprites
    if effect.particles then
        for _, particle in ipairs(effect.particles) do
            -- Skip invalid or inactive particles
            if not particle or not particle.active then
                goto next_draw_particle
            end
            
            -- Ensure required properties exist
            particle.alpha = particle.alpha or 1.0
            particle.scale = particle.scale or 1.0
            particle.x = particle.x or effect.sourceX
            particle.y = particle.y or effect.sourceY
            
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.9)
            
            -- Choose sprite based on particle type
            local sprite = nil
            if particle.spriteType == "pixel" and onePxImage then
                sprite = onePxImage
            elseif particle.spriteType == "twinkle1" and twinkle1Image then
                sprite = twinkle1Image
            elseif particle.spriteType == "twinkle2" and twinkle2Image then
                sprite = twinkle2Image
            else
                -- Fallback to any available primitive
                sprite = onePxImage or twinkle1Image or twinkle2Image or particleImage
            end
            
            if sprite then
                love.graphics.draw(
                    sprite,
                    particle.x, particle.y,
                    0,
                    particle.scale / 3, particle.scale / 3,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            else
                -- Final fallback
                love.graphics.circle("fill", particle.x, particle.y, particle.scale)
            end
            
            ::next_draw_particle::
        end
    end
    
    -- Draw blocked impact flash if beam hit a shield
    if effect.isBlocked and effect.blockPoint and effect.progress > effect.blockPoint then
        -- Calculate impact point
        local blockX = effect.sourceX + math.cos(effect.beamAngle) * (effect.beamLength * effect.blockPoint)
        local blockY = effect.sourceY + math.sin(effect.beamAngle) * (effect.beamLength * effect.blockPoint)

        -- Calculate impact flash size and alpha
        local impactProgress = (effect.progress - effect.blockPoint) / (1 - effect.blockPoint)
        local flashSize = 40 * (1.0 - impactProgress) * effect.pulseFactor
        local flashAlpha = 0.7 * (1.0 - impactProgress)

        -- Set to additive blending for bright flash
        love.graphics.setBlendMode("add")

        -- Draw impact flash using particle swarm
        local flashParticleCount = math.floor(flashSize / 3)
        for i = 1, flashParticleCount do
            local angle = (i / flashParticleCount) * math.pi * 2
            local radius = flashSize * (0.2 + math.random() * 0.8)
            local px = blockX + math.cos(angle) * radius
            local py = blockY + math.sin(angle) * radius
            
            love.graphics.setColor(1, 1, 1, flashAlpha * (0.6 + math.random() * 0.4))
            
            local sprite = (i % 3 == 0) and twinkle1Image or ((i % 3 == 1) and onePxImage or twinkle2Image)
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    2 + math.random() * 2, 2 + math.random() * 2,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end

        -- Get shield color based on type for distinctive visuals
        local shieldR, shieldG, shieldB = 1.0, 1.0, 0.3 -- Default yellow
        local shieldType = effect.blockType or (effect.options and effect.options.shieldType)
        if shieldType == "ward" then
            shieldR, shieldG, shieldB = 0.3, 0.3, 1.0 -- Blue for wards
        elseif shieldType == "field" then
            shieldR, shieldG, shieldB = 0.3, 1.0, 0.3 -- Green for fields
        end

        -- Draw colored shield impact ring
        love.graphics.setColor(shieldR, shieldG, shieldB, flashAlpha * 0.9)
        local ringSize = flashSize * 1.2
        local ringWidth = 3
        love.graphics.setLineWidth(ringWidth)
        love.graphics.circle("line", blockX, blockY, ringSize)

        -- Draw radial beams emanating from impact point
        local beamCount = 8
        for i = 1, beamCount do
            local angle = (i / beamCount) * math.pi * 2 + (effect.progress * 3)
            local rayLength = ringSize * (0.8 + 0.4 * math.sin(impactProgress * math.pi * 6))
            local x2 = blockX + math.cos(angle) * rayLength
            local y2 = blockY + math.sin(angle) * rayLength

            love.graphics.setLineWidth(ringWidth * 0.6)
            love.graphics.line(blockX, blockY, x2, y2)
        end

        -- Draw shield specific effects if applicable
        if shieldType and (shieldType == "ward" or shieldType == "barrier") then
            -- Shield-specific visualization
            local runeImages = getAssetInternal("runes")
            if runeImages and #runeImages > 0 then
                -- Get a deterministic rune index
                local runeIndex
                if effect.id then
                    runeIndex = (effect.id % #runeImages) + 1
                else
                    -- Calculate a stable index from the positions
                    local posHash = math.floor(effect.sourceX + effect.sourceY + effect.targetX + effect.targetY)
                    runeIndex = (posHash % #runeImages) + 1
                end
                local runeImage = runeImages[runeIndex]

                -- Draw the rune with rotation and pulsing
                local runeSize = 0.5 * (1 + 0.3 * math.sin(impactProgress * math.pi * 4))
                local runeAlpha = flashAlpha * 0.9

                love.graphics.setColor(1, 1, 1, runeAlpha)

                if runeImage then
                    love.graphics.draw(
                        runeImage,
                        blockX, blockY,
                        impactProgress * math.pi * 2,
                        runeSize, runeSize,
                        runeImage:getWidth()/2, runeImage:getHeight()/2
                    )
                end
            end
        end

        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end

    -- Restore the previous line width, blend mode, and color to avoid affecting other draw calls
    love.graphics.setLineWidth(prevLineWidth)
    love.graphics.setBlendMode(prevBlendMode[1], prevBlendMode[2])
    love.graphics.setColor(1, 1, 1, 1)
end

-- Initialize function for beam effects
local function initializeBeam(effect)
    -- First create the main beam shape
    effect.beamProgress = 0
    effect.beamLength = math.sqrt((effect.targetX - effect.sourceX)^2 + (effect.targetY - effect.sourceY)^2)
    effect.beamAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)

    -- Check for block info and set block properties
    if effect.options and effect.options.blockPoint then
        print(string.format("[BEAM INIT] Detected block at point %.2f", effect.options.blockPoint))
        effect.isBlocked = true
        effect.blockPoint = effect.options.blockPoint
        effect.blockType = effect.options.shieldType or "ward"
    end

    -- Then add particles along the beam
    for i = 1, effect.particleCount do
        local position = math.random()
        local offset = math.random(-10, 10)

        -- Create particle using ParticleManager
        local particle = ParticleManager.createBeamParticle(effect, position, offset)

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeBeam,
    update = updateBeam,
    draw = drawBeam
}```

## ./vfx/effects/cone.lua
```lua
-- cone.lua
-- Cone VFX module for handling cone/blast effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for cone effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for cone effects
local function updateCone(effect, dt)
    -- Initialize effect default values if not already set
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.waveCount = effect.waveCount or 3 -- Default wave count
    effect.coneAngle = effect.coneAngle or 70 -- Default cone angle (degrees)
    effect.beamDist = effect.beamDist or 200 -- Default beam distance
    effect.waveCrestSize = effect.waveCrestSize or 1.0 -- Default wave crest size
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Calculate the base direction from source to target
    local dirX = effect.targetX - effect.sourceX
    local dirY = effect.targetY - effect.sourceY
    local baseAngle = math.atan2(dirY, dirX)
    
    -- Update wave timing
    local waveCount = effect.waveCount or 3
    for i = 1, waveCount do
        -- Calculate when this wave should start
        local waveStartTime = (i - 1) * effect.duration * 0.3 / waveCount
        
        -- Update wave progress
        if effect.timer >= waveStartTime then
            -- Calculate how far this wave has traveled
            local waveProgress = math.min(1.0, (effect.timer - waveStartTime) / (effect.duration * 0.8))
            
            -- Store wave progress for drawing
            effect.waves = effect.waves or {}
            effect.waves[i] = {
                progress = waveProgress,
                startTime = waveStartTime,
                crestDelay = i * 0.05, -- Slight delay for the wave crest visualization
                age = effect.timer - waveStartTime
            }
        end
    end
    
    -- Apply intensity multiplier based on range band
    -- This makes close-range cones more powerful (wider, more intense colors)
    if not effect.rangeFactorApplied then
        if effect.rangeBand == "CLOSE" then
            effect.coneAngle = effect.coneAngle * 1.2
            effect.waveCrestSize = effect.waveCrestSize * 1.3
            effect.currentIntensityMultiplier = 1.3
        elseif effect.rangeBand == "MID" then
            effect.coneAngle = effect.coneAngle * 1.1
            effect.waveCrestSize = effect.waveCrestSize * 1.15
            effect.currentIntensityMultiplier = 1.15
        elseif effect.rangeBand == "FAR" then
            -- Default, no change
            effect.currentIntensityMultiplier = 1.0
        else
            -- Default, no change
            effect.currentIntensityMultiplier = 1.0
        end
        
        effect.rangeFactorApplied = true
    end
    
    -- Add particles at cone edges and along the waves
    if math.random() < 0.3 then
        -- Calculate cone properties
        local coneAngleRad = (effect.coneAngle or 70) * math.pi / 180
        local beamDist = effect.beamDist or 200
        
        -- Spawn particles along current wave fronts
        if effect.waves then
            for i, wave in ipairs(effect.waves) do
                -- Only add particles if the wave has started but not fully dissipated
                if wave.progress > 0 and wave.progress < 0.9 then
                    -- Calculate wave position (distance from source)
                    local waveDist = beamDist * wave.progress
                    
                    -- Add particles along the wave front
                    local numParticles = math.random(1, 3)
                    for j = 1, numParticles do
                        -- Calculate random angle within the cone
                        local randomAngleOffset = (math.random() * 2 - 1) * coneAngleRad / 2
                        local particleAngle = baseAngle + randomAngleOffset
                        
                        -- Calculate position
                        local distanceVariation = math.random() * 10 - 5
                        local particleDist = waveDist + distanceVariation
                        local particleX = effect.sourceX + math.cos(particleAngle) * particleDist
                        local particleY = effect.sourceY + math.sin(particleAngle) * particleDist
                        
                        -- Create particle
                        local particle = {
                            x = particleX,
                            y = particleY,
                            angle = particleAngle,
                            scale = math.random(10, 30) / 100,
                            alpha = math.random() * 0.7 + 0.3,
                            life = 0,
                            maxLife = math.random() * 0.2 + 0.1,
                            active = true
                        }
                        
                        table.insert(effect.particles, particle)
                    end
                end
            end
        end
    end
    
    -- Update existing particles
    local i = 1
    while i <= #effect.particles do
        local particle = effect.particles[i]
        
        -- Skip invalid particles
        if not particle then
            table.remove(effect.particles, i)
            goto next_particle
        end
        
        -- Initialize any missing particle properties
        particle.life = particle.life or 0
        particle.maxLife = particle.maxLife or 0.3
        particle.alpha = particle.alpha or 1.0
        particle.scale = particle.scale or 0.2
        
        -- Update particle lifetime
        particle.life = particle.life + dt
        
        -- Remove expired particles
        if particle.life >= particle.maxLife then
            table.remove(effect.particles, i)
        else
            -- Update particle properties
            local lifeProgress = particle.life / particle.maxLife
            
            -- Fade out
            particle.alpha = (1.0 - lifeProgress) * particle.alpha
            
            -- Grow slightly then shrink
            particle.scale = particle.scale * (1.0 + lifeProgress * 0.3 - lifeProgress * lifeProgress * 0.6)
            
            -- Move to next particle
            i = i + 1
        end
        
        ::next_particle::
    end
end

-- Draw function for cone effects
local function drawCone(effect)
    -- Initialize effect default values if not already set
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.waves = effect.waves or {} -- Initialize waves array if nil
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.coneAngle = effect.coneAngle or 70 -- Default cone angle (degrees)
    effect.beamDist = effect.beamDist or 200 -- Default beam distance
    effect.currentIntensityMultiplier = effect.currentIntensityMultiplier or 1.0 -- Default intensity multiplier
    
    -- Get assets
    local particleImage = getAssetInternal("sparkle")
    local glowImage = getAssetInternal("fireGlow") -- For enhanced glow effects
    
    -- Get intensity multiplier for range-based effects
    local intensityMult = effect.currentIntensityMultiplier or 1.0
    
    -- Draw background glow for the entire cone area at the beginning
    if effect.progress < 0.5 then
        -- Calculate cone properties
        local coneAngleRad = (effect.coneAngle or 70) * math.pi / 180
        local baseAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)
        local beamDist = effect.beamDist or 200
        
        -- Calculate glow alpha based on progress
        local glowAlpha = 0.3 * (0.5 - effect.progress) / 0.5
        
        -- Draw ambient background glow for the cone area
        local trianglePoints = {}
        
        -- Start from source point
        table.insert(trianglePoints, effect.sourceX)
        table.insert(trianglePoints, effect.sourceY)
        
        -- Number of points to create a smooth cone edge
        local numPoints = 10
        for i = 0, numPoints do
            local angle = baseAngle - coneAngleRad/2 + i * (coneAngleRad / numPoints)
            local x = effect.sourceX + math.cos(angle) * beamDist
            local y = effect.sourceY + math.sin(angle) * beamDist
            table.insert(trianglePoints, x)
            table.insert(trianglePoints, y)
        end
        
        -- Draw cone glow background
        love.graphics.setColor(effect.color[1] * 0.5, effect.color[2] * 0.5, effect.color[3] * 0.5, glowAlpha)
        love.graphics.polygon("fill", trianglePoints)
    end
    
    -- Draw the wave bands
    if effect.waves then
        for i, wave in ipairs(effect.waves) do
            -- Only draw if wave has started
            if wave.progress > 0 then
                -- Calculate wave properties
                local waveFront = wave.progress
                local waveBack = math.max(0, waveFront - 0.2)
                local waveFade = math.min(1.0, (1.0 - wave.progress) * 2)
                
                -- Calculate cone properties
                local coneAngleRad = (effect.coneAngle or 70) * math.pi / 180
                local baseAngle = math.atan2(effect.targetY - effect.sourceY, effect.targetX - effect.sourceX)
                local beamDist = effect.beamDist or 200
                
                -- Calculate color based on effect color
                local r = effect.color[1] * intensityMult
                local g = effect.color[2] * intensityMult
                local b = effect.color[3] * intensityMult
                local a = 0.7 * waveFade
                
                -- Draw the wave segments
                local segments = 10
                local prevX1, prevY1, prevX2, prevY2 = nil, nil, nil, nil
                
                for j = 0, segments do
                    -- Calculate angle for this segment
                    local segmentAngle = baseAngle - coneAngleRad/2 + j * (coneAngleRad / segments)
                    
                    -- Calculate front and back points of the wave
                    local x1 = effect.sourceX + math.cos(segmentAngle) * (beamDist * waveFront)
                    local y1 = effect.sourceY + math.sin(segmentAngle) * (beamDist * waveFront)
                    local x2 = effect.sourceX + math.cos(segmentAngle) * (beamDist * waveBack)
                    local y2 = effect.sourceY + math.sin(segmentAngle) * (beamDist * waveBack)
                    
                    -- Draw the wave segment if we have a previous point
                    if prevX1 ~= nil then
                        -- Draw the wave segment
                        love.graphics.setColor(r, g, b, a)
                        love.graphics.polygon("fill", x1, y1, prevX1, prevY1, prevX2, prevY2, x2, y2)
                    end
                    
                    -- Add extra glow points at wave crest with additive blending
                    if waveFront > 0.2 and j % 3 == 1 then
                        local glowSize = waveFront * (effect.waveCrestSize or 1.0) * 15
                        love.graphics.setColor(r, g, b, waveFront * 0.7)
                        
                        -- Save current blend mode and set to additive for the brightest elements
                        local prevMode = {love.graphics.getBlendMode()}
                        love.graphics.setBlendMode("add")
                        
                        love.graphics.circle("fill", (x1 + prevX1)/2, (y1 + prevY1)/2, glowSize * intensityMult)
                        
                        -- Restore previous blend mode
                        love.graphics.setBlendMode(prevMode[1], prevMode[2])
                    end
                    
                    -- Store current points as previous for next segment
                    prevX1, prevY1, prevX2, prevY2 = x1, y1, x2, y2
                end
            end
        end
    end
    
    -- Draw source glow (brighter at the beginning)
    local sourceGlowSize = 10 + 40 * (1.0 - effect.progress)
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.7 * (1.0 - effect.progress))
    love.graphics.circle("fill", effect.sourceX, effect.sourceY, sourceGlowSize)
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 1.0
        particle.scale = particle.scale or 0.2
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw the particle
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.8)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        ::next_draw_particle::
    end
end

-- Initialize function for cone effects
local function initializeCone(effect)
    -- For conical blast effects
    -- Calculate the base direction from source to target
    local dirX = effect.targetX - effect.sourceX
    local dirY = effect.targetY - effect.sourceY
    local baseAngle = math.atan2(dirY, dirX)

    -- Convert cone angle from degrees to radians
    local coneAngleRad = (effect.coneAngle or 60) * math.pi / 180
    local halfConeAngle = coneAngleRad / 2

    -- Set up wave parameters
    local waveCount = effect.waveCount or 3

    -- Calculate effect properties based on range and elevation
    local intensityMultiplier = 1.0
    if effect.rangeBand == Constants.RangeState.NEAR and effect.nearRangeIntensity then
        intensityMultiplier = intensityMultiplier * effect.nearRangeIntensity
    end

    -- Create particles for the cone blast
    for i = 1, effect.particleCount do
        -- Determine if this particle is part of a wave or general cone fill
        local isWaveParticle = i <= math.floor(effect.particleCount * 0.45) -- 45% of particles for waves

        -- Random position within the cone but with focus toward center if focusedCore enabled
        local angleOffset

        if effect.focusedCore then
            -- Apply quadratic distribution to concentrate particles near center
            -- Use squared random value to cluster toward cone center
            local angleRand = math.random()
            -- Apply bias toward center (squared distribution pushes values toward 0)
            angleRand = (angleRand * 2 - 1) * (angleRand * 2 - 1) * (angleRand > 0.5 and 1 or -1)
            angleOffset = angleRand * halfConeAngle
        else
            -- Standard uniform distribution across cone
            angleOffset = (math.random() * 2 - 1) * halfConeAngle
        end

        local angle = baseAngle + angleOffset

        -- Distance based on position in the cone (closer to edge or center)
        local maxDistance = effect.coneLength or 320

        -- For longer cone, we want more particles toward the end
        local distanceRand
        if math.random() < 0.6 then
            -- 60% chance for farther particles
            distanceRand = math.random() * 0.5 + 0.5 -- 0.5 to 1.0
        else
            -- 40% chance for closer particles
            distanceRand = math.random() * 0.5 -- 0.0 to 0.5
        end

        local distance = maxDistance * distanceRand

        -- Create the particle using ParticleManager
        local waveIndex = 0
        if isWaveParticle and effect.waveCrest then
            waveIndex = math.floor(math.random() * waveCount) + 1
        end

        local particle = ParticleManager.createConeParticle(effect, angle, distance, isWaveParticle, waveIndex)

        -- For focused cone, make particles in the center brighter and larger
        if effect.focusedCore and not isWaveParticle then
            -- Calculate distance from center angle
            local angleDiff = math.abs(angle - baseAngle) / halfConeAngle -- 0 at center, 1 at edge
            -- Particles closer to center get enhancements
            if angleDiff < 0.4 then
                local centerBoost = (1.0 - angleDiff/0.4) * 0.5
                particle.scale = particle.scale * (1 + centerBoost)
                particle.alpha = particle.alpha * (1 + centerBoost * 0.5)
            end
        end

        -- Apply intensity multiplier
        particle.intensityMultiplier = intensityMultiplier

        table.insert(effect.particles, particle)
    end

    -- Flag to track which waves have started
    effect.waveStarted = {}
    for i = 1, waveCount do
        effect.waveStarted[i] = false
    end
end

-- Return the module
return {
    initialize = initializeCone,
    update = updateCone,
    draw = drawCone
}```

## ./vfx/effects/conjure.lua
```lua
-- conjure.lua
-- Conjure VFX module for handling conjuration/summoning effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for conjure effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for conjure effects
local function updateConjure(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.sourceGlow = effect.sourceGlow or 0 -- Default source glow
    effect.poolGlow = effect.poolGlow or 0 -- Default pool glow
    effect.pulseRate = effect.pulseRate or 5 -- Default pulse rate
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update particles rising toward mana pool
    for i, particle in ipairs(effect.particles) do
        -- Skip invalid particles
        if not particle then
            goto next_particle
        end
        
        -- Initialize particle properties if missing
        particle.delay = particle.delay or 0
        particle.active = particle.active or false
        particle.baseX = particle.baseX or effect.sourceX
        particle.baseY = particle.baseY or effect.sourceY
        particle.targetX = particle.targetX or effect.targetX
        particle.targetY = particle.targetY or effect.targetY
        
        -- Check if particle should be active based on delay
        if effect.timer > particle.delay then
            particle.active = true
        end
        
        if particle.active then
            -- Calculate particle progress
            local particleProgress = math.min((effect.timer - particle.delay) / (effect.duration - particle.delay), 1.0)
            
            -- Update position - moving from source to target (mana pool)
            local startX = particle.baseX
            local startY = particle.baseY
            local endX = particle.targetX
            local endY = particle.targetY
            
            -- For a more interesting path, add some curves
            local bezierT = particleProgress
            local invT = 1.0 - bezierT
            
            -- Calculate bezier curve with randomized control points
            if not particle.ctrlPoint1X then
                -- Midpoint distance between source and target
                local midX = (startX + endX) / 2
                local midY = (startY + endY) / 2
                local dist = math.sqrt((endX - startX)^2 + (endY - startY)^2)
                
                -- Add random offset for natural path variation
                local offsetX = (math.random() - 0.5) * dist * 0.5
                local offsetY = (math.random() - 0.5) * dist * 0.5
                
                -- Store the control points for this particle's path
                particle.ctrlPoint1X = midX + offsetX
                particle.ctrlPoint1Y = midY + offsetY
            end
            
            -- Calculate quadratic bezier curve position
            particle.x = invT * invT * startX + 2 * invT * bezierT * particle.ctrlPoint1X + bezierT * bezierT * endX
            particle.y = invT * invT * startY + 2 * invT * bezierT * particle.ctrlPoint1Y + bezierT * bezierT * endY
            
            -- Calculate fade alpha based on progress
            -- Full opacity in the middle of the journey
            local fadeProgress = math.abs(particleProgress - 0.5) * 2 -- 0 at middle, 1 at start/end
            particle.alpha = 1.0 - fadeProgress * 0.7
            
            -- Update size - grow then shrink
            local sizeFactor = 1.0 - fadeProgress * 0.5
            particle.scale = (particle.baseScale or 0.3) * sizeFactor
        end
        
        ::next_particle::
    end
    
    -- Update glow at source position (starts strong, then fades)
    local sourceGlowProgress = math.min(effect.progress * 2, 1.0) -- 0->1 over first half
    effect.sourceGlow = 1.0 - sourceGlowProgress -- Fade from 1->0
    
    -- Update glow at mana pool (grows as particles converge)
    local poolGlowProgress = math.max(0, effect.progress * 2 - 1.0) -- 0->1 over second half
    effect.poolGlow = poolGlowProgress -- Grow from 0->1
    
    -- Create final pulse particles at the end
    if effect.progress > 0.85 and not effect.finalPulseCreated then
        -- Create a burst of particles radiating outward from mana pool
        local burstCount = 12
        for i = 1, burstCount do
            local angle = (i-1) * (2 * math.pi / burstCount)
            local particle = {
                x = effect.targetX,
                y = effect.targetY,
                angle = angle,
                speed = 80 + math.random() * 50,
                baseScale = 0.3 + math.random() * 0.2,
                scale = 0.3 + math.random() * 0.2,
                alpha = 0.8,
                life = 0,
                maxLife = 0.3 + math.random() * 0.2,
                active = true,
                type = "burst"  -- Mark these as burst particles
            }
            table.insert(effect.particles, particle)
        end
        
        effect.finalPulseCreated = true
    end
    
    -- Update final pulse particles (they move outward)
    for _, particle in ipairs(effect.particles) do
        if particle.type == "burst" and particle.active then
            -- Update position based on angle and speed
            particle.x = particle.x + math.cos(particle.angle) * particle.speed * dt
            particle.y = particle.y + math.sin(particle.angle) * particle.speed * dt
            
            -- Update lifecycle
            particle.life = particle.life + dt
            particle.alpha = 1.0 - (particle.life / particle.maxLife)
            particle.scale = particle.baseScale * (1.0 - particle.life / particle.maxLife)
            
            -- Deactivate if expired
            if particle.life >= particle.maxLife then
                particle.active = false
            end
        end
    end
end

-- Draw function for conjure effects
local function drawConjure(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default source position
    effect.sourceY = effect.sourceY or 0 -- Default source position
    effect.targetX = effect.targetX or 0 -- Default target position
    effect.targetY = effect.targetY or 0 -- Default target position
    effect.sourceGlow = effect.sourceGlow or 0 -- Default source glow
    effect.poolGlow = effect.poolGlow or 0 -- Default pool glow
    effect.timer = effect.timer or 0 -- Default timer
    
    local particleImage = getAssetInternal("sparkle")
    local glowImage = getAssetInternal("fireGlow")  -- We'll use this for all conjure types
    
    -- Draw source glow if active with additive blending
    if effect.sourceGlow and effect.sourceGlow > 0 then
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], effect.sourceGlow * 0.6)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, 50 * effect.sourceGlow)
        
        -- Draw expanding rings from source (hint at conjuration happening)
        local ringCount = 3
        for i = 1, ringCount do
            local ringProgress = ((effect.timer * 1.5) % 1.0) + (i-1) / ringCount
            if ringProgress < 1.0 then
                local ringSize = 60 * ringProgress
                local ringAlpha = 0.5 * (1.0 - ringProgress) * effect.sourceGlow
                love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], ringAlpha)
                love.graphics.circle("line", effect.sourceX, effect.sourceY, ringSize)
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle with additive blending for brighter appearance
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.8)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        ::next_draw_particle::
    end
    
    -- Draw mana pool glow with additive blending (grows at the end of the effect)
    if effect.poolGlow and effect.poolGlow > 0 then
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Add some pulsing to the glow
        local pulseOffset = math.sin(effect.timer * 8) * 0.2
        local finalGlowScale = effect.poolGlow * (1.0 + pulseOffset)
        
        -- Draw outer glow
        love.graphics.setColor(effect.color[1] * 0.6, effect.color[2] * 0.6, effect.color[3] * 0.6, effect.poolGlow * 0.7)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 50 * finalGlowScale)
        
        -- Draw inner glow (brighter)
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], effect.poolGlow * 0.9)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 30 * finalGlowScale)
        
        -- Draw bright center
        love.graphics.setColor(1, 1, 1, effect.poolGlow * 0.95)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 15 * finalGlowScale)
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
end

-- Initialize function for conjure effects
local function initializeConjure(effect)
    -- For conjuration spells, create particles that rise from caster toward mana pool
    -- Set the mana pool position (typically at top center)
    effect.manaPoolX = effect.options and effect.options.manaPoolX or 400 -- Screen center X
    effect.manaPoolY = effect.options and effect.options.manaPoolY or 120 -- Near top of screen

    -- Ensure spreadRadius has a default value
    effect.spreadRadius = effect.spreadRadius or 40

    -- Calculate direction vector toward mana pool
    local dirX = effect.manaPoolX - effect.sourceX
    local dirY = effect.manaPoolY - effect.sourceY
    local len = math.sqrt(dirX * dirX + dirY * dirY)
    dirX = dirX / len
    dirY = dirY / len

    for i = 1, effect.particleCount do
        -- Create a spread of particles around the caster
        local spreadAngle = math.random() * math.pi * 2
        local spreadDist = math.random() * effect.spreadRadius
        local startX = effect.sourceX + math.cos(spreadAngle) * spreadDist
        local startY = effect.sourceY + math.sin(spreadAngle) * spreadDist

        -- Randomize particle properties
        local speed = math.random(80, 180)
        local delay = i / effect.particleCount * 0.7

        -- Add some variance to path
        local pathVariance = math.random(-20, 20)
        local pathDirX = dirX + pathVariance / 100
        local pathDirY = dirY + pathVariance / 100

        -- Create particle using ParticleManager
        local particle = ParticleManager.createConjureParticle(effect, startX, startY, pathDirX, pathDirY, speed, delay)

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeConjure,
    update = updateConjure,
    draw = drawConjure
}```

## ./vfx/effects/impact.lua
```lua
-- impact.lua
-- Impact VFX module for handling impact/explosion effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for impact effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for impact effects
local function updateImpact(effect, dt)
    -- Initialize effect default values if not already set
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.radius = effect.radius or 50 -- Default radius
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Create impact wave that expands outward
    -- For effects with useTargetPosition=true, ensure particles use target position
    local useTargetPosition = effect.useTargetPosition
    
    for i, particle in ipairs(effect.particles) do
        -- Check if particle should be active based on delay
        if effect.timer > particle.delay then
            particle.active = true
            
            -- Update particle base position to current target position for effects that track target
            if useTargetPosition then
                particle.baseX = effect.targetX
                particle.baseY = effect.targetY
            end
            
            -- Calculate particle progress
            local particleProgress = (effect.timer - particle.delay) / (effect.duration - particle.delay)
            particleProgress = math.min(particleProgress, 1.0)
            
            -- Update particle based on its specific animation type
            if particle.animType == "expand" then
                -- Expand outward from center
                local distProgress = particleProgress -- Distance progress
                local fadeProgress = particleProgress ^ 0.7 -- Fade progress (start faster)
                
                -- Calculate distance from center
                local angle = particle.angle
                local dist = particle.maxDist * distProgress
                
                -- Update position
                particle.x = particle.baseX + math.cos(angle) * dist
                particle.y = particle.baseY + math.sin(angle) * dist
                
                -- Update alpha (fade out)
                particle.alpha = (1.0 - fadeProgress)
                
                -- Update scale (grow slightly, then shrink)
                local scaleProgress = particleProgress
                particle.scale = particle.baseScale * (1.0 + scaleProgress * 0.5) * (1.0 - scaleProgress * 0.8)
            end
        end
    end
end

-- Draw function for impact effects
local function drawImpact(effect)
    -- Make sure essential properties exist
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.targetX = effect.targetX or 0 -- Default position
    effect.targetY = effect.targetY or 0 -- Default position
    effect.radius = effect.radius or 50 -- Default radius
    
    local particleImage = getAssetInternal("fireParticle")
    local impactImage = getAssetInternal("impactRing")
    
    -- Draw expanding ring
    local ringProgress = math.min(effect.progress * 1.5, 1.0) -- Ring expands faster than full effect
    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], (1.0 - ringProgress)) -- Use base color, apply ring alpha
    local ringScale = effect.radius * 0.02 * ringProgress
    love.graphics.draw(
        impactImage,
        effect.targetX, effect.targetY,
        0,
        ringScale, ringScale,
        impactImage:getWidth()/2, impactImage:getHeight()/2
    )
    
    -- Draw central flash with additive blending for extra brightness
    if effect.progress < 0.3 then
        local flashIntensity = 1.0 - (effect.progress / 0.3)
        love.graphics.setColor(1, 1, 1, flashIntensity * 0.7)
        
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.circle("fill", effect.targetX, effect.targetY, 30 * flashIntensity)
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        if particle.active and particle.alpha > 0 then
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.7)
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        end
    end
end

-- Initialize function for impact effects
local function initializeImpact(effect)
    -- For impact effects, create a radial explosion using ParticleManager
    for i = 1, effect.particleCount do
        local angle = (i / effect.particleCount) * math.pi * 2
        local delay = math.random() * 0.2 -- Slight random delay

        -- Create particle using specialized helper
        local particle = ParticleManager.createImpactParticle(effect, angle, delay)

        -- Additional motion-related properties
        particle.motion = effect.motion -- Store motion style on particle

        -- Additional properties for special motion
        particle.startTime = 0
        particle.baseX = effect.targetX
        particle.baseY = effect.targetY
        particle.angle = angle

        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeImpact,
    update = updateImpact,
    draw = drawImpact
}```

## ./vfx/effects/meteor.lua
```lua
-- meteor.lua
-- Meteor VFX module for handling falling meteor/comet effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for meteor effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for meteor effects - SIMPLIFIED IMPLEMENTATION
local function updateMeteor(effect, dt)
    print("[METEOR] Start of updateMeteor()")

    -- Initialize basic effect properties
    effect.particles = effect.particles or {}
    effect.color = effect.color or {1, 1, 1}
    effect.height = effect.height or 300
    effect.spread = effect.spread or 40

    -- Set delaysDamage flag to true - this tells the spell system to wait for impact
    -- This should be checked in the wizard's castSpell function
    effect.delaysDamage = true
    
    -- Debug output
    print(string.format("[METEOR] Effect: timer=%.2f, progress=%.2f, particles=%d, target=(%d,%d)",
                      effect.timer or 0, effect.progress or 0, #effect.particles, 
                      effect.targetX or 0, effect.targetY or 0))
    
    -- Create particles if none exist
    if #effect.particles == 0 and effect.targetX and effect.targetY then
        print("[METEOR] Creating new meteor particles")

        local particleCount = effect.particleCount or 8

        -- Increase spread to make meteors more visually distinct
        local spreadX = effect.spread * 2.5  -- Much wider X spread
        local spreadY = effect.spread * 0.5  -- Less Y spread for a more uniform height

        for i = 1, particleCount do
            -- Create meteor particle with wide horizontal distribution and less vertical variation
            local offsetX = (math.random() - 0.5) * spreadX
            local offsetY = (math.random() - 0.5) * spreadY
            
            -- Create meteor particle using ParticleManager
            local meteor = ParticleManager.createMeteorParticle(effect, offsetX, offsetY)
            
            -- Initialize position
            meteor.x = meteor.startX
            meteor.y = meteor.startY
            
            table.insert(effect.particles, meteor)
            print(string.format("[METEOR] Created particle #%d at (%.1f, %.1f)", i, meteor.x, meteor.y))
        end
    end
    
    -- Process particles
    local rawProgress = effect.progress or 0
    
    for i, particle in ipairs(effect.particles) do
        if particle.type == "meteor" then
            -- Calculate individual particle progress
            local particleTime = (effect.timer or 0) - (particle.timeCreated or 0)
            local particleProgress = math.min(particleTime / (particle.lifespan or 1.0), 1.0)
            
            -- Use raw effect progress to move
            local moveProgress = rawProgress
            
            -- Simple linear movement from start to end position
            particle.x = particle.startX + (particle.endX - particle.startX) * moveProgress
            particle.y = particle.startY + (particle.endY - particle.startY) * moveProgress
            
            -- Update rotation
            particle.rotation = particle.rotation + particle.rotationSpeed * dt
            
            -- Logging for first particle
            if i == 1 then
                print(string.format("[METEOR] Main particle: progress=%.2f, pos=(%.1f, %.1f)", 
                                 moveProgress, particle.x, particle.y))
            end
            
            -- Randomly create trail particles
            if math.random() < 0.1 and moveProgress > 0.1 and moveProgress < 0.9 then
                local Pool = require("core.Pool")
                -- Create trail particle using ParticleManager
                local trail = ParticleManager.createMeteorTrailParticle(effect, particle)
                table.insert(effect.particles, trail)
            end
        elseif particle.type == "trail" then
            -- Update trail particles
            local trailTime = (effect.timer or 0) - (particle.timeCreated or 0)
            local trailProgress = math.min(trailTime / (particle.lifespan or 0.3), 1.0)
            
            -- Fade out trail
            particle.alpha = (1.0 - trailProgress) * particle.baseAlpha
            
            -- Shrink trail
            particle.scale = particle.baseScale * (1.0 - trailProgress * 0.5)
        elseif particle.type == "impact" then
            -- Update impact particles
            local impactTime = (effect.timer or 0) - (particle.timeCreated or 0)
            local impactProgress = math.min(impactTime / (particle.lifespan or 0.5), 1.0)
            
            -- Radiate outward
            local dist = particle.maxDist * impactProgress
            particle.x = effect.targetX + math.cos(particle.angle) * dist
            particle.y = effect.targetY + math.sin(particle.angle) * dist
            
            -- Fade out
            if impactProgress < 0.2 then
                particle.alpha = impactProgress / 0.2 * particle.baseAlpha
            else
                particle.alpha = (1.0 - (impactProgress - 0.2) / 0.8) * particle.baseAlpha
            end
        end
    end
    
    -- Create impact particles at end of animation
    if effect.progress > 0.8 and effect.progress < 0.9 and not effect.impactCreated then
        print("[METEOR] Creating impact particles")

        -- Create impact effect
        local impactCount = 12
        for i = 1, impactCount do
            local angle = (i-1) * (2 * math.pi / impactCount)
            local Pool = require("core.Pool")
            -- Create impact particle using ParticleManager
            local impact = ParticleManager.createMeteorImpactParticle(effect, angle)
            table.insert(effect.particles, impact)
        end

        -- TRIGGER DAMAGE EVENT AT IMPACT (similar to projectile implementation)
        -- Execute the damage callback if it exists (this is how we delay the actual damage until impact)
        if effect.options and effect.options.onImpact then
            print("[METEOR] Triggering onImpact callback for delayed damage!")

            local success, err = pcall(function()
                effect.options.onImpact(effect)
            end)

            if not success then
                print("[METEOR] Error in onImpact callback: " .. tostring(err))
            end
        end

        -- Trigger screen shake and hit stop on impact
        local shakeDuration = 0.25
        local shakeIntensity = 6

        -- Try to trigger screen shake if available
        if VFX.triggerShake then
            VFX.triggerShake(shakeDuration, shakeIntensity)
            print("[METEOR] Triggered screen shake")
        end

        -- Try to trigger hit stop if available
        if VFX.triggerHitstop then
            VFX.triggerHitstop(0.08)  -- Brief hitstop for impact feel
            print("[METEOR] Triggered hit stop")
        end

        effect.impactCreated = true
    end
    
    -- Clean up expired particles using ParticleManager
    local removedCount = ParticleManager.cleanupEffectParticles(effect.particles, function(particle)
        return particle.type == "trail" and particle.alpha <= 0.05
    end)

    if removedCount > 0 then
        print(string.format("[METEOR] Cleaned up %d expired particles", removedCount))
    end
    
    print(string.format("[METEOR] End of update: %d particles", #effect.particles))
end

-- Draw function for meteor effects
local function drawMeteor(effect)
    -- Set additive blending for the entire effect
    love.graphics.setBlendMode("add")
    
    -- Draw all active particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or invisible particles
        if not particle or particle.alpha <= 0.01 then
            goto next_draw_particle
        end
        
        -- Get the appropriate asset
        local asset = getAssetInternal(particle.assetId or "fireParticle")
        
        if asset then
            -- Get color
            local colorR, colorG, colorB = effect.color[1], effect.color[2], effect.color[3]
            if particle.color then
                colorR, colorG, colorB = particle.color[1], particle.color[2], particle.color[3]
            end
            
            -- Set color and alpha
            love.graphics.setColor(colorR, colorG, colorB, particle.alpha)
            
            -- Draw particle with rotation
            love.graphics.draw(
                asset,
                particle.x, particle.y,
                particle.rotation or 0,
                particle.scale, particle.scale,
                asset:getWidth()/2, asset:getHeight()/2
            )
            
            -- Draw glow for meteor particles
            if particle.type == "meteor" then
                -- Draw glow around meteor with additional color intensity
                love.graphics.setColor(colorR * 1.2, colorG * 1.2, colorB * 1.2, particle.alpha * 0.7)
                local glowAsset = getAssetInternal("fireGlow")
                
                if glowAsset then
                    love.graphics.draw(
                        glowAsset,
                        particle.x, particle.y,
                        0,
                        particle.scale * 2, particle.scale * 2,
                        glowAsset:getWidth()/2, glowAsset:getHeight()/2
                    )
                end
            end
        else
            -- Fallback if asset is missing
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha)
            love.graphics.circle("fill", particle.x, particle.y, (particle.scale or 1) * 20)
        end
        
        ::next_draw_particle::
    end
    
    -- Reset blend mode
    love.graphics.setBlendMode("alpha")
end

-- Return the module
return {
    update = updateMeteor,
    draw = drawMeteor
}```

## ./vfx/effects/projectile.lua
```lua
-- projectile.lua
-- Projectile VFX module for handling spell projectiles

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for projectile effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for projectile effects
local function updateProjectile(effect, dt)
    -- Initialize effect default values if not already set
    effect.trailLength = effect.trailLength or 10 -- Default trail length
    effect.trailPoints = effect.trailPoints or {} -- Initialize trail points array if nil
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.size = effect.size or 1.0 -- Default size
    effect.arcHeight = effect.arcHeight or 60 -- Default arc height
    effect.frameDuration = effect.frameDuration or 0.1 -- Default frame duration
    effect.currentFrame = effect.currentFrame or 1 -- Default current frame
    effect.frameTimer = effect.frameTimer or 0 -- Default frame timer

    -- Always update visual progress from effect.progress on each frame
    -- This ensures visualProgress increases over time consistently

    -- Bug fix: visualProgress wasn't being set correctly for blocked projectiles
    if effect.isBlocked then
        -- For blocked effects, always update until it reaches the block point
        local blockPoint = (effect.options and effect.options.blockPoint) or 1.0

        if not effect.visualProgress or effect.visualProgress < effect.progress then
            effect.visualProgress = math.min(effect.progress, blockPoint)
            print("[PROJECTILE DEBUG] Updating visualProgress for blocked effect: " .. effect.visualProgress)
        end
    else
        -- For normal effects, always sync visualProgress with progress on each update
        effect.visualProgress = effect.progress
    end
    
    -- Ensure path-related properties are set
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.useCurvedPath = (effect.useCurvedPath ~= false) -- Default to true for bolt effects
    effect.useTrail = (effect.useTrail ~= false) -- Default to true
    
    if #effect.trailPoints == 0 then
        -- Initialize trail with source position
        for i = 1, effect.trailLength do
            table.insert(effect.trailPoints, {
                x = effect.sourceX, 
                y = effect.sourceY,
                alpha = i == 1 and 1.0 or (1.0 - (i-1)/effect.trailLength)
            })
        end
    end
    
    -- Get effect parameters with defaults
    local arcHeight = effect.arcHeight or 60
    
    -- Always use visualProgress for consistent animation
    -- This ensures the head position consistently updates with each frame
    local baseProgress = effect.visualProgress

    print(string.format("[PROJECTILE PROGRESS] isBlocked=%s, progress=%.2f, visualProgress=%.2f, baseProgress=%.2f",
        tostring(effect.isBlocked), effect.progress or 0, effect.visualProgress or 0, baseProgress))
    
    -- Calculate projectile position along the path
    local startX, startY = effect.sourceX, effect.sourceY
    local endX, endY = effect.targetX, effect.targetY
    
    -- For remote casting, override startX/Y to be the actual cast position
    if effect.useSourcePosition and effect.remoteSourceX and effect.remoteSourceY then
        startX = effect.remoteSourceX
        startY = effect.remoteSourceY
    end
    
    -- Special case for parabolic block
    local blockPoint = effect.blockPoint or 1.0
    
    -- Adjust the trajectory for blocked projectiles
    if effect.isBlocked and baseProgress > blockPoint then
        baseProgress = blockPoint
    end
    
    -- Calculate the current position of the projectile head
    local head = { 
        x = startX, 
        y = startY 
    }
    
    -- Ensure we're using a valid progress value
    -- Crucial: If baseProgress is nil, use effect.progress directly
    -- This ensures we always have a value that increases over time
    if baseProgress == nil then
        baseProgress = effect.progress or 0
        print("[PROJECTILE WARNING] baseProgress was nil, using effect.progress = " .. baseProgress)
    end

    -- Now calculate the position along the path
    if effect.useCurvedPath then
        -- Use a parabolic path
        head.x = startX + (endX - startX) * baseProgress
        head.y = startY + (endY - startY) * baseProgress
        
        -- Apply parabolic arc
        -- Calculate a parabola that starts at source, ends at target, and peaks at height
        local arcProgress = baseProgress
        
        if effect.isBlocked and blockPoint < 1.0 then
            -- The arc should complete over the shorter range to the block point
            arcProgress = baseProgress / blockPoint
        end
        
        -- Standard parabola: 4 * h * x * (1-x) where h is height and x is [0,1] progress
        local arcFactor = 4 * arcHeight * arcProgress * (1 - arcProgress)
        
        -- Apply the vertical offset
        head.y = head.y - arcFactor
    else
        -- Use a straight-line path
        head.x = startX + (endX - startX) * baseProgress
        head.y = startY + (endY - startY) * baseProgress
    end
    
    -- For source tracking, update the source position if needed
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
        end
    end
    
    -- For target tracking, update the target position if needed
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
        end
    end
    
    -- Update trail points (shifting all points to make room for the new head)
    -- Bug fix: Ensure head position is actually different before updating trail
    -- This prevents the trail from being stuck at the same point
    local shouldUpdateTrail = true

    if #effect.trailPoints > 0 then
        -- Check if the head has actually moved from the last position
        local lastHeadX = effect.trailPoints[1] and effect.trailPoints[1].x
        local lastHeadY = effect.trailPoints[1] and effect.trailPoints[1].y

        -- Only create a new trail point if the head has moved at least a small distance
        -- or if this is the first update
        local minDistance = 1.0 -- Minimum distance to consider movement significant
        if lastHeadX and lastHeadY then
            local dx = head.x - lastHeadX
            local dy = head.y - lastHeadY
            local distanceMoved = math.sqrt(dx*dx + dy*dy)
            shouldUpdateTrail = (distanceMoved >= minDistance)

            if not shouldUpdateTrail then
                print(string.format("[PROJECTILE DEBUG] Head position hasn't changed significantly: dist=%.2f < %.2f",
                    distanceMoved, minDistance))
            end
        end

        if shouldUpdateTrail then
            -- For trail with length n, we want to preserve n points
            -- Remove the last point
            table.remove(effect.trailPoints)

            -- Insert the new head position at the beginning
            table.insert(effect.trailPoints, 1, {
                x = head.x,
                y = head.y,
                alpha = 1.0
            })

            -- Update alpha values for the trail
            for i = 2, #effect.trailPoints do
                effect.trailPoints[i].alpha = 1.0 - (i-1)/effect.trailLength
            end

            print(string.format("[PROJECTILE DEBUG] Updated trail with new head position: (%.1f, %.1f)", head.x, head.y))
        end
    else
        -- If there are no trail points yet, initialize with current head position
        for i = 1, effect.trailLength do
            table.insert(effect.trailPoints, {
                x = head.x,
                y = head.y,
                alpha = i == 1 and 1.0 or (1.0 - (i-1)/effect.trailLength)
            })
        end
        print("[PROJECTILE DEBUG] Initialized trail with starting position")
    end
    
    -- Update particles for the projectile trail
    if effect.particles then
        -- Add many new particles at the current head position for dense swarm effect
        local particleRate = effect.particleRate or 15.0 -- Massive rate for spectacular particle swarm
        
        -- Generate multiple particles per frame for dense effect
        local particlesThisFrame = math.floor(particleRate)
        if math.random() < (particleRate - particlesThisFrame) then
            particlesThisFrame = particlesThisFrame + 1
        end
        
        for i = 1, particlesThisFrame do
            -- Create different types of particles using primitive assets
            local particle = ParticleManager.createProjectileTrailParticle(effect, head.x, head.y)
            
            -- Assign primitive sprite types for variety
            local spriteType = math.random(3)
            if spriteType == 1 then
                particle.spriteType = "pixel"
                particle.size = math.random(1, 3)
            elseif spriteType == 2 then
                particle.spriteType = "twinkle1"
                particle.size = math.random(2, 4)
            else
                particle.spriteType = "twinkle2"
                particle.size = math.random(2, 4)
            end
            
            -- Add some randomness to position for swarm effect
            particle.x = particle.x + (math.random() - 0.5) * 8
            particle.y = particle.y + (math.random() - 0.5) * 8
            
            -- Add the particle to the effect
            table.insert(effect.particles, particle)
        end
        
        -- Update existing particles
        local i = 1
        while i <= #effect.particles do
            local particle = effect.particles[i]
            
            -- Skip invalid particles
            if not particle then
                table.remove(effect.particles, i)
                goto next_particle
            end
            
            -- Ensure particle has all needed properties
            particle.x = particle.x or head.x
            particle.y = particle.y or head.y
            particle.xVel = particle.xVel or 0
            particle.yVel = particle.yVel or 0
            particle.life = particle.life or 0
            particle.maxLife = particle.maxLife or 0.5
            
            -- Update particle physics
            particle.x = particle.x + particle.xVel * dt
            particle.y = particle.y + particle.yVel * dt
            particle.life = particle.life + dt
            
            -- Calculate fade based on life
            particle.alpha = 1.0 - (particle.life / particle.maxLife)
            
            -- Remove dead particles
            if particle.life >= particle.maxLife then
                -- Release particle back to pool
                ParticleManager.releaseParticle(particle)
                table.remove(effect.particles, i)
            else
                i = i + 1
            end
            
            ::next_particle::
        end
    end
    
    -- Update sprite animation frame (if using sprites)
    if effect.useSprites then
        effect.frameTimer = effect.frameTimer + dt
        if effect.frameTimer >= effect.frameDuration then
            effect.frameTimer = 0
            effect.currentFrame = effect.currentFrame + 1
            
            -- Determine max frames based on effect type
            local maxFrames = 3  -- Default for bolt
            if effect.type == "orb_base" then
                maxFrames = 5
            end
            
            if effect.currentFrame > maxFrames then
                effect.currentFrame = 1
            end
        end
    end
    
    -- Write the head position to the effect for drawing
    -- Critical bugfix: Force head position update even if trail wasn't updated
    -- This ensures the head always reflects the current progress
    effect.headX = head.x
    effect.headY = head.y

    -- Debug logging - track position updates
    print(string.format("[PROJECTILE DEBUG] Updated head position: (%.1f, %.1f) at progress=%.2f",
        head.x, head.y, baseProgress))
end

-- Draw function for projectile effects
local function drawProjectile(effect)
    -- Make sure essential properties exist
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.size = effect.size or 1.0 -- Default size
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.trailPoints = effect.trailPoints or {} -- Initialize trail points array if nil
    effect.currentFrame = effect.currentFrame or 1 -- Default current frame
    effect.useCurvedPath = (effect.useCurvedPath ~= false) -- Default to true for bolt effects
    effect.useTrail = (effect.useTrail ~= false) -- Default to true
    
    -- Debug info for drawing
    print(string.format("[PROJECTILE DRAW] Effect: %s, Timer: %.2f, Progress: %.2f", 
        effect.name or "unnamed", effect.timer or 0, effect.progress or 0))
    print(string.format("[PROJECTILE DRAW] Head Position: (%.0f, %.0f), Source: (%.0f, %.0f), Target: (%.0f, %.0f)", 
        effect.headX or 0, effect.headY or 0, 
        effect.sourceX or 0, effect.sourceY or 0,
        effect.targetX or 0, effect.targetY or 0))
    
    -- Ensure the head position exists
    if not effect.headX or not effect.headY then
        -- If no head position, calculate it based on progress
        local progress = effect.isBlocked and effect.visualProgress or effect.progress or 0
        effect.headX = effect.sourceX + (effect.targetX - effect.sourceX) * progress
        effect.headY = effect.sourceY + (effect.targetY - effect.sourceY) * progress
        
        print(string.format("[PROJECTILE DRAW] Recalculated head position to (%.0f, %.0f) with progress %.2f", 
            effect.headX, effect.headY, progress))
    end
    
    -- Get assets including new primitive sprites
    local particleImage = getAssetInternal("fireParticle")
    local glowImage = getAssetInternal("fireGlow")
    local impactImage = getAssetInternal("impactRing")
    local onePxImage = getAssetInternal("pixel")
    local twinkle1Image = getAssetInternal("twinkle1")
    local twinkle2Image = getAssetInternal("twinkle2")
    
    -- Get sprite frames if needed
    local spriteFrames = nil
    if effect.useSprites then
        if effect.type == "orb_base" then
            spriteFrames = getAssetInternal("orbFrames")
        else
            spriteFrames = getAssetInternal("boltFrames")
        end
    end
    
    -- Calculate the actual trajectory angle for aimed shots
    -- This will be used for sprite rotation if it's a bolt
    local trajectoryAngle = nil
    if effect.useSourcePosition and effect.useTargetPosition then
        -- Calculate direction vector from current source to target
        local dirX = effect.targetX - effect.sourceX
        local dirY = effect.targetY - effect.sourceY
        
        -- Calculate the angle
        trajectoryAngle = math.atan2(dirY, dirX)
    end
    
    -- Get the head position (calculated in update)
    local head = {
        x = effect.headX or effect.sourceX,
        y = effect.headY or effect.sourceY
    }
    
    -- If we have a trail, draw it using particle swarms instead of large sprites
    if effect.useTrail and #effect.trailPoints > 1 then
        -- Draw trail using swarms of tiny particles at each point
        for i = #effect.trailPoints, 1, -1 do
            local point = effect.trailPoints[i]
            local trailIntensity = (1 - (i-1)/#effect.trailPoints)
            local trailAlpha = point.alpha * 0.6
            local particleCount = math.floor(trailIntensity * 50) -- Massive particle count for spectacular trail
            
            -- Draw swarm of tiny particles at each trail point
            local color = effect.color or {1, 1, 1}
            
            for p = 1, particleCount do
                -- Random offset for particle swarm
                local offsetX = (math.random() - 0.5) * trailIntensity * 15
                local offsetY = (math.random() - 0.5) * trailIntensity * 15
                
                -- Choose random primitive sprite
                local spriteChoice = math.random(3)
                local sprite, scale
                
                if spriteChoice == 1 and onePxImage then
                    sprite = onePxImage
                    scale = math.random(1, 2)
                elseif spriteChoice == 2 and twinkle1Image then
                    sprite = twinkle1Image
                    scale = math.random(0.8, 1.5)
                else
                    sprite = twinkle2Image or onePxImage
                    scale = math.random(0.8, 1.5)
                end
                
                if sprite then
                    love.graphics.setColor(
                        color[1], 
                        color[2], 
                        color[3], 
                        trailAlpha * (0.4 + math.random() * 0.6)
                    )
                    
                    love.graphics.draw(
                        sprite,
                        point.x + offsetX, point.y + offsetY,
                        0,
                        scale, scale,
                        sprite:getWidth()/2, sprite:getHeight()/2
                    )
                end
            end
        end
    end
    
    -- Draw the particles using primitive sprites
    if effect.particles then
        for _, particle in ipairs(effect.particles) do
            -- Skip invalid particles
            if not particle then
                goto next_draw_particle
            end
            
            local particleColor = particle.color or effect.color or {1, 1, 1}
            love.graphics.setColor(
                particleColor[1],
                particleColor[2],
                particleColor[3],
                (particle.alpha or 0.5) * 0.8
            )
            
            -- Choose sprite based on particle type
            local sprite = nil
            local scale = (particle.size or 3) / 3
            
            if particle.spriteType == "pixel" and onePxImage then
                sprite = onePxImage
            elseif particle.spriteType == "twinkle1" and twinkle1Image then
                sprite = twinkle1Image
            elseif particle.spriteType == "twinkle2" and twinkle2Image then
                sprite = twinkle2Image
            else
                -- Fallback to any available primitive
                sprite = onePxImage or twinkle1Image or twinkle2Image or particleImage
            end
            
            -- Draw particle with primitive sprite
            if sprite then
                love.graphics.draw(
                    sprite,
                    particle.x, particle.y,
                    0,
                    scale, scale,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            else
                -- Final fallback to a circle
                love.graphics.circle("fill", particle.x, particle.y, particle.size or 3)
            end
            
            ::next_draw_particle::
        end
    end
    
    -- Draw the projectile head
    local leadingIntensity = 1.3 -- Make the leading edge brighter
    
    -- Draw sprite-based projectile (like lightning bolt or orb)
    if effect.useSprites and spriteFrames then
        -- Use projectile sprites
        local frame = spriteFrames[effect.currentFrame]
        local scale = effect.size * 2
        
        -- Handle rotation based on effect type
        local rotation = 0
        if effect.type == "orb_base" then
            -- Orbs don't rotate with trajectory, but can have gentle spinning
            rotation = (effect.spriteRotationOffset or 0) + (love.timer.getTime() * 0.5)
        else
            -- Bolts rotate based on trajectory
            rotation = trajectoryAngle or 0
        end
        
        love.graphics.setColor(
            effect.color[1], 
            effect.color[2], 
            effect.color[3], 
            0.9
        )
        
        love.graphics.draw(
            frame, 
            head.x, head.y,
            rotation,
            scale, scale,
            frame:getWidth()/2, frame:getHeight()/2
        )
    else
        -- Draw particle-based projectile using swarms of tiny primitives
        
        -- Draw outer glow using massive swarm of tiny particles
        local color = effect.color or {1, 1, 1}
        local outerRadius = (effect.size or 1.0) * 25
        local outerParticleCount = 80
        
        for i = 1, outerParticleCount do
            local angle = (i / outerParticleCount) * math.pi * 2
            local radius = outerRadius * (0.6 + math.random() * 0.4)
            local px = head.x + math.cos(angle) * radius
            local py = head.y + math.sin(angle) * radius
            
            love.graphics.setColor(
                color[1] * 0.6, 
                color[2] * 0.6, 
                color[3] * 0.6, 
                0.3 * (0.5 + math.random() * 0.5)
            )
            
            local sprite = (i % 2 == 0) and onePxImage or twinkle1Image
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    1 + math.random(), 1 + math.random(),
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Inner glow using massive swarm of tiny particles with additive blending
        local innerRadius = (effect.size or 1.0) * 12
        local innerParticleCount = 65
        
        -- Save current blend mode and set to additive for brightness
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        for i = 1, innerParticleCount do
            local angle = (i / innerParticleCount) * math.pi * 2 + love.timer.getTime() * 2
            local radius = innerRadius * (0.3 + math.random() * 0.7)
            local px = head.x + math.cos(angle) * radius
            local py = head.y + math.sin(angle) * radius
            
            love.graphics.setColor(
                math.min(1.0, color[1] * leadingIntensity), 
                math.min(1.0, color[2] * leadingIntensity), 
                math.min(1.0, color[3] * leadingIntensity), 
                0.6 * (0.4 + math.random() * 0.6)
            )
            
            local sprite = (i % 3 == 0) and twinkle2Image or ((i % 3 == 1) and twinkle1Image or onePxImage)
            if sprite then
                love.graphics.draw(
                    sprite, px, py, 0,
                    0.8 + math.random() * 0.6, 0.8 + math.random() * 0.6,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        -- Add electrical corona effect using primitive particles
        local coronaRadius = (effect.size or 1.0) * 35
        local coronaParticleCount = 45
        local time = love.timer.getTime()
        
        -- Save current blend mode and set to additive for electrical effect
        local prevMode2 = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        for i = 1, coronaParticleCount do
            local angle = (i / coronaParticleCount) * math.pi * 2 + time * 3
            local pulseRadius = coronaRadius * (0.8 + 0.3 * math.sin(time * 5 + i))
            local px = head.x + math.cos(angle) * pulseRadius
            local py = head.y + math.sin(angle) * pulseRadius
            
            -- Flickering alpha for electrical effect
            local flickerAlpha = 0.15 + 0.1 * math.sin(time * 8 + i * 0.5)
            
            love.graphics.setColor(
                color[1] * 0.8, 
                color[2] * 0.9, 
                color[3] * 1.0, 
                flickerAlpha
            )
            
            -- Use tiny 1px sprites for electrical sparks
            if onePxImage then
                love.graphics.draw(
                    onePxImage, px, py, 0,
                    1 + math.random() * 0.5, 1 + math.random() * 0.5,
                    onePxImage:getWidth()/2, onePxImage:getHeight()/2
                )
            end
        end
        
        -- Add sparkle layer using twinkle sprites
        local sparkleRadius = (effect.size or 1.0) * 40
        local sparkleCount = 30
        
        for i = 1, sparkleCount do
            local angle = (i / sparkleCount) * math.pi * 2 + time * -1.5
            local radius = sparkleRadius * (0.6 + 0.4 * math.random())
            local px = head.x + math.cos(angle) * radius
            local py = head.y + math.sin(angle) * radius
            
            -- Twinkling effect
            local twinklePhase = math.sin(time * 4 + i * 1.2)
            local twinkleAlpha = math.max(0, 0.2 + 0.3 * twinklePhase)
            
            love.graphics.setColor(
                color[1], 
                color[2], 
                color[3], 
                twinkleAlpha
            )
            
            local sprite = (i % 2 == 0) and twinkle1Image or twinkle2Image
            if sprite then
                local scale = 0.8 + 0.4 * math.abs(twinklePhase)
                love.graphics.draw(
                    sprite, px, py, 0,
                    scale, scale,
                    sprite:getWidth()/2, sprite:getHeight()/2
                )
            end
        end
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode2[1], prevMode2[2])
        
        -- Core (solid center)
        love.graphics.setColor(1, 1, 1, 0.9)
        local coreScale = (effect.size or 1.0) * 0.5
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                head.x, head.y,
                0,
                coreScale, coreScale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback
            love.graphics.circle("fill", head.x, head.y, coreScale * 10)
        end
    end
    
    -- Draw block impact if projectile was blocked
    if effect.isBlocked and effect.blockPoint and effect.progress > effect.blockPoint then
        -- Calculate the impact position at the block point
        local blockX = effect.sourceX + (effect.targetX - effect.sourceX) * effect.blockPoint
        local blockY = effect.sourceY + (effect.targetY - effect.sourceY) * effect.blockPoint
        
        -- If using curved path, apply the arc height
        if effect.useCurvedPath then
            -- Apply parabolic arc at block point
            local arcFactor = 4 * (effect.arcHeight or 60) * effect.blockPoint * (1 - effect.blockPoint)
            blockY = blockY - arcFactor
        end
        
        -- Draw impact flash
        local impactProgress = (effect.progress - effect.blockPoint) / (1 - effect.blockPoint)
        local impactSize = 20 * (1 - impactProgress) * effect.size
        local impactAlpha = 0.7 * (1 - impactProgress)
        
        if impactAlpha > 0 then
            love.graphics.setColor(1, 1, 1, impactAlpha)
            
            -- Save current blend mode and set to additive for the brightest elements
            local prevMode = {love.graphics.getBlendMode()}
            love.graphics.setBlendMode("add")
            
            if impactImage then
                love.graphics.draw(
                    impactImage,
                    blockX, blockY,
                    0,
                    impactSize/10, impactSize/10,
                    impactImage:getWidth()/2, impactImage:getHeight()/2
                )
            else
                -- Fallback
                love.graphics.circle("fill", blockX, blockY, impactSize)
            end
            
            -- Draw shield runes if this was blocked by a shield
            local shieldType = effect.blockType or effect.options.shieldType
            if shieldType and (shieldType == "ward" or shieldType == "barrier") then
                -- Shield-specific visualization
                local runeImages = getAssetInternal("runes")
                if runeImages and #runeImages > 0 then
                    -- Get a deterministic or random rune
                    local runeIndex
                    if effect.id then
                        runeIndex = (effect.id % #runeImages) + 1
                    else
                        -- Calculate a stable index from the positions
                        local posHash = math.floor(effect.sourceX + effect.sourceY + effect.targetX + effect.targetY)
                        runeIndex = (posHash % #runeImages) + 1
                    end
                    local runeImage = runeImages[runeIndex]
                    
                    -- Draw the rune
                    local runeSize = 0.5 * impactSize * (1 + 0.5 * math.sin(impactProgress * math.pi * 4))
                    local runeAlpha = impactAlpha * 0.8
                    love.graphics.setColor(1, 1, 1, runeAlpha)
                    
                    if runeImage then
                        love.graphics.draw(
                            runeImage,
                            blockX, blockY,
                            math.pi * 2 * impactProgress,
                            runeSize, runeSize,
                            runeImage:getWidth()/2, runeImage:getHeight()/2
                        )
                    end
                end
            end
            
            -- Restore previous blend mode
            love.graphics.setBlendMode(prevMode[1], prevMode[2])
        end
    end
end

-- Initialize function for projectile effects
local function initializeProjectile(effect)
    -- Calculate base trajectory properties
    local dirX = effect.targetX - effect.sourceX
    local dirY = effect.targetY - effect.sourceY
    local distance = math.sqrt(dirX*dirX + dirY*dirY)
    local baseAngle = math.atan2(dirY, dirX)

    -- Check for block info and set block properties
    if effect.options and effect.options.blockPoint then
        print(string.format("[PROJECTILE INIT] Detected block at point %.2f", effect.options.blockPoint))
        effect.isBlocked = true
        effect.blockPoint = effect.options.blockPoint
        effect.blockType = effect.options.shieldType or "ward"
    end

    -- Get turbulence factor or use default
    local turbulence = effect.turbulence or 0.5
    local coreDensity = effect.coreDensity or 0.6
    local trailDensity = effect.trailDensity or 0.4

    -- Core particles (at the leading edge of the projectile)
    local coreCount = math.floor(effect.particleCount * coreDensity)
    local trailCount = effect.particleCount - coreCount

    -- Create core/leading particles using ParticleManager
    for i = 1, coreCount do
        local particle = ParticleManager.createProjectileCoreParticle(effect, baseAngle, turbulence)

        -- Apply motion style variations
        if effect.motion == Constants.MotionStyle.SWIRL then
            particle.swirlRadius = math.random(5, 15)
            particle.swirlSpeed = math.random(3, 8)
        elseif effect.motion == Constants.MotionStyle.PULSE then
            particle.pulseFreq = math.random(3, 7)
            particle.pulseAmplitude = 0.2 + math.random() * 0.3
        end

        table.insert(effect.particles, particle)
    end

    -- Create trail particles using ParticleManager
    for i = 1, trailCount do
        local particle = ParticleManager.createProjectileFullTrailParticle(effect, baseAngle, turbulence, i, trailCount)
        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeProjectile,
    update = updateProjectile,
    draw = drawProjectile
}```

## ./vfx/effects/remote.lua
```lua
-- remote.lua
-- Remote VFX module for handling teleport/warp effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for remote effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for remote effects
local function updateRemote(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.useTargetPosition = (effect.useTargetPosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    effect.followTargetEntity = (effect.followTargetEntity ~= false) -- Default to true
    effect.useSprites = effect.useSprites or false -- Default for sprite usage
    effect.frameTimer = effect.frameTimer or 0 -- Animation timer
    effect.currentFrame = effect.currentFrame or 1 -- Current animation frame
    effect.frameDuration = effect.frameDuration or 0.1 -- Duration between frames
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update target position if we're tracking an entity
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        -- If the target entity has a position, update our target position
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
            
            -- Apply any entity offsets if present
            if effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
                effect.targetX = effect.targetX + effect.targetEntity.currentXOffset
                effect.targetY = effect.targetY + effect.targetEntity.currentYOffset
            end
        end
    end
    
    -- Update particles for the warp/remote effect
    for i, particle in ipairs(effect.particles) do
        -- Skip invalid particles
        if not particle then
            goto next_particle
        end
        
        -- Initialize particle properties if missing
        particle.delay = particle.delay or 0
        particle.active = particle.active or false
        
        -- Activate particles based on delay
        if effect.timer > particle.delay then
            particle.active = true
        end
        
        if particle.active then
            -- Calculate particle progress
            local particleProgress = math.min((effect.timer - particle.delay) / (effect.duration - particle.delay), 1.0)
            
            -- Update particle position based on type
            if particle.type == "source" then
                -- Source particles expand outward
                local dist = particle.maxDist * particleProgress
                particle.x = effect.sourceX + math.cos(particle.angle) * dist
                particle.y = effect.sourceY + math.sin(particle.angle) * dist
                
                -- Fade out as they expand
                particle.alpha = 1.0 - particleProgress
            elseif particle.type == "target" then
                -- Target particles converge inward
                local dist = particle.maxDist * (1.0 - particleProgress)
                particle.x = effect.targetX + math.cos(particle.angle) * dist
                particle.y = effect.targetY + math.sin(particle.angle) * dist
                
                -- Fade in as they converge
                particle.alpha = particleProgress
            end
            
            -- Update particle scale
            local scaleFactor = 1.0 - math.abs(particleProgress - 0.5) * 0.6
            particle.scale = (particle.baseScale or 0.3) * scaleFactor
        end
        
        ::next_particle::
    end
    
    -- Update sprite animation for warp effect
    if effect.useSprites then
        effect.frameTimer = effect.frameTimer + dt
        if effect.frameTimer >= effect.frameDuration then
            effect.frameTimer = 0
            effect.currentFrame = effect.currentFrame + 1
            if effect.currentFrame > 3 then
                effect.currentFrame = 1
            end
        end
    end
end

-- Draw function for remote effects
local function drawRemote(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default source position
    effect.sourceY = effect.sourceY or 0 -- Default source position
    effect.targetX = effect.targetX or 0 -- Default target position
    effect.targetY = effect.targetY or 0 -- Default target position
    effect.progress = effect.progress or 0 -- Default progress
    effect.useSprites = effect.useSprites or false -- Default for sprite usage
    effect.currentFrame = effect.currentFrame or 1 -- Current animation frame
    
    local particleImage = getAssetInternal("sparkle")
    local glowImage = getAssetInternal("fireGlow")
    local impactImage = getAssetInternal("impactRing")
    
    -- Get warp frames if needed
    local warpFrames = nil
    if effect.useSprites then
        warpFrames = getAssetInternal("warpFrames")
    end
    
    -- Draw effects at source position
    if effect.progress < 0.6 then
        -- Fade out as effect progresses
        local sourceAlpha = 1.0 - (effect.progress / 0.6)
        
        -- Draw glow effect at source with additive blending
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw expanding ring for warp-out effect
        local ringSize = 30 + effect.progress * 60
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.5 * sourceAlpha)
        love.graphics.circle("line", effect.sourceX, effect.sourceY, ringSize)
        
        -- Draw bright glow core
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.8 * sourceAlpha)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, 25 * (1.0 - effect.progress/0.6))
        
        -- Draw inner bright center
        love.graphics.setColor(1, 1, 1, 0.9 * sourceAlpha)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, 10 * (1.0 - effect.progress/0.6))
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        -- Draw sprite-based warp effect if enabled
        if effect.useSprites and warpFrames then
            local frame = warpFrames[effect.currentFrame]
            local scale = 1.0 * (1.0 - effect.progress/0.6)
            
            -- Draw the warp sprite
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], sourceAlpha)
            love.graphics.draw(
                frame,
                effect.sourceX, effect.sourceY,
                0,
                scale, scale,
                frame:getWidth()/2, frame:getHeight()/2
            )
        end
    end
    
    -- Draw effects at target position
    if effect.progress > 0.4 then
        -- Fade in at target position
        local targetAlpha = math.min(1.0, (effect.progress - 0.4) / 0.6)
        
        -- Draw glow effect at target with additive blending
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw converging ring for warp-in effect
        local ringSize = 90 - (effect.progress - 0.4) * 60
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.5 * targetAlpha)
        love.graphics.circle("line", effect.targetX, effect.targetY, ringSize)
        
        -- Draw bright glow core
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 0.8 * targetAlpha)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 25 * ((effect.progress - 0.4)/0.6))
        
        -- Draw inner bright center
        love.graphics.setColor(1, 1, 1, 0.9 * targetAlpha)
        love.graphics.circle("fill", effect.targetX, effect.targetY, 10 * ((effect.progress - 0.4)/0.6))
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        -- Draw sprite-based warp effect if enabled
        if effect.useSprites and warpFrames then
            local frame = warpFrames[effect.currentFrame]
            local scale = 1.0 * ((effect.progress - 0.4)/0.6)
            
            -- Draw the warp sprite
            love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], targetAlpha)
            love.graphics.draw(
                frame,
                effect.targetX, effect.targetY,
                0,
                scale, scale,
                frame:getWidth()/2, frame:getHeight()/2
            )
        end
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle with additive blending for brighter effect
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.7)
        
        if particleImage then
            love.graphics.draw(
                particleImage,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                particleImage:getWidth()/2, particleImage:getHeight()/2
            )
        else
            -- Fallback if particle image is missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 30)
        end
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        ::next_draw_particle::
    end
end

-- Initialize function for remote effects
local function initializeRemote(effect)
    -- For remote effects like warp, create particles at the target location
    -- Set flags for position tracking
    effect.useTargetPosition = true  -- This tells the system to use the current target position

    -- Make sure to use the initial position with offsets if available
    local centerX = effect.targetX
    local centerY = effect.targetY

    -- Initialize with offset if the target entity has position offsets
    if effect.targetEntity and effect.targetEntity.currentXOffset and effect.targetEntity.currentYOffset then
        centerX = effect.targetEntity.x + effect.targetEntity.currentXOffset
        centerY = effect.targetEntity.y + effect.targetEntity.currentYOffset

        -- Update effect's target position to include offsets
        effect.targetX = centerX
        effect.targetY = centerY

        print(string.format("[VFX] Initializing warp at (%d, %d) with offsets (%d, %d)",
            centerX, centerY, effect.targetEntity.currentXOffset, effect.targetEntity.currentYOffset))
    end

    local radius = effect.radius or 60

    -- Calculate how many particles to create based on density
    local particlesToCreate = effect.particleCount
    if effect.particleDensity then
        particlesToCreate = math.floor(effect.particleCount * effect.particleDensity)
    end

    for i = 1, particlesToCreate do
        -- Create particles in a circular pattern around the target
        local angle = (i / particlesToCreate) * math.pi * 2
        -- Random distance from center
        local distance = math.random(10, radius)
        -- Random speed for movement
        local speed = math.random(10, 70)

        -- Create particle using ParticleManager
        local particle = ParticleManager.createRemoteParticle(effect, angle, distance, speed)

        table.insert(effect.particles, particle)
    end

    -- Initialize sprite rotation angle if needed
    if effect.rotateSprite then
        effect.spriteAngle = 0
    end
end

-- Return the module
return {
    initialize = initializeRemote,
    update = updateRemote,
    draw = drawRemote
}```

## ./vfx/effects/surge.lua
```lua
-- surge.lua
-- Surge VFX module for handling fountain/burst effects

-- Import dependencies
local Constants = require("core.Constants")
local ParticleManager = require("vfx.ParticleManager")

-- Access to the main VFX module (will be required after vfx.lua is loaded)
local VFX

-- Helper functions needed for surge effects
local function getAssetInternal(assetId)
    -- Lazy-load VFX module to avoid circular dependencies
    if not VFX then
        -- Use a relative path that works with LÖVE's require system
        VFX = require("vfx") -- This will look for vfx.lua in the game's root directory
    end
    
    -- Use the main VFX module's getAsset function
    return VFX.getAsset(assetId)
end

-- Update function for surge effects
local function updateSurge(effect, dt)
    -- Initialize effect default values
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.color = effect.color or {1, 1, 1} -- Default color (white)
    effect.centerGlow = (effect.centerGlow ~= false) -- Default to true
    effect.useSourcePosition = (effect.useSourcePosition ~= false) -- Default to true
    effect.followSourceEntity = (effect.followSourceEntity ~= false) -- Default to true
    
    -- Update source position if we're tracking an entity
    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        -- If the source entity has a position, update our source position
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
            
            -- Apply any entity offsets if present
            if effect.sourceEntity.currentXOffset and effect.sourceEntity.currentYOffset then
                effect.sourceX = effect.sourceX + effect.sourceEntity.currentXOffset
                effect.sourceY = effect.sourceY + effect.sourceEntity.currentYOffset
            end
        end
    end
    
    -- Update center glow animation
    if effect.centerGlow then
        effect.centerParticleTimer = (effect.centerParticleTimer or 0) + dt
    end
    
    -- Rising helix motion around the caster
    for _, particle in ipairs(effect.particles) do
        if not particle then
            goto next_particle
        end

        particle.delay = particle.delay or 0
        particle.active = particle.active or false

        if effect.timer > particle.delay then
            particle.active = true
        end

        if particle.active then
            local age = effect.timer - particle.delay
            local progress = math.min(age / effect.duration, 1.0)

            local angle = (particle.startAngle or 0) + (particle.spinSpeed or 4) * age
            local radius = (particle.baseRadius or 8) + progress * (particle.spiralAmplitude or 20)
            local rise = progress * (effect.height or 160)

            particle.x = effect.sourceX + math.cos(angle) * radius
            particle.y = effect.sourceY - rise + math.sin(angle) * radius * 0.1

            -- Alpha fades in then out
            local alphaPeak = 0.3
            local alphaValue
            if progress < alphaPeak then
                alphaValue = progress / alphaPeak
            else
                alphaValue = 1.0 - ((progress - alphaPeak) / (1.0 - alphaPeak))
            end
            particle.alpha = alphaValue * (particle.baseAlpha or 1.0)

            local sizeCurve = 1.0 + math.sin(progress * math.pi) * 0.5
            particle.scale = (particle.baseScale or 0.3) * sizeCurve
        end

        ::next_particle::
    end
    
    -- Update center glow pulsing if enabled
    if effect.centerGlow then
        local pulseSpeed = 5
        effect.centerGlowPulse = 0.7 + 0.3 * math.sin(effect.centerParticleTimer * pulseSpeed)
    end
end

-- Draw function for surge effects
local function drawSurge(effect)
    -- Initialize effect default values
    effect.color = effect.color or {1, 1, 1} -- Default color
    effect.particles = effect.particles or {} -- Initialize particles array if nil
    effect.sourceX = effect.sourceX or 0 -- Default position
    effect.sourceY = effect.sourceY or 0 -- Default position
    effect.progress = effect.progress or 0 -- Default progress
    effect.centerGlow = (effect.centerGlow ~= false) -- Default to true
    effect.centerGlowPulse = effect.centerGlowPulse or 1.0 -- Default pulse value
    
    local particleImage = getAssetInternal("sparkle")
    local onePxImage = getAssetInternal("pixel")
    local twinkle1Image = getAssetInternal("twinkle1")
    local twinkle2Image = getAssetInternal("twinkle2")
    
    -- Draw expanding ground effect ring at source
    if effect.progress < 0.7 then
        local ringProgress = effect.progress / 0.7
        local ringSize = 30 + ringProgress * 40 -- Grows from 30 to 70 pixels
        local ringAlpha = 0.5 * (1 - ringProgress)
        
        love.graphics.setColor(effect.color[1] * 0.8, effect.color[2] * 0.8, effect.color[3] * 0.8, ringAlpha)
        love.graphics.circle("line", effect.sourceX, effect.sourceY, ringSize)
    end
    
    -- Draw center glow effect with additive blending
    if effect.centerGlow then
        -- Calculate glow size based on progress
        -- Stronger at the start, then fades
        local glowProgress = math.max(0, 1.0 - effect.progress * 1.5)
        local centerGlowSize = 30 * glowProgress
        
        -- Calculate pulsing and intensity
        local glowPulse = effect.centerGlowPulse or 1.0
        local glowIntensity = 1.0 + 0.5 * glowPulse
        local glowAlpha = 0.7 * glowProgress
        
        -- Save current blend mode and set to additive for the brightest elements
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        -- Draw outer glow layers with additive blending
        love.graphics.setColor(effect.color[1] * 0.5, effect.color[2] * 0.5, effect.color[3] * 0.5, glowAlpha * 0.4)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 1.2 * glowPulse)
        
        -- Middle glow layer
        love.graphics.setColor(effect.color[1] * 0.8, effect.color[2] * 0.8, effect.color[3] * 0.8, glowAlpha * 0.6)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.8 * glowPulse)
        
        -- Bright core
        love.graphics.setColor(effect.color[1] * glowIntensity, effect.color[2] * glowIntensity, 
                              effect.color[3] * glowIntensity, glowAlpha * 0.8)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.5 * glowPulse)
        
        -- White inner core
        love.graphics.setColor(1, 1, 1, glowAlpha * 0.9 * glowPulse)
        love.graphics.circle("fill", effect.sourceX, effect.sourceY, centerGlowSize * 0.2 * glowPulse)
        
        -- Restore previous blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
    end
    
    -- Draw particles
    for _, particle in ipairs(effect.particles) do
        -- Skip invalid or inactive particles
        if not particle or not particle.active then
            goto next_draw_particle
        end
        
        -- Ensure required properties exist
        particle.alpha = particle.alpha or 0
        particle.scale = particle.scale or 0.3
        particle.x = particle.x or effect.sourceX
        particle.y = particle.y or effect.sourceY
        
        -- Draw particle with additive blending for extra brightness
        local prevMode = {love.graphics.getBlendMode()}
        love.graphics.setBlendMode("add")
        
        love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], particle.alpha * 0.7)
        
        -- Choose sprite based on assigned type
        local sprite
        if particle.spriteType == "pixel" then
            sprite = onePxImage
        elseif particle.spriteType == "twinkle1" then
            sprite = twinkle1Image
        elseif particle.spriteType == "twinkle2" then
            sprite = twinkle2Image
        else
            sprite = particleImage
        end

        if sprite then
            love.graphics.draw(
                sprite,
                particle.x, particle.y,
                0,
                particle.scale, particle.scale,
                sprite:getWidth()/2, sprite:getHeight()/2
            )
        else
            -- Fallback if image missing
            love.graphics.circle("fill", particle.x, particle.y, particle.scale * 3)
        end
        
        -- Restore blend mode
        love.graphics.setBlendMode(prevMode[1], prevMode[2])
        
        ::next_draw_particle::
    end
end

-- Initialize function for surge effects
local function initializeSurge(effect)
    -- Pre-load center particle
    effect.centerParticleTimer = 0

    -- Create particles with varied properties using ParticleManager
    for i = 1, effect.particleCount do
        local particle = ParticleManager.createSurgeParticle(effect)
        table.insert(effect.particles, particle)
    end
end

-- Return the module
return {
    initialize = initializeSurge,
    update = updateSurge,
    draw = drawSurge
}
```

## ./vfx/effects/zap.lua
```lua
-- zap.lua
-- Simple lightning zap effect drawing tiled sprites between source and target

local VFX

local function getAssetInternal(assetId)
    if not VFX then
        VFX = require("vfx")
    end
    return VFX.getAsset(assetId)
end

local function initializeZap(effect)
    effect.timer = 0
end

local function updateZap(effect, dt)
    -- ensure defaults
    effect.useSourcePosition = (effect.useSourcePosition ~= false)
    effect.useTargetPosition = (effect.useTargetPosition ~= false)
    effect.followSourceEntity = (effect.followSourceEntity ~= false)
    effect.followTargetEntity = (effect.followTargetEntity ~= false)
    effect.color = effect.color or {1,1,1}
    effect.segmentLength = effect.segmentLength or 20

    if effect.useSourcePosition and effect.followSourceEntity and effect.sourceEntity then
        if effect.sourceEntity.x and effect.sourceEntity.y then
            effect.sourceX = effect.sourceEntity.x
            effect.sourceY = effect.sourceEntity.y
        end
    end
    if effect.useTargetPosition and effect.followTargetEntity and effect.targetEntity then
        if effect.targetEntity.x and effect.targetEntity.y then
            effect.targetX = effect.targetEntity.x
            effect.targetY = effect.targetEntity.y
        end
    end

    local dx = (effect.targetX or 0) - (effect.sourceX or 0)
    local dy = (effect.targetY or 0) - (effect.sourceY or 0)
    effect.angle = math.atan2(dy, dx)
    effect.length = math.sqrt(dx*dx + dy*dy)
    effect.headX = (effect.sourceX or 0) + dx * (effect.progress or 0)
    effect.headY = (effect.sourceY or 0) + dy * (effect.progress or 0)
end

local function drawZap(effect)
    local frames = getAssetInternal("zapFrames")
    if not frames or #frames < 3 then return end
    local seg1, seg2, terminus = frames[1], frames[2], frames[3]

    love.graphics.setColor(effect.color[1], effect.color[2], effect.color[3], 1)

    local segLen = effect.segmentLength or seg1:getWidth()
    local drawn = 0
    local maxLen = math.min(effect.length, effect.length * (effect.progress or 0))

    while drawn + segLen < maxLen do
        local img = (math.floor(drawn/segLen) % 2 == 0) and seg1 or seg2
        local x = effect.sourceX + math.cos(effect.angle) * drawn
        local y = effect.sourceY + math.sin(effect.angle) * drawn
        love.graphics.draw(img, x, y, effect.angle, 1, 1, 0, img:getHeight()/2)
        drawn = drawn + segLen
    end

    -- draw terminus at head
    love.graphics.draw(terminus, effect.headX, effect.headY, effect.angle, 1, 1,
        terminus:getWidth()/2, terminus:getHeight()/2)
end

return {
    initialize = initializeZap,
    update = updateZap,
    draw = drawZap
}
```

## ./vfx/init.lua
```lua
-- Base VFX module that acts as the entrypoint
local VFX = require("vfx.lua") -- Relative path to vfx.lua in the game's root directory

-- Expose the module with its public interface
return VFX```

## ./vfx/initializeParticles.lua
```lua
-- initializeParticles.lua
-- Centralized function for initializing particles for each effect type

-- Import dependencies
local Constants = require("core.Constants")

-- Initialize particles function
local function initializeParticles(effect)
    -- Import the appropriate effect module
    local effectModule

    -- Extract the base effect type for loading the proper module
    local effectType = effect.type

    -- Map template names directly to module paths
    local typeToModuleMap = {
        -- Base templates
        ["proj_base"] = "projectile",
        ["bolt_base"] = "projectile",
        ["orb_base"] = "projectile",
        ["zap_base"] = "zap",
        ["impact_base"] = "impact",
        ["beam_base"] = "beam",
        ["blast_base"] = "cone",
        ["zone_base"] = "aura",
        ["util_base"] = "aura",
        ["surge_base"] = "surge",
        ["wave_base"] = "projectile",
        ["conjure_base"] = "conjure",
        ["remote_base"] = "remote",
        ["warp_base"] = "remote",
        ["shield_hit_base"] = "impact",

        -- Specific effect templates
        ["meteor"] = "meteor",
        ["impact"] = "impact",
        ["force_blast"] = "impact",
        ["free_mana"] = "aura",
        ["shield"] = "aura",
        ["emberlift"] = "surge",
        ["range_change"] = "surge",

        -- Critical backward compatibility (to be removed in future)
        [Constants.AttackType.PROJECTILE] = "projectile"
    }

    local moduleName = typeToModuleMap[effectType]

    -- If type isn't in our map, attempt a direct match with module name
    if not moduleName then
        -- Try using type as direct module name
        if effectType and (effectType == "projectile" or
                         effectType == "impact" or
                         effectType == "beam" or
                         effectType == "cone" or
                         effectType == "aura" or
                         effectType == "remote" or
                         effectType == "meteor" or
                         effectType == "surge" or
                         effectType == "conjure") then
            moduleName = effectType
            print(string.format("[VFX] Using effect.type '%s' directly as module name", effectType))
        else
            -- Last fallback to avoid crashes - default to impact effect
            print(string.format("[VFX] Warning: Unknown effect type: '%s' - falling back to impact", tostring(effectType)))
            moduleName = "impact"
        end
    end

    -- Load the module based on name
    effectModule = require("vfx.effects." .. moduleName)

    -- Call the module's initialize function if it exists
    if effectModule and effectModule.initialize then
        effectModule.initialize(effect)
    else
        print("[VFX] Warning: No initialize function found for effect type: " .. tostring(effectType))
    end
end

-- Return the function
return initializeParticles```

## ./wizard.lua
```lua
-- Wizard class

local Wizard = {}
Wizard.__index = Wizard

-- Load required modules
local Constants = require("core.Constants")
local SpellsModule = require("spells")
local Spells = SpellsModule.spells
local ShieldSystem = require("systems.ShieldSystem")
local WizardVisuals = require("systems.WizardVisuals")
local TokenManager = require("systems.TokenManager")
local UnlockSystem = require("systems.UnlockSystem")

-- We'll use game.compiledSpells instead of a local compiled spells table

-- Get a compiled spell by ID, compile on demand if not already compiled
local function getCompiledSpell(spellId, wizard)
    -- Make sure we have a game reference
    if not wizard or not wizard.gameState then
        print("Error: No wizard or gameState to get compiled spell")
        return nil
    end
    
    local gameState = wizard.gameState
    
    -- Try to get from game's compiled spells
    if gameState.compiledSpells and gameState.compiledSpells[spellId] then
        return gameState.compiledSpells[spellId]
    end
    
    -- If not found, try to compile on demand
    if Spells[spellId] and gameState.spellCompiler and gameState.keywords then
        -- Make sure compiledSpells exists
        if not gameState.compiledSpells then
            gameState.compiledSpells = {}
        end
        
        -- Compile the spell and store it
        gameState.compiledSpells[spellId] = gameState.spellCompiler.compileSpell(
            Spells[spellId], 
            gameState.keywords
        )
        print("Compiled spell on demand: " .. spellId)
        return gameState.compiledSpells[spellId]
    else
        print("Error: Could not compile spell with ID: " .. spellId)
        return nil
    end
end

function Wizard.new(name, x, y, color, spellbook)
    local self = setmetatable({}, Wizard)
    
    self.name = name
    self.x = x
    self.y = y
    self.color = color  -- RGB table
    
    -- Wizard state
    self.health = 100
    self.elevation = Constants.ElevationState.GROUNDED  -- GROUNDED or AERIAL
    self.elevationTimer = 0      -- Timer for temporary elevation changes
    
    -- Position animation state
    self.positionAnimation = {
        active = false,
        startX = 0,
        startY = 0, 
        targetX = 0,
        targetY = 0,
        progress = 0,
        duration = 0.3 -- 300ms animation by default
    }
    
    -- Status effects
    self.statusEffects = {
        [Constants.StatusType.BURN] = {
            active = false,
            duration = 0,
            tickDamage = 0,
            tickInterval = 1.0,
            elapsed = 0,         -- Time since last tick
            totalTime = 0        -- Total time effect has been active
        },
        [Constants.StatusType.STUN] = {
            active = false,
            duration = 0,
            elapsed = 0,
            totalTime = 0
        }
    }
    
    -- Visual effects
    self.blockVFX = {
        active = false,
        timer = 0,
        x = 0,
        y = 0
    }
    
    -- Hit flash effect
    self.hitFlashTimer = 0

    -- Cast frame animation properties
    self.castFrameSprite = nil
    self.castFrameTimer = 0
    self.castFrameDuration = 0.25 -- Show cast frame for 0.25 seconds

    -- Idle animation properties
    self.idleAnimationFrames = {}
    self.currentIdleFrame = 1
    self.idleFrameTimer = 0
    self.idleFrameDuration = 0.15 -- seconds per frame
    -- Positional animation sets (per range/elevation combo)
    self.positionalAnimations = {}
    self.lastPositionalKey = nil

    -- Spell cast notification (temporary until proper VFX)
    self.spellCastNotification = nil
    
    -- Spell keying system
    self.activeKeys = {
        [1] = false,
        [2] = false,
        [3] = false
    }
    self.currentKeyedSpell = nil
    
    -- Spell loadout provided by character data
    self.spellbook = spellbook or {}
    
    -- Create 3 spell slots for this wizard
    self.spellSlots = {}
    for i = 1, 3 do
        self.spellSlots[i] = {
            active = false,
            progress = 0,
            castTime = 0,
            spell = nil,
            spellType = nil,
            tokens = {},
            isShield = false,
            defenseType = nil,
            blocksAttackTypes = nil,
            reflect = false,
            frozen = false,
            freezeTimer = 0,
            castTimeModifier = 0, -- Additional time from freeze effects
            willBecomeShield = false,
            wasAlreadyCast = false -- Track if the spell has already been cast
        }
    end
    
    -- Load sprite with fallback
    local spritePath = "assets/sprites/" .. string.lower(name) .. ".png"
    local success, result = pcall(function()
        return love.graphics.newImage(spritePath)
    end)

    if success then
        self.sprite = result
        print("Loaded wizard sprite: " .. spritePath)
    else
        -- Fallback to default wizard sprite
        print("Warning: Could not load sprite " .. spritePath .. ". Using default wizard.png instead.")
        self.sprite = love.graphics.newImage("assets/sprites/wizard.png")
    end

    -- Load cast frame sprite with fallback
    local castFramePath = "assets/sprites/" .. string.lower(name) .. "-cast.png"
    local castSuccess, castResult = pcall(function()
        return love.graphics.newImage(castFramePath)
    end)

    if castSuccess then
        self.castFrameSprite = castResult
        print("Loaded wizard cast frame: " .. castFramePath)
    else
        -- No fallback for cast frame, just leave it nil
        print("Warning: Could not load cast frame " .. castFramePath .. ". Cast animation will be disabled.")
    end

    -- Load default idle animation frames (used as fallback for positional sets)
    if name == "Ashgar" then
        local AssetCache = require("core.AssetCache")
        for i = 1, 7 do
            local framePath = "assets/sprites/" .. string.lower(name) .. "-idle-" .. i .. ".png"
            local frameImg = AssetCache.getImage(framePath)
            if frameImg then
                table.insert(self.idleAnimationFrames, frameImg)
            else
                print("Warning: Could not load Ashgar idle frame: " .. framePath)
                table.insert(self.idleAnimationFrames, self.sprite)
            end
        end
        if #self.idleAnimationFrames == 0 then
            print("Warning: Ashgar has no idle animation frames loaded, using static sprite.")
            table.insert(self.idleAnimationFrames, self.sprite)
        end
    else
        table.insert(self.idleAnimationFrames, self.sprite)
    end

    -- Load positional animation sets (idle + cast for range/elevation combos)
    self:loadPositionalAnimations()

    self.scale = 1.0
    
    -- Keep references
    self.gameState = _G.game  -- Reference to global game state
    self.manaPool = self.gameState.manaPool
    
    -- Track UI offsets
    self.currentXOffset = 0
    self.currentYOffset = 0
    
    -- Flags for trap triggering and spell expiry
    self.justCastSpellThisFrame = false
    self.justConjuredMana = false
    
    return self
end

function Wizard:update(dt)
    -- Reset flags at the beginning of each frame
    self.justCastSpellThisFrame = false
    self.justConjuredMana = false

    -- Update hit flash timer
    if self.hitFlashTimer > 0 then
        self.hitFlashTimer = math.max(0, self.hitFlashTimer - dt)
    end

    -- Update cast frame timer
    if self.castFrameTimer > 0 then
        self.castFrameTimer = math.max(0, self.castFrameTimer - dt)
    end

    -- Update idle animation timer and frame based on positional state
    local posKey = self:getPositionalKey()

    if posKey ~= self.lastPositionalKey then
        self.currentIdleFrame = 1
        self.idleFrameTimer = 0
        self.lastPositionalKey = posKey
    end

    local idleFrames = self:getIdleFramesForKey(posKey)

    if self.castFrameTimer <= 0 then
        self.idleFrameTimer = self.idleFrameTimer + dt
        if self.idleFrameTimer >= self.idleFrameDuration then
            self.idleFrameTimer = self.idleFrameTimer - self.idleFrameDuration
            self.currentIdleFrame = self.currentIdleFrame + 1
            if self.currentIdleFrame > #idleFrames then
                self.currentIdleFrame = 1
            end
        end
    else
        self.currentIdleFrame = 1
        self.idleFrameTimer = 0
    end
    
    -- Update position animation
    if self.positionAnimation.active then
        self.positionAnimation.progress = self.positionAnimation.progress + dt / self.positionAnimation.duration
        
        -- Check if animation is complete
        if self.positionAnimation.progress >= 1.0 then
            self.positionAnimation.active = false
            self.positionAnimation.progress = 1.0
            self.currentXOffset = self.positionAnimation.targetX
            self.currentYOffset = self.positionAnimation.targetY
        end
    end
    
    -- Update stun status effect
    if self.statusEffects[Constants.StatusType.STUN] and self.statusEffects[Constants.StatusType.STUN].active then
        local stun = self.statusEffects[Constants.StatusType.STUN]
        stun.totalTime = stun.totalTime + dt
        if stun.duration > 0 and stun.totalTime >= stun.duration then
            stun.active = false
            stun.totalTime = stun.duration
            print(self.name .. " is no longer stunned")
        end
    end
    
    -- Update elevation effects (NEW LOGIC)
    if self.elevationEffects then
        for elevationType, effectData in pairs(self.elevationEffects) do
            effectData.duration = effectData.duration - dt
            
            if effectData.duration <= 0 then
                -- Execute the expiration action (e.g., set elevation back to GROUNDED)
                if effectData.expireAction then
                    effectData.expireAction()
                end
                
                -- Remove the effect from the table
                self.elevationEffects[elevationType] = nil
                
                -- Create landing VFX if we just returned to GROUNDED
                if self.elevation == Constants.ElevationState.GROUNDED then
                    if self.gameState and self.gameState.vfx then
                        local Constants = require("core.Constants")
                        self.gameState.vfx.createEffect(Constants.VFXType.IMPACT, self.x, self.y + 30, nil, nil, {
                            duration = 0.5,
                            color = {0.7, 0.7, 0.7, 0.8},
                            particleCount = 8,
                            radius = 20
                        })
                    end
                end
            end
        end
    end
    
    -- Update shield visuals using ShieldSystem
    ShieldSystem.updateShieldVisuals(self, dt)
    
    -- Update status effects generically
    if self.statusEffects then
        for effectType, effectData in pairs(self.statusEffects) do
            if effectData.active then
                -- Increment total time the effect has been active
                effectData.totalTime = effectData.totalTime + dt
                
                -- Check for expiration
                if effectData.duration > 0 then -- Only expire effects with explicit duration
                    if effectData.totalTime >= effectData.duration then
                        -- Reset the effect
                        effectData.active = false
                        effectData.elapsed = 0
                        effectData.totalTime = 0
                        print(string.format("%s's %s effect expired", self.name, effectType))
                    end
                end
                
                -- If this is a burn effect, handle damage ticks
                if effectType == Constants.StatusType.BURN and effectData.active then
                    effectData.elapsed = effectData.elapsed + dt
                    if effectData.elapsed >= effectData.tickInterval then
                        -- Apply burn damage
                        self.health = math.max(0, self.health - effectData.tickDamage)
                        
                        -- Set hit flash timer for DoT visual feedback
                        self.hitFlashTimer = 0.125 -- 125ms flash duration
                        
                        print(string.format("%s took %d burn damage (health: %d)", 
                            self.name, effectData.tickDamage, self.health))
                        
                        -- Create burn damage effect
                        if self.gameState and self.gameState.vfx then
                            self.gameState.vfx.createEffect(Constants.VFXType.IMPACT, self.x, self.y, nil, nil, {
                                duration = 0.3,
                                color = {1.0, 0.2, 0.0, 0.6},
                                particleCount = 10,
                                radius = 25
                            })
                        end
                        
                        -- Reset tick interval timer but keep total duration timer
                        effectData.elapsed = 0
                        
                        -- Check for defeat
                        if self.health <= 0 then
                            print(self.name .. " was defeated by burn damage!")
                            if self.gameState then
                                self.gameState.gameOver = true
                                self.gameState.winner = self.name == "Ashgar" and "Selene" or "Ashgar"
                                
                                -- Create defeat effect
                                if self.gameState.vfx then
                                    self.gameState.vfx.createEffect(Constants.VFXType.IMPACT, self.x, self.y, nil, nil, {
                                        duration = 1.0,
                                        color = {1.0, 0.0, 0.0, 0.8},
                                        particleCount = 30,
                                        radius = 80
                                    })
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Update block effect
    if self.blockVFX.active then
        self.blockVFX.timer = self.blockVFX.timer - dt
        if self.blockVFX.timer <= 0 then
            self.blockVFX.active = false
        end
    end
    
    -- Update cast notification
    if self.spellCastNotification then
        self.spellCastNotification.timer = self.spellCastNotification.timer - dt
        if self.spellCastNotification.timer <= 0 then
            self.spellCastNotification = nil
        end
    end
    
    -- Update spell slots
    for i, slot in ipairs(self.spellSlots) do
        if slot.active then
            if slot.isShield then
                -- Shields remain active and don't progress further
                -- But we still need to update token orbits, which happens below
            else
                -- For frozen spells, don't increment progress but accumulate castTimeModifier
                if slot.frozen then
                    -- Track the total freeze time as castTimeModifier
                    slot.castTimeModifier = (slot.castTimeModifier or 0) + dt
                    
                    -- Decrease freeze timer
                    slot.freezeTimer = slot.freezeTimer - dt
                    if slot.freezeTimer <= 0 then
                        slot.frozen = false
                        print(string.format("%s's spell in slot %d is no longer frozen after %.2f seconds (%.4f castTimeModifier)", 
                            self.name, i, slot.castTimeModifier, slot.castTimeModifier))
                    end
                else
                    -- Normal progress update for unfrozen spells
                    slot.progress = slot.progress + dt
                    
                    -- Shield state is now managed directly in the castSpell function
                    -- and tokens remain as CHANNELED until the shield is activated
                    
                    -- ONLY check for spell completion when NOT frozen
                    if slot.progress >= slot.castTime and not slot.wasAlreadyCast then
                        -- Mark this slot as already cast to prevent repeated casting
                        slot.wasAlreadyCast = true
                        
                        -- Cast the spell
                        self:castSpell(i)
                        
                        -- Debug message to confirm we're setting the flag
                        print(string.format("[DEBUG] Marked slot %d as already cast to prevent repetition", i))
                        
                        -- For non-shield spells, we return tokens and reset the slot
                        -- For shield spells, castSpell will handle setting up the shield 
                        -- UNLESS the spell is a sustained spell like a trap
                        
                        -- Check for both shield and sustained spells (traps, etc.)
                        if not slot.isShield and not slot.sustainedId then
                            -- Start return animation for tokens
                            if #slot.tokens > 0 then
                                for _, tokenData in ipairs(slot.tokens) do
                                    -- Request return animation directly on the token
                                    if tokenData.token and tokenData.token.requestReturnAnimation then
                                        tokenData.token:requestReturnAnimation()
                                    else
                                        -- Fallback to legacy method if token doesn't have the method
                                        self.manaPool:returnToken(tokenData.index)
                                    end
                                end
                                
                                -- Clear token list (tokens still exist in the mana pool)
                                slot.tokens = {}
                            end
                            
                            -- Reset slot using unified method only if it's not a sustained spell
                            self:resetSpellSlot(i)
                        end
                    end
                end
            end
        end
    end

    -- Update visual particles for spell slot arcs
    WizardVisuals.updateArcParticles(self, dt)
end

function Wizard:draw()
    -- Use WizardVisuals module for drawing
    WizardVisuals.drawWizard(self)
end

-- Helper function to draw an ellipse (delegated to WizardVisuals)
function Wizard:drawEllipse(x, y, radiusX, radiusY, mode)
    return WizardVisuals.drawEllipse(x, y, radiusX, radiusY, mode)
end

-- Helper function to draw an elliptical arc (delegated to WizardVisuals)
function Wizard:drawEllipticalArc(x, y, radiusX, radiusY, startAngle, endAngle, segments)
    return WizardVisuals.drawEllipticalArc(x, y, radiusX, radiusY, startAngle, endAngle, segments)
end

-- Draw status effects with durations using horizontal bars (delegated to WizardVisuals)
function Wizard:drawStatusEffects()
    return WizardVisuals.drawStatusEffects(self)
end

function Wizard:drawSpellSlots()
    -- Delegate to WizardVisuals module
    return WizardVisuals.drawSpellSlots(self)
end

-- Handle key press and update currently keyed spell
function Wizard:keySpell(keyIndex, isPressed)
    -- Check if wizard is stunned
    local stun = self.statusEffects[Constants.StatusType.STUN]
    if stun and stun.active and isPressed then
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        print(self.name .. " tried to key a spell but is stunned for " .. string.format("%.1f", remaining) .. " more seconds")
        return false
    end
    
    -- Update key state
    self.activeKeys[keyIndex] = isPressed
    
    -- Determine current key combination
    local keyCombo = ""
    for i = 1, 3 do
        if self.activeKeys[i] then
            keyCombo = keyCombo .. i
        end
    end
    
    -- Update currently keyed spell based on combination
    if keyCombo == "" then
        self.currentKeyedSpell = nil
    else
        self.currentKeyedSpell = self.spellbook[keyCombo]
        
        -- Log the currently keyed spell
        if self.currentKeyedSpell then
            print(self.name .. " keyed " .. self.currentKeyedSpell.name .. " (" .. keyCombo .. ")")
            
            -- Debug: verify spell definition is complete
            if not self.currentKeyedSpell.cost then
                print("WARNING: Spell '" .. self.currentKeyedSpell.name .. "' has no cost defined!")
            end
        else
            print(self.name .. " has no spell for key combination: " .. keyCombo)
        end
    end
    
    return true
end

-- Cast the currently keyed spell
function Wizard:castKeyedSpell()
    -- Check if wizard is stunned
    local stun = self.statusEffects[Constants.StatusType.STUN]
    if stun and stun.active then
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        print(self.name .. " tried to cast a spell but is stunned for " .. string.format("%.1f", remaining) .. " more seconds")
        return false
    end
    
    -- Check if a spell is keyed
    if not self.currentKeyedSpell then
        print(self.name .. " tried to cast, but no spell is keyed")
        return false
    end
    
    -- Queue the spell
    return self:queueSpell(self.currentKeyedSpell)
end

-- Format mana cost for display
function Wizard:formatCost(cost)
    if not cost then return "nil" end
    
    -- If cost is not a table, return as string
    if type(cost) ~= "table" then
        return tostring(cost)
    end
    
    -- Format cost components
    local costStrings = {}
    for _, component in ipairs(cost) do
        if type(component) == "table" and component.type then
            table.insert(costStrings, component.amount .. " " .. component.type)
        else
            table.insert(costStrings, tostring(component))
        end
    end
    
    return table.concat(costStrings, ", ")
end

function Wizard:queueSpell(spell)
    -- Check if wizard is stunned
    local stun = self.statusEffects[Constants.StatusType.STUN]
    if stun and stun.active then
        local remaining = stun.duration > 0 and (stun.duration - stun.totalTime) or 0
        print(self.name .. " tried to queue a spell but is stunned for " .. string.format("%.1f", remaining) .. " more seconds")
        return false
    end
    
    -- Validate the spell
    if not spell then
        print("No spell provided to queue")
        return false
    end
    
    -- Get the compiled spell if available
    local spellToUse = spell
    if spell.id and not spell.executeAll then
        -- This is an original spell definition, not a compiled one - get the compiled version
        local compiledSpell = getCompiledSpell(spell.id, self)
        if compiledSpell then
            spellToUse = compiledSpell
            print("Using compiled spell for queue: " .. spellToUse.id)
        else
            print("Warning: Using original spell definition - could not get compiled version of " .. spell.id)
        end
    end
    
    -- Find the innermost available spell slot
    for i = 1, #self.spellSlots do
        if not self.spellSlots[i].active then
            -- Determine cost source (static table or dynamic function)
            local costSource = spellToUse.getCost or spellToUse.cost

            -- Check if we can pay the mana cost from the pool
            local tokenReservations = self:canPayManaCost(costSource)
            
            if tokenReservations then
                local tokens = {}
                
                -- Check if we need tokens (empty cost doesn't need tokens)
                if #tokenReservations == 0 then
                    -- Free spell - no tokens needed
                    print("[TOKEN MANAGER] Free spell (no mana cost)")
                else
                    -- Resolve actual cost table now if using dynamic cost
                    local actualCost = type(costSource) == "function" and costSource(self, nil) or costSource

                    -- Use TokenManager to acquire and position tokens for the spell
                    local success, acquiredTokens = TokenManager.acquireTokensForSpell(self, i, actualCost)
                    
                    -- If TokenManager succeeded, use those tokens
                    if success and acquiredTokens then
                        tokens = acquiredTokens
                    else
                        -- TokenManager failed, fallback to legacy method
                        print("[TokenManager] Failed to acquire tokens, using legacy method")
                        
                        -- Move each token from mana pool to spell slot with animation
                        for _, reservation in ipairs(tokenReservations) do
                            local token = self.manaPool.tokens[reservation.index]
                            
                            -- Mark the token as being channeled using state machine if available
                            if token.setState then
                                token:setState(Constants.TokenStatus.CHANNELED)
                            else
                                token.state = Constants.TokenState.CHANNELED
                            end
                            
                            -- Store original position for animation
                            token.startX = token.x
                            token.startY = token.y
                            
                            -- Calculate target position in the spell slot based on 3D positioning
                            -- These must match values in drawSpellSlots
                            local slotYOffsets = {30, 0, -30}  -- legs, midsection, head
                            local horizontalRadii = {80, 70, 60}
                            local verticalRadii = {20, 25, 30}
                            
                            local targetX = self.x
                            local targetY = self.y + slotYOffsets[i]  -- Vertical offset based on slot
                            
                            -- Animation data
                            token.targetX = targetX
                            token.targetY = targetY
                            token.animTime = 0
                            token.animDuration = 0.5 -- Half second animation
                            token.slotIndex = i
                            token.tokenIndex = #tokens + 1 -- Position in the slot
                            token.spellSlot = i
                            token.wizardOwner = self
                            
                            -- 3D perspective data
                            token.radiusX = horizontalRadii[i]
                            token.radiusY = verticalRadii[i]
                            
                            table.insert(tokens, {token = token, index = reservation.index})
                        end
                    end
                end
                
                -- Store the tokens and cost in the spell slot
                self.spellSlots[i].tokens = tokens
                self.spellSlots[i].cost = type(costSource) == "function" and costSource(self, nil) or costSource
                
                -- Successfully paid the cost, queue the spell
                self.spellSlots[i].active = true
                self.spellSlots[i].progress = 0
                self.spellSlots[i].spellType = spellToUse.name
                
                -- Calculate base cast time (handling dynamic function)
                local baseCastTime
                if spellToUse.getCastTime and type(spellToUse.getCastTime) == "function" then
                    baseCastTime = spellToUse.getCastTime(self)
                    print(self.name .. " is using dynamic base cast time: " .. baseCastTime .. "s")
                else
                    baseCastTime = spellToUse.castTime
                end

                -- Check for and apply Slow status effect
                local finalCastTime = baseCastTime
                if self.statusEffects and self.statusEffects[Constants.StatusType.SLOW] and self.statusEffects[Constants.StatusType.SLOW].active then
                    local slowEffect = self.statusEffects[Constants.StatusType.SLOW]
                    local targetSlot = slowEffect.targetSlot -- Slot the slow effect targets (nil for any)
                    local queueingSlot = i -- Slot we are currently queueing into

                    -- Check if the slow effect applies to this specific slot or any slot
                    if targetSlot == nil or targetSlot == 0 or targetSlot == queueingSlot then
                        local slowMagnitude = slowEffect.magnitude or 0
                        finalCastTime = baseCastTime + slowMagnitude
                        print(string.format("[STATUS] Slow effect applied! Base cast: %.1fs, Slowed cast: %.1fs (Slot %s)",
                            baseCastTime, finalCastTime, tostring(targetSlot or "Any")))
                        
                        -- Consume the slow effect
                        slowEffect.active = false
                        slowEffect.magnitude = nil
                        slowEffect.targetSlot = nil 
                        -- Keep duration timer running so it eventually clears from statusEffects table if update loop doesn't
                    end
                end
                
                -- Store the final cast time (potentially modified by slow)
                self.spellSlots[i].castTime = finalCastTime
                
                self.spellSlots[i].spell = spellToUse
                
                -- Check if this is a shield spell and mark it accordingly
                if spellToUse.isShield or (spellToUse.keywords and spellToUse.keywords.block) then
                    print("SHIELD SPELL DETECTED during queue: " .. spellToUse.name)
                    -- Flag that this will become a shield when cast
                    self.spellSlots[i].willBecomeShield = true
                    
                    -- Prepare tokens for shield status using TokenManager
                    TokenManager.prepareTokensForShield(tokens)
                    
                    -- DO NOT mark tokens as SHIELDING yet - let them orbit normally during casting
                    -- Only mark them as SHIELDING after the spell is fully cast
                    
                    -- Mark this in the compiled spell if not already marked
                    if not spellToUse.isShield then
                        spellToUse.isShield = true
                    end
                end
                
                -- Set attackType if present in the new schema
                if spellToUse.attackType then
                    self.spellSlots[i].attackType = spellToUse.attackType
                end
                
                print(self.name .. " queued " .. spellToUse.name .. " in slot " .. i .. " (cast time: " .. spellToUse.castTime .. "s)")
                return true
            else
                -- Couldn't pay the cost
                print(self.name .. " tried to queue " .. spellToUse.name .. " but couldn't pay the mana cost")
                return false
            end
        end
    end
    
    -- No available slots
    print(self.name .. " tried to queue " .. spellToUse.name .. " but all slots are full")
    return false
end

-- This is a stub that delegates to the ShieldSystem module
local function createShield(wizard, spellSlot, shieldParams)
    return ShieldSystem.createShield(wizard, spellSlot, shieldParams)
end

-- Add createShield method to Wizard for compatibility
function Wizard:createShield(spellSlot, shieldParams)
    return ShieldSystem.createShield(self, spellSlot, shieldParams)
end

-- Free all active spells and return their mana to the pool
function Wizard:freeAllSpells()
    print(self.name .. " is freeing all active spells")
    
    -- Iterate through all spell slots
    for i, slot in ipairs(self.spellSlots) do
        if slot.active then
            -- Return tokens to the mana pool using TokenManager
            if #slot.tokens > 0 then
                -- Use TokenManager to return all tokens to pool
                TokenManager.returnTokensToPool(slot.tokens)
                
                -- Clear token list (tokens still exist in the mana pool)
                slot.tokens = {}
            end
            
            -- Reset all slot properties using unified method
            self:resetSpellSlot(i)
            
            print("Freed spell in slot " .. i)
        end
    end
    
    -- Create visual effect for all spells being canceled
    if self.gameState and self.gameState.vfx then
        self.gameState.vfx.createEffect(Constants.VFXType.FREE_MANA, self.x, self.y, nil, nil)
    end
    
    -- Reset active key inputs
    for i = 1, 3 do
        self.activeKeys[i] = false
    end
    
    -- Clear keyed spell
    self.currentKeyedSpell = nil
    
    return true
end

-- Helper function to check if mana cost can be paid without actually taking the tokens
-- This is a wrapper around TokenManager functionality for backward compatibility
-- Helper function to check if mana cost can be paid without actually taking the tokens
-- Accepts either a cost table or a getCost function
function Wizard:canPayManaCost(costOrGetCostFn, target)
    local cost = costOrGetCostFn

    if type(costOrGetCostFn) == "function" then
        cost = costOrGetCostFn(self, target)
    end

    local tokenReservations = {}
    local reservedIndices = {} -- Track which token indices are already reserved
    
    -- Handle cost being nil or not a table
    if not cost then
        return {}
    end
    
    -- Check if cost is a valid table we can iterate through
    if type(cost) ~= "table" then
        print("Cost is not a table, it's a " .. type(cost))
        return nil
    end
    
    -- Early exit if cost is empty
    if #cost == 0 then 
        return {} 
    end
    
    -- Convert legacy cost format to standardized manaCost object
    local standardizedCost = {}
    
    -- Process each cost component
    for i, component in ipairs(cost) do
        if type(component) == "table" and component.type and component.amount then
            -- New schema: {type="fire", amount=2}
            local tokenType = component.type
            standardizedCost[tokenType] = (standardizedCost[tokenType] or 0) + component.amount
        elseif type(component) == "string" then
            -- Old schema: "fire", "water", "any", etc.
            standardizedCost[component] = (standardizedCost[component] or 0) + 1
        elseif type(component) == "number" then
            -- Old schema numeric: 1, 2, 3 means ANY token of that count
            -- Use "any" for consistency with string "any"
            standardizedCost[Constants.TokenType.ANY] = (standardizedCost[Constants.TokenType.ANY] or 0) + component
        else
            -- Unknown cost component format
            print("Unknown cost component format: " .. type(component))
            return nil
        end
    end
    
    -- Using our local function to maintain backward compatibility
    local function reserveToken(tokenType, amount)
        -- Find matching tokens in the mana pool
        
        local count = 0
        
        -- Special case for "any" token type
        if tokenType == Constants.TokenType.ANY or tokenType == "ANY" then
            -- Go through all tokens in the mana pool
            for i, token in ipairs(self.manaPool.tokens) do
                -- Skip already reserved tokens
                if not reservedIndices[i] and token.state == Constants.TokenState.FREE then
                    -- Any free token will work
                    count = count + 1
                    
                    -- Add to reservations
                    table.insert(tokenReservations, {index = i, token = token})
                    reservedIndices[i] = true
                    
                    -- Check if we've found enough
                    if count >= amount then
                        break
                    end
                end
            end
        else
            -- Normal token type or nil (for random)
            -- Go through all tokens in the mana pool
            for i, token in ipairs(self.manaPool.tokens) do
                -- Skip already reserved tokens
                if not reservedIndices[i] then
                    -- Match either by specific type or any type if no type specified
                    if (tokenType == nil and token.state == Constants.TokenState.FREE) or (token.type == tokenType and token.state == Constants.TokenState.FREE) then
                        -- This token matches our requirements
                        count = count + 1
                        
                        -- Add to reservations
                        table.insert(tokenReservations, {index = i, token = token})
                        reservedIndices[i] = true
                        
                        -- Check if we've found enough
                        if count >= amount then
                            break
                        end
                    end
                end
            end
        end
        
        -- Check if we found enough tokens
        return count >= amount
    end
    
    -- Check each token type in the standardized cost
    for tokenType, amount in pairs(standardizedCost) do
        if tokenType == Constants.TokenType.RANDOM or tokenType == Constants.TokenType.ANY or tokenType == "ANY" then
            -- Random/any token type (any token will do)
            local success = reserveToken(tokenType, amount)
            if not success then
                print("Cannot find " .. amount .. " tokens of any type")
                return nil
            end
        else
            -- Specific token type
            local success = reserveToken(tokenType, amount)
            if not success then
                print("Cannot find enough " .. tokenType .. " tokens (need " .. amount .. ")")
                return nil
            end
        end
    end
    
    -- If we get here, all components were successfully reserved
    return tokenReservations
end

function Wizard:castSpell(spellSlot)
    local slot = self.spellSlots[spellSlot]
    if not slot or not slot.active or not slot.spell then return end
    
    -- Set the flag to indicate a spell was cast this frame (for trap triggers)
    self.justCastSpellThisFrame = true

    print(self.name .. " cast " .. slot.spellType .. " from slot " .. spellSlot)

    -- Activate cast frame animation if sprite is available
    if self.castFrameSprite then
        self.castFrameTimer = self.castFrameDuration
    end
    
    -- Create a temporary visual notification for spell casting
    self.spellCastNotification = {
        text = self.name .. " cast " .. slot.spellType,
        timer = 2.0,  -- Show for 2 seconds
        x = self.x,
        y = self.y + 70, -- Moved below the wizard instead of above
        color = {self.color[1]/255, self.color[2]/255, self.color[3]/255, 1.0}
    }
    
    -- Get target (the other wizard)
    local target = nil
    for _, wizard in ipairs(self.gameState.wizards) do
        if wizard ~= self then
            target = wizard
            break
        end
    end
    
    if not target then return end
    
    -- Get the spell (either compiled or original)
    local spellToUse = slot.spell
    
    -- Convert to compiled spell if needed
    if spellToUse.id and not spellToUse.executeAll then
        -- This is an original spell, not a compiled one - get the compiled version
        local compiledSpell = getCompiledSpell(spellToUse.id, self)
        if compiledSpell then
            spellToUse = compiledSpell
            -- Store the compiled spell back in the slot for future use
            slot.spell = compiledSpell
            print("Using compiled spell: " .. spellToUse.id)
        else
            print("Warning: Falling back to original spell - could not get compiled version of " .. spellToUse.id)
        end
    end

    -- Check for character unlocks based on this spell
    UnlockSystem.checkSpellUnlock(spellToUse, self)
    
    -- Get attack type for shield checking
    local attackType = spellToUse.attackType or Constants.AttackType.PROJECTILE
    
    -- Check if the spell can be blocked by any of the target's shields
    -- This now happens BEFORE spell execution per ticket PROG-20
    local blockInfo = ShieldSystem.checkShieldBlock(spellToUse, attackType, target, self)
    
    -- Handle shield block effects
    if blockInfo.blockable then
        print(string.format("[SHIELD BLOCK] %s's %s was blocked by %s's %s shield!", 
            self.name, spellToUse.name, target.name, blockInfo.blockType or "unknown"))
        
        -- Set a standard blockPoint for visual effect (75% of the way from caster to target)
        blockInfo.blockPoint = 0.75
        
        -- Use the ShieldSystem to handle token consumption for the shield
        ShieldSystem.handleShieldBlock(target, blockInfo.blockingSlot, spellToUse)
        
        -- Create a partial results table with initialResults
        local blockedResults = { blockInfo = blockInfo }
        
        -- Execute the spell, but convert the DAMAGE events to BLOCKED_DAMAGE
        -- This will show visuals but prevent actual damage application
        effect = spellToUse.executeAll(self, target, blockedResults, spellSlot)
        
        -- Set blocked flag in the effect results
        effect.blocked = true
        effect.blockType = blockInfo.blockType
        effect.blockingSlot = blockInfo.blockingSlot
        
        -- Return tokens from our spell slot
        if #slot.tokens > 0 then
            -- Use TokenManager to return tokens to pool
            TokenManager.returnTokensToPool(slot.tokens)
            -- Clear token list after requesting return animations
            slot.tokens = {}
        end
        
        -- Reset our slot using unified method
        self:resetSpellSlot(spellSlot)
        
        -- Return the effect
        return effect
    end
    
    -- Now execute the spell
    
    -- For tracking if the spell is a shield spell
    local isShieldSpell = false
    if slot.willBecomeShield or spellToUse.isShield then
        isShieldSpell = true
    end
    
    -- Handle spell execution based on type
    local effect = nil
    local shouldSustain = false  -- Initialize outside if-block so it's available throughout the function
    
    -- Execute the spell using compiled spell format
    print("Executing spell: " .. spellToUse.id)
    
    -- Execute the spell with blockInfo if the spell is blocked
    local initialResults = blockInfo.blockable and { blockInfo = blockInfo } or {}
    effect = spellToUse.executeAll(self, target, initialResults, spellSlot)
    
    -- After execution, check if the spell was blocked (results should have blocked=true)
    if effect.blocked then
        print(string.format("[SHIELD] %s's %s was fully blocked by shield!", 
            self.name, spellToUse.name))
    end
    
    -- Check if this is a sustained spell (from sustain keyword)
    shouldSustain = effect.isSustained or false
    print("DEBUG: effect.isSustained = " .. tostring(effect.isSustained) .. ", shouldSustain = " .. tostring(shouldSustain))
    
    -- If no valid effect was returned, create an empty one
    if not effect then
        print("WARNING: Spell " .. spellToUse.id .. " didn't return any effect")
        effect = {}
    end
    
    -- Shield spell creation - check if the effect has shield params
    if effect.isShield and not effect.blocked and not slot.isShield then
        if effect.shieldParams then
            -- Create a shield in this spell slot using ShieldSystem
            print("Creating shield in spell slot " .. spellSlot)
            
            -- Explicitly mark as sustained (shields are a type of sustained spell)
            effect.isSustained = true
            shouldSustain = true
            
            -- Mark this slot as already cast to prevent repeated casting
            slot.wasAlreadyCast = true
            
            local shieldResult = ShieldSystem.createShield(self, spellSlot, effect.shieldParams)
            
            -- Register shield with SustainedSpellManager (shields are a type of sustained spell)
            if shieldResult.shieldCreated and self.gameState and self.gameState.sustainedSpellManager then
                -- Mark the effect as sustained for shields too
                effect.isSustained = true
                shouldSustain = true  -- Make sure shouldSustain is set for shields as well
                
                -- Make sure the shield params are set in the proper field expected by SustainedSpellManager
                effect.shieldParams = effect.shieldParams or {}
                effect.isShield = true
                
                local sustainedId = self.gameState.sustainedSpellManager.addSustainedSpell(
                    self,        -- wizard who cast the spell
                    spellSlot,   -- slot index where the shield is
                    effect       -- effect table from executeAll with shield params
                )
                
                -- Store the sustained spell ID in the slot for reference
                slot.sustainedId = sustainedId
                
                print(string.format("[SUSTAINED] Registered shield in slot %d with ID: %s", 
                    spellSlot, tostring(sustainedId)))
            end
            
            -- Apply any elevation change specified by the shield
            if shieldResult.shieldCreated and effect.shieldParams.setElevation then
                self.elevation = effect.shieldParams.setElevation
                if effect.shieldParams.elevationDuration and effect.shieldParams.setElevation == Constants.ElevationState.AERIAL then
                    self.elevationTimer = effect.shieldParams.elevationDuration
                end
                print(self.name .. " moved to " .. self.elevation .. " elevation by shield spell")
            end
        else
            print("ERROR: Shield spell missing shieldParams")
        end
    end
    
    -- For shields, skip the rest of the processing (shields are a specific kind of sustained spell)
    if effect.isShield or slot.isShield then
        -- Debug log - make it clear to use sustain instead in new code, but shields keep working
        if effect.isSustained and effect.isShield then
            print("[SUSTAINED] Note: Spell " .. spellToUse.id .. " has both isShield and isSustained flags - shields are already sustained")
        end
        return effect
    end
    
    if not isShieldSpell and not slot.isShield and not effect.isShield then
        -- Only reset slot and return tokens if this isn't a sustained spell
        if not shouldSustain then
            -- Start return animation for tokens
            if #slot.tokens > 0 then
                -- Check if any tokens are marked as SHIELDING using TokenManager
                local hasShieldingTokens = false
                for _, tokenData in ipairs(slot.tokens) do
                    if tokenData.token and TokenManager.validateTokenState(tokenData.token, Constants.TokenStatus.SHIELDING) then
                        hasShieldingTokens = true
                        break
                    end
                end
                
                -- Handle blocked spells - should always return tokens
                if effect and effect.blocked then
                    print("Returning tokens for blocked spell")
                    TokenManager.returnTokensToPool(slot.tokens)
                    slot.tokens = {}
                elseif not hasShieldingTokens then
                    -- Normal case: Safe to return tokens if not shielding
                    TokenManager.returnTokensToPool(slot.tokens)
                    
                    -- Clear token list (tokens still exist in the mana pool)
                    slot.tokens = {}
                else
                    print("Found SHIELDING tokens, preventing token return")
                end
            end
            
            -- Reset slot only if it's not a shield
            self:resetSpellSlot(spellSlot)
        else
            -- This is a sustained spell - keep slot active and tokens in place
            print(string.format("[SUSTAINED] %s's spell in slot %d is being sustained", self.name, spellSlot))
            
            -- Keep the slot as active with full progress
            slot.active = true
            slot.progress = slot.castTime -- Mark as fully cast
            slot.wasAlreadyCast = true -- Keep the flag set to prevent repeated casting
            
            -- Register with the SustainedSpellManager
            if self.gameState and self.gameState.sustainedSpellManager then
                local sustainedId = self.gameState.sustainedSpellManager.addSustainedSpell(
                    self,        -- wizard who cast the spell
                    spellSlot,   -- slot index where the spell is
                    effect       -- effect table from executeAll (contains trapTrigger, trapEffect, etc.)
                )
                
                -- Store the sustained spell ID in the slot for reference
                slot.sustainedId = sustainedId
                
                print(string.format("[SUSTAINED] Registered spell in slot %d with ID: %s", 
                    spellSlot, tostring(sustainedId)))
            else
                print("[SUSTAINED ERROR] Could not register sustained spell - gameState or sustainedSpellManager missing")
            end
        end
    else
        -- For shield spells, the slot remains active and tokens remain in orbit
        -- Make sure slot is marked as a shield
        slot.isShield = true
        
        -- Use TokenManager to mark tokens as SHIELDING
        TokenManager.markTokensAsShielding(slot.tokens)
    end
end

-- Reset a spell slot to its default state
-- This function can be used to clear a slot when a spell is cast, canceled, or a shield is destroyed
function Wizard:resetSpellSlot(slotIndex)
    local slot = self.spellSlots[slotIndex]
    if not slot then return end
    
    -- Debug message when slot reset happens
    print(string.format("[DEBUG] resetSpellSlot called for %s slot %d", self.name, slotIndex))
    
    -- Remove from SustainedSpellManager if it's a sustained spell
    if slot.sustainedId and self.gameState and self.gameState.sustainedSpellManager then
        self.gameState.sustainedSpellManager.removeSustainedSpell(slot.sustainedId)
        print(string.format("[SUSTAINED] Removed spell in slot %d with ID: %s during slot reset", 
            slotIndex, tostring(slot.sustainedId)))
        slot.sustainedId = nil
    end

    -- Reset the basic slot properties
    slot.active = false
    slot.spell = nil
    slot.spellType = nil
    slot.castTime = 0
    slot.castProgress = 0
    slot.progress = 0 -- Used in many places instead of castProgress
    slot.wasAlreadyCast = false -- Reset the flag that tracks if the spell was already cast
    
    -- Reset shield-specific properties
    slot.isShield = false
    slot.willBecomeShield = false
    slot.defenseType = nil
    slot.blocksAttackTypes = nil
    slot.blockTypes = nil
    slot.reflect = nil
    slot.shieldStrength = 0
    
    -- Reset spell status properties
    slot.frozen = false
    slot.freezeTimer = 0
    slot.castTimeModifier = 0 -- Renamed from frozenTimeAccrued
    
    -- Reset zone-specific properties
    slot.zoneAnchored = nil
    slot.anchorRange = nil
    slot.anchorElevation = nil
    slot.anchorRequireAll = nil
    slot.affectsBothRanges = nil
    
    -- Reset spell properties
    slot.attackType = nil
    
    -- Clear token references *after* animations have been requested
    slot.tokens = {}
end

-- Add method to check for spell fizzle/shield collapse when a token is removed
-- This is a wrapper around TokenManager.checkFizzleCondition
function Wizard:checkFizzleOnTokenRemoval(slotIndex, removedTokenObject)
    return TokenManager.checkFizzleCondition(self, slotIndex, removedTokenObject)
end

-- Handle the effects of a spell being blocked by a shield in a specific slot
-- This is now a wrapper method that delegates to ShieldSystem
function Wizard:handleShieldBlock(slotIndex, incomingSpell)
    print("[WIZARD DEBUG] handleShieldBlock called for " .. self.name .. " slot " .. slotIndex)
    
    -- Debug the shield slot to check for onBlock
    if self.spellSlots and self.spellSlots[slotIndex] then
        local slot = self.spellSlots[slotIndex]
        if slot.onBlock then
            print("[WIZARD DEBUG] onBlock handler found in shield slot")
        else
            print("[WIZARD DEBUG] No onBlock handler found in shield slot")
        end
    else
        print("[WIZARD DEBUG] Invalid slot index: " .. tostring(slotIndex))
    end
    
    return ShieldSystem.handleShieldBlock(self, slotIndex, incomingSpell)
end

-- Determine the current positional key string for animation lookup
function Wizard:getPositionalKey()
    local range = self.gameState and self.gameState.rangeState or Constants.RangeState.FAR
    local elevation = self.elevation or Constants.ElevationState.GROUNDED
    return string.lower(range .. "-" .. elevation)
end

-- Retrieve idle frames for a given positional key
function Wizard:getIdleFramesForKey(key)
    if self.positionalAnimations[key] and self.positionalAnimations[key].idle then
        return self.positionalAnimations[key].idle
    end
    return self.idleAnimationFrames
end

-- Retrieve cast frame for a given positional key
function Wizard:getCastFrameForKey(key)
    if self.positionalAnimations[key] then
        return self.positionalAnimations[key].cast or self.castFrameSprite
    end
    return self.castFrameSprite
end

-- Load positional animation assets for all range/elevation combinations
function Wizard:loadPositionalAnimations()
    local AssetCache = require("core.AssetCache")
    for _, range in pairs(Constants.RangeState) do
        for _, elevation in pairs(Constants.ElevationState) do
            local key = string.lower(range .. "-" .. elevation)
            local dir = string.format("assets/sprites/%s-%s-%s", string.lower(self.name), string.lower(range), string.lower(elevation))
            local anim = { idle = {}, cast = nil }

            if love.filesystem.getInfo(dir, "directory") then
                local files = love.filesystem.getDirectoryItems(dir)
                table.sort(files)
                for _, file in ipairs(files) do
                    if file:match("%.png$") then
                        local path = dir .. "/" .. file
                        if file:lower():find("cast") then
                            anim.cast = AssetCache.getImage(path)
                        else
                            local img = AssetCache.getImage(path)
                            if img then table.insert(anim.idle, img) end
                        end
                    end
                end
            end

            if #anim.idle == 0 then
                anim.idle = self.idleAnimationFrames
            end
            if not anim.cast then
                anim.cast = self.castFrameSprite
            end

            self.positionalAnimations[key] = anim
        end
    end
end

return Wizard
```

# Documentation

## docs/AddingVisualTemplates.md
# Adding Visual Templates

This guide walks through the **end-to-end** workflow for adding a new VFX "template" (a _base_ effect definition) and making it available everywhere (runtime, constants, resolver and tests).

---
## 1  Create/extend the template in `vfx.lua`
1.  Open `vfx.lua` and locate the `VFX.effects` table near the top.
2.  Add a new entry, e.g.
   ```lua
   myeffect_base = {
       type          = "myEffectType",  -- projectile / beam / surge / etc.
       duration      = 1.0,
       particleCount = 30,
       startScale    = 0.4,
       endScale      = 0.8,
       color         = Constants.Color.SMOKE,
       -- any extra fields that the effect's logic needs
   }
   ```
3.  If you introduce **new per-template fields** (e.g. `spread`, `height`, `defaultParticleAsset`):
   • Copy them into the effect instance in `VFX.createEffect` (`effect.spread = template.spread`).  
   • Clear them in `VFX.resetEffect` (`effect.spread = nil`).

---
## 2  Add particle initialisation
Inside `VFX.initializeParticles(effect)` insert a new `elseif effect.type == "myEffectType" then ...` branch that **creates particles** and stores them in `effect.particles`.

---
## 3  Add per-frame logic
1.  Implement `VFX.updateMyEffect(effect, dt)` to animate particles and update per-effect state.
2.  Call it from the main dispatcher in `VFX.update`:
   ```lua
   elseif effect.type == "myEffectType" then
       VFX.updateMyEffect(effect, dt)
   ```

---
## 4  Add rendering
1.  Implement `VFX.drawMyEffect(effect)`.
2.  Dispatch it from `VFX.draw` just like the update step.

---
## 5  Expose a constant for the template
Add an identifier in `core/Constants.lua` so other systems can reference it:
```lua
Constants.VFXType.MY_EFFECT_BASE = "myeffect_base"
```

---
## 6  Hook into **VisualResolver** (optional but typical)
1.  Decide how the game should pick the template (by `visualShape`, `attackType`, tags, etc.).
2.  Update `systems/VisualResolver.lua` mapping tables, e.g.:
   ```lua
   TEMPLATE_BY_SHAPE["myShape"] = Constants.VFXType.MY_EFFECT_BASE
   ```

---
## 7  Assets & sounds (if any)
• Add asset paths in `VFX.assetPaths`.  
• If the effect **must** be shown instantly (e.g. shields) preload the asset in `VFX.init()`.  
• Otherwise it will be lazily loaded on first use.

---
## 8  Testing checklist
☑  The game starts with no Lua errors.  
☑  `VisualResolver.test()` prints the expected base template for a crafted event.  
☑  In-game the effect animates, updates and fades out correctly.  
☑  Pool statistics (`VFX.showPoolStats()`) do not leak particles.

---
## 9  Troubleshooting
| Symptom | Common cause |
|---------|--------------|
| Nil-field error inside update/draw | Forgot to copy the field from template in `createEffect()` |
| Effect visible but never removed | Didn't mark `effect.progress` to `1` or forgot `isComplete` flag |
| No visual appears | Asset path typo or `initializeParticles` created **zero** particles |

---
Happy effect hacking! 🎆 

## docs/Bugs.md
* Zone spells not blocked by Barriers - found with Eruption vs. Wrap in Moonlight

## docs/ProgrammingIdeaBoard.md
## Purpose
This is a hybrid to-do list and bluesky whiteboard, organized by task type.

## Visualization/Gamefeel
### Tie Mana Pool orbits to mana token type
* MOON moves in sine wave shaped orbit, FIRE moves in ellipse, etc.

### Better visual language for spell slots and cast progress
* ?? on whole thing...current vibes are serviceable
* DONE - Experiment with no explicitly drawn static orbit, only draw as cast bar
* Experiment with transparent lines or particles flowing between mana tokens in slot. Strengthen with cast progress?

### Unique "idle" animations for each stance
* DONE - Stretch: unique "cast" animations for each stance
  
### Tween frames for range/position changes
* DONE
### Establish visual language for Ninefold Path
* Two colors per element, "core" and "aura"?

### FX on taking damage
* DONE - Hitstop - exclude DoT (burn, etc. Minimum threshold?)
  * Implementation scales with DMG value - consistent rule that makes DoTs feel right.
* Flashing effect for DoT (for everything maybe?)
  * DONE, for everything

### Consistent-fy visual language for shield types: ward vs. barrier
* Barrier is a partly-transparent "screen" that extends up and down from the spell slot
* Ward is a set of floating runes that orbits in-line wit the spell slot

### SFX
* Whole thing needs to be built
* Stubbed alongside VFX, should be similar and a bit simpler
* handle overlapping sounds somehow

## Rules Engine
### Update mana types to canonical Ninefold Path
  * DONE
* Material: FIRE, WATER, SALT
* Celestial: SUN, MOON, STAR
* Transcendental: SOURCE, MIND, VOID
* Update all spells to use definitions

### Unify Shield spells with new "Trap" type/keyword set under a "sustained spell" umbrella
* DONE

### Support "Field" spell type/keyword as an additional type of ongoing effect/"sustained spell"

### Better consistent rules for Burn stacking rather than quasi-overlapping shared timer thing. Use in Brightwulf design.

## docs/VFX_Audit_Report.md
# Spells VFX Audit Report

This report shows the current VFX setup for each spell and recommendations for improvement.

| Spell Name | Element | Attack Type | Current VFX | Using VFX Keyword | Generates EFFECT Events | Recommended VFX | Status |
|------------|---------|-------------|-------------|-------------------|------------------------|-----------------|--------|
| Adaptive Surge | fire | projectile | adaptive_surge | No | Yes | adaptive_surge | ✅ Correct |
| Arcane Reversal | fire | remote | arcane_reversal | No | Yes | arcane_reversal | ✅ Correct |
| Battle Shield | fire | utility | battle_shield | No | Yes | battle_shield | ✅ Correct |
| Blast Wave | fire | zone | blastwave | No | Yes | blastwave | ✅ Correct |
| Blazing Ascent | fire | zone | blazing_ascent | No | Yes | blazing_ascent | ✅ Correct |
| Combust Mana | fire | utility | combust_lock | No | Yes | combust_lock | ✅ Correct |
| Conjure Fire | fire | utility | fire_conjure | No | Yes | fire_conjure | ✅ Correct |
| Conjure Moonlight | moon | utility | moon_conjure | No | Yes | moon_conjure | ✅ Correct |
| Conjure Nothing | void | utility | void_conjure | No | Yes | void_conjure | ✅ Correct |
| Conjure Salt | salt | utility | force_conjure | No | Yes | force_conjure | ✅ Correct |
| Conjure Stars | star | utility | star_conjure | No | Yes | star_conjure | ✅ Correct |
| Cosmic Rift | fire | zone | cosmic_rift | No | Yes | cosmic_rift | ✅ Correct |
| Drag From the Sky | moon | zone | None | Yes | Yes | gravity_pin_ground | ✅ Correct |
| Emberlift | sun | utility | ember_lift | No | Yes | ember_lift | ✅ Correct |
| Enhanced Mirror Shield | fire | utility | enhanced_mirror_shield | No | Yes | enhanced_mirror_shield | ✅ Correct |
| Firebolt | fire | projectile | None | Yes | Yes | firebolt | ✅ Correct |
| Force Blast | fire | remote | force_blast | No | Yes | force_blast | ✅ Correct |
| Full Moon Beam | moon | projectile | moon_beam | No | Yes | moon_beam | ✅ Correct |
| Gravity Trap | moon | utility | gravity_trap_set | No | Yes | gravity_trap_set | ✅ Correct |
| Infinite Procession | moon | utility | infinite_procession | No | Yes | infinite_procession | ✅ Correct |
| Lunar Disjunction | moon | projectile | lunardisjunction | No | Yes | lunardisjunction | ✅ Correct |
| Lunar Tides | fire | zone | lunar_tide | No | Yes | lunar_tide | ✅ Correct |
| Meteor Dive | sun | zone | None | Yes | Yes | meteor | ✅ Correct |
| Mirror Shield | fire | utility | mirror_shield | No | Yes | mirror_shield | ✅ Correct |
| Molten Ash | fire | zone | lava_eruption | No | Yes | lava_eruption | ✅ Correct |
| Moon Dance | moon | remote | None | No | No | fullmoonbeam | ❌ Missing VFX |
| Moon Ward | fire | utility | moon_ward | No | Yes | moon_ward | ✅ Correct |
| Nature Field | fire | utility | nature_field | No | Yes | nature_field | ✅ Correct |
| Nova Conjuring | sun | utility | nova_conjure | No | Yes | nova_conjure | ✅ Correct |
| Shield Breaker | fire | projectile | force_blast | No | Yes | force_blast | ✅ Correct |
| Storm Meld | fire | utility | storm_meld | No | Yes | storm_meld | ✅ Correct |
| Sun Block | fire | utility | force_barrier | No | Yes | force_barrier | ✅ Correct |
| Test Shield | fire | utility | force_barrier | No | Yes | force_barrier | ✅ Correct |
| Tidal Force | water | remote | tidal_force | No | Yes | tidal_force | ✅ Correct |
| Total Eclipse | moon | utility | eclipse_burst | No | Yes | eclipse_burst | ✅ Correct |
| Wings of Moonlight | moon | utility | None | Yes | Yes | mistveil | ✅ Correct |
| Witch Conjuring | moon | utility | witch_conjure | No | Yes | witch_conjure | ✅ Correct |

## Summary Statistics

- **Total Spells:** 37
- **Correctly Implemented:** 36 (97.3%)
- **Needs VFX Keyword:** 0 (0.0%)
- **Missing VFX:** 1 (2.7%)

## Implementation Recommendations

1. **Replace top-level VFX properties with VFX keywords:**
   ```lua
   -- Before:
   vfx = "firebolt",

   -- After:
   keywords = {
       -- other keywords...
       vfx = { effect = Constants.VFXType.FIREBOLT, target = Constants.TargetType.ENEMY }
   },
   ```

2. **Add VFX keywords to spells missing visual effects:**
   - Use Constants.VFXType for standard effect names
   - Match the effect type to the spell's element and attack pattern
   - Consider spell's role when selecting the visual effect

3. **Run the automated fix tool:**
   ```bash
   lua tools/fix_vfx_events.lua
   ```

4. **Test with the VFX events test:**
   ```bash
   lua tools/test_vfx_events.lua
   ```

## docs/VerticalSliceMustHaves.md
Polished spell templates:
* DONE BOLT
* DONE BEAM
* WARP
* BLAST
* METEOR
* FOUNTAIN

Polished mechanical templates:
* WARD
* BARRIER
* TRAP

SFX:
* Figure this out!

Character animation:
* Absolute bare minimum: 2-frame idles
* Ideally: 4-frame idles _per position_.
* DONE 1-frame Cast per-position
* DONE Flash/shake on-hit
* DONE Screenshake on big hit (Meteor Dive, charged Full Moon Beam)
* 

## docs/Visual_Language.md
# Visual Language Reference

This document defines the visual language for the Manastorm game, mapping game concepts to visual elements to ensure consistency across the game.

## Overview

The visual language is organized by:

1. **Element**: The magical element (Fire, Moon, etc.)
2. **Concept**: The game mechanic (Damage, Heal, Shield, etc.)
3. **Target**: Who/what the effect targets (Self, Enemy, Pool)
4. **VFX Name**: The corresponding `Constants.VFXType` value
5. **Particle Sprite**: The asset used by the VFX system
6. **Core Color**: The base color used for the effect (from `Constants.Color`)

## Visual Language Map

| Element | Concept | Target | VFX Name | Particle Sprite | Core Color | Notes |
|---------|---------|--------|----------|----------------|------------|-------|
| **Fire** | Damage | Enemy | `FIREBOLT` | fireParticle | CRIMSON | Fast, direct projectile |
| Fire | Area Damage | Enemy | `METEOR` | fireParticle | OCHRE | Impact-focused with larger radius |
| Fire | Elevation | Self | `EMBERLIFT` | fireParticle | ORANGE | Vertical rising particles |
| Fire | Conjure | Pool | `CONJUREFIRE` | fireParticle | ORANGE | Particles converge on mana pool |
| **Water** | Damage | Enemy | `TIDAL_FORCE` | sparkle | OCEAN | Flowing, wave-like projectile |
| Water | Ground | Enemy | `TIDAL_FORCE_GROUND` | impactRing | OCEAN | Downward pressing impact |
| Water | Shield | Self | `SHIELD` | impactRing | OCEAN | Barrier-type with liquid appearance |
| **Moon** | Damage | Enemy | `LUNARDISJUNCTION` | sparkle | PINK | Elegant, arcing projectile |
| Moon | Disable | Enemy | `DISJOINT_CANCEL` | impactRing | PINK | Disruptive, sparkling impact |
| Moon | Conjure | Pool | `CONJUREMOONLIGHT` | moonGlow | SKY | Soft, glowing particles to pool |
| Moon | Shield | Self | `SHIELD` | runeAssets | SKY | Ward-type with runic symbols |
| Moon | Field | Area | `MISTVEIL` | sparkle | SKY | Diffuse, fog-like effect |
| **Sun** | Damage | Enemy | `METEOR` | fireParticle | ORANGE | Falling impact from above |
| Sun | Shield | Self | `SHIELD` | impactRing | ORANGE | Barrier-type with bright rings |
| Sun | Conjure | Pool | `NOVA_CONJURE` | sparkle | ORANGE | Bright, star-like particles |
| **Star** | Damage | Enemy | `STAR_CONJURE` | sparkle | YELLOW | Small, bright flashes |
| **Salt** | Control | Enemy | `TOKEN_LOCK` | impactRing | SAND | Crystalline, binding appearance |
| **Force** | Push | Enemy | `FORCE_BLAST` | forceWave | YELLOW | Wave-like, rippling effect |
| Force | Elevate | Enemy | `FORCE_BLAST_UP` | forceWave | YELLOW | Upward-moving force waves |
| Force | Conjure | Pool | `FORCE_CONJURE` | sparkle | YELLOW | Dynamic, energetic particles |
| **Life** | Heal | Self | `FREE_MANA` | sparkle | LIME | Gentle, pulsing aura |
| **Mind** | Control | Enemy | `SPELL_FREEZE` | sparkle | PINK | Twisting, distorting effect |
| **Void** | Consume | Enemy | `TOKEN_CONSUME` | sparkle | BONE | Draining, empty appearance |
| **Generic** | Impact | Any | `IMPACT` | impactRing | SMOKE | Basic impact when no specific VFX |
| Generic | Range Change | Both | `RANGE_CHANGE` | sparkle | SMOKE | Quick positional indicator |
| Generic | Acceleration | Slot | `SPELL_ACCELERATE` | sparkle | LIME | Speed-up animation |
| Generic | Cancel | Slot | `SPELL_CANCEL` | impactRing | CRIMSON | Spell interruption effect |
| Generic | Echo | Slot | `SPELL_ECHO` | sparkle | BONE | Spell replication effect |

## Shield Visual Language

Shields have distinct visual characteristics based on their type:

| Shield Type | Visual Style | Color | Asset | Description |
|-------------|--------------|-------|-------|-------------|
| `barrier` | Solid, physical | ORANGE (Sun) | impactRing | Concentric rings that expand outward, solid appearance |
| `ward` | Magical, runic | SKY (Moon) | runeAssets | Runic symbols that rotate around the wizard, ethereal glow |
| `field` | Energy, force | YELLOW (Force) | forceWave | Wave-like energy that pulses outward, semi-transparent |

## Element Color Reference

For consistency, these are the primary colors associated with each element:

- Fire: CRIMSON/ORANGE
- Water: OCEAN
- Salt: SAND
- Sun: ORANGE (brighter than Fire)
- Moon: SKY/PINK
- Star: YELLOW
- Life: LIME
- Mind: PINK
- Void: BONE
- Force: YELLOW
- Generic: SMOKE

## Implementation Checklist

When implementing visual effects for a new spell:

1. Identify which element the spell belongs to
2. Determine the primary concept (what game mechanic it represents)
3. Choose the appropriate target type
4. Select the matching VFX from the table above
5. Use the color values in the spell's visual implementation
6. Consider combining multiple VFX types for complex spells

## Particle System Usage

The particle system has several main effect types that produce different visual patterns:

- `projectile`: Moves from source to target with trailing particles
- `impact`: Creates a radial burst of particles from a central point
- `aura`: Generates particles orbiting around a central point
- `beam`: Creates a solid beam with particle effects along its length
- `conjure`: Creates particles that rise toward the mana pool

## docs/combat_events.md
# Manastorm Combat Event System

This document defines the event schema for the Manastorm combat system. Events are generated by the spell compiler and processed by the EventRunner to apply state changes to the game.

## Event Structure

All events follow a common structure:

```lua
{
  type = "EVENT_TYPE",  -- Required: string identifying the event type
  source = "caster",    -- Required: entity that generated the event ("caster" or "target")
  target = "enemy",     -- Required: entity that receives the effect ("self", "enemy", "both", or specific slot)
  
  -- Additional fields specific to the event type
  ...
}
```

## Core Event Types

### Damage Events

```lua
{
  type = "DAMAGE",
  source = "caster",
  target = "enemy",
  amount = 10,
  damageType = "fire"  -- Optional: type of damage (fire, ice, force, etc.)
}
```

### Status Effect Events

```lua
{
  type = "APPLY_STATUS",
  source = "caster",
  target = "enemy",
  statusType = "burn",
  duration = 3.0,
  tickDamage = 2,      -- For DoT effects
  tickInterval = 1.0,  -- For DoT effects
  -- Additional status-specific parameters
}
```

### Elevation Events

```lua
{
  type = "SET_ELEVATION",
  source = "caster",
  target = "self",    -- or "enemy" for forced elevation changes
  elevation = "AERIAL",
  duration = 5.0      -- Optional: duration of the effect (nil = permanent)
}
```

### Range Events

```lua
{
  type = "SET_RANGE",
  source = "caster",
  target = "both",    -- Range changes always affect both wizards
  position = "NEAR"
}
```

### Force Position Events

```lua
{
  type = "FORCE_POSITION",
  source = "caster",
  target = "enemy",   -- Force enemy to move to caster's range
}
```

## Resource and Token Events

### Conjure Token Events

```lua
{
  type = "CONJURE_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "fire", -- Type of token to create
  amount = 1          -- Number of tokens to create
}
```

### Dissipate Token Events

```lua
{
  type = "DISSIPATE_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "any",  -- Type of token to remove, "any" for any type
  amount = 1          -- Number of tokens to remove
}
```

### Token Shift Events

```lua
{
  type = "SHIFT_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "fire", -- Type to transform tokens into
  amount = 1          -- Number of tokens to transform
}
```

### Lock Token Events

```lua
{
  type = "LOCK_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  duration = 5.0,     -- Duration of the lock
  amount = 1,         -- Number of tokens to lock
  tokenType = "any"   -- Optional: specific type to lock
}
```

## Spell Timing Events

### Delay Events

```lua
{
  type = "DELAY_SPELL",
  source = "caster",
  target = "enemy_slot", -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,         -- Specific slot to target (nil = random active slot)
  amount = 1.0           -- Amount to delay by in seconds
}
```

### Accelerate Events

```lua
{
  type = "ACCELERATE_SPELL",
  source = "caster",
  target = "self_slot",   -- Can specify exact slot number (1-3) or "current"
  slotIndex = 2,          -- Specific slot to target (nil = current slot)
  amount = 1.0            -- Amount to accelerate by in seconds
}
```

### Cancel Spell Events

```lua
{
  type = "CANCEL_SPELL",
  source = "caster",
  target = "enemy_slot",  -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,          -- Specific slot to target (nil = random active slot)
  returnMana = true       -- Whether to return mana to the pool (true = dispel, false = disjoint)
}
```

### Freeze Spell Events

```lua
{
  type = "FREEZE_SPELL",
  source = "caster",
  target = "enemy_slot",  -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,          -- Specific slot to target (nil = random active slot)
  duration = 2.0          -- Duration of the freeze effect
}
```

## Defense Events

### Create Shield Events

```lua
{
  type = "CREATE_SHIELD",
  source = "caster",
  target = "self_slot",   -- Always targets a slot of the caster
  slotIndex = 1,          -- Slot where the shield is created
  defenseType = "barrier", -- Type of shield
  blocksAttackTypes = {"projectile", "zone"}, -- Attack types this shield blocks
  reflect = false         -- Whether the shield reflects damage
}
```

### Reflect Events

```lua
{
  type = "REFLECT",
  source = "caster",
  target = "self",
  duration = 3.0          -- Duration of the reflect effect
}
```

## Special Events

### Echo Events

```lua
{
  type = "ECHO",
  source = "caster",
  target = "self_slot",   -- Always targets a slot of the caster
  slotIndex = 1,          -- Slot to echo
  delay = 2.0             -- Delay before echo triggers
}
```

### Zone Anchor Events

```lua
{
  type = "ZONE_ANCHOR",
  source = "caster",
  target = "self",
  anchorRange = "NEAR",    -- Range state to anchor to (or "ANY")
  anchorElevation = "AERIAL", -- Elevation to anchor to (or "ANY")
  requireAll = true       -- Whether all conditions must be met
}
```

### Zone Multi Events

```lua
{
  type = "ZONE_MULTI",
  source = "caster",
  target = "self"
}
```

## Event Processing Order

Events are processed in the following order to ensure consistent game state:

1. **State Setting Events**: Elevation, Range, Zone anchors
2. **Resource Events**: Conjure, Dissipate, Shift, Lock 
3. **Spell Timeline Events**: Delay, Accelerate, Cancel, Freeze
4. **Defense Events**: Create Shield, Reflect
5. **Status Effect Events**: Apply DoTs and other effects
6. **Damage Events**: Direct damage
7. **Special Effect Events**: Echo, Zone Multi

## Integration with Existing Systems

The EventRunner module is responsible for processing events and applying their effects to the game state. It will:

1. Receive events from the spell compiler
2. Sort them according to the processing order
3. Apply each event to the game state
4. Handle any visual effects triggered by events
5. Return a summary of applied effects for UI updates

## Design Principles

1. **Separation of Concerns**: Events describe what happens, the runner decides how it happens
2. **Deterministic Execution**: The same events always produce the same game state changes
3. **Testability**: Events can be serialized and replayed for testing
4. **Extensibility**: New event types can be added without changing the core system
5. **Backward Compatibility**: The event system supports all existing keyword behaviors

## Examples

### Example: Fireball Spell Events

```lua
-- Events generated by a Fireball spell
{
  {
    type = "DAMAGE",
    source = "caster",
    target = "enemy",
    amount = 10,
    damageType = "fire"
  },
  {
    type = "APPLY_STATUS",
    source = "caster",
    target = "enemy",
    statusType = "burn",
    duration = 3.0,
    tickDamage = 2,
    tickInterval = 1.0
  }
}
```

### Example: Shield Spell Events

```lua
-- Events generated by a Barrier Shield spell
{
  {
    type = "CREATE_SHIELD",
    source = "caster",
    target = "self_slot",
    slotIndex = 1,
    defenseType = "barrier",
    blocksAttackTypes = {"projectile", "zone"},
    reflect = false
  }
}
```

## Future Extensions

Possible future extensions to the event system:

1. **Event Logging**: Recording all events for replay and analysis
2. **Deterministic Replay**: Replaying a sequence of events to recreate a game state
3. **Network Synchronization**: Using events for multiplayer synchronization
4. **AI Decision-Making**: AI can analyze possible events to make decisions
5. **Event Modifications**: Allowing special effects to modify events before processing

## docs/constants.md
# Constants Reference

This document provides a reference for the Constants module in Manastorm.

## Overview

The Constants module (`core/Constants.lua`) provides centralized string constants used throughout the game, replacing string literals with structured reference tables. This approach offers several benefits:

- **Reduced typos**: References are checked at compile time
- **Better IDE support**: Autocomplete suggestions for constants
- **Centralized documentation**: All constants defined in one place
- **Easier refactoring**: Change a value in one place instead of throughout the codebase

## Usage

```lua
-- Import the module
local Constants = require("core.Constants")

-- Use constants in code
if wizard.elevation == Constants.ElevationState.AERIAL then
    -- Do something with aerial wizards
end

-- Use in tables
local spell = {
    attackType = Constants.AttackType.PROJECTILE,
    cost = {Constants.TokenType.FIRE, Constants.TokenType.FORCE}
}
```

## Available Constants

### Token Types

```lua
Constants.TokenType.FIRE    -- "fire"
Constants.TokenType.FORCE   -- "force"
Constants.TokenType.MOON    -- "moon"
Constants.TokenType.NATURE  -- "nature"
Constants.TokenType.STAR    -- "star"
Constants.TokenType.RANDOM  -- "random" (special: used in spell costs)
Constants.TokenType.ANY     -- "any" (special: used in keywords)
```

### Token States

```lua
Constants.TokenState.FREE       -- "FREE"
Constants.TokenState.CHANNELED  -- "CHANNELED"
Constants.TokenState.SHIELDING  -- "SHIELDING"
Constants.TokenState.LOCKED     -- "LOCKED"
Constants.TokenState.DESTROYED  -- "DESTROYED"
```

### Range States

```lua
Constants.RangeState.NEAR  -- "NEAR"
Constants.RangeState.FAR   -- "FAR"
```

### Elevation States

```lua
Constants.ElevationState.GROUNDED  -- "GROUNDED"
Constants.ElevationState.AERIAL    -- "AERIAL"
```

### Shield Types

```lua
Constants.ShieldType.BARRIER  -- "barrier"
Constants.ShieldType.WARD     -- "ward"
Constants.ShieldType.FIELD    -- "field"
```

### Attack Types

```lua
Constants.AttackType.PROJECTILE  -- "projectile"
Constants.AttackType.REMOTE      -- "remote"
Constants.AttackType.ZONE        -- "zone"
Constants.AttackType.UTILITY     -- "utility"
```

### Target Types

```lua
Constants.TargetType.SELF        -- "SELF"
Constants.TargetType.ENEMY       -- "ENEMY"
Constants.TargetType.SLOT_SELF   -- "SLOT_SELF"
Constants.TargetType.SLOT_ENEMY  -- "SLOT_ENEMY"
Constants.TargetType.POOL_SELF   -- "POOL_SELF"
Constants.TargetType.POOL_ENEMY  -- "POOL_ENEMY"
Constants.TargetType.CASTER      -- "caster"
Constants.TargetType.TARGET      -- "target"
```

### Damage Types

```lua
Constants.DamageType.FIRE     -- "fire"
Constants.DamageType.FORCE    -- "force"
Constants.DamageType.MOON     -- "moon"
Constants.DamageType.NATURE   -- "nature"
Constants.DamageType.STAR     -- "star"
Constants.DamageType.GENERIC  -- "generic"
Constants.DamageType.MIXED    -- "mixed"
```

### Player Sides

```lua
Constants.PlayerSide.PLAYER    -- "PLAYER"
Constants.PlayerSide.OPPONENT  -- "OPPONENT"
Constants.PlayerSide.NEUTRAL   -- "NEUTRAL"
```

### Status Types

```lua
Constants.StatusType.BURN    -- "burn"
Constants.StatusType.SLOW    -- "slow"
Constants.StatusType.STUN    -- "stun"
Constants.StatusType.REFLECT -- "reflect"
```

## Helper Functions

The Constants module also provides helper functions:

### `Constants.poolSide(side)`

Converts a side (SELF/ENEMY) to its POOL_ equivalent.

```lua
Constants.poolSide(Constants.TargetType.SELF)  -- Returns Constants.TargetType.POOL_SELF
```

### `Constants.slotSide(side)`

Converts a side (SELF/ENEMY) to its SLOT_ equivalent.

```lua
Constants.slotSide(Constants.TargetType.ENEMY)  -- Returns Constants.TargetType.SLOT_ENEMY
```

### Collection Functions

- `Constants.getAllTokenTypes()` - Returns a table with all token types
- `Constants.getAllShieldTypes()` - Returns a table with all shield types
- `Constants.getAllAttackTypes()` - Returns a table with all attack types

## CI Checking

We've implemented a CI check to prevent new string literals from being added. Run the check script:

```
lua tools/check_magic_strings.lua
```

This will scan the codebase for string literals that should be using Constants instead.

## docs/manapool.md
# ManaPool Module (`manapool.lua`)

## Overview

The `manapool.lua` module manages the central shared pool of mana tokens that wizards use to cast spells. It handles the creation, storage, update (movement, state changes), and drawing of these tokens. It also defines the core state machine logic for individual tokens.

## Key Components

### 1. ManaPool Object

*   **Role:** Represents the central mana pool area.
*   **State:**
    *   `x`, `y`: Center position of the pool.
    *   `tokens`: Array table holding references to all active token objects currently managed by the pool (regardless of their state: FREE, CHANNELED, etc.).
    *   `valences`: Defines multiple elliptical orbital paths (rings) within the pool area for `FREE` tokens, each with different radii and base speeds.
    *   `valenceJumpChance`: Probability for `FREE` tokens to switch valences.
    *   `lockOverlay`: Loaded image for drawing on `LOCKED` tokens.
*   **Core Methods:**
    *   `ManaPool.new(x, y)`: Constructor. Initializes state, defines valences, loads assets, ensures the "token" object pool exists.
    *   `ManaPool:addToken(tokenType, imagePath)`: Creates a new token. Acquires a recycled object from the pool, adds `TokenMethods`, initializes state (`FREE`), sets orbital parameters, loads image, and adds it to `self.tokens`.
    *   `ManaPool:update(dt)`: Per-frame update loop. Iterates through `self.tokens` and updates each based on its `status`:
        *   `FREE`: Manages orbital motion, valence jumps, and smooth transitions.
        *   `CHANNELED`/`SHIELDING`: Updates animation towards the wizard along a Bezier path (position is handled by `Wizard` once animation completes).
        *   `RETURNING`: Updates animation back to the pool center along a Bezier path, triggers `animationCallback` (`finalizeReturn`) on completion.
        *   `DISSOLVING`: Updates animation timer, triggers `animationCallback` (`finalizeDestruction`) on completion.
        *   `LOCKED`: Updates timer, unlocks to `FREE` when timer expires, applies constrained movement.
    *   `ManaPool:draw()`: Draws all active tokens. Z-sorts for layering. Applies state-dependent visuals (glows, trails, color tints, overlays).
    *   `ManaPool:clear()`: Releases all tokens back to the object pool and clears `self.tokens`.
    *   `ManaPool:findFreeToken(tokenType)`: Helper to find a `FREE` token of a specific type *without* changing its state.
    *   `ManaPool:getToken(tokenType)`: Legacy/fallback (?) function to find a `FREE` token and set its state to `CHANNELED`.
    *   `ManaPool:returnToken(tokenIndex)`: Legacy/fallback function called if a token lacks `requestReturnAnimation`. Wraps the call if possible, otherwise handles return logic directly.
    *   `ManaPool.resetToken(token)`: Static function used by the object pool (`core.Pool`) to completely reset a token object's fields when it's released.

### 2. Token Objects & State Machine (`TokenMethods`)

*   **Object Pooling:** Tokens are managed using `core.Pool` for performance. Objects are acquired via `Pool.acquire("token")` and returned via `Pool.release("token", token)` (triggered by `finalizeDestruction` or `ManaPool:clear`).
*   **State (`token.status`):** Managed using `Constants.TokenStatus` values:
    *   `FREE`: Idle in the mana pool, orbiting.
    *   `CHANNELED`: Reserved/moving towards a wizard's spell slot.
    *   `SHIELDING`: Part of an active shield, orbiting the wizard (position managed by Wizard module).
    *   `LOCKED`: Unusable, timer counts down until returned to `FREE`.
    *   `RETURNING`: Animating back towards the mana pool center.
    *   `DISSOLVING`: Animating destruction.
    *   `POOLED`: Inactive, object released back to the pool.
*   **Core Methods (`TokenMethods` table, applied to token objects):**
    *   `token:setState(newStatus)`: Validates and applies state changes, maintains legacy `token.state` sync.
    *   `token:requestReturnAnimation()`: Preferred method to initiate return. Sets state to `RETURNING`, sets up animation parameters and `finalizeReturn` callback.
    *   `token:requestDestructionAnimation()`: Initiates destruction. Sets state to `DISSOLVING`, sets up animation parameters and `finalizeDestruction` callback, triggers VFX.
    *   `token:finalizeReturn()`: Callback after return animation. Sets state to `FREE`, clears wizard references, initializes orbital parameters within the pool.
    *   `token:finalizeDestruction()`: Callback after destruction animation. Sets state to `POOLED`, removes token from `manaPool.tokens`, releases object back to `core.Pool`.
*   **Other Token Properties:** `type`, `image`, `x`, `y`, `scale`, `rotAngle`, `orbitAngle`, `orbitSpeed`, animation timers/flags, references (`manaPool`, `gameState`, `wizardOwner`, `spellSlot`), etc.

### 3. Visuals

*   The pool itself is visually defined only by the orbiting `FREE` tokens.
*   Tokens have complex drawing logic based on state:
    *   Colored glows (type-specific).
    *   Pulsation.
    *   Z-ordering for depth.
    *   Color tints (`LOCKED`, `SHIELDING`).
    *   Shield type icons drawn inside `SHIELDING` tokens.
    *   Trails for `RETURNING` tokens.
    *   Fade-out/scale effects for `DISSOLVING` tokens.
    *   Lock overlay and timer for `LOCKED` tokens.

### 4. Potential Cleanup Areas

*   The `ManaPool:getToken` method seems less robust than the reservation system used in `Wizard` and might be a candidate for removal or refactoring.
*   The Bezier curve calculations used for animating tokens (`CHANNELED`/`SHIELDING`, `RETURNING`) are duplicated between the `update` function and the `draw` function (for trails). This could be consolidated into a helper function.

## Dependencies

*   `core.Constants`
*   `core.AssetCache`
*   `core.Pool`
*   Global `game` state (optional, via `self.gameState` reference, primarily for VFX access) 

## docs/shield_hooks.md
# Shield On-Block Hooks

This document describes the on-block hook system for shield spells, which allows custom effects to be triggered when a shield successfully blocks an incoming spell.

## Overview

Shields can now define an `onBlock` callback function that is invoked whenever the shield successfully blocks an attack. This callback can emit events that are processed by the EventRunner, allowing for a wide variety of dynamic effects.

## onBlock Callback Signature

The `onBlock` callback has the following signature:

```lua
function onBlock(defender, attacker, slotIndex, blockInfo)
    -- Return an array of events to process
    return events
end
```

### Parameters

- `defender`: The wizard who owns the shield (shield caster)
- `attacker`: The wizard who cast the spell being blocked (may be nil)
- `slotIndex`: The spell slot index where the shield is active
- `blockInfo`: A table with contextual information about the block:
  - `blockType`: The type of shield (barrier, ward, field)

### Return Value

The callback should return an array of events to be processed by the EventRunner. Each event should follow the standard event structure defined in the EventRunner system.

## Examples

### Simple Elevation on Block

```lua
onBlock = function(defender, attacker, slotIndex, blockInfo)
    return {{
        type = "SET_ELEVATION",
        source = "caster",
        target = "self",
        elevation = "AERIAL",
        duration = 4.0
    }}
end
```

### Counter Damage

```lua
onBlock = function(defender, attacker, slotIndex, blockInfo)
    if not attacker then return {} end
    
    return {{
        type = "DAMAGE",
        source = "caster",
        target = "enemy",
        amount = 10,
        damageType = "fire"
    }}
end
```

### Multiple Effects

```lua
onBlock = function(defender, attacker, slotIndex, blockInfo)
    local events = {}
    
    -- Deal counter damage
    table.insert(events, {
        type = "DAMAGE",
        source = "caster",
        target = "enemy",
        amount = 8,
        damageType = "fire"
    })
    
    -- Accelerate next spell
    table.insert(events, {
        type = "ACCELERATE_SPELL",
        source = "caster",
        target = "self_slot",
        slotIndex = 0,
        amount = 2.0
    })
    
    return events
end
```

## Creating Custom Shield Spells

To create a shield spell with an on-block hook:

1. Define a normal spell with the `block` keyword
2. Add an `onBlock` function to the block keyword parameters
3. Return an array of events from the `onBlock` function

The events will be processed through the EventRunner system, maintaining compatibility with all existing game systems.

## docs/spellcasting.md
# Manastorm Spell System

## Overview

The spell system in Manastorm is designed to be modular and data-driven, allowing for complex spell effects to be defined by combining simpler, reusable components. It revolves around four key files, which can be thought of using a kitchen metaphor:

1.  **`keywords.lua`**: The **Ingredients** - Defines atomic game actions.
2.  **`spells.lua`**: The **Recipes** - Combines ingredients (keywords) into specific spells.
3.  **`spellCompiler.lua`**: The **Chef** - Prepares the recipes for execution.
4.  **`systems/EventRunner.lua`**: The **Waiter** - Delivers the effects of the prepared spell to the game state.

This system is transitioning towards a pure event-based architecture, where spell effects generate descriptive events that are then processed centrally, ensuring consistent application order and state management.

## Core Components

### 1. `keywords.lua` - The Ingredients

*   **Purpose:** Defines the fundamental "verbs" or atomic actions that spells can perform. Each keyword represents a specific game mechanic (e.g., dealing damage, applying a status effect, changing position, manipulating tokens).
*   **Structure:** A large Lua table (`Keywords`) where each key is a keyword name (e.g., `damage`, `elevate`, `conjure`, `block`). The value is a table containing:
    *   `behavior`: A sub-table describing the keyword's effect conceptually (e.g., `dealsDamage = true`, `targetType = Constants.TargetType.ENEMY`, `category = "DAMAGE"`). This acts as metadata and helps define default parameters.
    *   `execute`: A function implementing the keyword's logic. **Crucially, this function should ideally generate events rather than directly modify game state.** It takes `caster`, `target`, `params`, `results` (for legacy compatibility), and an `events` table as arguments. It should add event tables (e.g., `{ type = "DAMAGE", ... }`) to the `events` list.
*   **Event-Based Shift:** Comments emphasize that new keywords should generate events processed by the `EventRunner`. Older keywords might still directly modify the `results` table for backward compatibility.

### 2. `spells.lua` - The Recipes

*   **Purpose:** Defines the concrete spells available by combining keywords (`ingredients`) with specific parameters. Acts as a database of spell definitions.
*   **Structure:** A large Lua table (`Spells`) where each key is a unique spell ID (e.g., `firebolt`). The value is a table adhering to a schema:
    *   **Basic Info:** `id`, `name`, `description`.
    *   **Mechanics:** `attackType` (`projectile`, `remote`, `zone`, `utility`), `castTime`, `cost` (array of token types like `Constants.TokenType.FIRE`). If a `getCost` function is provided it will be used at runtime instead of the static table.
    *   **`keywords`:** **The core.** A table mapping keyword names (from `keywords.lua`) to parameter tables (e.g., `damage = { amount = 10 }`, `elevate = { duration = 5.0 }`). Parameters can be static values or functions.

    The optional `getCost(caster, target)` function allows a spell's mana cost to change based on game state. It should return a table of token types just like the static `cost` field. `getCost` is evaluated each time the spell is queued or affordability is checked.

    **Example:** A spell that gets cheaper as the caster's health drops might be implemented as:

    ```lua
    getCost = function(caster)
        local fireCost = 3
        if caster.health < 75 then fireCost = 2 end
        if caster.health < 40 then fireCost = 1 end
        if caster.health < 20 then fireCost = 0 end
        local t = {}
        for i = 1, fireCost do
            t[i] = Constants.TokenType.FIRE
        end
        return t
    end
    ```
*   **Optional:** `vfx`, `sfx`, `getCastTime` (dynamic cast time function), `getCost` (dynamic mana cost), `onBlock`/`onMiss`/`onSuccess` (legacy callbacks).
*   **Validation:** Includes a `validateSpell` function called at load time to ensure schema adherence and add defaults, printing warnings for issues.

### 3. `spellCompiler.lua` - The Chef

*   **Purpose:** Takes a raw spell definition (`recipe`) from `spells.lua` and "compiles" it into an optimized, executable object, ready to be used in the game.
*   **Compilation (`compileSpell` function):**
    *   Creates a `compiledSpell` table, copying basic properties.
    *   Iterates through the `spellDef.keywords`.
    *   For each keyword, finds the corresponding definition in `keywords.lua`.
    *   Merges default keyword `behavior` with spell-specific `params` into `compiledSpell.behavior[keyword]`.
    *   Binds the `keywords.lua` `execute` function to `compiledSpell.behavior[keyword].execute`.
*   **Execution (`executeAll` method):**
    *   Adds an `executeAll` method to the `compiledSpell` object.
    *   Called by `Wizard:castSpell` when a spell finishes casting.
    *   Iterates through all behaviors defined in `compiledSpell.behavior`.
    *   Calls the bound `execute` function for each keyword, passing context (`caster`, `target`) and an **empty `events` table**.
    *   Keywords populate the `events` table.
    *   Calls `EventRunner.processEvents(events, ...)` to handle the generated events.
    *   Returns a `results` table (combining legacy results and the `EventRunner` summary).
*   **Configuration:** Includes toggles (`setUseEventSystem`, `setDebugEvents`) for debugging and controlling the execution path.

### 4. `systems/EventRunner.lua` - The Waiter

*   **Purpose:** Takes the list of raw events generated by `compiledSpell.executeAll` and applies their effects to the actual game state in a controlled, ordered manner.
*   **Structure:**
    *   `PROCESSING_PRIORITY`: Defines the order for processing different event types (e.g., state changes before damage).
    *   `EVENT_HANDLERS`: A table mapping event type strings (e.g., `"DAMAGE"`, `"APPLY_STATUS"`) to handler functions.
    *   `resolveTarget`: Helper to find the target game object(s) based on event data (e.g., `"self"`, `"enemy"`, `"enemy_slot"`).
*   **Processing Flow (`processEvents` function):**
    *   Receives the `events` list, `caster`, `target`, `spellSlot`.
    *   Sorts events based on `PROCESSING_PRIORITY`.
    *   Iterates through sorted events.
    *   Looks up the appropriate handler in `EVENT_HANDLERS` using `event.type`.
    *   Calls the handler function (`handleEvent`).
    *   **Handlers modify state:** The specific handler function (e.g., `EVENT_HANDLERS.DAMAGE`) uses `resolveTarget` and then directly modifies game state (e.g., `targetEntity.health -= event.amount`) or calls appropriate object methods (e.g., `wizard:resetSpellSlot`, `manaPool:addToken`). Handlers also trigger VFX.
    *   Returns a summary of processed events and effects.

## Interaction Flow Example (Firebolt)

1.  **Definition (`spells.lua`):** Defines `Spells.firebolt` using the `damage` keyword from `keywords.lua` with params `{ amount = 10, type = "fire" }`.
2.  **Compilation (`spellCompiler.lua`):** At game load, `compileSpell` processes `Spells.firebolt`, creating `compiledSpell` linking the `damage` keyword logic and params.
3.  **Casting (`wizard.lua`):** Player casts Firebolt; `Wizard:castSpell` calls `compiledSpell.executeAll`.
4.  **Execution & Event Generation (`spellCompiler.lua` -> `keywords.lua`):** `executeAll` calls the `damage` keyword's `execute` function, passing an `events` table. `damage.execute` adds `{ type="DAMAGE", target="enemy", amount=10, damageType="fire" }` to the `events` table.
5.  **Event Processing (`spellCompiler.lua` -> `EventRunner.lua`):** `executeAll` calls `EventRunner.processEvents` with the `events` list.
6.  **State Modification (`EventRunner.lua`):** `processEvents` sorts events, finds the `DAMAGE` handler, resolves the target to the enemy wizard, and executes `target.health = target.health - 10`. Triggers VFX.
7.  **Result:** Enemy health updated. `processEvents` returns summary. `executeAll` returns results to `castSpell`.

---

This modular system allows defining complex spell effects by combining simple, reusable keywords. The event-based execution ensures effects are applied consistently and in the correct order, making the system easier to manage and extend.

## docs/status_effects.md
# Status Effects

This document lists the built-in status effects available in the game and their expected behavior. All status types are defined in `core/Constants.lua` under `Constants.StatusType`.

## Available Statuses

| Status | Description |
|--------|-------------|
| `BURN` | Deals periodic damage over time. Damage ticks use `tickDamage` at intervals defined by `tickInterval` for the duration of the effect. |
| `SLOW` | Increases the cast time of the next spell by `magnitude` seconds. Can optionally target a specific slot. Consumed after affecting a cast or when the duration expires. |
| `STUN` | Prevents the affected wizard from keying or casting spells for the duration. |
| `REFLECT` | Causes the wizard to reflect incoming spells while active. |

## Usage

Status effects are applied through `APPLY_STATUS` events emitted by keywords or spell logic. Event handlers store the effect data on the target wizard in the `statusEffects` table.

```lua
-- Example APPLY_STATUS event
{
    type = "APPLY_STATUS",
    source = "caster",
    target = "enemy",
    statusType = Constants.StatusType.BURN,
    duration = 3.0,
    tickDamage = 2,
    tickInterval = 1.0
}
```

The `EventRunner` module processes these events and manages status state each frame.

## docs/token_lifecycle.md
# Mana Token Lifecycle State Machine

## Overview
This document describes the token lifecycle system in Manastorm, which handles the transition of mana tokens between various states, from creation to destruction.

## Implementation Status

The token lifecycle system is implemented in the following files:
- `core/Constants.lua` - Defines the TokenStatus enum
- `manapool.lua` - Implements the token methods and updates the mana pool update loop to drive animations
- Future tickets will update all token acquisition and return points to use the new methods

## States

```
+-------+    channeling    +------------+    shield creation    +-----------+
| FREE  |----------------->| CHANNELED  |-------------------->  | SHIELDING |
+-------+                  +------------+                       +-----------+
   ^                           |    |                               |
   |                           |    |                               |
   |                           |    v                               |
   |      animation            |  +------------+                    |
   |<-----------------+--------+  | DISSOLVING |                    |
   |      complete    |           +------------+                    |
   |                  |                 |                           |
   |                  |                 v                           |
   |                  |          +------------+                     |
   |                  +----------| RETURNING  |<--------------------+
   |                             +------------+
   |                                    |
   |                                    v
   |                             +------------+
   +-----------------------------+   POOLED   |
                                 +------------+
```

### State Descriptions

- **FREE**: Token is available in the mana pool for use
- **CHANNELED**: Token is being used for an active spell or ability
- **SHIELDING**: Token is specifically being used as part of a shield
- **RETURNING**: Token is animating back to the mana pool (temporary transition state)
- **DISSOLVING**: Token is being destroyed and will be released back to object pool (temporary transition state)
- **POOLED**: Token is fully released to the object pool and no longer exists in game

## Token Methods

Each token has the following state machine methods:

### setState(newStatus)
- Validates and changes the token's state
- Logs the state transition for debugging
- Maintains backward compatibility with legacy token.state

### requestReturnAnimation()
- Initiates the process of returning a token to the pool
- Validates that token is in CHANNELED or SHIELDING state
- Sets animation parameters and schedules the finalizeReturn callback

### requestDestructionAnimation()
- Initiates the process of dissolving/destroying a token
- Sets animation parameters and schedules the finalizeDestruction callback
- Creates visual effects for the dissolution

### finalizeReturn()
- Called when return animation completes
- Positions the token appropriately in the mana pool
- Resets token properties for its FREE state

### finalizeDestruction()
- Called when dissolve animation completes
- Removes token from the tokens list
- Releases token to the object pool (POOLED state)

## Usage

### Acquiring a Token
```lua
local token, index = manaPool:getToken(tokenType)
-- token.status is now CHANNELED
```

### Returning a Token to Pool
```lua
token:requestReturnAnimation()
-- Animation will play, then token.status will become FREE
```

### Destroying a Token
```lua
token:requestDestructionAnimation()
-- Animation will play, then token will be released to pool
```

### Canceling a Spell with Disjoint (Event-based)
```lua
-- In keywords.lua, the disjoint keyword creates a CANCEL_SPELL event
table.insert(events, {
    type = "CANCEL_SPELL",
    source = "caster",
    target = "enemy_slot", -- Use string that EventRunner understands
    slotIndex = targetSlotIndex,
    returnMana = false -- Key difference for disjoint
})

-- The EventRunner handles the CANCEL_SPELL event and destroys tokens
for _, tokenData in ipairs(slot.tokens) do
    if tokenData.token then
        tokenData.token:requestDestructionAnimation()
    end
end

-- Then it resets the slot without manipulating token states
wizard:resetSpellSlot(slotIndex)
```

## Benefits

1. Encapsulation: Token manages its own lifecycle
2. Clear states: Each token's state is well-defined
3. Animation/Logic Separation: Animation logic is clearly separated from state transition logic
4. Safety: Invalid state transitions are prevented and logged
5. Unified approach: All token handling follows the same pattern
6. Event System Integration: Token lifecycle integrates with the game's event system

## Event System Integration

The token lifecycle system integrates with the event-driven architecture:

1. **CANCEL_SPELL Events**: Handle spell cancellation
   - With `returnMana = true`: Tokens are returned to the pool (dispel)
   - With `returnMana = false`: Tokens are destroyed (disjoint)

2. **Direct vs. Event-Driven Manipulation**:
   - Old approach: Set `token.state = "DESTROYED"` directly
   - New approach: Generate events that call appropriate token methods
   
3. **Decoupled Spell Slot Reset**:
   - `resetSpellSlot` no longer manipulates token states directly
   - All slot resets across the codebase use a centralized method
   - Token animations are requested first, then slot references are cleared later 
   - Clean separation between token state management and slot reset
   - Unified handling of all slot properties (basic, shield, zone, etc.)

## Animation System

The ManaPool:update method now drives token animations based on their status:

- For tokens with status == RETURNING:
  - Updates their return animation progress (moving towards pool center)
  - When animation completes, calls token.animationCallback() which triggers finalizeReturn()

- For tokens with status == DISSOLVING:
  - Updates their dissolve animation progress (scaling/fading)
  - When animation completes, calls token.animationCallback() which triggers finalizeDestruction()

- For each status (FREE, CHANNELED, SHIELDING, LOCKED):
  - Updates positions based on appropriate behavior (orbiting, spell slot, wobbling, etc.)

This separation of concerns ensures that:
1. Animations are consistent and predictable
2. Token state transitions only happen at well-defined points
3. The ManaPool update method is more maintainable, focusing on animation driving rather than state management

## docs/vfxTodo.md
# Spell "Visual Shapes" for Demo
1. Affect Mana Pool (Utility)
2. Barrier (Utility)
3. Wings (Utility)
4. Surge (Utility)
5. Eclipse (Utility)
6. Bolt (Projectile)
7. Beam (Projectile)
8. Zap (Projectile)
9. Orb (Projectile)
10. Blast (Zone)
11. Ground Burst (Zone)
12. Meteor (Zone)
13. Warp (Remote)

## docs/visualShape.md
# visualShape Property in Spell Definitions

## Overview

The `visualShape` property is an optional field in spell definitions that allows overriding the default visual template selection based on attackType. This property gives greater control over the visual representation of spells without requiring custom VFX definitions for every spell variant.

## Purpose

In Manastorm's visual system:

1. By default, the `VisualResolver` selects a base visual template based on a spell's `attackType`:
   - `PROJECTILE` → `proj_base`
   - `REMOTE` → `remote_base`
   - `ZONE` → `zone_base`
   - `UTILITY` → `util_base`

2. The `visualShape` property allows overriding this default mapping to select a more appropriate template.

## Example Use Case

Consider a spell like `Full Moon Beam` which has `attackType = REMOTE` but should visually appear as a beam:

```lua
MoonSpells.fullmoonbeam = {
    id = "fullmoonbeam",
    name = "Full Moon Beam",
    affinity = Constants.TokenType.MOON,
    description = "Channels moonlight into a beam",
    attackType = Constants.AttackType.REMOTE,
    visualShape = "beam",  -- Override to use beam template instead of remote template
    -- other properties...
}
```

Without the `visualShape` property, this spell would use the `remote_base` template (which might be an explosion effect). By setting `visualShape = "beam"`, it will use the `beam_base` template instead.

## Supported Values

The `visualShape` property supports the following values:

- `"beam"` - A sustained beam effect (uses `beam_base` template)
- `"bolt"` or `"orb"` - Projectile effects (use `proj_base` template)
- `"zap"` - Lightning bolt effect (uses `zap_base` template)
- `"blast"` or `"groundBurst"` - Area effects (use `zone_base` template)
- `"warp"`, `"surge"`, or `"affectManaPool"` - Utility effects (use `util_base` template)
- `"wings"` or `"mirror"` - Shield/barrier effects (use `shield_overlay` template)
- `"eclipse"` - Special effect (uses a specialized template)

## Implementation Details

1. The spell definition includes a `visualShape` property.
2. This property is carried through to the compiled spell.
3. When the spell is cast, the VisualResolver checks for this property in the event.
4. If found, it overrides the template selection logic to use the specified template instead of the default based on attackType.

## Benefits

- Maintains the benefit of the rules-driven VFX system while allowing visual customization
- Allows spells with the same attackType to have different visual styles
- Reduces the need for custom VFX definitions for every spell
- Separates the gameplay behavior (attackType) from visual representation (visualShape)

## Relationship with Other VFX Properties

The `visualShape` property works alongside other VFX-related properties:

- `vfx`: Directly specifies a VFX template (highest priority, bypasses VisualResolver)
- `visualShape`: Overrides the base template selection in VisualResolver
- `attackType`: Default method for determining base template (lowest priority)

## Example Implementation Flow

1. Spell definition includes `visualShape = "beam"`
2. Spell is cast, generates a DAMAGE event
3. DAMAGE handler creates an EFFECT event with the same visualShape
4. VisualResolver receives the event with visualShape property
5. VisualResolver maps "beam" to beam_base template
6. VFX is rendered using the beam_base template with appropriate colors and modifiers based on spell affinity

## docs/wizard.md
# Wizard Module (`wizard.lua`)

## Overview

The `wizard.lua` module defines the "class" for the player characters in Manastorm. It encapsulates the state, capabilities, and core logic for each wizard participating in the duel. This includes handling health, position, status effects, spellcasting (keying, channeling, casting, shielding), input interpretation (via delegation), updates, and drawing.

## Key Components

### 1. State Variables

Each `Wizard` instance maintains a comprehensive set of state variables:

*   **Identity & Position:** `name`, `x`, `y`, `color`.
*   **Combat:** `health`.
    * `statusEffects[Constants.StatusType.STUN]`: Tracks stun duration.
*   **Positioning:**
    *   `elevation`: String ("GROUNDED" or "AERIAL").
    *   `elevationTimer`: Duration for temporary AERIAL state.
    *   `currentXOffset`, `currentYOffset`: Calculated visual offsets based on game range state (`NEAR`/`FAR`) and elevation, used for drawing.
*   **Status Effects:** `statusEffects` table (e.g., `statusEffects.burn` tracks active state, duration, tick damage, timers).
*   **Spellcasting State:**
    *   `spellbook`: Table mapping key combinations ("1", "12", "123") to specific spell definitions from `SpellsModule`. Unique per wizard name ("Ashgar", "Selene").
    *   `activeKeys`: Table tracking pressed state of spell keys [1], [2], [3].
    *   `currentKeyedSpell`: Reference to the spell definition matching `activeKeys`.
    *   `spellSlots`: Array of 3 tables, each representing a casting/shield slot. Tracks:
        *   `active`: Boolean indicating if the slot is in use.
        *   `progress`: Current casting time elapsed.
        *   `castTime`: Total time required to cast the spell (can be dynamic).
        *   `spell`: Reference to the compiled spell object.
        *   `spellType`: Name of the spell.
        *   `tokens`: Array table holding references to mana tokens ({token=..., index=...}) currently channeled or part of a shield in this slot.
        *   `isShield`: Boolean indicating if the slot holds an active shield.
        *   `defenseType`: String ("barrier", "ward", "field") for shield type.
        *   `blocksAttackTypes`: Table mapping attack types this shield blocks.
        *   `reflect`: Boolean indicating if the shield reflects damage.
        *   `frozen`: Boolean indicating if the spell cast is paused (e.g., by Eclipse Echo).
        *   `freezeTimer`: Remaining duration for the frozen state.
*   **Visuals:** `sprite` (loaded image), `scale`, `blockVFX` (timer/state for block visuals).
*   **References:** `manaPool` (instance of ManaPool), `gameState` (reference to the global `game` table in `main.lua`).

### 2. Core Methods

*   **`Wizard.new(name, x, y, color, spellbook)`:** Constructor. Initializes all state variables, loads sprite, and assigns the provided `spellbook`.
*   **`Wizard:update(dt)`:** Per-frame update logic. Manages timers (stun, elevation, status effects), applies burn damage ticks, updates shield token orbits, increments spell casting `progress`. Calls `castSpell` upon completion.
*   **`Wizard:draw()`:** Main drawing function. Draws the wizard sprite (applying offsets/effects), elevation visuals, status bars (`drawStatusEffects`), and spell slots (`drawSpellSlots`).
*   **`Wizard:drawSpellSlots()`:** Visualizes casting/shields. Draws elliptical orbits, progress arcs (colored by state: casting, shield, frozen), shield type names, and orbiting mana tokens (with Z-ordering for depth).
*   **`Wizard:keySpell(keyIndex, isPressed)`:** Updates `activeKeys` and `currentKeyedSpell` based on player input.
*   **`Wizard:castKeyedSpell()`:** Entry point for casting. Checks stun state, validates `currentKeyedSpell`, and calls `queueSpell`.
*   **`Wizard:queueSpell(spell)`:** Initiates spell casting.
    *   Finds an available `spellSlot`.
    *   Checks mana availability using `canPayManaCost`.
        *   If the spell defines `getCost`, that function is called with `caster` and `target` to determine the token list.
    *   If affordable, acquires token references from `manaPool` via reservations.
    *   Sets token state to `CHANNELED`.
    *   Sets up animation parameters for tokens (Bezier curve towards wizard).
    *   Activates the `spellSlot`, storing spell info and cast time.
    *   Flags slot if it `willBecomeShield`.
*   **`Wizard:castSpell(spellSlot)`:** Executes the spell effect when casting completes.
    *   Performs preemptive shield check on the target (`checkShieldBlock`).
    *   If blocked: calls `target:handleShieldBlock`, returns caster's tokens, resets caster's slot (`resetSpellSlot`).
    *   If not blocked: Executes spell logic via `spell.executeAll` (compiled) or legacy system.
    *   Interprets returned `effect` table:
        *   Shield Spells: Calls local `createShield` helper, potentially applies elevation, leaves slot active with tokens (`isShield=true`).
        *   Normal Spells: Applies damage (`target.health`), status effects (burn, stun), position changes (range, elevation), mana manipulation (lock, delay) based on `effect` table. Returns caster's tokens (`requestReturnAnimation`/`manaPool:returnToken`), resets caster's slot (`resetSpellSlot`).
*   **`Wizard:handleShieldBlock(slotIndex, blockedSpell)`:** (Called on the target wizard). Consumes tokens from the specified shield slot based on `blockedSpell.shieldBreaker`, returns consumed tokens, and calls `resetSpellSlot` if the shield breaks (runs out of tokens).
*   **`Wizard:resetSpellSlot(slotIndex)`:** Utility function to reset all properties of a spell slot to default/inactive state and clear its token list. Used after normal casts, cancellations, or shield breaks.
*   **`Wizard:canPayManaCost(costOrFn[, target])`:** Checks if a mana cost can be paid without consuming tokens. `costOrFn` may be a static table or the `getCost` function from a spell definition. The function returns a reservation detail table or `nil` if the cost can't currently be met.
*   **`Wizard:freeAllSpells()`:** Cancels all active spells/shields, returns their tokens, and resets the corresponding slots.

### 3. Token Interaction

The Wizard module interacts heavily with the `ManaPool` and individual token objects:

*   Uses `canPayManaCost` to check availability.
*   Reserves tokens during `queueSpell`.
*   Sets token state to `CHANNELED`.
*   Manages token position updates *while they are animating towards or orbiting the wizard*.
*   Initiates token return via `token:requestReturnAnimation()` (preferred) or `manaPool:returnToken()` (fallback).
*   Shields maintain references to their tokens; `handleShieldBlock` removes tokens from the target's shield slot and initiates their return.

### 4. Potential Cleanup Areas

*   Consider factoring to smaller modules.

## Dependencies

*   `core.Constants`
*   `core.AssetCache`
*   `spells` (SpellsModule)
*   `manapool` (via `self.manaPool` reference)
*   Global `game` state (via `self.gameState` reference) for accessing `vfx`, `wizards` list, `rangeState`.
*   Local `getCompiledSpell` helper (defined within `wizard.lua`)
*   Local `checkShieldBlock` helper (defined within `wizard.lua`)
*   Local `createShield` helper (defined within `wizard.lua`) 

## ./AGENTS.md
Prime for development on _Manastorm_, a strategic action game of magical dueling, using the following docs as your primary entry points:

* CrashCourse.md
* DevelopmentGuidelines.md

You will want to explore the "docs" folder and the relevant Lua code related to some specific bug or feature request once you have gotten your bearing with the above documents. You can assume the content of the "Tickets" folder to have already been completed unless directed there explicitly for tasks.

## ./ComprehensiveDesignDocument.md
Game Title: Manastorm (working title)

Genre: Tactical Wizard Dueling / Real-Time Strategic Battler

Target Platforms: PC (initial), with possible future expansion to consoles

Core Pitch:

A high-stakes, low-input real-time dueling game where two spellcasters 
clash in arcane combat by channeling mana from a shared pool to queue 
spells into orbiting "spell slots." Strategy emerges from a shared 
resource economy, strict limitations on casting tempo, and deep 
interactions between positional states and spell types. Think Street 
Fighter meets Magic: The Gathering, filtered through an occult operating 
system.

Core Gameplay Loop:

Spell Selection Phase (Pre-battle)

Each player drafts a small set of spells from a shared pool.

These spells define their available actions for the match.

OR

Character Select Phase (Pre-battle)

Each player selects a character with a unique spellbook from a fighting-game style roster.

Combat Phase (Real-Time)

Players queue spells from their loadout (max 3 at a time).

Each spell channels mana from a shared pool and takes time to resolve.

Spells resolve in real-time after a fixed cast duration.

Cast spells release mana back into the shared pool, ramping intensity.

Positioning states (NEAR/FAR, GROUNDED/AERIAL) alter spell legality and 
effects.

Players win by reducing the opponent’s health to zero.

Key Systems & Concepts:

1. Spell Queue & Spell Slots

Each player has 3 spell slots.

Spells are queued into slots using hotkeys (Q/W/E or similar).

Each slot is visually represented as an orbit ring around the player 
character.

Channeled mana tokens orbit in these rings.

2. Mana Pool System

A shared pool of mana tokens floats in the center of the screen.

Tokens are temporarily removed when used to queue a spell.

Upon spell resolution, tokens return to the pool.

Tokens have types (e.g. FIRE, VOID, WATER), which interact with spell 
costs and effects.

The mana pool escalates tension by becoming more dynamic and volatile as 
spells resolve.

3. Token States

FREE: Available in the pool.

CHANNELED: Orbiting a caster while a spell is charging.

LOCKED: Temporarily unavailable due to enemy effects.

DESTROYED: Rare, removed from match entirely.

4. Positional States

Each player exists in binary positioning states:

Range: NEAR / FAR

Elevation: GROUNDED / AERIAL

Many spells can only be cast or take effect under certain conditions.

Players can be moved between states via spell effects.

5. Cast Feedback (Diegetic UI)

Each spell slot shows its cast time progression via a glowing arc rotating 
around the orbit.

Players can visually read how close a spell is to resolving.

No abstract bars; all feedback is embedded in the arena.

6. Spellbook System

Players have access to a limited loadout of spells during combat.

A separate spellbook UI (toggleable) shows full names, descriptions, and 
mechanics.

Core battlefield UI remains minimal to prioritize visual clarity and 
strategic deduction.

Visual & Presentation Goals

Combat is side-view, 2D.

Wizards are expressive but minimal sprites.

Mana tokens are vibrant, animated symbols.

All key mechanics are visible in-world (tokens, cast arcs, positioning 
shifts).

No HUD overload; world itself communicates state.

Design Pillars

Tactical Clarity: All decisions have observable consequences.

Strategic Literacy: Experienced players gain advantage by reading visual 
patterns.

Diegetic Information: The battlefield tells the story; minimal overlays.

Shared Economy, Shared Risk: Players operate in a closed loop that fuels 
both offense and defense.

Example Spells (Shortlist)

Ashgar the Emberfist:

Firebolt: Quick ranged hit, more damage at FAR.

Meteor Dive: Aerial finisher, hits GROUNDED enemies.

Combust Lock: Locks opponent mana token, punishes overqueueing.

Selene of the Veil:

Mist Veil: Projectile block, grants AERIAL.

Gravity Pin: Traps AERIAL enemies.

Eclipse Echo: Delays central queued spell.

Target Experience

Matches last 2–5 minutes.

Constant mental engagement without twitchy inputs.

Read-your-opponent mind games and counterplay at the forefront.

Replayable duels with high skill ceiling and unique matchups.

This document will evolve, but this version represents the intended 
holistic vision of the gameplay experience, tone, and structure of 
Manastorm.

## ./CrashCourse.md
Manastorm Crash Course: Welcome to the Ninefold Circle!
Purpose: To quickly bring new contributors up to speed on the overall architecture and key systems of Manastorm.
Target Audience: Developers new to the Manastorm codebase.
1. Introduction: What is Manastorm?
Manastorm is a real-time tactical wizard dueling game. Two spellcasters face off, drawing mana from a shared central pool to queue and cast spells. The core gameplay revolves around:
Shared Resource Economy: Both players draw from the same mana pool.
Casting Tempo: Spells take time to charge, creating windows of opportunity and vulnerability.
Positional Strategy: NEAR/FAR range and GROUNDED/AERIAL elevation states significantly impact spell legality and effects.
Diegetic UI: Game information is primarily conveyed through in-world visual cues rather than traditional HUD elements.
(Refer to ComprehensiveDesignDocument.md for the full vision.)
2. Core Architectural Pillars
The game is built around several key interconnected systems:
Game Loop & State (main.lua):
Manages the main game states (MENU, CHARACTER_SELECT, BATTLE, GAME_OVER, BATTLE_ATTRACT, etc.).
Handles love.load(), love.update(), love.draw(), and input routing via core/Input.lua.
The global game table holds references to major game objects and state (wizards, mana pool, VFX system, etc.).
Wizards (wizard.lua):
The primary actors in the game. Each wizard has health, spell slots, a spellbook, and manages their current state (elevation, status effects).
Spellcasting: Wizards don't cast spells instantly. They:
Key Spells: Players press key combinations (e.g., Q, W, E or Q+W) to select a spell from their spellbook.
Queue Spells: If a slot is available and mana cost can be paid, the spell is queued into an orbiting spell slot. Mana tokens are acquired from the ManaPool and animated towards the wizard.
Channeling: The spell "charges" in the slot, visually represented by a progress arc.
Resolution: Once charged, Wizard:castSpell() is called.
(See docs/wizard.md for more details.)
Mana Pool (manapool.lua):
A shared, central pool of mana tokens.
Tokens have types (Constants.TokenType) and states (Constants.TokenStatus - FREE, CHANNELED, SHIELDING, RETURNING, DISSOLVING, POOLED).
Manages token animations (orbiting in the pool, moving to/from wizards).
Employs object pooling (core/Pool.lua) for token objects to reduce garbage collection.
(See docs/manapool.md and docs/token_lifecycle.md for more details.)
Spell System (The "Triune Spell Engine"):
keywords.lua (Ingredients): Defines atomic game actions (e.g., damage, elevate, conjure). Each keyword has a behavior (metadata) and an execute function.
Crucially, keyword execute functions generate events describing state changes, rather than directly modifying game state.
spells/ directory (Recipes): Spell definitions are organized by element (e.g., spells/elements/fire.lua). Each spell is a table combining keywords with specific parameters (e.g., damage = { amount = 10, type = "fire" }).
spellCompiler.lua (Chef): Takes raw spell definitions and "compiles" them into executable objects. It merges keyword behaviors and binds their execute functions. The compiled spell's executeAll() method is called by Wizard:castSpell().
(See docs/spellcasting.md and docs/keywords.lua [generated] for more details.)
Event System (systems/EventRunner.lua):
The Core of Gameplay Logic Application. After compiledSpell.executeAll() generates a list of events, the EventRunner processes them.
Events have a type, source, target, and event-specific data.
The EventRunner sorts events by PROCESSING_PRIORITY and calls specific handler functions from EventRunner.EVENT_HANDLERS for each event type.
It is these handlers within EventRunner that actually modify the game state (e.g., wizard health, token states, VFX triggers).
(See docs/combat_events.md for the event schema.)
Visual Effects (VFX) System (vfx.lua & systems/VisualResolver.lua):
Rule-Driven: Most VFX are not manually specified per spell. Instead, the VisualResolver inspects metadata within EFFECT events (like affinity, attackType, visualShape, manaCost, tags) to pick a base VFX template and its parameters (color, scale, motion).
vfx.lua contains base effect templates (e.g., proj_base, beam_base) and the logic to update and draw active visual effects. It also uses object pooling for effects and particles.
Specific named effects (like meteor) exist for more unique visuals.
(See docs/Visual_Language.md, docs/AddingVisualTemplates.md, and VFX-RulesBasedRefactor-GamePlan.md.)
AI System (ai/):
OpponentAI.lua: Provides the core FSM (Idle, Attack, Defend, etc.) and Perception-Decision-Action loop.
PersonalityBase.lua: Defines an interface for character-specific AI behavior.
ai/personalities/: Contains specific AI logic for different wizards (e.g., SelenePersonality.lua). Personalities suggest spells and can influence state transitions.
The AI interacts with its wizard object via the same API as a human player would (e.g., wizard:queueSpell()), not by simulating key presses.
Core Utilities (core/):
Constants.lua: Centralized string constants. Crucial for avoiding magic strings.
AssetCache.lua: Prevents duplicate loading of images and sounds.
Pool.lua: Generic object pooling system.
Input.lua: Unified input routing. Uses an action-based scheme defined in
  `Constants.ControlAction`. Keyboard and gamepad bindings are loaded from
  Settings.lua and can be changed at runtime.
Settings.lua: Handles persistent game settings.
assetPreloader.lua: Manages preloading of assets.
3. Key Interactions & Data Flow
Player Input (core/Input.lua) -> Wizard (wizard.lua):
Keys pressed are routed to wizard:keySpell() to select a spell, then wizard:castKeyedSpell() calls wizard:queueSpell().
Spell Queuing (wizard.lua):
wizard:canPayManaCost() checks ManaPool.
TokenManager.acquireTokensForSpell() moves tokens from ManaPool to wizard.spellSlots[i].tokens (state: CHANNELED).
Spell slot becomes active; casting progress begins.
Spell Resolution (wizard.lua -> spellCompiler.lua -> keywords.lua):
When slot.progress >= slot.castTime, wizard:castSpell() is called.
compiledSpell.executeAll() (from spellCompiler) iterates through the spell's keywords.
Each keyword's execute() function is called, adding descriptive events to a list.
Event Processing (spellCompiler.lua -> systems/EventRunner.lua):
executeAll() passes the generated event list to EventRunner.processEvents().
EventRunner sorts events and calls the appropriate handler for each.
State Mutation & VFX Triggering (systems/EventRunner.lua):
Event handlers modify game state (e.g., targetWizard.health -= event.amount).
For visual changes, handlers often generate an EFFECT event.
The EFFECT event handler calls VisualResolver.pick(event) to determine the baseEffectName and vfxOpts.
Then, VFX.createEffect(baseEffectName, ..., vfxOpts) is called to create the visual.
Visual Rendering (vfx.lua, systems/WizardVisuals.lua):
VFX.update() and VFX.draw() manage active visual effects.
WizardVisuals.drawWizard() handles drawing the wizard sprite, spell slots, and status effects.
4. Current Development Focus
"Game Juice": Enhancing visual and audio feedback to make gameplay feel more impactful and satisfying.
Content Creation: Adding new spells, characters, and potentially AI personalities.
Balancing: Tweaking spell costs, cast times, and effects.
5. Getting Started
Read the Docs: Start with ComprehensiveDesignDocument.md, README.md, then dive into system-specific docs relevant to your task (e.g., spellcasting.md, VFX-RulesBasedRefactor-GamePlan.md).
Trace a Spell: Pick a simple spell (e.g., Firebolt). Trace its definition in spells/elements/fire.lua, its keywords in keywords.lua, how spellCompiler.lua prepares it, how wizard.lua casts it, how EventRunner.lua processes the resulting events, and how vfx.lua (via VisualResolver.lua) displays it.
Look at Tickets: The Tickets/ directory shows recent work and priorities, which can give context to code changes.

## ./DevelopmentGuidelines.md
Manastorm Development Guidelines
Purpose: To establish conventions and best practices for coding new features and refactoring existing systems in Manastorm, ensuring consistency and maintainability.
I. General Principles
Modularity:
Keep systems decoupled. Favor communication through well-defined interfaces or events.
New major functionalities should generally reside in their own modules within appropriate directories (e.g., systems/, ai/, core/).
Avoid "god objects"; delegate responsibilities to specialized modules.
Data-Driven Design:
Prefer defining game entities (spells, character stats, AI behaviors) in Lua tables rather than hardcoding logic. This is evident in spells/, keywords.lua, and ai/personalities/.
This makes balancing and content creation easier.
Event-Driven Architecture (for Gameplay Logic):
Primary Rule: Changes to game state (wizard health, token status, positions, status effects) resulting from spell effects must be processed through the EventRunner.
Keywords and spell logic should generate descriptive events, not directly mutate state.
Refer to docs/combat_events.md for the event schema.
Use EventRunner.queueVisual() (or generate an EFFECT event) for triggering VFX from game systems outside direct spell casts (e.g., token destruction animations).
Use Constants (core/Constants.lua):
Strictly avoid magic strings for anything that represents a defined game state, type, or category (e.g., "fire", "AERIAL", "projectile").
Always use Constants.TokenType.FIRE, Constants.ElevationState.AERIAL, Constants.AttackType.PROJECTILE, etc.
Add new constants to core/Constants.lua as needed, following existing naming conventions.
Run tools/check_magic_strings.lua periodically or as a pre-commit hook.
Readability & Clarity:
Write clear, self-documenting code where possible.
Use meaningful variable and function names.
Add comments to explain complex logic or non-obvious decisions.
Performance Considerations:
Object Pooling: For frequently created/destroyed objects (mana tokens, VFX particles, VFX effect containers), use the core/Pool.lua system. Ensure resetFn thoroughly clears all object fields.
Asset Caching: All image and sound loading must go through core/AssetCache.lua to prevent duplicate loads.
Avoid heavy computations in love.update() or love.draw() where possible. Profile if performance issues arise.
II. Specific System Guidelines
Adding New Spells:
Define the spell in the appropriate spells/elements/your_element.lua file.
Adhere to the schema in spells/schema.lua (id, name, affinity, description, attackType, castTime, cost, keywords, visualShape (optional)).
Compose spell effects using existing keywords from keywords.lua. If new mechanics are needed, define new keywords first.
Spell visualShape and affinity will primarily drive visuals via VisualResolver. Only use the vfx keyword with effectOverride for truly unique cinematic effects.
Update characterData.lua if the spell is part of a default spellbook or the character's general spell list for the Compendium.
Add to game.unlockedSpells in main.lua if it's unlockable.
Modifying or Adding Keywords (keywords.lua):
Event Generation: The execute function must add events to the passed-in events table. It should not directly modify caster, target, or gameState.
Parameters: Keyword parameters defined in spells.lua can be static values or functions (resolved by keywords.lua.resolve()).
Dynamic Costs: Spells may include a `getCost(caster, target)` function which returns a token cost table at runtime. Use this for mechanics like health-scaled or target-dependent costs.
Metadata: Keep the behavior table updated with descriptive flags, targetType, and category.
VFX: Keywords generally should not trigger VFX directly. Instead, the events they generate (e.g., DAMAGE, SET_ELEVATION) will be picked up by EventRunner, which then uses VisualResolver for VFX. If a keyword has a unique, inherent visual distinct from its gameplay event (rare), it can generate a specific EFFECT event.
Documentation: Update docs/keywords.lua (or ensure it's auto-generated) if adding or significantly changing a keyword.
Visual Effects (VFX - vfx.lua, systems/VisualResolver.lua):
Rule-Driven First: Strive to have visuals determined by VisualResolver based on event metadata (affinity, attackType, visualShape, manaCost, tags).
Base Templates: Add to or modify base templates in VFX.effects (e.g., proj_base, beam_base) to handle parameters like color, scale, and motion style.
Motion Styles: Utilize Constants.MotionStyle and implement the corresponding logic in VFX.updateParticle.
Constants.VFXType: Add new base template names or unique override effect names to Constants.VFXType.
Asset Handling: Add asset paths to VFX.assetPaths. Critical assets needed immediately should be preloaded in VFX.init(); others will be lazy-loaded via getAssetInternal.
(Refer to docs/AddingVisualTemplates.md and VFX-RulesBasedRefactor-GamePlan.md.)
AI Personalities (ai/personalities/):
Create new personality files that implement the interface defined in ai/PersonalityBase.lua.
Personality modules are responsible for spell selection logic for a specific character.
Keep the core OpponentAI.lua generic; character-specific logic belongs in personality modules.
AI actions should use wizard:queueSpell(), not simulate input.
Input Handling:
  The game uses an action-based input layer. All actions are defined in
  `Constants.ControlAction`. Default bindings for keyboard and gamepad live in
  `core/Settings.lua` and can be rebound at runtime through the Settings menu.
UI (ui.lua, main.lua draw functions):
Strive for diegetic UI where possible (information integrated into the game world).
Keep UI drawing logic separate from game state update logic.
For complex UI elements, consider dedicated update/draw functions within ui.lua.
State Management & Game Logic:
EventRunner is King: Gameplay state changes resulting from spell effects must go through the EventRunner.
Wizard Object: Owns its immediate state (health, slots, current keyed spell, position).
_G.game Table: Holds global game state and references to major systems. Use judiciously.
main.lua: Orchestrates system updates and drawing based on game.currentState.
Asset Handling:
core/AssetCache.lua: All static file-based assets (images, sounds) must be loaded via AssetCache.getImage() or AssetCache.getSound().
core/assetPreloader.lua: Add paths for new assets to assetManifest to ensure they are preloaded at game start, preventing hitches. For VFX assets, also add paths to VFX.assetPaths in vfx.lua for lazy loading fallback/management.
III. Coding Conventions
Naming:
Modules / "Classes": PascalCase (e.g., OpponentAI, VisualResolver).
Functions / Methods: camelCase (e.g., requestReturnAnimation, canPayManaCost).
Local Variables: camelCase.
Constants: ALL_CAPS_SNAKE_CASE (e.g., Constants.TokenType.FIRE).
Private module functions (not intended for export): prefix with _ (e.g., _privateHelperFunction).
Comments:
Use LuaDoc-style comments for public functions/methods in modules (--- Description \n -- @param name type \n -- @return type).
Add inline comments for complex or non-obvious logic.
Use TODO:, FIXME:, NOTE: prefixes for actionable comments.
Error Handling & Logging:
Use pcall() for operations that might fail (e.g., file loading, external calls if any).
Use print("ERROR: ...") or print("WARNING: ...") for logging issues.
Leverage core/Log.lua (Log.debug(...)) for verbose development logs, which can be toggled.
Constants: Reiterate: No magic strings.
Global State:
Minimize direct modification of _G.game from modules other than main.lua. Systems should generally read from _G.game or have necessary parts passed to them.
Functions within modules should operate on self or passed-in parameters.
IV. Testing
Unit Tests (Informal): While a formal unit testing framework isn't in place, consider writing small, isolated test functions within modules or in tools/ to verify specific logic, especially for utility functions or complex algorithms.
V. Documentation
Update Existing Docs: If a change impacts a system described in docs/, update the relevant markdown file.
New Systems: Create new markdown documents in docs/ for significant new systems or architectural patterns.
Code Comments: Keep docblocks and inline comments current.

## ./README.md
# Manastorm

A tactical wizard dueling game built with LÖVE (Love2D).

## Description

Manastorm is a real-time strategic battler where two spellcasters clash in arcane combat by channeling mana from a shared pool to queue spells into orbiting "spell slots." Strategy emerges from a shared resource economy, strict limitations on casting tempo, and deep interactions between positional states and spell types.

## Requirements

- [LÖVE](https://love2d.org/) 11.4 or later

## How to Run

1. Install LÖVE from [love2d.org](https://love2d.org/)
2. Clone this repository
3. Run the game:
   - On Windows: Drag the folder onto love.exe, or run `"C:\Program Files\LOVE\love.exe" path\to\Manastorm`
   - On macOS: Run `open -n -a love.app --args $(pwd)` from the Manastorm directory
   - On Linux: Run `love .` from the Manastorm directory

## Controls

Manastorm uses an **action-based** input layer. Each action is defined in
`Constants.ControlAction` and can be bound independently for keyboard or
gamepad via the Settings menu. The mappings below reflect the defaults shipped
with the game.

### Default Keyboard Mapping

**Player 1**

- Q / W / E: Spell slots 1–3
- F: Cast (also acts as menu confirm)
- G: Free spells (also acts as menu cancel)
- B: Toggle spellbook
- Arrow Keys: Menu navigation

**Player 2**

- I / O / P: Spell slots 1–3
- J: Cast
- H: Free spells
- M: Toggle spellbook

### Default Gamepad Mapping

Gamepad controls mirror the keyboard actions. Use the D-pad for spell slots and
menu navigation. The **A** button casts or confirms, **Y** frees or cancels, and
**B** toggles the spellbook. When a second gamepad is connected these mappings
apply to Player 2 as well.

### General
- ESC: Quit the game

## Unlocking Characters

Casting any Salt-affinity spell during a match unlocks the wizard **Silex** for
future character selection.

## Debug Logging

Verbose debug output can be toggled at runtime. Require the `core.Log` module and
call `Log.setVerbose(true)` to enable detailed logging. Set it to `false` (the
default) to silence development traces.

## Development Status

This is a late prototype with basic full engine functionality:
- Two opposing wizards with health bars
- Shared mana pool with floating tokens
- Three spell slots per wizard with visual feedback
- Simple spatial state representation (NEAR/FAR, GROUNDED/AERIAL)
- Data-driven VFX engine (actual visuals are still rough)
- Various spell types with unique mechanics: Attack, Utility, Shield, Trap (with various subtypes of each)
- Various spell keywords with rigorously defined mechanics.
- "Triune Spell Engine" custom DSL/data-driven format for defining spells in terms of keywords. Spells are "compiled" at runtime from keyword-based definitions which can be authored using any convenient tool.

## Next Steps

- Polish VFX and add SFX. Use consistent design language driven by TSE spell definitions.
- Add basic main menu, mode select, control customization.
- Add AI opponent (strategy design pattern).
- Add content. Lots of content. Lots and lots and lots of content.

## ./SFX_GATING_IMPLEMENTATION.md
# SFX Gating Implementation

## Overview
The SFX gating system prevents crashes when sound files are missing or corrupted during development. All sound-related operations are now conditional based on an `ENABLE_SFX` configuration flag.

## Changes Made

### 1. Settings Module (`core/Settings.lua`)
- Added `ENABLE_SFX = false` to the defaults configuration
- This disables SFX by default during development

### 2. VFX Module (`vfx.lua`)
- Added Settings import
- Added `VFX.isSFXEnabled()` helper function
- Modified sound loading to check `ENABLE_SFX` before attempting to load sounds
- Added error handling with `pcall` for sound loading
- Modified sound playing to check `ENABLE_SFX` before playing
- Added documentation comments

### 3. AssetCache Module (`core/AssetCache.lua`)
- Added Settings import
- Modified `getSound()` function to check `ENABLE_SFX` before loading
- Modified `preload()` function to skip sound loading when SFX is disabled
- Added appropriate logging messages

### 4. Main Module (`main.lua`)
- Modified sound play operation in slot highlighting to check `ENABLE_SFX`

## How to Enable SFX

### Method 1: Edit settings.lua
```lua
return {
    dummyFlag = false,
    gameSpeed = "FAST",
    ENABLE_SFX = true,  -- Enable SFX
    controls = {
        -- ... rest of settings
    }
}
```

### Method 2: Programmatically
```lua
local Settings = require("core.Settings")
Settings.set("ENABLE_SFX", true)
```

### Method 3: Check SFX Status
```lua
local VFX = require("vfx")
if VFX.isSFXEnabled() then
    -- SFX is enabled
else
    -- SFX is disabled
end
```

## Benefits

1. **Crash Prevention**: Game won't crash when sound files are missing
2. **Development Friendly**: Can develop without sound assets
3. **Configurable**: Easy to enable/disable via settings
4. **Graceful Degradation**: Visual effects work without sound
5. **Error Handling**: Proper error messages when sound loading fails

## Testing

The system has been tested to ensure:
- Game starts without crashes when SFX is disabled
- Sound loading is properly gated
- Sound playing is properly gated
- Settings can be changed at runtime
- Error handling works correctly

## Future Considerations

- When actual sound assets are created, set `ENABLE_SFX = true` in production
- Consider adding individual sound enable/disable flags for fine-grained control
- May want to add volume controls when SFX is enabled 

## ./manastorm_codebase_dump.md

## Tickets/Backlog/dynamic-block-points.md
Ticket ID: VFX-P1 (Visual Polish)
Title: VFX: Implement Dynamic Shield Block Point Calculation
Goal: Enhance visual realism by making blocked projectiles visually stop at the calculated intersection point with the defender's shield orbit, rather than at a fixed percentage along the trajectory.
Problem: Currently, blockPoint is hardcoded to 0.75 in Wizard:castSpell. This causes visual inconsistencies where the projectile might appear to stop too early (FAR range) or too late/behind the target (NEAR range), breaking immersion.
Tasks:
Modify Wizard:castSpell (wizard.lua):
Locate the if blockInfo.blockable then block.
Replace blockInfo.blockPoint = 0.75.
Calculate dynamic blockPoint:
Get caster position (self.x, self.y including currentX/YOffset).
Get defender position (target.x, target.y including currentX/YOffset).
Calculate total distance (casterDist) between them.
Approximate the shield's visual radius based on blockInfo.blockingSlot (using radii from WizardVisuals as a reference, e.g., local shieldRadius = WizardVisuals.slotRadii.h[blockInfo.blockingSlot] or 70).
Calculate the distance from the caster to the impact point: local impactDistance = casterDist - shieldRadius.
Calculate the ratio: local pointRatio = impactDistance / casterDist.
Set blockInfo.blockPoint = math.max(0.05, math.min(0.95, pointRatio)) (clamp to prevent edge cases).
Verify Propagation: Ensure the calculated blockInfo.blockPoint is correctly passed through blockedResults, BLOCKED_DAMAGE event conversion, EFFECT event generation, and finally arrives in the opts table for VFX.createEffect.
Acceptance Criteria:
When a spell is blocked, the blockPoint value passed to VFX.createEffect is calculated dynamically based on caster/defender positions and the blocking slot's radius.
Visually, blocked projectiles stop noticeably closer to the defender when NEAR compared to when FAR.
The visual stop point roughly corresponds to the outer edge of the defender's shield orbit animation for the blocking slot.
System remains stable, no new errors introduced.
Notes:
This is primarily a visual polish ticket.
The shield radius approximation can be refined later, especially if shield visuals become non-elliptical.
Depends on the core blocking logic and event system being stable.
Priority: Low (Post-Demo)

## Tickets/Backlog/simplify-projectile-shield-block-animation-logic.md
Ticket ID: VFX-R7 (Refactor)
Title: VFX: Simplify Projectile Shield Block Animation Logic
Goal: Refactor the projectile blocking visual logic within VFX:updateProjectile for increased clarity, reliability, and maintainability, while ensuring a clear "stop and shatter" visual.
Problem: The current logic in VFX:updateProjectile for handling blocked effects (if isBlocked...) is complex, involving multiple flags (blockTimerStarted, impactParticlesCreated, blockLogged), potentially racy timers, and spawning secondary effects (shield_hit_base). This complexity can lead to inconsistent visuals (partial animations, effect ending prematurely) and is hard to debug.
Tasks:
Modify VFX:updateProjectile (vfx.lua):
Locate the if isBlocked then ... end block.
Simplify State: Rely primarily on detecting effect.visualProgress >= effect.options.blockPoint. Remove blockTimerStarted and potentially impactParticlesCreated if the impact visual can be integrated.
Integrate Impact Visual: Instead of creating a separate shield_hit_base effect, consider adding a short-lived "impact particle group" directly to the current effect instance when the block occurs. These particles would handle the "shatter" flash at the blockX, blockY point. Alternatively, ensure the EFFECT event generated by EventRunner for the BLOCKED_DAMAGE only triggers the shield_hit_base effect, and updateProjectile focuses solely on stopping/scattering its own particles.
Simplify Particle Scattering: When the block is detected:
Immediately stop the forward motion of core particles (set speedX/Y = 0 or apply strong opposing force).
Initiate a consistent scattering/fading animation for all particles (core and trail) originating from the blockX, blockY point. This could reuse or adapt the existing deflect* logic but trigger it more deterministically.
Standardize Cleanup: When the block occurs, set a fixed additional duration for the effect (e.g., effect.duration = effect.timer + 0.5) to allow the scatter/fade animation to complete reliably before the effect is removed by the main VFX.update loop. Remove any logic that artificially speeds up effect.timer after a block.
Acceptance Criteria:
The visual sequence for a blocked projectile (stop -> impact flash -> particle scatter -> fade) is clear and consistent across different ranges and block timings.
The code within VFX:updateProjectile's blocking section is simpler and easier to follow.
The reliance on multiple boolean flags for state tracking within the block sequence is reduced.
Blocked effects reliably clean themselves up after the scatter/fade animation completes.
No VFX objects or particles are leaked (verify with pool stats).
Notes:
This focuses on reliability and maintainability of the blocking visual.
It might involve choosing between integrating the impact flash into the main effect vs. ensuring the separately spawned shield_hit_base effect works reliably. Integrating might be cleaner if feasible.
Depends on VFX-P1 (Dynamic Block Point) for the most accurate visual positioning, but can be done independently focusing purely on the animation logic after a block is detected.
Priority: Medium (Post-Demo, improves stability)

## Tickets/S10_GameJuice/AI-1-abstract-ai-core-from-personality.md
Abstract Core AI Logic & Create Personality Interface
Goal: Refactor OpponentAI.lua to remove hardcoded spell choices and 
delegate character-specific decisions to a new "Personality" system.
Tasks:
Define Personality Interface (ai/PersonalityBase.lua or similar concept):
Outline the functions a personality module must provide, e.g.:
getAttackSpell(ai, perception, spellbook)
getDefenseSpell(ai, perception, spellbook)
getCounterSpell(ai, perception, spellbook)
getEscapeSpell(ai, perception, spellbook)
getConjureSpell(ai, perception, spellbook)
getPositioningSpell(ai, perception, spellbook) (Optional, for 
STATE.POSITION)
These functions should return a specific spell object from the AI's 
spellbook or nil if no suitable spell is found/affordable.
Modify OpponentAI.new(wizard, gameState, personalityModule):
Add personalityModule as a parameter.
Store self.personality = personalityModule.
Refactor OpponentAI:decide():
Remove all direct spellbook["X"] lookups.
When a state (ATTACK, DEFEND, etc.) determines a spell should be cast, 
call the appropriate function from self.personality, passing self, 
self.perception, and self.wizard.spellbook.
Example: if self.currentState == STATE.ATTACK, then local spellToCast = 
self.personality.getAttackSpell(self, p, self.wizard.spellbook).
The decision to cast should still check 
self.wizard:canPayManaCost(spellToCast.cost) and 
self:hasAvailableSpellSlot().
Refactor OpponentAI:castOffensiveSpell(), castDefensiveSpell(), etc.:
These helper methods in OpponentAI:act() should be simplified or removed.
The decide() function will now return specific spells if one is chosen.
act() will primarily handle decision.type == "CAST_SPELL" with 
decision.spell directly.
If decide() returns a more general action like ATTACK_ACTION (without a 
specific spell because the personality couldn't find one), act() can then 
call a generic self.personality.getBestSpellForIntent(STATE.ATTACK, ...) 
or simply do nothing if no spell is forthcoming.
Acceptance Criteria:
OpponentAI.lua no longer contains hardcoded spell IDs for Selene.
OpponentAI:decide() calls methods on a self.personality object to get 
spell suggestions.
The game still runs with the AI (it will be broken until AI-R2 is 
complete, but shouldn't crash due to missing methods if a dummy 
personality is temporarily used).
Design Notes:
The personality module effectively becomes the AI's "brain" for spell 
selection strategy.
The core OpponentAI FSM and perception logic remains generic.

## Tickets/S10_GameJuice/AI-2-implement-selene-personality.md
Implement SelenePersonality Module
Goal: Create the personality module for Selene, encapsulating her current 
hardcoded spell selection logic.
Tasks:
Create ai/personalities/SelenePersonality.lua:
Implement the functions defined in the Personality Interface (from AI-R1).
Move Selene's spell selection logic from the old OpponentAI:decide() and 
cast<Type>Spell() methods into these new functions.
getDefenseSpell: Prioritize spellbook["2"] (Wrap in Moonlight).
getEscapeSpell: Prioritize spellbook["2"] then spellbook["3"] (Moondance).
getAttackSpell: Implement logic to choose between spellbook["123"] (Full 
Moon Beam), spellbook["13"] (Eclipse), spellbook["3"] (Moondance) based on 
perception (e.g., mana, opponent health).
getCounterSpell: Choose between spellbook["13"] (Eclipse) and 
spellbook["3"] (Moondance).
getConjureSpell: Return spellbook["1"] (Conjure Moonlight).
Update AI Initialization (main.lua):
When creating the AI for game.wizards[2] (Selene), pass an instance of 
SelenePersonality:
local SelenePersonality = require("ai.personalities.SelenePersonality")
game.opponentAI = OpponentAI.new(game.wizards[2], game, SelenePersonality)
Use code with caution.
Lua
Acceptance Criteria:
The AI controlling Selene behaves identically to its pre-refactor state.
Selene AI correctly selects and attempts to cast her specific spells based 
on game situations.

## Tickets/S10_GameJuice/AI-3-implement-ashgar-personality.md
 Implement AshgarPersonality Module
Goal: Create a new personality module for Ashgar, enabling the AI to 
control him.
Tasks:
Analyze Ashgar's Spellbook (wizard.lua):
"1": Conjure Fire (Conjure)
"2": Nova Conjuring (Resource Management/Setup - harder for AI initially, 
maybe focus on "1" for conjure)
"3": Firebolt (Attack)
"12": Battle Shield (Defense)
"13": Blast Wave (Attack - Zone, good vs NEAR)
"23": Emberlift (Positioning/Utility, Conjure Fire)
"123": Meteor (Attack - Aerial Finisher, requires AERIAL setup)
Create ai/personalities/AshgarPersonality.lua:
Implement the Personality Interface functions for Ashgar.
getDefenseSpell: Prioritize spellbook["12"] (Battle Shield).
getEscapeSpell: Could be spellbook["23"] (Emberlift) for repositioning. If 
low health, might also consider freeAllSpells.
getAttackSpell:
If opponent AERIAL: Maybe spellbook["123"] (Meteor) if self is AERIAL.
If opponent NEAR: spellbook["13"] (Blast Wave).
Default/FAR: spellbook["3"] (Firebolt).
Consider spellbook["123"] (Meteor) as a high-mana option if AI is AERIAL 
and opponent is GROUNDED.
getCounterSpell: Ashgar doesn't have direct counters like Selene's 
Eclipse. Could use Blast Wave to disrupt NEAR, or Emberlift to change 
range/elevation. This might be less effective initially.
getConjureSpell: Prioritize spellbook["1"] (Conjure Fire). Nova Conjuring 
is more complex due to its cost.
getPositioningSpell: spellbook["23"] (Emberlift).
Testing:
Temporarily modify main.lua to assign Ashgar's personality to an AI 
controlling Ashgar (e.g., game.wizards[1] if P2 is human, or set up a 
temporary AI vs AI).
Acceptance Criteria:
An AI controlling Ashgar can select and attempt to cast spells from 
Ashgar's spellbook.
The spell choices are somewhat logical for Ashgar's kit (e.g., uses 
shields defensively, firebolt offensively).
The Ashgar AI functions without errors.

## Tickets/S10_GameJuice/AI-4-trigger-attract-mode.md
Attract Mode Trigger & AI vs. AI Setup
Goal: Implement the mechanism to trigger an AI vs. AI duel after a period 
of inactivity on the main menu.
Tasks:
Idle Timer (main.lua):
In love.update, when game.currentState == "MENU", add an idle timer.
game.menuIdleTimer = (game.menuIdleTimer or 0) + dt.
Reset game.menuIdleTimer = 0 whenever any key is pressed in the MENU state 
(modify Input.lua or main menu key handlers).
Attract Mode Trigger (main.lua):
In love.update (MENU state), if game.menuIdleTimer > ATTRACT_MODE_DELAY 
(e.g., 15-30 seconds):
Set game.attractModeActive = true.
Call a new function startGameAttractMode().
startGameAttractMode() function (main.lua):
Call resetGame() (ensure resetGame() doesn't try to re-initialize player 
AI if attractModeActive is true).
Disable player input (e.g., by setting a flag that Input.lua checks, or by 
temporarily clearing Input.Routes.p1 and Input.Routes.p2).
Randomly select (or predefine) two different wizards (e.g., Ashgar vs 
Selene).
Create OpponentAI instances for both game.wizards[1] and game.wizards[2].
local AshgarPersonality = require("ai.personalities.AshgarPersonality")
local SelenePersonality = require("ai.personalities.SelenePersonality")
game.player1AI = OpponentAI.new(game.wizards[1], game, AshgarPersonality)
game.player2AI = OpponentAI.new(game.wizards[2], game, SelenePersonality)
(Or, if one AI should be fixed, game.opponentAI can be used for P2, and a 
new game.player1AI for P1)
Set game.currentState = "BATTLE_ATTRACT" (or a similar new state to 
distinguish from normal battle).
Reset game.menuIdleTimer = 0.
Update AI Calls (main.lua):
In love.update (BATTLE state), if game.attractModeActive is true, call 
game.player1AI:update(dt) and game.player2AI:update(dt).
If not in attract mode, call the regular game.opponentAI:update(dt) if 
game.useAI is true.
Acceptance Criteria:
After ~15-30 seconds of inactivity on the main menu, the game 
automatically starts an AI vs. AI duel.
Both AI-controlled wizards attempt to cast spells.
Player input is disabled during attract mode.

## Tickets/S10_GameJuice/AI-5-play-and-cleanup-attract-mode.md
Attract Mode Gameplay Loop & Exit Condition
Goal: Ensure the AI vs. AI duel in attract mode plays out to completion 
and can be exited by the player.
Tasks:
Game Over Handling (main.lua):
Ensure the existing game over logic (if wizard.health <= 0) correctly 
identifies a winner in AI vs. AI mode.
When game.gameOver becomes true during BATTLE_ATTRACT state:
Transition to GAME_OVER_ATTRACT state.
Display the win screen as normal.
After winScreenDuration, or on player input, transition back to MENU 
state.
Exiting Attract Mode (Input.lua / main.lua):
Modify Input.handleKey (or relevant key handlers in main.lua if attract 
mode bypasses Input.lua):
If game.attractModeActive is true, any key press should:
Set game.attractModeActive = false.
Clean up AI instances: game.player1AI = nil, game.player2AI = nil.
Re-enable player input routes if they were disabled.
Call resetGame() to prepare for a potential player-initiated game.
Set game.currentState = "MENU".
Reset game.menuIdleTimer = 0.
UI for Attract Mode (Optional, ui.lua):
Consider adding a small "Attract Mode - Press Any Key" text overlay during 
BATTLE_ATTRACT or GAME_OVER_ATTRACT.
Acceptance Criteria:
AI vs. AI duels play until one wizard wins.
The win screen is displayed.
Pressing any key during the attract mode (battle or game over screen) 
immediately returns to the main menu.
The game state is correctly reset, and player controls are restored after 
exiting attract mode.

## Tickets/S10_GameJuice/GFX-1-hit-flash.md
Title: Implement Character Hit Flash
Goal: Provide immediate, clear visual feedback when a wizard takes damage.
Description: Currently, damage reduces health but lacks instant visual 
feedback on the character sprite itself. Adding a brief color flash will 
make impacts more readable.
Tasks:
Modify EventRunner.lua: In the DAMAGE handler (and potentially 
APPLY_STATUS for DoTs), after health is reduced, set a temporary flag or 
timer on the targetWizard (e.g., targetWizard.hitFlashTimer = 0.1).
Modify Wizard:update(dt): Decrement hitFlashTimer if it's > 0.
Modify WizardVisuals.drawWizard:
Before drawing the wizard sprite, check if wizard.hitFlashTimer > 0.
If true, use love.graphics.setColor(1, 1, 1, 1) (or maybe a slight red 
tint like 1, 0.8, 0.8) just before drawing the sprite.
Immediately after drawing the sprite, reset the color using 
love.graphics.setColor(1, 1, 1, 1).
Acceptance Criteria:
When a wizard's health is reduced by a direct hit or DoT tick, their 
sprite flashes white/red briefly (e.g., for ~0.1 seconds).
The flash does not interfere with other color changes (like stun).
Technical Notes: Using a simple timer on the wizard object is efficient. 
Ensure color reset happens correctly to avoid persistent tinting.

## Tickets/S10_GameJuice/GFX-2-hit-stop.md
Title: Implement Screen Shake & Hitstop
Goal: Add significant physical weight and impact feedback to powerful hits 
or events.
Description: Implement global screen shake and brief update pause 
triggered by specific game events.
Tasks:
Implement Helpers (main.lua or core/CameraUtils.lua):
Create triggerShake(duration, intensity): Sets global variables 
shakeTimer, shakeIntensity.
Create triggerHitstop(duration): Sets global variable hitstopTimer.
Modify love.update (main.lua):
At the very beginning, check if hitstopTimer > 0 then hitstopTimer = 
hitstopTimer - dt; return end.
Decrement shakeTimer if > 0.
Modify love.draw (main.lua):
Before the main love.graphics.push() for scaling:
Calculate shake offset: local offsetX, offsetY = 0, 0. If shakeTimer > 0, 
calculate offsetX = math.random(-shakeIntensity, shakeIntensity), offsetY 
= math.random(-shakeIntensity, shakeIntensity). Gradually reduce 
shakeIntensity as shakeTimer decreases.
Apply this offset using love.graphics.translate(offsetX, offsetY).
Ensure there's a love.graphics.pop() at the very end of love.draw to undo 
this translation.
Trigger from EventRunner.lua:
In relevant handlers (e.g., DAMAGE for high event.amount, potentially 
BLOCKED_DAMAGE, or based on specific event.tags), call triggerShake(...) 
and triggerHitstop(...).
Acceptance Criteria:
The screen visibly shakes for a short duration upon specific high-impact 
events.
The game briefly pauses (hitstop) upon specific high-impact events.
Effects are configurable (duration, intensity).

## Tickets/S10_GameJuice/Sidequest-ReorgVFX/VFX-SQ-1-CreateVFXDispatcher.md
Title: Create VFX Effect Dispatcher Infrastructure
Goal: Set up the core structure in vfx.lua to dynamically call update/draw 
functions based on effect type.
Description: Before moving individual effect logic, establish the 
dispatcher mechanism that will call the separated functions.
Tasks:
In vfx.lua, create empty tables: VFX.updaters = {} and VFX.drawers = {}.
Modify the main VFX.update loop:
Inside the loop iterating through VFX.activeEffects:
Replace the large if/elseif effect.type == ... block with a dispatcher 
call:
local updater = VFX.updaters[effect.type]
if updater then
    updater(effect, dt)
else
    -- Fallback or warning for unhandled types
    -- print("Warning: No updater found for VFX type: " .. 
tostring(effect.type))
    -- Optionally call a default update function here
end
Use code with caution.
Lua
Modify the main VFX.draw loop similarly, using VFX.drawers[effect.type].
(Temporary): For now, populate VFX.updaters and VFX.drawers by directly 
assigning the existing functions within vfx.lua itself (e.g., 
VFX.updaters["projectile"] = VFX.updateProjectile). This verifies the 
dispatcher works before moving files.
Acceptance Criteria:
The game runs, and all existing VFX update and draw correctly using the 
new dispatcher mechanism.
VFX.updaters and VFX.drawers tables exist and are populated (initially 
with local functions).
The large if/elseif blocks in the main update and draw loops are replaced 
with lookups and function calls.

## Tickets/S10_GameJuice/Sidequest-ReorgVFX/VFX-SQ-2-extract-projectile-vfx.md
Title: Separate Projectile VFX Logic
Goal: Move updateProjectile and drawProjectile logic into its own file.
Tasks:
Create directory vfx/effects/.
Create file vfx/effects/projectile.lua.
Move the VFX.updateProjectile and VFX.drawProjectile functions from 
vfx.lua into projectile.lua.
Modify projectile.lua to return a table: return { update = 
updateProjectile, draw = drawProjectile }. Ensure any helper functions 
used only by these two are also moved or handled appropriately.
In vfx.lua:
Remove the original VFX.updateProjectile and VFX.drawProjectile functions.
Add local ProjectileEffect = require("vfx.effects.projectile").
Update the dispatcher population: VFX.updaters["projectile"] = 
ProjectileEffect.update, VFX.drawers["projectile"] = 
ProjectileEffect.draw.
Acceptance Criteria:
Projectile-type VFX (including bolt-base, which uses projectile logic) 
update and draw correctly.
The projectile logic resides entirely within vfx/effects/projectile.lua.
vfx.lua is smaller.

## Tickets/S10_GameJuice/Sidequest-ReorgVFX/VFX-SQ-3-extract-impact-vfx.md
Title: Separate Impact VFX Logic
Goal: Move updateImpact and drawImpact logic into its own file.
Tasks:
Create file vfx/effects/impact.lua.
Move the VFX.updateImpact and VFX.drawImpact functions from vfx.lua into 
impact.lua.
Modify impact.lua to return { update = updateImpact, draw = drawImpact }.
In vfx.lua:
Remove the original functions.
Require the new module: local ImpactEffect = 
require("vfx.effects.impact").
Update dispatchers: VFX.updaters["impact"] = ImpactEffect.update, 
VFX.drawers["impact"] = ImpactEffect.draw. (Handle other types mapping to 
impact like remote_base, shield_hit_base here or adjust their 
definitions).
Acceptance Criteria:
Impact-type VFX update and draw correctly.
vfx.lua is further reduced in size.

## Tickets/S10_GameJuice/Sidequest-ReorgVFX/VFX-SQ-4-extract-remaining-vfx-types.md
Title: Separate Remaining VFX Type Logic (Aura, Beam, Cone, Conjure, 
Surge, Vertical, Meteor, etc.)
Goal: Move update/draw logic for all remaining specific effect types into 
their own files.
Tasks:
Repeat the process from VFX-R8/R9 for each distinct effect type currently 
handled in vfx.lua:
Create vfx/effects/[type_name].lua.
Move update[TypeName] and draw[TypeName] functions.
Return { update = ..., draw = ... }.
Remove originals from vfx.lua.
Require the new module in vfx.lua.
Update VFX.updaters and VFX.drawers accordingly.
Acceptance Criteria:
All effect types update and draw correctly from their dedicated modules.
vfx.lua primarily contains core logic (init, createEffect, main 
update/draw loops, pooling, assets) and the dispatcher setup.

## Tickets/S10_GameJuice/VFX-1-additive-blending-on-core-vfx-primitives.md
Title: Implement Additive Blending for Core VFX Components
Goal: Enhance visual impact and brightness of key effect elements like 
particle cores, impacts, and beams.
Description: Apply additive blending selectively to make bright parts of 
effects bloom realistically when overlapping or against dark backgrounds.
Tasks:
Identify drawing calls in vfx.lua's draw* functions that render the 
brightest/core components (e.g., inner glow layers, impact flashes, beam 
cores, bright core particles).
Wrap these specific love.graphics.draw or love.graphics.circle calls with:
local prevMode = {love.graphics.getBlendMode()}
love.graphics.setBlendMode("add")
-- ... drawing calls for bright elements ...
love.graphics.setBlendMode(prevMode[1], prevMode[2])
Use code with caution.
Lua
Acceptance Criteria:
Core elements of impacts, projectiles, beams, etc., appear noticeably 
brighter and bloom when overlapping.
Overall visual clarity is maintained (don't make everything additive).

## Tickets/S10_GameJuice/VFX-2-add-glow-particles-and-layers-to-spell-templates.md
Title: Add Secondary Particles & Glow Layers to Base Templates
Goal: Increase visual richness and depth of core effect templates.
Description: Modify base templates (proj_base, impact_base, etc.) to spawn 
secondary, softer/larger/dimmer particles alongside the primary ones.
Tasks:
Modify VFX.initializeParticles in vfx.lua.
For relevant effect types (e.g., "projectile", "impact", "beam"):
Adjust effect.particleCount logic if necessary (e.g., allocate 70% 
primary, 30% secondary).
In the particle creation loop, sometimes create secondary particles (e.g., 
using fireGlow asset, lower alpha, slower speed, different scale 
progression). Store a flag particle.isSecondary = true.
Modify corresponding draw* functions:
Draw secondary particles first (behind primary).
Use different assets/drawing parameters based on particle.isSecondary.
Acceptance Criteria:
Projectiles, impacts, and other core effects have visible softer glow 
layers or slower background particles complementing the main effect.
Performance remains acceptable.

## Tickets/S10_GameJuice/VFX-3-better-beams.md
Title: Enhance Beam Visuals (Width/Intensity)
Goal: Make beam effects feel more dynamic and powerful.
Description: Vary the beam's width and core intensity over its duration or 
based on parameters.
Tasks:
Modify VFX.updateBeam and VFX.drawBeam in vfx.lua.
In drawBeam, make beamWidth calculation dynamic. Use effect.timer or 
effect.progress with math.sin for pulsing, or potentially read an 
intensity value from effect.options.
Adjust the alpha/color of the inner core line based on the same dynamic 
value to make the intensity fluctuate.
Acceptance Criteria:
Beam effects visually pulse or vary in intensity/width during their 
animation.

## Tickets/S10_GameJuice/VFX-4-better-surges.md
Title: Enhance Surge/Fountain Effects
Goal: Add more detail and stages to surge-type VFX (like Emberlift, 
Conjure).
Description: Incorporate initial flash, rising streaks, and clearer 
particle dissipation.
Tasks:
Modify VFX.updateSurge and VFX.drawSurge (and potentially 
updateConjure/drawConjure).
Initial Flash: In createEffect or initializeParticles for surge/conjure, 
add a small number of very fast, bright particles that fade quickly for an 
initial burst.
Rising Streaks: In drawSurge, add love.graphics.line calls drawing faint 
vertical lines originating from the source and fading with height/time.
Particle Dissipation: Ensure particles clearly shrink and fade towards the 
end of their lifecycle in the update logic.
Acceptance Criteria:
Surge/Conjure effects have a more distinct visual "pop" at the start.
Rising particle streams are visually enhanced.
Particles have a clearer end-of-life visual.

## Tickets/S10_GameJuice/VFX-5-impact-sparks.md
Title: Add Impact Debris/Sparks to Impact Effects
Goal: Make impact visuals sharper and more explosive.
Description: Enhance the impact_base template to include faster, 
shorter-lived spark particles.
Tasks:
Modify VFX.initializeParticles in vfx.lua for type == "impact".
Add logic to create a small number (e.g., 5-10) of additional particles.
Configure these "debris" particles:
Use sparkle asset (or similar sharp texture).
Give them higher initial speed (math.random(200, 400)).
Give them shorter lifespan (effect.duration * 0.3).
Make them scale down very quickly (startScale = 0.6, endScale = 0.05).
Use a brighter color variation (e.g., closer to white).
Ensure drawImpact renders these particles correctly (potentially using the 
sparkle asset if particle.isDebris flag is set).
Acceptance Criteria:
Impact effects have a noticeable sharper, faster "spark" component 
alongside the main radial burst.

## Tickets/S11_WizardVisualsJuice/1-asset-loading-and-wizard-state-preparation.md
Asset Loading & Wizard State Preparation
Goal: Load Ashgar's idle animation frames and prepare the Wizard object to 
manage animation state.
Tasks:
Update Asset Manifest (core/assetPreloader.lua):
Add paths for Ashgar's 7 idle frames to the assetManifest.images table.
-- In assetManifest.images
"assets/sprites/ashgar-idle-1.png",
"assets/sprites/ashgar-idle-2.png",
"assets/sprites/ashgar-idle-3.png",
"assets/sprites/ashgar-idle-4.png",
"assets/sprites/ashgar-idle-5.png",
"assets/sprites/ashgar-idle-6.png",
"assets/sprites/ashgar-idle-7.png",
Use code with caution.
Lua
Modify Wizard.new (wizard.lua):
For Ashgar, load and store the idle animation frames.
Add new properties to the Wizard instance for animation control.
function Wizard.new(name, x, y, color, spellbook)
    local self = setmetatable({}, Wizard)
    -- ... (existing properties) ...

    self.idleAnimationFrames = {}
    self.currentIdleFrame = 1
    self.idleFrameTimer = 0
    self.idleFrameDuration = 0.15 -- seconds per frame (adjust for desired 
speed)

    -- Load sprite with fallback
    local spritePathBase = "assets/sprites/" .. string.lower(name)
    
    -- ... (existing sprite loading for self.sprite and 
self.castFrameSprite) ...

    -- Load idle animation frames specifically for Ashgar
    if name == "Ashgar" then
        for i = 1, 7 do
            local framePath = spritePathBase .. "-idle-" .. i .. ".png"
            local frameImg = AssetCache.getImage(framePath)
            if frameImg then
                table.insert(self.idleAnimationFrames, frameImg)
            else
                print("Warning: Could not load Ashgar idle frame: " .. 
framePath)
                -- Optional: Add a fallback, e.g., use self.sprite
                table.insert(self.idleAnimationFrames, self.sprite) 
            end
        end
        -- If no idle frames loaded, use the main sprite as a single-frame 
animation
        if #self.idleAnimationFrames == 0 then
            print("Warning: Ashgar has no idle animation frames loaded, 
using static sprite.")
            table.insert(self.idleAnimationFrames, self.sprite)
        end
    else
        -- For other wizards, populate with their main sprite for now
        table.insert(self.idleAnimationFrames, self.sprite)
    end
    
    -- ... (rest of Wizard.new) ...
    return self
end
Use code with caution.
Lua
Acceptance Criteria:
Ashgar's idle animation frames are preloaded at game start.
The Wizard object for Ashgar contains the idleAnimationFrames table 
populated with image objects.
currentIdleFrame, idleFrameTimer, and idleFrameDuration properties are 
initialized.

## Tickets/S11_WizardVisualsJuice/2-idle-animation-logic.md
Implement Idle Animation Logic
Goal: Update the Wizard's animation state over time.
Tasks:
Modify Wizard:update (wizard.lua):
Add logic to advance the idle animation frame. This should only happen if 
no other primary animation (like casting) is overriding the display.
function Wizard:update(dt)
    -- ... (existing update logic: hitFlashTimer, castFrameTimer, 
positionAnimation, etc.) ...

    -- Update idle animation timer and frame
    -- Only animate idle if not casting or in another special visual state
    if self.castFrameTimer <= 0 then -- Play idle if not in cast animation
        self.idleFrameTimer = self.idleFrameTimer + dt
        if self.idleFrameTimer >= self.idleFrameDuration then
            self.idleFrameTimer = self.idleFrameTimer - 
self.idleFrameDuration -- Subtract to carry over excess time
            self.currentIdleFrame = self.currentIdleFrame + 1
            if self.currentIdleFrame > #self.idleAnimationFrames then
                self.currentIdleFrame = 1 -- Loop animation
            end
        end
    else
        -- If casting, reset idle animation to first frame to look clean 
when cast finishes
        self.currentIdleFrame = 1
        self.idleFrameTimer = 0
    end

    -- ... (rest of Wizard:update logic for status effects, spell slots, 
etc.) ...
end
Use code with caution.
Lua
Acceptance Criteria:
wizard.currentIdleFrame cycles from 1 to 7 (or the number of frames) 
repeatedly.
wizard.idleFrameTimer correctly manages time per frame.
Idle animation is paused/reset if castFrameTimer > 0.

## Tickets/S11_WizardVisualsJuice/3-update-drawing-logic.md
Update Drawing Logic
Goal: Draw the current idle animation frame for Ashgar instead of his 
static sprite.
Tasks:
Modify WizardVisuals.drawWizard (systems/WizardVisuals.lua):
Change the sprite drawing logic to use the current idle animation frame 
when appropriate.
function WizardVisuals.drawWizard(wizard)
    -- ... (existing logic for xOffset, yOffset, wizardColor, ground 
indicator) ...

    WizardVisuals.drawSpellSlots(wizard, "back") -- Draw back slots

    -- Draw the wizard sprite
    if wizard.sprite then -- Still check if a base sprite exists (for 
fallbacks/other wizards)
        local flipX = (wizard.name == "Selene") and -1 or 1
        local adjustedScale = wizard.scale * flipX

        local spriteToDraw = nil

        if wizard.castFrameTimer > 0 and wizard.castFrameSprite then
            spriteToDraw = wizard.castFrameSprite
        elseif wizard.idleAnimationFrames and #wizard.idleAnimationFrames 
> 0 then
            spriteToDraw = 
wizard.idleAnimationFrames[wizard.currentIdleFrame]
        else
            -- Fallback to the original static sprite if no animation 
frames are available
            spriteToDraw = wizard.sprite 
        end

        -- Ensure spriteToDraw is not nil before attempting to draw
        if not spriteToDraw then
            print("Error: No sprite to draw for wizard " .. wizard.name)
            -- Optionally draw a placeholder or return
            love.graphics.setColor(1,0,0,1) -- Red error color
            love.graphics.rectangle("fill", wizard.x + xOffset - 20, 
wizard.y + yOffset - 30, 40, 60)
            love.graphics.setColor(1,1,1,1) -- Reset color
        else
            -- Draw shadow first (when not AERIAL)
            if wizard.elevation == Constants.ElevationState.GROUNDED then
                love.graphics.setColor(0, 0, 0, 0.2)
                love.graphics.draw(
                    spriteToDraw,
                    wizard.x + xOffset,
                    wizard.y + 40, -- Shadow on ground
                    0, 
                    adjustedScale * 0.8, 
                    wizard.scale * 0.3, 
                    spriteToDraw:getWidth() / 2,
                    spriteToDraw:getHeight() / 2
                )
            end

            -- Hit flash logic (applies color before drawing main sprite)
            if wizard.hitFlashTimer > 0 then
                local prevBlendMode = love.graphics.getBlendMode()
                love.graphics.setBlendMode("add")
                love.graphics.setColor(wizardColor[1], wizardColor[2], 
wizardColor[3], wizardColor[4]) 
                love.graphics.draw(
                    spriteToDraw,
                    wizard.x + xOffset, wizard.y + yOffset, 0,
                    adjustedScale * 2, wizard.scale * 2,
                    spriteToDraw:getWidth() / 2, spriteToDraw:getHeight() 
/ 2
                )
                love.graphics.setBlendMode(prevBlendMode)
                -- Reset color for normal drawing if hit flash isn't 
covering it
                love.graphics.setColor(1,1,1,1) 
                if wizard.flashBlendMode ~= "add" then -- if hit flash 
isn't additive, draw base normally
                     love.graphics.draw(
                        spriteToDraw,
                        wizard.x + xOffset, wizard.y + yOffset, 0,
                        adjustedScale * 2, wizard.scale * 2,
                        spriteToDraw:getWidth() / 2, 
spriteToDraw:getHeight() / 2
                    )
                end

            else 
                -- Normal drawing (no hit flash)
                love.graphics.setColor(wizardColor[1], wizardColor[2], 
wizardColor[3], wizardColor[4])
                love.graphics.draw(
                    spriteToDraw,
                    wizard.x + xOffset, wizard.y + yOffset, 0,
                    adjustedScale * 2, wizard.scale * 2,
                    spriteToDraw:getWidth() / 2, spriteToDraw:getHeight() 
/ 2
                )
            end
        end
        
        love.graphics.setColor(1, 1, 1, 1) -- Reset color

        -- Draw AERIAL cloud effect (existing logic)
        if wizard.elevation == Constants.ElevationState.AERIAL then
            -- ... (existing cloud drawing logic) ...
        end
    else
        -- ... (existing fallback circle drawing) ...
    end

    WizardVisuals.drawSpellSlots(wizard, "front") -- Draw front slots

    -- ... (existing logic for status effects, spell cast notification) 
...
end
Use code with caution.
Lua
Important: The logic should prioritize castFrameSprite if castFrameTimer > 
0. The idle animation should only play if the cast animation is not 
active.
The existing hit flash (tinting wizardColor) should apply to the current 
animation frame.
Acceptance Criteria:
Ashgar is drawn using his idle animation frames when not casting.
The cast animation (ashgar-cast.png) still takes precedence during 
castFrameTimer.
Hit flash and other visual effects correctly apply to the animated sprite.
Selene (and any other future wizards) continue to display their static 
sprites correctly.

## Tickets/S12_CampaignFoundation/1-define-campaign-data-structure-and-state.md
Ticket #CAMP-1: Define Campaign Data Structure & Basic Game State
Goal: Establish where and how campaign progression and opponent lists will be stored, and add the new game state for campaign play.
Tasks:
Modify characterData.lua:
For each character entry (e.g., characterData.Ashgar), add a new key, campaignOpponents, which will be an ordered list (array table) of opponent character names (strings, e.g., {"Selene", "Silex", "Borrak"}).
Initially populate this for Ashgar and Selene with 2-3 opponents each for testing.
Modify main.lua (game table):
Add new states to game.currentState's possible values: "CAMPAIGN_MENU" (for selecting a character's campaign), "CAMPAIGN_VICTORY", "CAMPAIGN_DEFEAT". We will reuse the existing "BATTLE" state, using game.campaignProgress to differentiate campaign battles.
Add game.campaignProgress = nil. When active, this will be a table like { characterName = "Ashgar", currentOpponentIndex = 1, wins = 0 }.
Modify main.lua (drawMainMenu and input handling):
Add a new menu option, e.g., "[1] Campaign", to drawMainMenu.
Update Input.Routes.ui["1"] (or a new key if "1" is too overloaded) in Input.setupRoutes to set game.currentState = "CAMPAIGN_MENU" if chosen from the main menu.
Acceptance Criteria:
characterData.lua includes campaignOpponents lists for Ashgar and Selene.
main.lua recognizes new campaign-related game states.
The main menu has a "Campaign" option that transitions game.currentState to "CAMPAIGN_MENU".
game.campaignProgress is initialized to nil.
Design Notes/Pitfalls:
Opponent lists should contain valid character names that have corresponding AI personalities.
The CAMPAIGN_MENU state will initially be simple, focusing on character selection for the campaign.

## Tickets/S12_CampaignFoundation/2-campaign-character-selection-ui-and-logic.md
Ticket #CAMP-2: Campaign Character Selection UI & Logic
Goal: Allow the player to select a character whose campaign they wish to play.
Tasks:
Create drawCampaignMenu() function in main.lua:
This function will be called when game.currentState == "CAMPAIGN_MENU".
Display a list of unlocked player characters (from game.unlockedCharacters and game.characterRoster).
Implement simple cursor logic (can adapt parts of drawCharacterSelect() or drawSettingsMenu() for cursor movement and display). Store the selected character index/name in a temporary variable, e.g., game.campaignMenu = { selectedCharacterIndex = 1 }.
Update Input.setupRoutes() for CAMPAIGN_MENU state:
Handle up, down for cursor movement in drawCampaignMenu.
Handle return (Enter) or f (or another confirm key) to confirm character selection.
On confirmation:
Get selectedCharacterName using game.campaignMenu.selectedCharacterIndex.
Set game.campaignProgress = { characterName = selectedCharacterName, currentOpponentIndex = 1, wins = 0 }.
Call a new function startCampaignBattle() (to be created in CAMP-3).
(The startCampaignBattle function will set the state to BATTLE).
Handle escape to return to game.currentState = "MENU" and clear game.campaignMenu.
Acceptance Criteria:
Player can view and select an unlocked character for their campaign from the CAMPAIGN_MENU.
Upon selection, game.campaignProgress is correctly initialized with the chosen character and currentOpponentIndex = 1.
The game logic proceeds to start the first campaign battle.
Design Notes/Pitfalls:
The UI can be very basic text for now. Reusing drawCharacterSelect components might be too complex; a simpler list is fine.
Ensure error handling if no unlocked characters are available (though for now, Ashgar and Selene are default unlocked).

## Tickets/S12_CampaignFoundation/3-starting-and-managing-campaign-battle.md
Ticket #CAMP-3: Starting and Managing a Campaign Battle
Goal: Correctly set up and start a duel based on the current campaign progress, and modify resetGame to be campaign-aware.
Tasks:
Create startCampaignBattle() function in main.lua:
This function is called after character selection (from CAMP-2) and after winning a campaign battle (CAMP-4).
Preconditions: game.campaignProgress must be populated.
Retrieve playerCharacterName = game.campaignProgress.characterName.
Retrieve opponentIndex = game.campaignProgress.currentOpponentIndex.
Get opponentCharacterName from game.characterData[playerCharacterName].campaignOpponents[opponentIndex].
If opponentCharacterName is nil (i.e., opponentIndex is out of bounds), it means the campaign is complete. Call handleCampaignVictory() (new function, details in CAMP-4). Return early from startCampaignBattle.
Call setupWizards(playerCharacterName, opponentCharacterName).
Set game.useAI = true.
Initialize AI for game.wizards[2]:
local personality = getPersonalityFor(opponentCharacterName) (using existing helper in main.lua).
game.opponentAI = OpponentAI.new(game.wizards[2], game, personality).
Call resetGame().
Set game.currentState = "BATTLE".
Modify resetGame() in main.lua:
This function is called by startCampaignBattle and also when exiting GAME_OVER.
Crucially, when resetGame() is called during an active campaign (i.e., game.campaignProgress is not nil and we are setting up for the next campaign battle), it should not clear game.opponentAI if game.useAI is true (as it's set by startCampaignBattle).
The part of resetGame that initializes game.opponentAI should only run if game.campaignProgress is nil (i.e., it's a regular duel).
Alternatively, startCampaignBattle can set a temporary flag like game.isSettingUpCampaignBattle = true before calling resetGame, and resetGame can check this flag to skip AI re-initialization. Clear the flag afterwards.
Acceptance Criteria:
startCampaignBattle correctly configures game.wizards[1] (player) and game.wizards[2] (AI opponent) based on game.campaignProgress.
The AI opponent uses the personality appropriate for its character name.
resetGame correctly prepares the battle state without interfering with ongoing campaign AI setup.
The game transitions to the "BATTLE" state.
Design Notes/Pitfalls:
The interaction between startCampaignBattle and resetGame regarding AI initialization needs care to avoid double-initialization or premature clearing of the campaign AI. Using a temporary flag might be the cleanest.
Consider what happens if campaignOpponents list is empty or an opponent name is invalid.

## Tickets/S12_CampaignFoundation/4-campaign-progression-and-victory-logic.md
Ticket #CAMP-4: Campaign Progression & Victory/Loss Logic
Goal: Implement logic to advance to the next opponent upon winning, or end the campaign attempt on loss/completion.
Tasks:
Create handleCampaignVictory() function in main.lua:
Called by startCampaignBattle if no more opponents.
print(game.campaignProgress.characterName .. " campaign complete! Wins: " .. game.campaignProgress.wins).
Set game.currentState = "CAMPAIGN_VICTORY".
(Optionally: game.campaignProgress = nil here, or defer to when leaving CAMPAIGN_VICTORY state).
Create handleCampaignDefeat() function in main.lua:
Called if player loses a campaign battle.
print(game.campaignProgress.characterName .. " campaign failed at opponent " .. game.campaignProgress.currentOpponentIndex).
Set game.currentState = "CAMPAIGN_DEFEAT".
(Optionally: game.campaignProgress = nil here).
Modify love.update() in main.lua for GAME_OVER state:
When game.winScreenTimer >= game.winScreenDuration (or player input like Space to continue from win screen):
Check if game.campaignProgress is not nil (i.e., we were in a campaign battle).
If player won (game.winner == 1 assuming player is game.wizards[1]):
Increment game.campaignProgress.wins.
Increment game.campaignProgress.currentOpponentIndex.
Call startGameCampaignBattle() (which will check if it's the end of the campaign or set up the next fight).
Else (player lost, game.winner == 2):
Call handleCampaignDefeat().
Else (not in campaign, game.campaignProgress is nil):
Existing logic: resetGame() and game.currentState = "MENU". This remains the default for non-campaign duels.
Acceptance Criteria:
Winning a campaign battle triggers startCampaignBattle() to load the next opponent.
Losing a campaign battle triggers handleCampaignDefeat() and sets state to CAMPAIGN_DEFEAT.
Successfully defeating all opponents in a campaign triggers handleCampaignVictory() and sets state to CAMPAIGN_VICTORY.
Design Notes/Pitfalls:
The player is always game.wizards[1] in campaign mode.
The order of operations in GAME_OVER is important: check campaign status before defaulting to resetGame() and returning to menu.

## Tickets/S12_CampaignFoundation/5-ui-for-campaign-states.md
Ticket #CAMP-4: Campaign Progression & Victory/Loss Logic
Goal: Implement logic to advance to the next opponent upon winning, or end the campaign attempt on loss/completion.
Tasks:
Create handleCampaignVictory() function in main.lua:
Called by startCampaignBattle if no more opponents.
print(game.campaignProgress.characterName .. " campaign complete! Wins: " .. game.campaignProgress.wins).
Set game.currentState = "CAMPAIGN_VICTORY".
(Optionally: game.campaignProgress = nil here, or defer to when leaving CAMPAIGN_VICTORY state).
Create handleCampaignDefeat() function in main.lua:
Called if player loses a campaign battle.
print(game.campaignProgress.characterName .. " campaign failed at opponent " .. game.campaignProgress.currentOpponentIndex).
Set game.currentState = "CAMPAIGN_DEFEAT".
(Optionally: game.campaignProgress = nil here).
Modify love.update() in main.lua for GAME_OVER state:
When game.winScreenTimer >= game.winScreenDuration (or player input like Space to continue from win screen):
Check if game.campaignProgress is not nil (i.e., we were in a campaign battle).
If player won (game.winner == 1 assuming player is game.wizards[1]):
Increment game.campaignProgress.wins.
Increment game.campaignProgress.currentOpponentIndex.
Call startGameCampaignBattle() (which will check if it's the end of the campaign or set up the next fight).
Else (player lost, game.winner == 2):
Call handleCampaignDefeat().
Else (not in campaign, game.campaignProgress is nil):
Existing logic: resetGame() and game.currentState = "MENU". This remains the default for non-campaign duels.
Acceptance Criteria:
Winning a campaign battle triggers startCampaignBattle() to load the next opponent.
Losing a campaign battle triggers handleCampaignDefeat() and sets state to CAMPAIGN_DEFEAT.
Successfully defeating all opponents in a campaign triggers handleCampaignVictory() and sets state to CAMPAIGN_VICTORY.
Design Notes/Pitfalls:
The player is always game.wizards[1] in campaign mode.
The order of operations in GAME_OVER is important: check campaign status before defaulting to resetGame() and returning to menu.

## Tickets/S12_CampaignFoundation/6-data-population-and-polish.md
Ticket #CAMP-6: Data Population, Testing & Polish
Goal: Populate campaign data for more characters, test the full flow, and refine transitions.
Tasks:
Populate campaignOpponents in characterData.lua:
Add gauntlets for Silex and Borrak (or any other characters with implemented AI personalities). Use a mix of opponents for variety. Ensure these opponents have AI personalities defined.
Refine Transitions:
Ensure smooth and logical transitions between: Main Menu -> Campaign Menu -> Battle -> Game Over -> Next Battle / Campaign Victory / Campaign Defeat -> Main Menu.
Confirm game.campaignProgress is correctly initialized and cleared at the appropriate times.
Test Thoroughly:
Play through each implemented character's campaign.
Test winning streaks and losing at various points in a campaign.
Test exiting a campaign mid-battle (e.g., pressing ESC during a campaign BATTLE state should probably reset game.campaignProgress and return to Main Menu for now).
Acceptance Criteria:
At least 4 characters have defined, playable (short) campaigns against existing AI personalities.
The campaign mode is robust and handles various win/loss/exit scenarios gracefully.
No crashes or major logical errors in campaign flow.
Design Notes/Pitfalls:
This ticket is crucial for catching edge cases and ensuring the feature feels complete enough for its basic scope.
If an opponent in a campaign list doesn't have an AI personality, getPersonalityFor will return nil, and OpponentAI.new will use the PersonalityBase. This is acceptable for now but should be noted.

## Tickets/S13_FlexibleSpellCosts/SCT-1-core-getcost-mechanism-wizard-integration.md
# SCT-1: Core getCost Mechanism & Wizard Integration

**Goal:** Establish the foundational mechanism for dynamic costs and integrate it into the wizard's spellcasting logic.

## Tasks

### 1. Modify spells/schema.lua
- Update the `validateSpell` function to acknowledge an optional `getCost` function in spell definitions
- If `getCost` is present, the static cost table can still exist (perhaps as a "base" or "UI display" cost) or be optional
- For now, assume if `getCost` exists, it's the source of truth at runtime

### 2. Modify wizard.lua - Wizard:canPayManaCost(costOrGetCostFn)
- This function currently takes a cost table
- Update to accept either a cost table OR the spell.getCost function
- If `costOrGetCostFn` is a function, call it: `local actualCost = costOrGetCostFn(self, target, nil)`
  - Note: `canPayManaCost` is often called without a specific target context (e.g., by AI checking general affordability)
  - The `getCost` function signature should account for this: `getCost(caster, [potentialTarget])`
- The rest of `canPayManaCost` (token reservation logic) will then use `actualCost`

### 3. Modify wizard.lua - Wizard:queueSpell(spell)
- When checking affordability, pass `spellToUse.getCost` or `spellToUse.cost` to `self:canPayManaCost()`
- When acquiring tokens with `TokenManager.acquireTokensForSpell`, if `spellToUse.getCost` exists, call it to get the `actualCost` table to pass to TokenManager. Otherwise, pass `spellToUse.cost`
- The `spellToUse.cost` in the `spellSlots[i]` entry should ideally store the actual cost paid if it was dynamic, for potential future use (e.g., Dispel keyword). For now, storing the original reference is fine

### 4. Modify TokenManager.acquireTokensForSpell (if needed)
- Ensure it robustly handles the `manaCost` table passed to it, which will now always be a resolved table of token types/counts
- No major changes likely needed here if wizard.lua does the resolution

## Acceptance Criteria
- A spell can be defined with a `getCost` function
- `Wizard:canPayManaCost` correctly evaluates affordability using the dynamic cost if `getCost` is present
- `Wizard:queueSpell` correctly acquires tokens based on the dynamically calculated cost
- Spells with static costs continue to work as before

## Design Notes/Pitfalls
- The `getCost` function must return a table in the same format as the static cost property (e.g., `{Constants.TokenType.FIRE, Constants.TokenType.WATER}` or `{ [Constants.TokenType.FIRE] = 2 }`)
- Ensure the caster (and potentially target if relevant for a specific spell's dynamic cost) context is correctly passed to `getCost`

## Tickets/S13_FlexibleSpellCosts/SCT-2-ai-adaptation-for-dynamic-costs.md
# SCT-2: AI Adaptation for Dynamic Costs

**Goal:** Enable the AI to understand and correctly evaluate the affordability of spells with dynamic costs.

## Tasks

### 1. Modify ai/OpponentAI.lua - OpponentAI:decide()
When the AI considers casting a spell (e.g., `spell = self.personality:getAttackSpell(...)`), it currently checks `self.wizard:canPayManaCost(spell.cost)`.

This check needs to be updated to correctly use the dynamic cost function if available:

```lua
local costToEvaluate
if spell.getCost then
    -- AI needs to evaluate the cost in its current perceived context
    -- The OpponentAI's 'self.wizard' is the AI's wizard, 'self.playerWizard' is the opponent
    costToEvaluate = spell.getCost(self.wizard, self.playerWizard) 
else
    costToEvaluate = spell.cost
end
local canAfford = self.wizard:canPayManaCost(costToEvaluate)

if spell and self:hasAvailableSpellSlot() and canAfford then
    return { type = "CAST_SPELL", spell = spell, reason = reason }
end
```

### 2. Modify Personality Modules (e.g., ai/personalities/SelenePersonality.lua)
- No direct changes needed in how personalities return spells
- They should continue to return the spell object
- The core AI (`OpponentAI:decide()`) will handle the dynamic cost evaluation
- However, more advanced personality logic might internally call `wizard:canPayManaCost(spell.getCost and spell.getCost(...) or spell.cost)` if it needs to make finer-grained decisions about which spell to suggest based on fluctuating costs
- For now, this isn't strictly necessary

## Acceptance Criteria
- The AI correctly determines if it can afford a spell with a dynamic cost
- The AI attempts to cast dynamically-costed spells only when affordable based on the current game state

## Design Notes/Pitfalls
- The AI's perception of the game state (which `getCost` might depend on) might be slightly delayed due to `perceptionInterval`
- This is generally acceptable for AI behavior

## Tickets/S13_FlexibleSpellCosts/SCT-3-ui-display-of-dynamic-costs.md
# SCT-3: UI Display of Dynamic Costs

**Goal:** Update the UI (spellbook modal, keyed spell popup) to appropriately display costs for spells that might be dynamic.

## Tasks

### 1. Modify ui.lua - UI.drawSpellbookModal (and its internal formatCost)
- The `formatCost` helper and the spell display logic currently expect `spell.cost` to be a static table
- When displaying a spell's cost, check if `spell.getCost` exists
- If it does, call `local displayCost = spell.getCost(wizard, opponentWizard)` to get the current cost for display purposes
  - Need to ensure `opponentWizard` is available in this context, or `getCost` functions need to be robust to a nil target if not relevant
- Then, use `displayCost` with the `formatCost` helper
- Consider adding a visual indicator (e.g., an asterisk `*` or a different color) if a spell's cost is dynamic to inform the player

### 2. Modify ui.lua - UI.drawPlayerSpellbook (for keyed spell popup)
- Similar to the spellbook modal, if `wizard.currentKeyedSpell.getCost` exists, evaluate it in the current context to display its cost
- Note: This part of the UI doesn't currently show cost, but if it were to be added, it would need this logic
- The keyed spell popup `wizard.currentKeyedSpell.name` is drawn. Cost is not shown there, so no change needed for this specific part unless we decide to add cost display there

### 3. Modify characterData.lua or spell definitions (spells/elements/*.lua)
- If a spell uses `getCost`, its static cost field could represent a "base cost" or "typical cost" for display if evaluating the dynamic one is too complex or volatile for a quick UI glance
- The UI would then need to be aware of this convention
- For simplicity now, we'll assume UI always tries to evaluate `getCost`

## Acceptance Criteria
- Spellbook UI displays the dynamically calculated cost of spells if `getCost` is defined
- (Optional) UI indicates that a spell's cost is dynamic

## Design Notes/Pitfalls
- Displaying a constantly changing cost in the UI might be distracting
- A "base cost" with an indicator, or evaluating it only when the spellbook is opened, might be better UX long-term
- For now, live evaluation is simplest to implement
- The `formatCost` helper itself likely doesn't need changes, as it already expects a resolved cost table

## Tickets/S13_FlexibleSpellCosts/SCT-4-example-spell-implementation.md
# SCT-4: Example Spell Implementation

**Goal:** Implement 1-2 spells that utilize the new dynamic getCost feature to demonstrate and test its functionality.

## Tasks

### 1. Choose/Design Spells
- **Example 1:** A "Desperation Strike" spell whose cost in FIRE tokens decreases as the caster's health gets lower
- **Example 2:** A "Resource Drain" spell whose cost in MOON tokens increases based on the number of STAR tokens the opponent has in their active spell slots

### 2. Implement in spells/elements/*.lua

#### Example: Desperation Fire
```lua
-- Example: Desperation Fire
Spells.desperationFire = {
    id = "desperationfire",
    name = "Desperation Fire",
    affinity = Constants.TokenType.FIRE,
    description = "A fiery attack whose Fire cost decreases as your health lowers.",
    attackType = Constants.AttackType.PROJECTILE,
    castTime = Constants.CastSpeed.NORMAL,
    cost = { Constants.TokenType.FIRE, Constants.TokenType.FIRE, Constants.TokenType.FIRE }, -- Base/max cost for UI reference
    keywords = { damage = { amount = 15, type = Constants.DamageType.FIRE } },
    getCost = function(caster, target)
        local fireCost = 3
        if caster.health < 75 then fireCost = 2 end
        if caster.health < 40 then fireCost = 1 end
        if caster.health < 20 then fireCost = 0 end -- Free at critical health
        
        local finalCost = {}
        for i = 1, fireCost do
            table.insert(finalCost, Constants.TokenType.FIRE)
        end
        -- Add any other static costs if necessary
        -- table.insert(finalCost, Constants.TokenType.ANY) 
        return finalCost
    end
}
```

#### Example: Moon Drain
```lua
-- Example: Moon Drain (cost depends on opponent's channeled STAR tokens)
Spells.moonDrain = {
    id = "moondrain",
    name = "Moon Drain",
    affinity = Constants.TokenType.MOON,
    description = "Drains opponent. Costs more Moon tokens if opponent is channeling Star mana.",
    attackType = Constants.AttackType.REMOTE,
    castTime = Constants.CastSpeed.FAST,
    cost = { Constants.TokenType.MOON }, -- Base cost
    keywords = { damage = { amount = 8, type = Constants.DamageType.MOON } },
    getCost = function(caster, target)
        local moonTokens = 1
        if target then
            for _, slot in ipairs(target.spellSlots) do
                if slot.active and slot.tokens then
                    for _, tokenData in ipairs(slot.tokens) do
                        if tokenData.token.type == Constants.TokenType.STAR then
                            moonTokens = moonTokens + 1
                        end
                    end
                end
            end
        end
        local finalCost = {}
        for i = 1, math.min(moonTokens, 4) do -- Cap cost increase
            table.insert(finalCost, Constants.TokenType.MOON)
        end
        return finalCost
    end
}
```

### 3. Add to a Character's Spellbook (characterData.lua)
Make these spells available to test.

## Acceptance Criteria
- The example spells function correctly, with their costs changing based on the defined game state conditions
- These spells can be cast by both player and AI (if AI is configured to use them)

## Design Notes/Pitfalls
- `getCost` functions should be relatively lightweight
- Can reuse `expr.lua` helpers within `getCost` if the desired output is a token type string, though direct logic as shown above is also fine

## Tickets/S13_FlexibleSpellCosts/SCT-5-documentation.md
# SCT-5: Documentation

**Goal:** Document the new dynamic cost feature and ensure robust testing.

## Tasks

### 1. Update docs/spellcasting.md
- Explain the `getCost` function in spell definitions
- Provide an example of its usage

### 2. Update docs/wizard.md
- Mention how `canPayManaCost` and `queueSpell` handle dynamic costs

### 3. Update docs/DevelopmentGuidelines.md
- Add a section on defining spells with dynamic costs

## Acceptance Criteria
- Relevant documentation is updated

## Tickets/S14_InputSystemRefactor/INPUT-1-define-control-actions-default-mappings-settings-integration.md
# INPUT-1: Define Control Actions, Default Mappings, and Settings Integration

**Goal:** Establish a canonical list of abstract game actions, define default keyboard/gamepad mappings for them, and update the settings system to store and manage these control configurations.

## Tasks

### 1. Define Action Constants (core/Constants.lua)
Create `Constants.ControlAction = { ... }` enum table.

Include actions for:
- **Player 1:** P1_SLOT1, P1_SLOT2, P1_SLOT3, P1_CAST, P1_FREE, P1_BOOK
- **Player 2:** P2_SLOT1, P2_SLOT2, P2_SLOT3, P2_CAST, P2_FREE, P2_BOOK
- **Menu Navigation:** MENU_UP, MENU_DOWN, MENU_LEFT, MENU_RIGHT
- **Menu Actions:** MENU_CONFIRM, MENU_CANCEL_BACK
- **System (Optional):** SYS_TOGGLE_DEBUG, SYS_QUIT_MENU_BACK (for unified Escape key)

### 2. Define Default Mappings & Update Settings (core/Settings.lua)
Modify `defaults.controls` to map `Constants.ControlAction` enums to default input strings (e.g., "q", "a" for gamepad button, "dpup" for D-pad up).

Structure:
```lua
defaults.controls = {
    keyboardP1 = { [Constants.ControlAction.P1_SLOT1] = "q", ... },
    keyboardP2 = { [Constants.ControlAction.P2_SLOT1] = "i", ... },
    gamepadP1  = { [Constants.ControlAction.P1_SLOT1] = "dpdown", [Constants.ControlAction.P1_CAST] = "a", ... },
    gamepadP2  = { [Constants.ControlAction.P2_SLOT1] = "dpdown", ... } -- Placeholder for P2 controller
}
```

- Ensure `Settings.load()` correctly merges new defaults if a settings.lua file already exists (handle adding new control sections)
- Ensure `Settings.save()` correctly serializes the new structure

### 3. Update Input.lua (Initial Settings Load)
- Modify `Input.init(game)` to load the new control structures from `gameState.settings.get("controls")`
- For now, `Input.setupRoutes()` might be partially non-functional until INPUT-2, but ensure no crashes occur due to the changed settings structure

## Acceptance Criteria
- `Constants.ControlAction` enum table is fully defined in core/Constants.lua
- core/Settings.lua contains default keyboard (P1 & P2) and generic gamepad (P1) mappings for all defined actions
- The game loads settings with the new control structure without errors and saves them correctly
- Game runs without crashing, input might be partially broken pending INPUT-2

## Tickets/S14_InputSystemRefactor/INPUT-2-refactor-input-lua-action-based-dispatch.md
# INPUT-2: Refactor Input.lua for Action-Based Dispatch

**Goal:** Rework Input.lua to map physical inputs (keys/buttons) to abstract ControlActions, and have game logic respond to these actions.

## Tasks

### 1. Modify Input.setupRoutes() (core/Input.lua)
- `Input.Routes` (e.g., `Input.Routes.p1_kb`, `Input.Routes.p2_kb`, `Input.Routes.gp1`, `Input.Routes.system`) will now store anonymous functions
- Dynamically populate `Input.Routes` based on loaded settings:
  - Iterate through `controls.keyboardP1`. For each `actionConstant = keyName` pair, `Input.Routes.p1_kb[keyName] = function() Input.triggerAction(actionConstant, 1) end`
  - Similarly for `keyboardP2`
  - Gamepad routes will be handled differently in INPUT-3

### 2. Create Input.triggerAction(action, playerIndex, params) (core/Input.lua)
This new central function will contain the if/elseif logic previously in individual route handlers.

Takes the action (from `Constants.ControlAction`), an optional `playerIndex` (1 or 2), and optional `params`.

Example:
```lua
function Input.triggerAction(action, playerIndex, params)
    local gs = gameState -- Local reference for brevity
    if action == Constants.ControlAction.P1_SLOT1 and playerIndex == 1 then
        gs.wizards[1]:keySpell(1, true)
    elseif action == Constants.ControlAction.P1_CAST and playerIndex == 1 then
        gs.wizards[1]:castKeyedSpell()
    elseif action == Constants.ControlAction.P1_SLOT1_RELEASE and playerIndex == 1 then -- New action type
        gs.wizards[1]:keySpell(1, false)
    -- ... similar for P2 actions ...
    elseif action == Constants.ControlAction.MENU_UP then
        Input.triggerUIAction(action, params) -- Delegate UI actions
    -- ...
    end
end
```

### 3. Modify Input.handleKey(key, scancode, isrepeat)
- Its role is now to look up `key` in the appropriate `Input.Routes` (e.g., `Input.Routes.p1_kb[key]`) and call the routed function if found
- Distinguish between P1 and P2 keyboard routes

### 4. Modify Input.handleKeyReleased(key, scancode)
- Load current P1/P2 keyboard controls
- If key matches a P1 slot key, call `Input.triggerAction(Constants.ControlAction.P1_SLOT1_RELEASE, 1)` (or SLOT2/3)
- Similarly for P2

### 5. Create Input.triggerUIAction(action, params) (core/Input.lua or main.lua)
- This function will handle actions like `MENU_UP`, `MENU_CONFIRM`
- It will check `gameState.currentState` and call the appropriate game logic (e.g., `gameState.settingsMove(-1)`, `gameState.characterSelectConfirm()`)

## Acceptance Criteria
- Player 1 and Player 2 keyboard controls function as before, now dispatched via `Input.triggerAction`
- `Input.setupRoutes` dynamically builds routes from settings
- Input.lua internally uses `Constants.ControlAction`
- Menu-related system keys (like Escape for main menu back/quit) are routed to `Input.triggerUIAction`

## Tickets/S14_InputSystemRefactor/INPUT-3-implement-gamepad-input-processing.md
# INPUT-3: Implement Gamepad Input Processing

**Goal:** Enable the game to receive and process input from gamepads, initially for Player 1.

## Tasks

### 1. Add Gamepad Event Handlers (main.lua)
Implement:
- `love.gamepadpressed(joystick, button)`
- `love.gamepadreleased(joystick, button)`  
- `love.axismoved(joystick, axis, value)` (note: `love.axispressed` is not a LÖVE callback, `love.joystickmoved` handles axes for gamepads too)

Inside these:
- Get `joystick:getID()`
- Initially, assume the first active joystick (`joystick:getID() == 1` or the first one that sends an event) controls Player 1
- Call new functions in Input.lua:
  - `Input.handleGamepadButton(joystickID, buttonName, true/false)`
  - `Input.handleGamepadAxis(joystickID, axisName, value)`

### 2. Modify Input.lua for Gamepad

#### Input.handleGamepadButton(joystickID, buttonName, isPressed)
- Determine `playerIndex` (e.g., if `joystickID == game.p1GamepadID`, then `playerIndex = 1`)
- Load `controls.gamepadP1` (or `gamepadP2`)
- Iterate through this mapping to find which `ControlAction` corresponds to `buttonName`
- Call `Input.triggerAction(action, playerIndex, {pressed = isPressed})`
- Handle button release for spell slot keys by triggering `_RELEASE` variants of actions

#### Input.handleGamepadAxis(joystickID, axisName, value)
- Determine `playerIndex`
- Load `controls.gamepadP1` (or `gamepadP2`)
- Map axis movements (e.g., "leftx", "lefty", "dpup", "dpdown" - LÖVE uses "dpup" etc. for D-pad buttons) to `MENU_UP/DOWN/LEFT/RIGHT` actions
- Implement a deadzone for analog stick axes
- Implement a repeat timer for sustained axis input for menu navigation
- Call `Input.triggerUIAction(action, {value = value})`

### 3. Gamepad ID Management (main.lua or Input.lua)
- Add `game.p1GamepadID = nil`, `game.p2GamepadID = nil`
- In `love.joystickadded(joystick)`:
  - If `game.p1GamepadID` is nil, assign `joystick:getID()` to it
  - Or, if P2 needs a controller, assign it to `game.p2GamepadID`
- In `love.joystickremoved(joystick)`:
  - If `joystick:getID()` matches a stored ID, set it back to nil

## Acceptance Criteria
- A connected gamepad can control Player 1's wizard actions using the default gamepad bindings
- Gamepad D-pad and/or left analog stick can navigate menus that currently support keyboard arrow navigation  
- Gamepad connect/disconnect is handled gracefully

## Tickets/S14_InputSystemRefactor/INPUT-4-settings-menu-for-control-rebinding.md
# INPUT-4: Settings Menu for Control Rebinding

**Goal:** Allow players to rebind keyboard and gamepad controls for all actions via an enhanced Settings menu.

## Tasks

### 1. Extend Settings Menu UI (main.lua -> drawSettingsMenu, new drawRebindMenu)
- Add a "Rebind Controls" option to the main settings menu
- Selecting it sets `game.settingsMenu.mode = "rebind_select_player"` (or similar)

#### drawRebindMenu:
- If `mode == "rebind_select_player"`: Show options like "Player 1 Keyboard", "Player 2 Keyboard", "Player 1 Gamepad"
- If `mode == "rebind_action_list"`: Display a scrollable list of all `Constants.ControlAction` relevant to the selected player/input type. Show current binding next to each. Highlight selected action

### 2. Implement Rebinding Logic (main.lua & Input.lua)
When an action is selected for rebinding:
- Set `game.settingsMenu.waitingForKey = { playerType = "keyboardP1", action = Constants.ControlAction.P1_SLOT1, label = "P1 Slot 1" }` (similar to existing but use `playerType` to specify `keyboardP1`, `gamepadP1` etc.)

#### Input.handleKey():
- If `waitingForKey`, capture key, update `game.settings.controls[playerType][action] = newKeyString`

#### Input.handleGamepadButton():
- If `waitingForKey`, capture button, update `game.settings.controls[playerType][action] = newButtonString`

#### Input.handleGamepadAxis():
- If `waitingForKey` and axis is suitable for binding (e.g., D-pad as buttons), capture axis input
- (Analog stick full axis binding is more complex, might defer)

After capture:
- Call `game.settings.save()`
- Clear `waitingForKey`
- Call `Input.setupRoutes()` to apply changes immediately

### 3. Update Input.setupRoutes()
- Must now be robust enough to handle empty or conflicting bindings (e.g., log warnings, potentially revert to default for specific action if unbound)

## Acceptance Criteria
- Players can navigate to a detailed control rebinding screen
- Players can select any rebindable game action and assign a new keyboard key or gamepad button to it
- The UI updates to show the new binding
- New bindings are saved persistently and are active immediately and upon game restart
- The system handles attempts to bind already-used keys (e.g., prompt for overwrite or disallow)

## Tickets/S14_InputSystemRefactor/INPUT-5-standardize-menu-navigation-with-abstract-actions.md
# INPUT-5: Standardize Menu Navigation with Abstract Actions

**Goal:** Unify menu navigation across all game menus to use the new abstract control actions, supporting keyboard arrows, gamepad D-pad/analog stick, and game action keys (Cast/Free).

## Tasks

### 1. Refactor Menu Input Logic (main.lua)
- Modify existing menu-specific input functions (`settingsMove`, `compendiumMove`, `characterSelectMove`, `campaignMenuMove`, and their "select/confirm/back" counterparts)
- These functions should now be callable with a generic direction (e.g., -1 for up/left, 1 for down/right) or an actionType (e.g., CONFIRM, CANCEL)
- The core `Input.triggerUIAction(action, params)` function will call these refactored menu logic functions based on `gameState.currentState` and the action type (`MENU_UP`, `MENU_CONFIRM`, etc.)

### 2. Update Input.setupRoutes() (core/Input.lua)
- Map keyboard arrow keys (e.g., "up", "down", "left", "right") to `Constants.ControlAction.MENU_UP`, `MENU_DOWN`, `MENU_LEFT`, `MENU_RIGHT`
- Map "return" (Enter) and "space" to `MENU_CONFIRM`
- Map "escape" to `MENU_CANCEL_BACK`

### 3. Enhance Input.triggerAction()
If `gameState.currentState` indicates a menu is active:
- If action is `P1_CAST` or `P2_CAST`, also call `Input.triggerUIAction(Constants.ControlAction.MENU_CONFIRM)`
- If action is `P1_FREE` or `P2_FREE`, also call `Input.triggerUIAction(Constants.ControlAction.MENU_CANCEL_BACK)`

## Acceptance Criteria
- All game menus (Main, Settings, Rebind, Character Select, Compendium, Campaign) are navigable using keyboard arrow keys
- All game menus are navigable using gamepad D-pad and/or left analog stick (with deadzone and repeat)
- The primary "Cast" game action (default F/gamepad A) functions as "Confirm" in menus
- The primary "Free" game action (default G/gamepad B) functions as "Cancel/Back" in menus
- Escape key consistently functions as "Cancel/Back" in menus or "Quit" from the main menu

## Tickets/S14_InputSystemRefactor/INPUT-6-player-2-ai-controller-management.md
# INPUT-6: Player 2 & AI Controller Management

**Goal:** Provide clear mechanisms for enabling/disabling Player 2 human control versus AI, and manage controller assignments.

## Tasks

### 1. Player 2 Mode Selection (Character Select Screen)
- Modify `drawCharacterSelect()` and its associated logic in main.lua
- When Player 2's character is being selected (or after P1 selection if it's a global P2 setting), display an option "P2: Human / AI"
- Allow toggling this setting. This will set/unset `game.useAI`

### 2. Conditional AI Initialization (main.lua)
In `setupWizards()` or `resetGame()` or wherever AI is typically initialized for a battle:
- If `game.useAI` is true, initialize `game.opponentAI` for `game.wizards[2]`
- If `game.useAI` is false, ensure `game.opponentAI` is nil

### 3. Controller Assignment (Input.lua and main.lua)
Maintain `game.p1GamepadID` and `game.p2GamepadID`.

#### love.joystickadded(joystick):
- If `game.p1GamepadID` is nil, assign `joystick:getID()` to it
- Else if `game.p2GamepadID` is nil (and potentially `game.useAI` is false or we are in a state allowing P2 join), assign `joystick:getID()` to `game.p2GamepadID`

#### Input.handleGamepadButton/Axis: 
- Determine `playerIndex` based on `joystickID` matching `game.p1GamepadID` or `game.p2GamepadID`

**Stretch Goal:** If `game.useAI` is true and input is received from `game.p2GamepadID`, prompt "Player 2 Press Start?" or automatically switch `game.useAI` to false and activate P2.

### 4. Disable P2 Keyboard if Gamepad P2 Active
- If `game.p2GamepadID` is not nil and P2 is human, `Input.handleKey` should ignore P2 keyboard default routes to prevent conflicts
- This can be a simple flag `game.p2UsingGamepad = true`

## Acceptance Criteria
- Player can explicitly choose between a human Player 2 or an AI opponent during character selection
- If Human P2 is selected, keyboard controls (remappable) for P2 are active. If a second gamepad is connected and assigned, it controls P2
- If AI P2 is selected, `game.opponentAI` controls `wizards[2]`, and P2 human inputs are ignored
- Attract mode (AI vs AI) remains unaffected and uses its own AI instances

## Tickets/S14_InputSystemRefactor/INPUT-7-input-system-documentation-and-testing.md
# INPUT-7: Input System Documentation & Thorough Testing

**Goal:** Update all relevant documentation to reflect the new input system and perform comprehensive testing across all control schemes and game states.

## Tasks

### 1. Update Documentation

#### Update Input.reservedKeys in core/Input.lua
- List `Constants.ControlActions` and their default bindings for keyboard (P1/P2) and gamepad (P1/P2)

#### Update README.md
- Update the section on controls

#### Update CrashCourse.md and DevelopmentGuidelines.md
- Explain the action-based input system
- Document rebinding capabilities and controller support

### 2. Comprehensive Testing

#### Control Scheme Testing
- Test P1 default keyboard & P1 default gamepad controls
- Test P2 default keyboard controls (when P2 is human and no P2 gamepad)
- Test P2 default gamepad controls (when P2 is human and P2 gamepad active)

#### Rebinding Testing
- Test rebinding for various actions across keyboard P1/P2 and gamepad P1/P2
- Verify rebound controls work immediately and persist after game restart

#### Menu Navigation Testing
- Test all menu navigations with keyboard arrows, gamepad D-pad/analog, and Cast/Free as Confirm/Cancel

#### AI/Human Mode Testing
- Confirm AI mode selection works and AI behavior is correct when active
- Confirm Human P2 works correctly

#### Edge Case Testing
- Check for input conflicts, especially if P2 keyboard and P2 gamepad are both potentially active
- Test different controller connection scenarios (e.g., starting with no gamepad, connecting one mid-game)

## Acceptance Criteria
- All relevant documentation accurately reflects the new input system
- The game is fully playable and configurable with keyboard for P1 & P2, and gamepad for P1 (& P2 if implemented)
- No regressions in existing input-driven functionality
- System is robust to different controller connection scenarios

## Tickets/S1_CoreGameplay/1-1-setup-new-files.md
Ticket #1: Setup Keyword & Compiler Files

Goal: Create the basic file structure for the new system.
Tasks:
Create a new file: keywords.lua. Initialize it with an empty Lua table 
Keywords = {}.
Create a new file: spellCompiler.lua. Define an empty function 
compileSpell(spellDef, keywordData) that currently just returns the input 
spellDef. Require this file where needed (e.g., main.lua or combat.lua).
Ensure both files are correctly loaded by the LÖVE project.
Deliverable: The two new Lua files exist and are integrated into the 
project structure without errors.

## Tickets/S1_CoreGameplay/1-2-define-and-migrate-core-combat-keywords-behavior.md
~Define & Migrate Core Combat Keywords (Behavior Only)

Goal: Populate keywords.lua with initial keywords based on existing core 
combat mechanics found in spells.lua and combat.lua, focusing only on the 
behavior aspect.
Tasks:
Identify core combat actions currently hardcoded (e.g., dealing damage, 
applying stagger).
Define keyword entries in keywords.lua for: damage, stagger, burn (if 
exists).
Populate the behavior table for each. Example for damage: behavior = { 
dealsDamage = true, baseAmount = 10 } (adjust based on actual 
implementation).
Do not add VFX/SFX/description/flags yet.
Deliverable: keywords.lua contains definitions for damage, stagger, burn 
with populated behavior tables reflecting current game logic.~

## Tickets/S1_CoreGameplay/1-3-define-and-migrate-movement-and-positioning-keywords-behavior.md
~Define & Migrate Movement/Positioning Keywords (Behavior Only)

Goal: Define keywords related to player/opponent movement and positioning.
Tasks:
Identify positioning logic (NEAR/FAR, GROUNDED/AERIAL).
Define keyword entries in keywords.lua for: elevate, ground, rangeShift, 
forcePull.
Populate the behavior table for each (e.g., behavior = { setsCasterState = 
"AERIAL" }, behavior = { togglesRange = true }).
Deliverable: keywords.lua includes definitions for movement/positioning 
keywords with populated behavior tables.~

## Tickets/S1_CoreGameplay/1-4-define-and-migrate-resource-and-token-keywords-behavior.md
~Define & Migrate Resource/Token Keywords (Behavior Only)

Goal: Define keywords related to mana token manipulation.
Tasks:
Identify token logic (conjure, dissipate, shift, lock).
Define keyword entries in keywords.lua for: conjure, dissipate, 
tokenShift, lock.
Populate the behavior table for each (e.g., behavior = { addsTokens = 1, 
tokenType = "moon" }, behavior = { locksEnemyPool = true }).
Deliverable: keywords.lua includes definitions for resource/token keywords 
with populated behavior tables.~

## Tickets/S1_CoreGameplay/1-5-define-and-migrate-casttime-defense-zone-keywords.md
~Define & Migrate Cast Time/Defense/Zone Keywords (Behavior Only)

Goal: Define keywords for remaining mechanics: cast time, defense, zone 
effects.
Tasks:
Identify logic for delay, accelerate, dispel, disjoint, freeze, echo, 
block, reflect, zoneAnchor, zoneMulti.
Define corresponding keyword entries in keywords.lua.
Populate the behavior table for each.
Deliverable: keywords.lua includes definitions for these remaining 
keywords with populated behavior tables.~

## Tickets/S1_CoreGameplay/1-6-implement-spell-compiler-for-behavior.md
~ Implement Spell Compiler (Behavior Merging)

Goal: Make compileSpell function correctly merge behavior data from 
multiple keywords.
Tasks:
Implement the logic inside compileSpell(spellDef, keywordData) in 
spellCompiler.lua.
Loop through spellDef.keywords.
For each keyword, fetch its definition from keywordData.
Merge the behavior table from the keyword into a compiledSpell.behavior 
table. Define a clear merge strategy (e.g., simple table merge, last 
keyword wins for conflicting keys, or additive for things like damage 
bonuses).
The function should return a compiledSpell object containing name, cost, 
cooldown (from spellDef) and the merged behavior table.
Deliverable: compileSpell function correctly processes a sample spellDef 
and merges behavior tables from the specified keywords. Add unit tests if 
possible.~

## Tickets/S1_CoreGameplay/1-7-refactor-spells-file.md
~ Refactor spells.lua

Goal: Convert all spell definitions in spells.lua to use the new 
keyword-only format.
Tasks:
Go through each spell definition in spells.lua.
Remove all hardcoded behavior logic, VFX calls, SFX triggers etc.
Replace them with a keywords = { ... } list, using the keywords defined in 
keywords.lua.
Keep name, cost, cooldown fields.
Deliverable: spells.lua contains only keyword-based definitions. All 
previous spell logic is now represented by keyword lists.~

## Tickets/S1_CoreGameplay/1-8-integrate-compiled-spells.md
~Integrate Compiled Spells into Simulation

Goal: Modify the game simulation (combat.lua or relevant files) to use the 
compiled spell objects instead of the old spells.lua definitions.
Tasks:
Identify where spells are loaded/accessed for casting (e.g., main.lua on 
load, or combat.lua when casting starts).
Call compileSpell for each spell defined in spells.lua at game 
initialization. Store these compiled spell objects (e.g., in a 
CompiledSpells table).
Update functions like castSpell, applyEffect, etc., to read data from 
compiledSpell.behavior (e.g., if compiledSpell.behavior.dealsDamage then 
...) instead of checking spell names or reading directly from the old 
Spells table structure.
Deliverable: The game runs, spells can be cast, and their behavioral 
effects (damage, state changes, token manipulation) work correctly based 
on the data merged by the spellCompiler. Visuals and sounds might be 
broken or missing at this stage. Thorough testing is crucial here.~

## Tickets/S2_Shields/2-1-refactor-block-keyword-execution.md
# Ticket PROG-18: Refactor block Keyword Execution

## Goal
Make the block keyword only responsible for setting up the intent to create a shield when its spell resolves.

## Tasks

1. In keywords.lua, modify the block.execute function. Instead of just setting simple flags, have it return a structured shieldParams table within the results. Example:

```lua
execute = function(params, caster, target, results)
    results.shieldParams = {
        createShield = true,
        defenseType = params.type or "barrier",
        blocksAttackTypes = params.blocks or {"projectile"},
        reflect = params.reflect or false
        -- Mana-linking is now the default, no need for a flag
    }
    return results
end
```

2. Remove the direct setting of results.isShield, results.defenseType, etc., from the keyword's execute.

## Acceptance Criteria
The block keyword's execute function returns a shieldParams table in the results.

## Tickets/S2_Shields/2-2-refactor-wizard-castspell-for-shield-activation.md
# Ticket PROG-19: Refactor Wizard:castSpell for Shield Activation

## Goal
Handle the transition from a casting spell to an active shield state cleanly after keyword execution.

## Tasks

1. Modify Wizard:castSpell after the `effect = spellToUse.executeAll(...)` call.
   - Check if `effect.shieldParams` exists and `effect.shieldParams.createShield == true`.

2. If true:
   - Call the existing createShield function (or integrate its logic here), passing self (the wizard), spellSlot, and effect.shieldParams. This function will handle:
     - Setting `slot.isShield = true`.
     - Setting `slot.defenseType`, `slot.blocksAttackTypes`, `slot.reflect`.
     - Setting token states to SHIELDING.
     - Setting `slot.progress = slot.castTime` (shield is now fully "cast" and active).
     - Triggering the "Shield Activated" VFX.
   - Crucially: Do not reset the slot or return tokens for shield spells here. The slot remains active with the shield.

3. If not a shield spell (no effect.shieldParams), proceed with the existing logic for returning tokens and resetting the slot.

4. Remove the old `if slot.willBecomeShield...` logic from Wizard:update and the premature `slot.isShield = true` setting from Wizard:queueSpell. The state change happens definitively in castSpell now.

## Acceptance Criteria
Shield spells correctly transition to an active shield state managed by the slot. Tokens remain and are marked SHIELDING. Non-shield spells resolve normally. The createShield function is now properly triggered by the keyword result.

## Tickets/S2_Shields/2-3-integrate-checkshieldblock-into-castspell.md
# Ticket PROG-20: Integrate checkShieldBlock into castSpell

## Goal
Move the shield blocking check into the appropriate place in the spell resolution flow.

## Tasks

1. In Wizard:castSpell, before calling `effect = spellToUse.executeAll(...)` and before checking for the caster's own blockers (like the old Mist Veil logic, which should be removed per PROG-16), call the existing `checkShieldBlock(spellToUse, attackType, target, self)`.

2. If `blockInfo.blockable` is true:
   - Trigger block VFX.
   - Call `target:handleShieldBlock(blockInfo.blockingSlot, spellToUse)` (from PROG-14 - assuming it exists or implement it now).
   - Crucially: Return early from castSpell. Do not execute the spell's keywords or apply any other effects.

3. Remove the separate checkShieldBlock call that happens later in the current castSpell.

## Acceptance Criteria
Incoming offensive spells are correctly checked against active shields before their effects are calculated or applied. Successful blocks prevent the spell and trigger shield mana consumption.

## Tickets/S2_Shields/2-4-implement-wizard-handleshieldblock.md
# Ticket PROG-14: Implement Wizard:handleShieldBlock

## Goal
Centralize the logic for consuming mana from a shield when it blocks.

## Tasks

1. Create `Wizard:handleShieldBlock(slotIndex, blockedSpell)`.

2. Get the shieldSlot.

3. Check token count > 0.

4. Determine tokensToConsume based on blockedSpell.shieldBreaker (default 1).

5. Remove the correct number of tokens from shieldSlot.tokens.

6. Call `self.manaPool:returnToken()` for each consumed token index.

7. Trigger "token release" VFX.

8. If `#shieldSlot.tokens == 0`: Deactivate the slot, trigger "shield break" VFX, clear shield properties (isShield, etc.).

## Acceptance Criteria
Shield correctly consumes mana tokens upon blocking. Shield breaks when mana is depleted. Slot becomes available again.

## Tickets/S2_Shields/2-5-refactor-mist-veil.md
# Ticket PROG-21: Refactor Mist Veil

## Goal
Remove the custom executeAll from Spells.mist and define it purely using keywords.

## Tasks

1. In spells.lua, remove the executeAll function from Spells.mist.

2. Ensure its keywords table correctly defines both the block keyword parameters and the elevate keyword parameters:

```lua
keywords = {
    block = { type = "ward", blocks = {"projectile", "remote"} },
    elevate = { duration = 4.0 }
}
```

## Acceptance Criteria
Mist Veil works correctly using the standard keyword compilation and resolution process.

## Tickets/S2_Shields/2-6-remove-old-blocker-system.md
# Ticket PROG-16: Remove Old Blocker System

## Goal
Clean up the codebase by removing the deprecated blocker system that's now replaced by the shield keyword system.

## Tasks

1. Remove wizard.blockers property and related initialization.

2. Remove all logic that manages blocker timers.

3. Remove any drawing code related to the old blocker system.

4. Ensure all references to the old blocker system are removed or migrated to the new shield system.

## Acceptance Criteria
The old blocker system is completely removed from the codebase, and all shield functionality works through the new shield system without errors.

## Tickets/S2_Shields/2-7-visual-distinction-for-shield-slots.md
# Ticket PROG-15: Visual Distinction for Shield Slots

## Goal
Improve UI clarity by visually distinguishing active shield slots from regular spell slots.

## Tasks

1. Update drawSpellSlots to show active shields differently.

2. Implement visual indicators for active shield slots, such as:
   - Different border color or glow
   - Shield icon or overlay
   - Distinct background color or pattern

3. Ensure the visual distinction scales appropriately with the UI and is visible at different game resolutions.

## Acceptance Criteria
Active shield slots are visually distinct from regular spell slots in a way that clearly communicates their status to the player.

## Tickets/S3_CodeQualityAndEvents/3-1-implement-sprite-audio-asset-cache.md
# Ticket #1 – Implement Sprite/Audio Asset Cache

## Goal
Eliminate duplicate texture loads and audio buffers; centralise behind a lightweight cache so every part of the codebase calls the same memoised accessor.

## Tasks
1. Create core/AssetCache.lua.
2. Add getImage(path) and getSound(path); store results in up‑valued tables.
3. Replace every love.graphics.newImage / love.audio.newSource call with the cache accessor (grep for newImage( and newSource()).
4. Add a flush() helper for dev‑hot‑reload (optional).
5. Unit‑test by loading the same path twice and asserting object identity.

## Deliverables
* AssetCache module.
* Refactor PR touching manapool.lua, vfx.lua, etc.
* Unit‑test spec/asset_cache_spec.lua.

## Design notes
Use weak tables if you want GC to reclaim unused assets during scene unloads.
Expose a simple metrics function (dumpStats()) for debug overlay.

## Pitfalls
Don't cache images created at runtime (e.g., canvases). Ensure synchronous load only during boot, not inside the render loop.

## Senior Feedback
* **Additional Files to Check**: Also review ui.lua and wizard.lua as they may load UI images or character-specific sounds directly. Currently, manapool.lua loads assets/sprites/token-lock.png and token images, vfx.lua loads several particle/glow images, and wizard.lua loads the base wizard sprite.
* **Global State/GC Concerns**: A global or singleton AssetCache can sometimes hold references longer than intended, especially during scene transitions. Test the flush() helper thoroughly if implemented to ensure proper cleanup during hot-reloads.
* **Load Timing**: Ensure all assets needed for the initial scene are loaded synchronously during startup (love.load) and not deferred to first use, which could cause gameplay hitches. Consider an explicit preload() function.
* **Validation**: The pitfall about not caching runtime-created images is relevant – maintain strict separation between file-based assets and dynamic canvases.

## Tickets/S3_CodeQualityAndEvents/3-2-unify-key-input-routing.md
# Ticket #2 – Unify Key-Input Routing

## Goal
Replace the two clashing love.keypressed definitions with a single dispatcher that cleanly separates system shortcuts, player 1, player 2, and debug hooks.

## Tasks
1. Add core/Input.lua with Input.handleKey(key, scancode, isrepeat).
2. Move scaling keys, gameplay keys, debug keys into tables inside that file (Input.Routes.system, Routes.p1, …).
3. In main.lua, replace definitions with: function love.keypressed(...) Input.handleKey(...) end.
4. Update love.keyreleased similarly.
5. Write a quick doc block listing reserved keys.

## Deliverables
* Input module + updated main.lua.
* Manual QA: scaling shortcuts, spell casting, debug overlay still work.

## Pitfalls
Be careful not to double‑map "1"/"2" that are already used for both scaling and VFX tests— resolve or namespace via ALT modifier.

## Senior Feedback
* **Confirmed Key Conflicts**: The conflict with "1" and "2" keys is evident in the codebase. main.lua uses ALT + "1"/"2"/"3" for scaling and "1" through "8" for VFX tests. wizard.lua (via main.lua's love.keypressed) uses "1" and "2" for custom spells moonWard and mirrorShield.
* **Input Complexity Warning**: The current love.keypressed in main.lua handles multiple concerns: game state checks, player 1/2 inputs (q/w/e/f/g/b, i/o/p/j/h/m), debug keys (t, z, x, c, r, a, s), scaling (ALT+1/2/3/f), and VFX tests (1-8). This consolidation requires careful state management and clear separation of concerns.
* **Key Release Handling**: Ensure the love.keyreleased handler in main.lua (which updates wizard.activeKeys) is also correctly migrated to prevent sticky keys.
* **UI Input Planning**: Consider how UI interactions (like closing modal dialogs) will fit into this system if mouse input is added later, even if not immediately implemented.

## Tickets/S3_CodeQualityAndEvents/3-3-introduce-constants-enum-tables.md
# Ticket #3 – Introduce Constants / Enum Tables

## Goal
Replace string literals used as enums (token types, target types, range states, etc.) with a single canonical table (Constants). Improves auto‑complete, reduces typos.

## Tasks
1. Create core/Constants.lua.
2. Populate subtables: Tokens, Targets, RangeStates, ShieldTypes… (pull the raw strings from keywords.lua).
3. Refactor modules to reference Constants.Tokens.FIRE etc.; start with keywords.lua, spellCompiler.lua.
4. Add a luacheck rule or custom CI script to forbid new magic strings (grep -e '\"fire\"').

## Deliverables
* Constants module.
* Refactor PR (touches <10 files).
* CI lint rule update.

## Design notes
Use plain tables not metatables to avoid runtime cost; constants are just shared values.

## Pitfalls
Watch for concatenation like "POOL_" .. side—replace with a helper Constants.pooleSide(side).

## Senior Feedback
* **Additional Files to Check**: Also check wizard.lua (uses "GROUNDED"/"AERIAL", potentially shield types), manapool.lua (uses token states like "FREE", "CHANNELED", "LOCKED", "DESTROYED", "SHIELDING"), and main.lua (uses "NEAR"/"FAR"). Perform a comprehensive codebase search to verify the <10 files estimate.
* **Naming Conventions**: Ensure consistent naming conventions across all constant types (e.g., Constants.RangeState.NEAR, Constants.TokenType.FIRE).
* **Dynamic String Usage**: The concatenation pattern ("POOL_" .. side) wasn't immediately visible in the reviewed code, but look for similar patterns during refactoring. In keywords.lua under dissipate, pay attention to target selection (params.target == "caster" and caster or target).
* **CI Rule Complexity**: Implementing a luacheck rule to reliably forbid magic strings across the codebase will be tricky, especially distinguishing legitimate strings from enum candidates. Start with a simple rule that can be refined over time.

## Tickets/S3_CodeQualityAndEvents/3-4-implementation-summary.md
# Ticket 3-4 Implementation Summary

## Tasks Completed

1. **Core Pool Module**:
   - Created `core/Pool.lua` with `acquire()` and `release()` functions
   - Added pool statistics tracking and debugging tools
   - Implemented object reuse with customizable factory and reset functions
   - Added automatic pool growth for high-demand scenarios
   - Created comprehensive visual debug overlay

2. **Mana Token Pooling**:
   - Refactored `manapool.lua` to use Pool.acquire("token") instead of direct table creation
   - Implemented token reset function to safely clear all token properties
   - Modified token destruction code to release tokens back to the pool
   - Pre-allocated a pool of 50 tokens for smooth gameplay

3. **VFX Particle Pooling**:
   - Refactored `vfx.lua` to use pools for both effects and particles
   - Implemented proper cleanup with nested pool relationships (effects contain particles)
   - Added specialized reset functions to handle different particle types
   - Pre-allocated pools based on typical usage patterns
   - Added VFX-specific pool statistics functions

4. **Debug Features**:
   - Added pool statistics overlay (accessed with `` ` `` + `p` in debug mode)
   - Created pool usage tracking with reuse percentage calculations
   - Added console logging for key pool operations
   - Implemented test script for validating pool behavior

## Design Decisions

1. **Multiple Pool Types**: We decided to use separate pools for different object types (tokens, VFX particles, VFX effects) rather than a single pool with type information. This provides better type safety and simplifies reset functions.

2. **Reset Strategy**: Each pool has a custom reset function that meticulously clears all object properties to prevent "spooky action at a distance" bugs from lingering references.

3. **Debug Integration**: The pool system integrates with the existing debug overlay system, making it easy to monitor pool performance during gameplay.

4. **Factory Functions**: Each pool uses a factory function to customize object creation, allowing specialized initialization for different object types.

## Debug Instructions

To monitor pool usage:
1. Press `` ` `` to activate debug mode
2. Press `p` to show pool statistics overlay
3. Watch object counts, active/available ratios, and reuse percentages

## Testing 

A comprehensive test script at `tools/test_pools.lua` validates:
- Basic pool operations (create, acquire, release)
- Pool growth under high demand
- Token usage simulation with realistic patterns
- VFX particle simulation with bursts of effects

## Benefits

1. **Reduced Garbage Collection**: By reusing objects instead of creating and discarding them, we've reduced GC pressure significantly.

2. **Smoother Gameplay**: Frame spikes from large object allocations are eliminated, providing more consistent frame times.

3. **Memory Efficiency**: Object pooling keeps memory usage more predictable and avoids fragmentation over time.

4. **Enhanced Debugging**: The pool statistics tools make it easy to identify potential memory leaks or inefficient object usage.

## Future Enhancements

1. **Automatic Shrinking**: Pools could automatically shrink when demand decreases for extended periods.

2. **Time-Based Stats**: Add timing information to track peak allocation rates.

3. **Object Validation**: Add runtime checks to ensure objects are properly reset before reuse.

## Tickets/S3_CodeQualityAndEvents/3-4-object-pools-for-mana-tokens-vfx-particles.md
# Ticket #4 – Object Pools for Mana Tokens & VFX Particles

## Goal
Reduce garbage generation and frame spikes by reusing token and particle tables instead of creating / GC‑ing every frame.

## Tasks
1. Add core/Pool.lua with acquire() / release().
2. Refactor manapool.lua token creation to Pool.acquire("token").
3. Do the same for VFX.createEffect particle tables.
4. Optional: add game.showPoolsStats() debug overlay.

## Deliverables
* Pool module.
* Profiling numbers (before/after) in PR description.

## Pitfalls
Ensure released objects are fully reset; lingering references will cause spooky bugs.

## Senior Feedback
* **Complex Object Reset**: The resetting of released objects is particularly critical for this codebase:
  * Mana Tokens (manapool.lua) have many properties: state, lockDuration, valenceIndex, orbitAngle, orbitSpeed, pulsePhase, rotAngle, valenceJumpTimer, transition states, wizardOwner, spellSlot, etc. The Pool.release function must meticulously reset all of these. Consider adapting logic from the existing finalizeTokenReturn function in manapool.lua.
  * VFX Particles (vfx.lua) have different properties depending on the effect type: x, y, scale, alpha, rotation, delay, active, speed, targetX/Y, angle, distance, orbitalSpeed, position, offset, speedX/Y, finalPulse, etc.
* **Pool Design Question**: Decide whether to use a single Pool module handling different object types, or separate pools. If using a single Pool, ensure the acquire/release logic correctly handles the different structures for each object type.
* **Performance Measurement**: Focus profiling efforts on scenarios with high token/particle turnover (e.g., rapid spellcasting, complex VFX) to demonstrate the most significant improvements.

## Tickets/S3_CodeQualityAndEvents/3-5-event-list-execution-refactor.md
# Ticket #5 – Event-List Execution Refactor

## Goal
Decouple combat logic from in-memory wizard structures by having compiledSpell.executeAll() return an event list ({type="Damage", amount=12, target="enemy"}) instead of mutating slots/tokens directly.

## Tasks
1. Define event schema in docs/combat_events.md.
2. Update SpellCompiler.executeAll to push events rather than side-effects (start with damage, block, conjure).
3. Add systems/EventRunner.lua that consumes events and applies them to game state.
4. Refactor wizard.lua & token logic to use EventRunner.
5. Backfill unit tests for a few spells to assert event → state changes.

## Deliverables
* Event schema doc.
* Spell compiler refactor.
* Event runner + tests.
* No gameplay regressions (manual test).

## Design notes
This is the big refactor—do it in a feature branch. Begin with a "dual‑path" flag so you can compare old vs new at runtime.

## Pitfalls
Order‑of‑operations bugs (e.g., tokens conjured before damage vs after). Use deterministic test seeds.

## Senior Feedback
* **Complexity Assessment**: This is the most ambitious ticket and represents the core decoupling effort. Currently, SpellCompiler.executeAll directly calls keyword execute functions which often mutate caster, target, or results directly, or interact with caster.manaPool. Changing this to a descriptive event system is a significant architectural shift.
* **Event Schema Scope**: The event schema must be comprehensive, covering all effects produced by keywords:
  * Damage events (amount, type)
  * Status effects (burn, freeze, stagger - type, duration, parameters)
  * Elevation changes (target, state, duration)
  * Range changes (new state)
  * Mana pool changes (conjure type/amount, dissipate type/amount, lock duration)
  * Cast time changes (delay/accelerate amount, target slot)
  * Spell cancellation (dispel/disjoint target slot)
  * Shield creation (type, blocks, reflect)
  * Echo, zone effects, etc.
* **EventRunner Implementation**: EventRunner.lua will become the only place state is mutated based on spell effects. Consider whether it processes events sequentially or needs processing phases (e.g., apply all state changes first, then calculate/apply damage).
* **Extensive Refactoring Scope**: This touches spellCompiler.lua, keywords.lua (execute functions now return event descriptions), wizard.lua (state changes applied by the runner), manapool.lua (token changes applied by the runner), and requires the new EventRunner.lua.
* **Testing Strategy**: The "deterministic test seeds" suggestion is vital. Develop comprehensive unit tests comparing the before/after behavior of specific spells with controlled game states.

## Tickets/S3_CodeQualityAndEvents/3-5-implementation-summary.md
# Ticket #3-5: Event List Execution Refactor - Implementation Summary

## Overview

This ticket implements a major architectural shift in how spell effects are applied to the game state. Previously, the `compiledSpell.executeAll()` method directly mutated wizard and token states in memory. The new system generates a structured series of events that are then processed by a dedicated `EventRunner` which cleanly applies the state changes.

## Files Created/Modified

**New Files:**
- `docs/combat_events.md` - Comprehensive event schema definition
- `systems/EventRunner.lua` - Core event processing system
- `tools/test_eventRunner.lua` - Unit tests for EventRunner
- `tools/test_spellEvents.lua` - Tests for spell event generation
- `tools/compare_event_systems.lua` - Legacy vs. event system comparison
- `tools/system_test_event_integration.lua` - End-to-end integration test
- `patches/wizard_castSpell_event_integration.patch` - Patch for wizard.lua

**Modified Files:**
- `spellCompiler.lua` - Updated to generate events instead of mutating state
- `Tickets/3-5-implementation-summary.md` - This implementation summary

## Key Changes

1. **Event Schema Definition**
   - Created a comprehensive event schema in `docs/combat_events.md`
   - Defined standard event structure with type, source, and target fields
   - Documented 15+ event types covering all existing keyword behaviors

2. **EventRunner Implementation**
   - Created `systems/EventRunner.lua` to process events and apply state changes
   - Implemented priority-based event processing for consistent execution order
   - Added handlers for all event types (damage, status, elevation, etc.)
   - Built backward compatibility conversion from old results format

3. **Spell Compiler Updates**
   - Modified `SpellCompiler.lua` to generate events rather than mutate state directly
   - Added a toggle system to switch between legacy and event-based execution
   - Preserved backward compatibility while enabling the new functionality
   - Added debug options for tracing event generation and processing

4. **Testing and Validation**
   - Created test scripts to validate the new event system
   - Implemented side-by-side comparison of legacy vs. event-based execution
   - Added comprehensive unit tests for event generation and processing

## Implementation Details

### Event System Architecture

The new event system follows this execution flow:

1. Spell's `executeAll()` executes keyword behaviors to collect state changes
2. Changes are converted to structured events with standardized fields
3. Events are sorted by priority to ensure consistent execution order
4. `EventRunner.processEvents()` applies each event to the game state
5. Results are collected and returned for UI/VFX updates

### Execution Priority

Events are processed in a carefully designed order to ensure consistency:

1. State-setting events (elevation, range)
2. Resource events (token creation, destruction)
3. Spell timeline events (delay, accelerate, cancel)
4. Defense events (shields, reflects)
5. Status effect events
6. Damage events
7. Special effect events

### Backward Compatibility

The implementation maintains full backward compatibility through:

1. A dual-path system that can use either legacy or event-based execution
2. Automatic conversion of legacy results to events
3. Preservation of the existing results table structure

## Benefits

1. **Separation of Concerns**: Event description (what happens) is separated from state mutation (how it happens)
2. **Testability**: Event sequences can be stored, replayed, and validated
3. **Debugging**: Events provide a clear trace of what happened during a spell
4. **Side Effect Isolation**: All state modifications happen in one place (EventRunner)
5. **Future Extensibility**: New features like replay, network sync, and AI analysis are now possible

## Usage Instructions

### Enabling Event-Based Execution

```lua
-- Enable event-based execution (on by default)
SpellCompiler.setUseEventSystem(true)

-- Enable event debug output
SpellCompiler.setDebugEvents(true)
```

### Accessing Events

When using the event system, spell execution results include the generated events:

```lua
local results = compiledSpell.executeAll(caster, target, {}, spellSlot)
for _, event in ipairs(results.events) do
    print(event.type, event.target) -- Access event details
end
```

### Testing Tools

Several test scripts were created to validate the event system:

- `tools/test_eventRunner.lua`: Unit tests for the EventRunner module
- `tools/test_spellEvents.lua`: Tests event generation for various spell types
- `tools/compare_event_systems.lua`: Side-by-side comparison of execution modes

## Future Work

1. **Event Logging**: Add persistent logging of events for debugging and analytics
2. **Network Synchronization**: Use events as the basis for multiplayer state sync
3. **Deterministic Replay**: Save event streams to perfectly recreate matches
4. **AI Integration**: Use event prediction for AI decision-making

## Conclusion

The Event List Execution Refactor establishes a solid foundation for future game features while maintaining backward compatibility. By cleanly separating state description from mutation, the system is now more robust, testable, and extensible.

## Tickets/S4_TokenManagement/4-1-define-token-state-machine.md
# Ticket #TLC-1: Define Token State Machine & Encapsulated Methods

## Goal
Establish a clear, robust state machine for mana tokens and centralize state transitions within the token object itself.

## Description
Refactor the token's state management. Instead of direct manipulation of token.state from various modules, create dedicated methods on the token object to request state changes and manage transitions, tied to a well-defined set of states.

## Tasks

1. In core/Constants.lua (or a new dedicated file if preferred), formally define the new TokenStatus enum:
   - FREE
   - CHANNELED
   - SHIELDING
   - RETURNING (animating back to pool)
   - DISSOLVING (animating destruction)
   - POOLED (ready for object pool release)

2. Modify the token structure (likely within the ManaPool.resetToken and ManaPool:addToken factory logic, or define a formal Token class if needed) to include:
   - status (using TokenStatus constants)
   - isAnimating (boolean flag)
   - animationCallback (function to call on animation completion)

3. Implement token:setState(newStatus):
   - Add checks to prevent invalid transitions (e.g., cannot transition from POOLED)
   - Include print("[TOKEN LIFECYCLE] Token "..self.id.." state: "..self.status.." -> "..newStatus) for debugging
   - Update self.status

4. Implement token:requestReturnAnimation():
   - Check if current status is CHANNELED or SHIELDING. If not, log a warning and return
   - Set self.isAnimating = true
   - Call self:setState(TokenStatus.RETURNING)
   - Trigger the "return to pool" animation (details TBD in later ticket, for now, maybe just set a timer)
   - Store a callback function: self.animationCallback = function() self:finalizeReturn() end

5. Implement token:requestDestructionAnimation():
   - Check if current status is already DISSOLVING or POOLED. If so, return
   - Set self.isAnimating = true
   - Call self:setState(TokenStatus.DISSOLVING)
   - Trigger the "dissolve/destroy" animation (details TBD)
   - Store a callback function: self.animationCallback = function() self:finalizeDestruction() end

6. Implement token:finalizeReturn():
   - Check if status is RETURNING
   - Set self.isAnimating = false
   - Call self:setState(TokenStatus.FREE)
   - Ensure the token is correctly positioned/configured for the mana pool idle state (may involve logic moved from ManaPool:finalizeTokenReturn)

7. Implement token:finalizeDestruction():
   - Check if status is DISSOLVING
   - Set self.isAnimating = false
   - Call self:setState(TokenStatus.POOLED)
   - Call Pool.release("token", self)

## Acceptance Criteria
- New TokenStatus constants exist
- Token objects have the new properties (status, isAnimating, animationCallback)
- State transition methods (setState, request..., finalize...) exist and perform basic state validation/logging
- Direct assignments to token.state outside these methods are removed (or flagged for removal in subsequent tickets)

## Pitfalls
- Ensure the token object passed around is the actual table instance from the pool, not a copy
- Initial state in addToken must be TokenStatus.FREE

## Tickets/S4_TokenManagement/4-2-refactor-manapool-update-animation-handling.md
# Ticket #TLC-2: Refactor ManaPool Update & Animation Handling

## Goal
Modify ManaPool:update to drive token animations based on the new states and execute callbacks upon completion.

## Description
The Mana Pool update loop should no longer directly manage timers like lockDuration or complex state transitions. It should focus on updating token positions based on their current state and checking if animations (RETURNING, DISSOLVING) are complete to trigger their finalization callbacks.

## Tasks

1. Modify the main loop within ManaPool:update(dt):
   - For tokens with status == TokenStatus.RETURNING:
     - Update their return animation progress (e.g., move towards pool center)
     - Check if the animation is complete (e.g., token.animTime >= token.animDuration)
     - If complete, call token.animationCallback() (which should trigger token:finalizeReturn)
   - For tokens with status == TokenStatus.DISSOLVING:
     - Update their dissolve animation progress (e.g., scale/fade)
     - Check if the animation is complete (e.g., token.dissolveTime >= token.dissolveMaxTime)
     - If complete, call token.animationCallback() (which should trigger token:finalizeDestruction and release the token to the pool)
   - For tokens with status == TokenStatus.FREE, CHANNELED, SHIELDING, LOCKED: Update their position/rotation/visuals based on the existing logic for those states (orbiting pool, orbiting wizard, locked wobble, etc.)

2. Remove the explicit DESTROYED state check and Pool.release call from ManaPool:update – this is now handled by the token:finalizeDestruction callback.

3. Remove the direct management of token.lockDuration from ManaPool:update. If locking needs a timer, it should be handled within the token's own update logic or via timed events if preferred (though simpler to keep it on the token for now). When the timer expires, the token should call self:setState(TokenStatus.FREE).

## Acceptance Criteria
- ManaPool:update correctly drives animations for RETURNING and DISSOLVING states
- Animation callbacks (finalizeReturn, finalizeDestruction) are called correctly upon animation completion
- Pool.release("token", ...) is no longer called directly from ManaPool:update
- Locked tokens correctly transition back to FREE after their duration (timer managed internally or via event)

## Design Notes
This separates animation driving (in ManaPool) from state finalization (in the token callback).

## Tickets/S4_TokenManagement/4-3-1-ensure-disjoint-keyword-uses-event-system.md
# Ticket #TLC-3.1: Ensure Disjoint Keyword Uses Event System

## Goal
Modify the disjoint keyword to generate a CANCEL_SPELL event instead of setting legacy flags.

## Description
The current disjoint keyword implementation bypasses the event system and the new token state machine. This needs to be updated to correctly trigger the DISSOLVING state via an event.

## Tasks

1. In keywords.lua, replace the execute function for Keywords.disjoint with the event-generating version:
   - Update the function to generate a CANCEL_SPELL event with returnMana = false
   - Remove direct token state manipulation
   - Ensure the event includes all necessary context (spellIndex, caster, etc.)

2. In wizard.lua, remove the legacy if effect.disjoint then ... end block from the castSpell function:
   - Identify and remove code blocks that directly handle disjoint effects
   - Ensure the spellCancellation logic in the event system properly handles the disjoint case

## Acceptance Criteria
- Casting a spell with the disjoint keyword generates a CANCEL_SPELL event with returnMana = false
- The legacy disjoint handling logic is removed from Wizard:castSpell
- Tokens affected by disjoint correctly transition to DISSOLVING state through the event system
- The full lifecycle from disjoint keyword → CANCEL_SPELL event → token:requestDestructionAnimation() → DISSOLVING → POOLED works correctly

## Related Tickets
- TLC-1: Define Token State Machine & Encapsulated Methods
- TLC-3: Refactor Token Acquisition & Return Points

## Tickets/S4_TokenManagement/4-3-2-decouple-resetspellslot-from-token-state.md
# Ticket #TLC-3.2: Decouple Wizard:resetSpellSlot from Token State

## Goal
Prevent resetSpellSlot from prematurely altering token states or interfering with state transitions managed by the token itself or the EventRunner.

## Description
resetSpellSlot currently sets token states to FREE which conflicts with the state machine's handling, especially for disjoint (which should lead to DISSOLVING -> POOLED). It should only reset the slot's properties.

## Tasks

1. In wizard.lua, modify resetSpellSlot to remove the loop that sets tokenData.token.state = "FREE":
   - Identify the current implementation that directly modifies token.state
   - Remove this direct manipulation while preserving other functionality
   - Add comments explaining that token state is now managed by the token object itself

2. Ensure resetSpellSlot still clears the slot.tokens = {} table:
   - The slot should no longer reference the tokens after cancellation
   - This is important because the tokens will either return to FREE state or be POOLED
   - Verify the slot's other properties are correctly reset

3. Review related methods that might be affected:
   - Check if freeAllSpells or other methods have similar direct state manipulation
   - Ensure they are refactored to use token:requestReturnAnimation() or token:requestDestructionAnimation()

## Acceptance Criteria
- resetSpellSlot no longer modifies token.state or token.status
- resetSpellSlot correctly clears the slot's tokens table
- Disjointed tokens correctly enter the DISSOLVING state via the EventRunner and are eventually pooled
- Tokens returning to the mana pool correctly enter the RETURNING state and eventually FREE

## Related Tickets
- TLC-1: Define Token State Machine & Encapsulated Methods
- TLC-3: Refactor Token Acquisition & Return Points
- TLC-3.1: Ensure Disjoint Keyword Uses Event System

## Tickets/S4_TokenManagement/4-3-refactor-token-acquisition-return-points.md
# Ticket #TLC-3: Refactor Token Acquisition & Return Points

## Goal
Update all parts of the code that get, return, or destroy tokens to use the new token methods.

## Description
Replace direct state manipulation and calls to ManaPool:returnToken or Pool.release with calls to the new encapsulated token methods (requestReturnAnimation, requestDestructionAnimation).

## Tasks

1. Wizard Spell Completion:
   - In Wizard:castSpell, for non-shield spells, instead of calling self.manaPool:returnToken(tokenData.index), call tokenData.token:requestReturnAnimation()

2. Wizard Shield Blocking:
   - In Wizard:handleShieldBlock, instead of calling self.manaPool:returnToken(tokenData.index), call tokenData.token:requestReturnAnimation()

3. Wizard Free All:
   - In Wizard:freeAllSpells, instead of calling self.manaPool:returnToken(tokenData.index), call tokenData.token:requestReturnAnimation()

4. Keyword/Event - Disjoint/Dissipate:
   - Modify Keywords.dissipate.execute to find the target token(s) and call token:requestDestructionAnimation() instead of setting token.state = "DESTROYED". Remove the results.dissipate=true logic, as the effect is now handled by the token itself
   - Modify EventRunner handler for CANCEL_SPELL where returnMana == false (Disjoint) to find the target token(s) and call token:requestDestructionAnimation()

5. Mana Cost Payment:
   - In Wizard:queueSpell (where payManaCost logic resides), ensure tokens acquired from the pool are correctly set to TokenStatus.CHANNELED using token:setState()

6. Shield Creation:
   - In the createShield helper function (wizard.lua), ensure tokens are set to TokenStatus.SHIELDING using token:setState()

7. Remove Old ManaPool:returnToken:
   - Delete the old ManaPool:returnToken and ManaPool:finalizeTokenReturn functions as their logic is now encapsulated in the token methods and animation callbacks

## Acceptance Criteria
- All logical points where tokens are finished with (spell completion, shield block, free all, disjoint) now call token:requestReturnAnimation() or token:requestDestructionAnimation()
- Tokens correctly transition through RETURNING or DISSOLVING states driven by ManaPool:update
- Tokens correctly end up in FREE state (for returns) or are released to the pool (for destruction) after their animations complete
- Old ManaPool:returnToken and finalizeTokenReturn are removed

## Pitfalls
- Ensure the correct token object reference is being used when calling the new methods, not just an index

## Tickets/S4_TokenManagement/4-4-refine-animations-visual-states.md
# Ticket #TLC-4: Refine Animations & Visual States

## Goal
Ensure the visual representation of tokens accurately reflects their new lifecycle states and animations.

## Description
Update the drawing logic in ManaPool:draw and potentially Wizard:drawSpellSlots to correctly display tokens based on their status (FREE, CHANNELED, SHIELDING, RETURNING, DISSOLVING) and potentially isAnimating flag. Implement the actual animations for returning and dissolving.

## Tasks

1. ManaPool:draw:
   - Modify the main drawing loop to switch based on token.status
   - Implement distinct visual styles or effects for RETURNING (e.g., streaking towards center, brighter glow) and DISSOLVING (e.g., shrinking, fading, particle burst)
   - Ensure POOLED tokens are not drawn
   - Ensure FREE, CHANNELED, SHIELDING, LOCKED states are still drawn correctly

2. Animation Implementation:
   - In ManaPool:update, add the actual position/scale/alpha modification logic for the RETURNING state (e.g., lerping position towards self.x, self.y). Define token.animDuration for return
   - In ManaPool:update, add the actual position/scale/alpha modification logic for the DISSOLVING state. Define token.dissolveMaxTime (or similar) for destruction animation

3. (Optional) Wizard:drawSpellSlots:
   - Review if any changes are needed here. Currently, it seems to handle drawing orbiting tokens correctly based on slot.tokens
   - Ensure it doesn't draw tokens that might be in RETURNING or DISSOLVING states if they somehow haven't been removed from slot.tokens yet (though TLC-3 should prevent this)

## Acceptance Criteria
- Tokens visually animate correctly when returning to the pool
- Tokens visually animate correctly when being destroyed
- Tokens in different states (FREE, CHANNELED, SHIELDING, LOCKED) are visually distinct and correctly represented
- Tokens disappear completely from the game view once they are POOLED (released)

## Design Notes
The dissolve animation logic previously within the DESTROYED state check in ManaPool:update can be adapted for the DISSOLVING state. The return animation needs bezier curve or lerp logic.

## Tickets/S5_SustainedSpells/SST-1-foundation-sustain-keyword.md
# Ticket #SST-1: Foundation - The sustain Keyword & Slot Retention

## Description
Introduce the core concept of a "sustained" spell that keeps its slot active and mana locked after its initial cast time completes. This is the foundation for both Shields and Traps.

## Tasks

### Define Keyword (keywords.lua)
- Create Keywords.sustain
- Behavior: { marksSpellAsSustained = true, category = "TIMING" }
- Execute: `function(params, caster, target, results, events) results.isSustained = true return results end`

### Modify Spell Compiler (spellCompiler.lua)
- Ensure compileSpell processes the sustain keyword
- Ensure executeAll correctly adds results.isSustained = true when the keyword is present

### Modify Casting Logic (wizard.lua -> Wizard:castSpell)
- After the line `effect = spellToUse.executeAll(self, target, {}, spellSlot)`, add a check: `local shouldSustain = effect.isSustained or false`
- Modify the existing logic block that handles non-shield spell completion: Wrap the calls to `TokenManager.returnTokensToPool(slot.tokens)` and `self:resetSpellSlot(spellSlot)` inside an `if not shouldSustain then ... end` block
- Crucially: Ensure that if shouldSustain is true, the tokens in slot.tokens remain in their CHANNELED state (or a similar 'in use' state) and are not returned. Verify that TokenManager.returnTokensToPool isn't called elsewhere implicitly for these sustained spells upon cast completion

## Acceptance Criteria
- A spell defined with `keywords = { sustain = true, ... }` completes its cast timer but the spell slot remains `active = true`
- The mana tokens for the sustained spell remain associated with the slot (in slot.tokens) and in the CHANNELED state, not returning to the mana pool
- The visual progress arc for the sustained spell remains full
- Regular, non-sustained spells complete, return tokens, and reset their slots as normal

## Design Notes
This ticket focuses only on preventing the slot reset for sustained spells. Expiry/triggering comes later. We use CHANNELED for now, assuming it prevents reuse/return.

## Tickets/S5_SustainedSpells/SST-2-define-trap-component-keywords.md
# Ticket #SST-2: Define Trap Component Keywords

## Description
Create the keywords used to define the parameters of a Trap spell (trap_trigger, trap_window, trap_effect). These keywords will only store data in the spell's execution results; they won't implement the trap logic itself yet.

## Tasks

### Define Keywords (keywords.lua)
Create entries for:

#### trap_trigger
- Behavior: { storesTriggerCondition = true, category = "TRAP" }
- Execute: `function(params, caster, target, results, events) results.trapTrigger = params return results end` (Stores data like { condition = "on_opponent_elevate" })

#### trap_window
- Behavior: { storesWindowCondition = true, category = "TRAP" }
- Execute: `function(params, caster, target, results, events) results.trapWindow = params return results end` (Stores data like { duration = 5.0 } or { condition = "until_next_conjure" })

#### trap_effect
- Behavior: { storesEffectPayload = true, category = "TRAP" }
- Execute: `function(params, caster, target, results, events) results.trapEffect = params return results end` (Stores the keyword structure for the effect, e.g., { damage = { amount = 10 } })

### Update Spell Compiler (spellCompiler.lua)
- Ensure compileSpell correctly processes these new keywords
- Verify that executeAll populates results.trapTrigger, results.trapWindow, and results.trapEffect when these keywords are present in a spell definition

## Acceptance Criteria
- The three trap keywords (trap_trigger, trap_window, trap_effect) exist and are processed by the compiler
- When a spell using these keywords is executed via executeAll, the corresponding results.trapTrigger, results.trapWindow, and results.trapEffect fields contain the parameters defined in the spell
- These keywords produce no side effects or events on their own

## Pitfalls
The structure stored in results.trapEffect must be a valid keyword definition that can be processed later by the EventRunner.

## Tickets/S5_SustainedSpells/SST-3-create-sustained-spell-manager.md
# Ticket #SST-3: Create Sustained Spell Manager System

## Description
Implement the basic structure for a new system (SustainedSpellManager) that will track all active sustained spells (Shields and Traps).

## Tasks

### Create File (systems/SustainedSpellManager.lua)
- Create the module SustainedSpellManager
- Initialize `SustainedSpellManager.activeSpells = {}`. Use a structure that allows easy lookup and removal, perhaps keyed by a unique ID or a composite key like wizard_name .. "_" .. slotIndex. Example entry structure: `{ id = uniqueId, wizard = wizardRef, slotIndex = slotIndex, spell = compiledSpellRef, windowData = ..., triggerData = ..., effectData = ..., expiryTimer = ... }`
- Implement `SustainedSpellManager.addSustainedSpell(wizard, slotIndex, spellData)`:
  - Generate a unique ID
  - Extract relevant info from spellData (the results table from executeAll, containing isSustained, trapTrigger, trapWindow, trapEffect, shieldParams etc.)
  - Store the entry in activeSpells. Initialize expiry timers if spellData.trapWindow.duration exists
  - Log the addition: `print("[SustainedManager] Added spell '"..spellData.spell.name.."' for "..wizard.name.." slot "..slotIndex)`
- Implement `SustainedSpellManager.removeSustainedSpell(id)`: Finds and removes the entry from activeSpells. Log the removal
- Implement `SustainedSpellManager.update(dt)`:
  - Iterate through activeSpells
  - For spells with a duration in their windowData, decrement `expiryTimer = expiryTimer - dt`
  - (Placeholder) Log the current count of active sustained spells

### Initialize in main.lua
- `local SustainedSpellManager = require("systems.SustainedSpellManager")`
- Add `game.sustainedSpellManager = SustainedSpellManager` in love.load

## Acceptance Criteria
- SustainedSpellManager.lua exists with the specified functions and internal structure
- addSustainedSpell correctly stores data
- removeSustainedSpell removes the entry
- update iterates and logs basic info or decrements timers

## Design Notes
Storing a reference to the wizard and the slotIndex is critical for later cleanup.

## Tickets/S5_SustainedSpells/SST-4-integrate-manager-with-spellcasting.md
# Ticket #SST-4: Integrate Manager with Spell Casting & Update Loop

## Description
Connect the Wizard:castSpell function to the SustainedSpellManager so that sustained spells are registered, and ensure the manager updates each frame.

## Tasks

### Modify Casting Logic (wizard.lua -> Wizard:castSpell)
- Inside the `if shouldSustain then ... end` block (from SST-1):
  - Call `game.sustainedSpellManager.addSustainedSpell(self, spellSlot, effect)`. Ensure the effect table passed contains all data populated by keywords (isSustained, trapTrigger, trapWindow, trapEffect, shieldParams, etc.). Pass slot.spell as well if needed by the manager

### Call Manager Update (main.lua -> love.update)
- Add a call to `game.sustainedSpellManager.update(dt)` after the wizards and mana pool have been updated

## Acceptance Criteria
- When a sustained spell finishes casting, SustainedSpellManager.addSustainedSpell is called with the correct wizard, slot index, and spell data
- The SustainedSpellManager.update function executes each frame
- The manager's log shows sustained spells being added

## Pitfalls
Double-check that all necessary data (trigger, window, effect details) generated by keywords in executeAll's effect table is correctly passed to addSustainedSpell.

## Tickets/S5_SustainedSpells/SST-5-implement-trap-trigger-checking.md
# Ticket #SST-5: Implement Trap Trigger Condition Checking

## Description
Add logic to SustainedSpellManager.update to check if the trigger conditions for active Traps are met based on the current game state.

## Tasks

### Modify SustainedSpellManager.update(dt)
- In the loop iterating through activeSpells:
  - If the entry has triggerData (meaning it's a trap):
    - Get the casterWizard and targetWizard references (stored during addSustainedSpell). Access the global game state via casterWizard.gameState
    - Evaluate triggerData.condition:
      - If condition == "on_opponent_elevate": Check if `targetWizard.elevation == Constants.ElevationState.AERIAL`. Note: This triggers continuously while aerial. A refinement might be needed later to trigger only on the frame they enter AERIAL
      - If condition == "on_opponent_cast": Check a flag like `targetWizard.justCastSpellThisFrame` (this flag would need to be set in Wizard:castSpell and cleared at the start of Wizard:update)
      - Add checks for other potential trigger conditions defined in trap_trigger documentation
    - If the condition is met:
      - Log: `print("[SustainedManager] Trap triggered for "..casterWizard.name.." slot "..entry.slotIndex)`
      - Set a flag on the entry: `entry.triggered = true`

## Acceptance Criteria
- SustainedSpellManager.update evaluates trap trigger conditions based on game state
- When a condition is met, the corresponding log message appears, and the internal state of the tracked spell reflects `triggered = true`

## Design Notes
For simplicity, start with direct state polling (targetWizard.elevation). Event-based triggering is more complex. The justCastSpellThisFrame flag is a simple way to detect casting without event bus hooks.

## Tickets/S5_SustainedSpells/SST-6-implement-trap-effect-execution.md
# Ticket #SST-6: Implement Trap Effect Execution via EventRunner

## Description
When a trap is marked as triggered, execute its stored effect using the EventRunner and then clean up the trap.

## Tasks

### Modify SustainedSpellManager.update(dt)
- After checking triggers, check if `entry.triggered == true`
- If true:
  - Log: `print("[SustainedManager] Executing trap effect for "..entry.wizard.name.." slot "..entry.slotIndex)`
  - Get the effectData (e.g., `{ damage = { amount = 10 } }`)
  - Generate Events: Create an `events = {}` list. Iterate through effectData's keywords (like damage, ground). For each, call the corresponding `Keywords[keywordName].execute(params, caster, target, {}, events)` function to populate the events list. Crucially, determine the correct caster (likely entry.wizard) and target (based on the trap's definition, likely the opponent) to pass here
  - Process Events: `local EventRunner = require("systems.EventRunner"); EventRunner.processEvents(events, entry.wizard, targetWizard, nil)`
  - Cleanup:
    - Call `TokenManager.returnTokensToPool(entry.wizard.spellSlots[entry.slotIndex].tokens)` to start returning the mana
    - Call `entry.wizard:resetSpellSlot(entry.slotIndex)` to free the slot
    - Call `self.removeSustainedSpell(entry.id)` to remove it from the manager. Ensure iteration handles removal safely

## Acceptance Criteria
- Triggered trap effects (damage, grounding, etc.) are correctly applied via the EventRunner
- The trap is removed from the manager after triggering
- The spell slot used by the trap is reset
- The mana tokens used by the trap begin their return animation

## Pitfalls
Correctly identifying the caster and target for the trap_effect execution is vital. Safe removal from the activeSpells list during iteration is needed (e.g., iterate backwards or store IDs to remove after the loop). Ensure resetSpellSlot is called after returnTokensToPool is initiated.

## Tickets/S5_SustainedSpells/SST-7-implement-window-expiry-checking.md
# Ticket #SST-7: Implement Window/Expiry Condition Checking

## Description
Add logic to the SustainedSpellManager to expire sustained spells based on duration or game state conditions.

## Tasks

### Modify SustainedSpellManager.update(dt)
- Inside the loop iterating through activeSpells (before trigger checks):
  - If the entry has windowData:
    - Duration Check: If windowData.duration exists and entry.expiryTimer exists:
      - If `entry.expiryTimer <= 0`, mark for removal: `entry.expired = true`. Log expiry
    - Condition Check: If windowData.condition exists:
      - Evaluate the condition (e.g., until_next_conjure, while_elevated). Get necessary state from entry.wizard.gameState or entry.wizard
      - If the expiry condition is met, mark for removal: `entry.expired = true`. Log expiry
- After checking triggers and expiry, add a block: `if entry.expired and not entry.triggered then ... end`
- Inside this block (spell expired without triggering):
  - Log: `print("[SustainedManager] Spell expired for "..entry.wizard.name.." slot "..entry.slotIndex)`
  - Call `TokenManager.returnTokensToPool(entry.wizard.spellSlots[entry.slotIndex].tokens)`
  - Call `entry.wizard:resetSpellSlot(entry.slotIndex)`
  - Call `self.removeSustainedSpell(entry.id)`. Ensure safe removal during iteration

## Acceptance Criteria
- Sustained spells with a duration expire and clean up correctly when their timer runs out
- Sustained spells with conditions (implement at least one, e.g., until_next_conjure or while_elevated) expire and clean up when the condition is met
- Expired spells do not trigger their trap_effect
- Slot and mana are correctly released upon expiry

## Design Notes
For state-based conditions like until_next_conjure, the originating system (e.g., the conjure keyword handler in EventRunner) needs to set a temporary flag on the wizard (e.g., wizard.justConjuredMana = true) that the manager checks and then clears each frame.

## Tickets/S5_SustainedSpells/SST-8-visual-feedback-for-sustained-slots.md
# Ticket #SST-8: Visual Feedback for Sustained Slots

## Description
Update the spell slot visuals to clearly distinguish between empty slots, casting slots, active Shield slots, and active Trap slots.

## Tasks

### Modify WizardVisuals.drawSpellSlots (systems/WizardVisuals.lua)
- Inside the loop drawing each slot i:
  - Check slot.active. If not active, draw as empty/invisible (existing logic)
  - If active:
    - Check slot.isShield. If true, draw using Shield visuals (existing logic, maybe refine pulsing/color)
    - Else If check if slot.spell exists and slot.spell.behavior.trap_trigger exists (indicates a Trap). If true, draw using a new Trap visual style (e.g., purple orbit line, a subtle static "trap sigil" icon in the center, full progress arc but maybe dimmer or pulsing differently than shields)
    - Else If check if slot.spell exists and slot.spell.behavior.sustain exists (generic sustained spell, not shield/trap). Draw with another distinct style (e.g., maybe a steady white or grey full arc)
    - Else (it's an active, non-sustained spell currently casting): Draw using the existing casting progress arc visual

## Acceptance Criteria
- Empty slots look distinct
- Slots casting normal spells show a growing progress arc
- Slots holding active Shields have their unique visual style (e.g., yellow/blue/green pulsing full arc)
- Slots holding active Traps have a new, clearly different visual style (e.g., purple static full arc with an icon)

## Pitfalls
Ensure the checks for shield/trap/sustained are robust and don't misclassify slots.

## Tickets/S5_SustainedSpells/SST-9-implement-gravity-pin-trap-spell.md
# Ticket #SST-9: Implement Gravity Pin Trap Spell

## Description
Redefine the Gravity Pin spell (or create a new GravityTrap) in spells.lua to use the newly implemented sustained spell and trap keyword system.

## Tasks

### Update Spell Definition (spells.lua)
- Modify Spells.gravity or create Spells.gravityPin
- Set attackType = Constants.AttackType.UTILITY
- Define the keywords table as follows (adjust cost/castTime as needed):
```lua
keywords = {
    sustain = true,
    trap_trigger = { condition = "on_opponent_elevate" },
    trap_window = { duration = 5.0 },
    trap_effect = {
        -- Re-use existing keywords for the effect
        damage = { amount = 10, type = Constants.DamageType.FORCE, target = "ENEMY" },
        ground = { target = "ENEMY", vfx = "gravity_pin_ground" }
        -- Optional: stagger = { duration = 1.0, target = "ENEMY" }
    }
}
```
- Update vfx to gravity_trap_set (or similar) for the initial placement
- Remove the old damage and ground keywords that were executing immediately

### Testing
- Cast the spell. Verify the slot shows the "Trap" visual and mana/slot remain locked
- Have the opponent use an elevate spell (e.g., Emberlift via debug key '4' or Ashgar's '13' combo) within 5 seconds. Verify the trap triggers: opponent takes damage, is grounded, and the caster's trap slot resets/returns mana
- Cast the spell again. Wait 5 seconds without the opponent elevating. Verify the trap expires: the caster's trap slot resets/returns mana without any effect occurring

## Acceptance Criteria
- Gravity Pin spell is defined using sustain, trap_trigger, trap_window, trap_effect
- Casting it sets the trap correctly (visuals, slot state)
- The trap triggers correctly when the opponent becomes AERIAL within the window
- The trap expires correctly if the window closes without a trigger
- Slot and mana are correctly released in both trigger and expiry scenarios

## Tickets/S6_VfxUnificationAndPipeline/VFX-1-Keyword_Helper.md
# Ticket #VFX-1: Implement VFX Keyword Helper & Centralize Triggering

## Goal
Introduce a dedicated `vfx` keyword to allow spells to declaratively specify their visual effects. Centralize all spell-related VFX triggering through the event system by removing the direct call from `Wizard:castSpell`.

## Tasks

1.  **Create `vfx` Keyword Helper (`keywords.lua`):**
    *   Add the following definition to the `Keywords` table:
        ```lua
        Keywords.vfx = {
            behavior = {
                triggersVisualEffect = true, -- Add descriptive behavior flag
                category = "SPECIAL"         -- Or maybe a new "VISUAL" category
            },
            execute = function(params, caster, target, results, events)
                -- Default target to ENEMY if not specified, matching most spell effects
                local eventTarget = params.target or Constants.TargetType.ENEMY 
                table.insert(events or {}, {
                    type       = "EFFECT", -- Use the existing EFFECT event type
                    source     = Constants.TargetType.CASTER, -- Effects originate from caster
                    target     = eventTarget, -- Target where the effect appears (can be overridden)
                    effectType = params.effect or "impact", -- The specific VFX template name (e.g., "firebolt")
                    duration   = params.duration, -- Optional duration override
                    -- Pass through any other params for the VFX system
                    vfxParams  = params -- Store original params for flexibility
                })
                return results -- Return unmodified results (only adds an event)
            end
        }
        ```
    *   Ensure the `EFFECT` event structure aligns with `docs/combat_events.md`.

2.  **Integrate `vfx` Keyword into Example Spells (`spells.lua`):**
    *   Find the `Spells.firebolt` definition.
    *   Add the `vfx` keyword to its `keywords` table:
        ```lua
        Spells.firebolt = {
            -- ... other properties ...
            keywords = {
                damage = { ... },
                vfx = { effect = "firebolt" } -- Add this line
            },
            -- Remove the top-level vfx = "fire_bolt" if it exists, or ensure compiler prioritizes keyword
            -- ... other properties ...
        }
        ```
    *   Do the same for 1-2 other spells (e.g., `meteor`, `conjurefire`) to test integration.

3.  **Update Spell Compiler (Optional but Recommended) (`spellCompiler.lua`):**
    *   Modify `compileSpell` to automatically convert a top-level `spellDef.vfx = "some_effect"` into the equivalent `keywords.vfx = { effect = "some_effect" }` if the keyword isn't already present. This provides backward compatibility and a simpler definition option. Prioritize the explicit keyword if both exist.

4.  **Remove Direct VFX Call (`wizard.lua`):**
    *   In the `Wizard:castSpell` function, locate and **delete** the line:
        ```lua
        -- if self.gameState and self.gameState.vfx then -- DELETE THIS BLOCK
        --     self.gameState.vfx.createSpellEffect(spellToUse, self, target)
        -- end
        ```
    *   Verify that VFX are now solely triggered via the `EFFECT` event processed by the `EventRunner`.

## Deliverables
-   Updated `keywords.lua` with the new `Keywords.vfx` definition.
-   Updated `spells.lua` with `vfx` keywords added to `firebolt` and 1-2 other spells.
-   (Optional) Updated `spellCompiler.lua` to handle top-level `vfx` field conversion.
-   Updated `wizard.lua` with the direct `createSpellEffect` call removed from `castSpell`.
-   Manual Test: Cast `firebolt` (and other modified spells) and verify their visual effects still trigger correctly via the event system.

## Design Notes/Pitfalls
-   The `EFFECT` event handler already exists in `EventRunner`, so this keyword leverages existing infrastructure.
-   Ensure the `effectType` string passed in the event (e.g., `"firebolt"`) exactly matches a key in the `VFX.effects` table in `vfx.lua`. Mismatches will likely default to a generic "impact" effect (see Sprint 2).
-   The `vfxParams` field in the event is added for potential future use where specific keyword parameters might need to influence the visual effect directly (e.g., damage amount affecting impact size).

## Tickets/S6_VfxUnificationAndPipeline/VFX-2-Event_Contract.md
# Ticket #VFX-2: Formalize VFX Event Contract & Validation

## Goal
Strengthen the connection between gameplay events and visual effects by using constants for effect names and adding validation within the EventRunner to prevent crashes from unknown effect types.

## Tasks

1.  **Define VFX Constants (`core/Constants.lua`):**
    *   Add a new sub-table `Constants.VFXType = {}`.
    *   Populate it with constants corresponding to the keys in the `VFX.effects` table registry found in `vfx.lua`. Examples:
        ```lua
        Constants.VFXType = {
            IMPACT = "impact",
            FIREBOLT = "firebolt",
            METEOR = "meteor",
            MISTVEIL = "mistveil",
            EMBERLIFT = "emberlift",
            -- ... add ALL effect names from vfx.lua ...
            CONJURE_FIRE = "conjurefire",
            CONJURE_MOONLIGHT = "conjuremoonlight",
            SHIELD = "shield",
            GRAVITY_TRAP_SET = "gravity_trap_set",
            -- etc.
        }
        ```

2.  **Update Keyword & Spells (`keywords.lua`, `spells.lua`):**
    *   Modify the `Keywords.vfx.execute` function to expect and use constants: `effectType = params.effect or Constants.VFXType.IMPACT`.
    *   Update the spell definitions modified in VFX-1 (e.g., `firebolt`) to use the constants: `keywords.vfx = { effect = Constants.VFXType.FIREBOLT }`.

3.  **Add Validation in EventRunner (`systems/EventRunner.lua`):**
    *   Locate the `EFFECT` handler function within `EventRunner.EVENT_HANDLERS`.
    *   Before calling `safeCreateVFX`, validate `event.effectType`:
        *   Check if `event.effectType` exists as a value within `Constants.VFXType` (or directly check against `VFX.effects` keys if simpler).
        *   If the `effectType` is invalid or nil, log a warning (`print("Warning: Unknown effectType '"..tostring(event.effectType).."' requested by event. Defaulting to impact.")`) and set `event.effectType = Constants.VFXType.IMPACT` before calling `safeCreateVFX`.

## Deliverables
-   Updated `core/Constants.lua` with the `Constants.VFXType` table.
-   Updated `keywords.lua` and `spells.lua` (for spells modified in VFX-1) to use `Constants.VFXType`.
-   Updated `systems/EventRunner.lua` with validation logic in the `EFFECT` handler.
-   Manual Test: Intentionally trigger an `EFFECT` event with an invalid `effectType` and verify that a warning is logged and the default "impact" VFX plays without crashing.

## Design Notes/Pitfalls
-   Using constants prevents typos in effect names.
-   Validation in the `EventRunner` makes the system more robust against data errors in spell definitions.
-   Ensure *all* effect names from `vfx.lua` are added to `Constants.VFXType`.

## Tickets/S6_VfxUnificationAndPipeline/VFX-3-Lifecycle_Hooks.md
# Ticket #VFX-3: Standardize VFX Triggering from Lifecycle Hooks

## Goal
Ensure that game systems outside of direct spell casting (like token destruction, shield creation, elevation changes) trigger their associated VFX consistently through the `EventRunner` system, rather than calling the VFX module directly.

## Tasks

1.  **Create EventRunner Helper (`systems/EventRunner.lua`):**
    *   Add a new utility function to `EventRunner` (or a dedicated `GameEventManager` module if preferred):
        ```lua
        -- Function to queue a visual effect event from game systems
        function EventRunner.queueVisual(effectType, x, y, vfxParams)
            if not effectType or not x or not y then
                print("Warning: Invalid parameters for EventRunner.queueVisual")
                return
            end
            
            -- Basic event structure for a visual effect originating from game logic
            local visualEvent = {
                type       = "EFFECT",
                source     = "system", -- Indicate it's from game logic, not a specific spell caster
                target     = "world", -- Or maybe coordinates? Target is less relevant here.
                effectType = effectType,
                -- Store coordinates and params for the handler
                posX       = x, 
                posY       = y,
                vfxParams  = vfxParams or {} 
            }
            
            -- In a more robust system, you'd add this to an event queue.
            -- For now, we can process it immediately for simplicity, but beware of order issues.
            -- Let's assume immediate processing via handleEvent for now.
            print("[EventRunner] Queuing visual: " .. effectType .. " at " .. x .. "," .. y)
            -- We need dummy caster/target for handleEvent signature, can use nil or global game state
            EventRunner.handleEvent(visualEvent, _G.game, nil, nil, {}) 
        end
        ```
    *   Modify the `EFFECT` handler in `EventRunner.EVENT_HANDLERS` to use `event.posX`, `event.posY` if `event.source == "system"`.

2.  **Refactor Token Destruction VFX (`manapool.lua`):**
    *   Locate `TokenMethods:requestDestructionAnimation`.
    *   Find the block that calls `self.gameState.vfx.createEffect("impact", ...)`
    *   **Remove** that direct call.
    *   **Add** a call to the new helper: `local EventRunner = require("systems.EventRunner"); EventRunner.queueVisual(Constants.VFXType.IMPACT, self.x, self.y, { color = Constants.getColorForTokenType(self.type), radius = 30 })` (Pass necessary parameters like color).

3.  **Refactor Shield Creation VFX (`systems/ShieldSystem.lua`):**
    *   Locate the `ShieldSystem.createShield` function.
    *   Find the block that calls `wizard.gameState.vfx.createEffect("shield", ...)`
    *   **Remove** that direct call.
    *   **Add** a call to the new helper: `local EventRunner = require("systems.EventRunner"); EventRunner.queueVisual(Constants.VFXType.SHIELD, wizard.x, wizard.y, { shieldType = slot.defenseType, color = shieldColor })` (Pass shield type, color).

4.  **Refactor Elevation Change VFX (`systems/EventRunner.lua`):**
    *   Locate the `SET_ELEVATION` handler in `EventRunner.EVENT_HANDLERS`.
    *   Find the block that calls `safeCreateVFX(...)` for `elevation_up` or `elevation_down`.
    *   **Remove** that direct call.
    *   **Add** calls to the new helper instead:
        ```lua
        local effectConst = (event.elevation == Constants.ElevationState.AERIAL) and Constants.VFXType.EMBERLIFT or Constants.VFXType.IMPACT -- Or a specific 'LAND' effect
        EventRunner.queueVisual(effectConst, targetWizard.x, targetWizard.y, { duration = 1.0 }) 
        ```
    *   (Consider creating dedicated `Constants.VFXType.LIFT` and `Constants.VFXType.LAND` effects).

## Deliverables
-   Updated `systems/EventRunner.lua` with `queueVisual` helper and updated `EFFECT` handler.
-   Updated `manapool.lua` (`TokenMethods:requestDestructionAnimation`) to use `EventRunner.queueVisual`.
-   Updated `systems/ShieldSystem.lua` (`createShield`) to use `EventRunner.queueVisual`.
-   Updated `systems/EventRunner.lua` (`SET_ELEVATION` handler) to use `EventRunner.queueVisual`.
-   Manual Test: Verify that token destruction, shield creation, and elevation changes still trigger their expected visual effects.

## Design Notes/Pitfalls
-   The immediate processing in `queueVisual` is simple but might cause issues if the order of visual effects relative to state changes matters deeply. A proper event queue might be needed later.
-   Passing parameters like `color` and `shieldType` through `vfxParams` requires the `EFFECT` handler and `safeCreateVFX` to look inside this table when the source is "system".
-   Ensure `Constants.VFXType` includes any new effects needed (like `LAND`).

## Tickets/S6_VfxUnificationAndPipeline/VFX-4-Module_Ergonomics.md
# Ticket #VFX-4: Improve VFX Module Ergonomics

## Goal
Refactor the `vfx.lua` module to improve its internal organization, prepare for asynchronous operations, and optimize asset loading.

## Tasks

1.  **Consolidate Effect Registry (`vfx.lua`):**
    *   The file currently defines `VFX.effects` twice. Remove the duplicate definition and ensure only one canonical registry exists near the top of the file.
    *   Verify all effects used in `Constants.VFXType` are defined in this single registry.

2.  **Implement Basic Async Handling Stub (`vfx.lua`):**
    *   Add a new function `VFX.createEffectAsync(effectName, ...)`
    *   For now, this function can simply call the synchronous `VFX.createEffect(...)` internally.
    *   It should return a placeholder "promise" table: `return { onComplete = function(callback) print("Async VFX callback registered (stub)") end }`.
    *   *Note:* Full async/callback implementation is complex and deferred. This task only sets up the function signature and basic return structure.

3.  **Lazy Asset Loading (`vfx.lua`):**
    *   Modify the `VFX.init` function. Instead of loading all images into `VFX.assets` immediately using `AssetCache.getImage`, store *only the paths*:
        ```lua
        VFX.assetPaths = {
            fireParticle = "assets/sprites/fire-particle.png",
            fireGlow = "assets/sprites/fire-glow.png",
            -- ... etc
            runes = { -- Store paths for runes too
               "assets/sprites/runes/rune1.png",
               -- ...
            }
        }
        -- Remove the direct loading into VFX.assets here
        ```
    *   Create a helper function within `vfx.lua`:
        ```lua
        local function getAsset(assetId)
            local path = VFX.assetPaths[assetId]
            if not path then return nil end -- Handle missing asset paths
            
            -- Check if already loaded (simple cache within VFX module)
            if VFX.assets[assetId] then return VFX.assets[assetId] end 
            
            -- Load on demand using AssetCache
            print("[VFX] Lazily loading asset: " .. assetId)
            VFX.assets[assetId] = require("core.AssetCache").getImage(path) 
            return VFX.assets[assetId]
        end
        ```
    *   Update all `VFX.draw*` functions (e.g., `drawProjectile`, `drawImpact`) to call `local particleImage = getAsset("fireParticle")` etc., instead of directly accessing `VFX.assets.fireParticle`.
    *   Handle rune loading similarly within the `WizardVisuals.drawSpellSlots` function or refactor rune drawing to use `getAsset`.

## Deliverables
-   Updated `vfx.lua` with a single, consolidated `VFX.effects` registry.
-   Updated `vfx.lua` with the stub `VFX.createEffectAsync` function.
-   Updated `vfx.lua` implementing lazy loading for particle/effect assets via `getAsset`.
-   Manual Test: Verify that all visual effects still load and display correctly. Observe console output for "[VFX] Lazily loading asset:" messages during gameplay to confirm lazy loading works. Check game startup time for potential (minor) improvement.

## Design Notes/Pitfalls
-   Lazy loading slightly defers load time from startup to first use, which *could* cause a micro-hitch the very first time an effect is used if not already preloaded by `AssetPreloader`. Ensure `core/assetPreloader.lua` includes paths for common VFX assets.
-   The async stub provides the API for future expansion without needing immediate complex coroutine/callback management.
-   Remember to handle the rune assets' lazy loading as well, which might involve modifying `WizardVisuals.lua` or passing loaded assets from `vfx.lua`.

## Tickets/S6_VfxUnificationAndPipeline/VFX-5-Content_Pass.md
# Ticket #VFX-5: VFX Content Pass & Validation

## Goal
Ensure all spells have appropriate visual effects triggered via the event system, establish a clear visual language reference, and add automated testing for VFX event generation.

## Tasks

1.  **Audit Spell VFX (`spells.lua`, Engineer):**
    *   Go through *every* spell definition in `spells.lua`.
    *   For each spell, ensure it either:
        *   Has an appropriate `keywords.vfx = { effect = Constants.VFXType.SOME_EFFECT }` entry.
        *   Or, if it uses multiple keywords that should *each* produce a visual (like `ground` and `damage` in `gravity`), ensure those keywords' `execute` functions are correctly generating `EFFECT` events (may require modifying `keywords.lua` for some keywords).
        *   Or, if it's a `UTILITY` spell with no intended visual, confirm this is intentional.
    *   Add missing `vfx` keywords or modify keyword `execute` functions as needed. Use existing VFX types or add new basic ones (`impact`, `aura`) if required.

2.  **Create Visual Language Reference (Docs/Spreadsheet, Artist/Designer + Engineer):**
    *   Create a document (e.g., `docs/Visual_Language.md` or a spreadsheet) mapping game concepts to visual elements.
    *   **Columns:** Element (Fire, Moon, etc.), Concept (Damage, Heal, Buff, Debuff, Conjure, Shield Break, etc.), Target (Self, Enemy, Pool), VFX Name (`Constants.VFXType`), Particle Sprite (`VFX.assetPaths`), Core Color (`Constants.Color`), Notes.
    *   Fill this out based on existing effects and desired look-and-feel. This helps ensure consistency and provides a reference for creating new VFX presets.

3.  **Implement VFX Event Test (`tools/test_vfx_events.lua`, Engineer):**
    *   Create a new test script.
    *   Load all spells from `spells.lua`.
    *   For each spell:
        *   Compile it using `SpellCompiler.compileSpell`.
        *   Call the `compiledSpell.generateEvents(dummyCaster, dummyTarget, dummySlot)` method (a simplified version of `executeAll` that *only* generates events without running `EventRunner`).
        *   Assert that the returned `events` table contains at least one event with `type == "EFFECT"`, unless the spell is `attackType == Constants.AttackType.UTILITY` and known to have no visual.
    *   This test ensures that compilation and keyword execution are correctly set up to produce visual effect events.

## Deliverables
-   Updated `spells.lua` (and potentially `keywords.lua`) ensuring all non-utility spells trigger at least one `EFFECT` event.
-   `docs/Visual_Language.md` (or spreadsheet) defining the mapping between game concepts and visual styles.
-   `tools/test_vfx_events.lua` script that automatically verifies basic VFX event generation for all spells.
-   Test script passes.

## Design Notes/Pitfalls
-   Some spells might logically have multiple visual components (e.g., a projectile *and* an impact). Ensure the system supports triggering multiple `EFFECT` events from a single spell cast if needed.
-   The visual language document is crucial for maintaining consistency as more effects are added.
-   The automated test won't verify *correctness* of the VFX, only that an `EFFECT` event *is generated*. Manual testing is still needed for visual quality.

## Tickets/S6_VfxUnificationAndPipeline/VFX-6-Optional_DSL.md
# Ticket #VFX-6 (Optional): Implement Designer-Friendly VFX Preset DSL

## Goal
Create a simple, text-based Domain Specific Language (DSL) for defining VFX presets, allowing artists or designers to tweak effect parameters without modifying Lua code.

## Tasks

1.  **Define DSL Syntax:**
    *   Design a simple, readable syntax. Example:
        ```pgsql
        effect "firebolt" {
            type = "projectile" -- Corresponds to VFX.updateProjectile/drawProjectile
            duration = 1.0
            color = ORANGE -- Use color names mapped to Constants.Color
            particle {
                asset = "fireParticle" -- Maps to VFX.assetPaths key
                count = 20
                startScale = 0.5
                endScale = 1.0
            }
            trail {
                length = 12
            }
            impact { -- Optional section for impact parameters
                size = 1.4
                sound = "fire_impact" -- Optional sound trigger
            }
            sound = "fire_whoosh" -- Main sound
        }

        effect "impact_generic" {
            type = "impact"
            duration = 0.5
            color = SMOKE
            particle {
                asset = "sparkle"
                count = 15
                startScale = 0.8
                endScale = 0.2
            }
            ring { -- Parameters for the expanding ring
                 asset = "impactRing"
                 radius = 30
            }
        }
        ```

2.  **Create DSL Parser (`core/VFX_Parser.lua`):**
    *   Implement a basic Lua parser for the defined syntax. This could use string patterns (`string.gmatch`), LPEG, or a simpler line-by-line approach depending on complexity.
    *   The parser should take the DSL text file content as input.
    *   It should output a Lua table structure that mirrors the `VFX.effects` registry in `vfx.lua`.

3.  **Load DSL at Startup (`vfx.lua`):**
    *   Modify `VFX.init`.
    *   Read the content of a definition file (e.g., `assets/vfx/presets.vfx`).
    *   Call the parser to convert the text into a Lua table.
    *   Use this parsed table to populate `VFX.effects`, potentially overwriting or merging with any hardcoded defaults.

4.  **Update VFX System to Use Parsed Data:**
    *   Ensure `VFX.createEffect` and the `VFX.update*`/`VFX.draw*` functions correctly read parameters from the parsed `VFX.effects` structure (e.g., `effect.particle.count`, `effect.ring.radius`).

## Deliverables
-   Definition of the VFX DSL syntax (e.g., in `docs/VFX_DSL_Syntax.md`).
-   `core/VFX_Parser.lua` module capable of parsing the DSL.
-   Example `assets/vfx/presets.vfx` file defining at least `firebolt` and `impact` using the DSL.
-   Updated `vfx.lua` to load and use the DSL file at startup.
-   Manual Test: Modify parameters in `presets.vfx` (e.g., change `firebolt` color or particle count), restart the game, and verify the visual changes take effect.

## Design Notes/Pitfalls
-   Parsing can be complex. Start with a very simple syntax and parser. Avoid overly nested structures initially.
-   Error handling in the parser is important to provide feedback on syntax errors in the DSL file.
-   Need a mapping from DSL color names ("ORANGE") to `Constants.Color` tables.
-   This adds a dependency on the parser and the DSL file format.

## Tickets/S6_VfxUnificationAndPipeline/VfxGamePlan.md
# VFX Integration Plan

**Version:** 1.0
**Date:** 2025-04-26

## 1. Purpose

This plan outlines the steps to refactor Manastorm's visual effects (VFX) system. The primary goal is to create a clean, consistent, and event-driven pipeline for triggering and managing all visual effects, decoupling VFX logic from core gameplay simulation.

**Benefits:**
*   **Decoupling:** Gameplay logic (keywords, wizard state) won't directly trigger visuals. Effects will be described by events.
*   **Consistency:** All VFX will flow through a single pipeline (`EventRunner` -> `VFX` module).
*   **Maintainability:** Easier to add, modify, or debug visual effects without touching core game rules.
*   **Testability:** VFX triggers can be tested by asserting event generation.
*   **Designer Workflow:** Lays groundwork for potentially allowing designers/artists to configure effects more easily in the future.

## 2. Current State & Problems

Currently, VFX are triggered in multiple ways:
1.  Directly from `wizard.lua`'s `castSpell` function via `game.vfx.createSpellEffect(...)`.
2.  Via the `EFFECT` event handler in `systems/EventRunner.lua`, which calls `VFX.createEffect(...)`.
3.  Directly from `manapool.lua` within `TokenMethods:requestDestructionAnimation`.

This creates duplicate paths, makes it hard to track where visuals originate, and prevents keywords from declaratively specifying their visual components alongside their gameplay effects.

## 3. Target Architecture

The desired flow for VFX triggering will be:

Spell Keywords (keywords.lua) -- Define gameplay and associated VFX needs
│
▼
Spell Compiler (spellCompiler.lua) -- Packages keywords into a compiled spell
│
▼
Spell Execution (wizard.lua -> compiledSpell.executeAll) -- Runs keywords, generates EVENTS
│ (including EFFECT events)
▼
Event Runner (systems/EventRunner.lua) -- Processes ALL events in order
│
├─ Gameplay Handlers (modify wizard health, tokens, etc.)
│
└─ EFFECT Handler ---> VFX Module (vfx.lua) -- Creates/manages actual visuals
Non-spell systems (like token destruction, shield creation) will also trigger VFX via `EventRunner` using specific `EFFECT` events.

## 4. Sprint Overview

The refactor will proceed in the following tickets:

1.  **Ticket 1 (VFX Keyword):** Introduce a `vfx` keyword helper and centralize spell VFX triggers through the event system. Remove the legacy direct call from `wizard.lua`.
2.  **Ticket 2 (Event Contract):** Formalize the `EFFECT` event using `Constants` and add validation in the `EventRunner`.
3.  **Ticket 3 (Lifecycle Hooks):** Standardize how non-spell game systems (token lifecycle, shields, elevation) trigger VFX via events.
4.  **Ticket 4 (VFX Ergonomics):** Improve the internal structure and usability of the `vfx.lua` module (registry, async, lazy loading).
5.  **Ticket 5 (Content & Testing):** Audit all spells to ensure they use the `vfx` keyword, create a visual language reference, and add automated tests.
6.  **Ticket 6 (Optional DSL):** Explore creating a designer-friendly text format for defining VFX presets.

## 5. Key Modules Involved

-   `keywords.lua`
-   `spells.lua`
-   `spellCompiler.lua`
-   `wizard.lua`
-   `systems/EventRunner.lua`
-   `vfx.lua`
-   `core/Constants.lua`
-   `manapool.lua`
-   `systems/ShieldSystem.lua`

## Tickets/S7_RulesDrivenVfx/VFX-R1-Enrich_Events_with_Visual_Metadata.md
# Ticket #VFX-R1: Enrich Events with Visual Metadata

## Goal
Ensure gameplay events generated by keywords contain rich metadata (affinity, attackType, manaCost, tags, rangeBand, elevation) so the forthcoming `VisualResolver` can make accurate decisions.

## Tasks
1. **Modify `SpellCompiler.compileSpell` (`spellCompiler.lua`):**
   * When iterating through spell keywords, store the base `spell.affinity` and `spell.attackType` within the `compiledSpell` object so they are accessible during event generation.

2. **Update Keyword `execute` Functions (`keywords.lua`):**
   * For keywords that generate core gameplay events (e.g., `damage`, `apply_status`, `conjure`, `block`, `elevate`, `ground`, etc.), update their `execute` function signature to accept `spell` (the compiled spell object) as an argument, likely passed down from `executeAll`.
   * When creating an event within a keyword's `execute` function, add the relevant fields derived from the spell and current state:
     * `affinity  = spell.affinity`
     * `attackType = spell.attackType`
     * `tags      = { DAMAGE = true }` (or `BURN = true`, `SHIELD = true`, etc., based on the keyword's purpose)
     * `manaCost  = #slot.tokens` (approximate cost; requires access to `slot`)
     * `rangeBand = caster.gameState.rangeState`
     * `elevation = caster.elevation`

3. **Modify `SpellCompiler.executeAll` (`spellCompiler.lua`):**
   * Update calls to keyword `execute` functions to pass the necessary context (including the compiled spell object and potentially the slot table or index) so they can access `affinity`, `attackType`, `slot.tokens`, etc.

## Acceptance Criteria
* Key gameplay events (`DAMAGE`, `APPLY_STATUS`, `CONJURE_TOKEN`, `CREATE_SHIELD`, `SET_ELEVATION`, etc.) generated by keywords now include `affinity`, `attackType`, `manaCost`, `tags`, `rangeBand`, and `elevation` fields.
* Event generation functions correctly and does not introduce runtime errors.

## Design Notes / Pitfalls
* Accurately calculating `manaCost` may be tricky if tokens aren't fully assigned when the event is created; using `#slot.tokens` is a pragmatic first step.
* Passing the `compiledSpell` object down through `executeAll` to keyword `execute` functions is necessary for access to spell-level metadata.
* Ensure tag names are consistent and documented (e.g., use the keyword's `behavior.category` or a curated tag list). 

## Tickets/S7_RulesDrivenVfx/VFX-R2-Implement_VisualResolver_Module.md
# Ticket #VFX-R2: Implement VisualResolver Module

## Goal
Provide a central module that maps enriched gameplay events to VFX template names and parameters, decoupling gameplay logic from visual implementation.

## Tasks
1. **Create File (`systems/VisualResolver.lua`):**
   * Implement a new module file under `systems/` named `VisualResolver.lua`.

2. **Define Mapping Tables:**
   * `BASE_BY_ATTACK` – maps `Constants.AttackType` values to base VFX template names (e.g., `proj_base`, `beam_base`).
   * `COLOR_BY_AFF` – maps `Constants.TokenType` (affinities) to `Constants.Color` tables.
   * `TAG_ADDONS` – maps keyword tags (e.g., `burn`, `conjure`, `shield`) to overlay VFX template names (e.g., `ember_overlay`, `sparkle_overlay`).
   * `AFFINITY_MOTION` – maps `Constants.TokenType` values to `Constants.MotionStyle` (to be defined in next ticket).

3. **Implement `VisualResolver.pick(event)` Function:**
   * First, check `event.effectOverride`; if present, return it directly (`base`, `opts = {}`).
   * Determine base template using `BASE_BY_ATTACK[event.attackType]` (fallback to `impact_base`).
   * Determine color tint using `COLOR_BY_AFF[event.affinity]` (fallback to white).
   * Calculate scale based on `event.manaCost` (`0.8 + 0.15 * (event.manaCost or 1)`).
   * Determine motion style using `AFFINITY_MOTION[event.affinity]` (fallback to `Constants.MotionStyle.RADIAL`).
   * Build `addons` list from `event.tags` via `TAG_ADDONS`.
   * Return two values: `baseTemplateName`, and `opts` table containing `{ color, scale, motion, addons, rangeBand = event.rangeBand, elevation = event.elevation }`.

## Acceptance Criteria
* `systems/VisualResolver.lua` exists with mapping tables and a working `pick` function.
* Function returns appropriate defaults for unknown values.
* Unit tests or debug prints confirm correct mapping when fed sample events.

## Design Notes / Pitfalls
* Keep mappings data-driven for easy tweaking by designers.
* Ensure `Constants` tables are required safely to avoid circular deps.
* The `opts` table should be forward-compatible with additional parameters. 

## Tickets/S7_RulesDrivenVfx/VFX-R3-Integrate_VisualResolver_into_EventRunner.md
# Ticket #VFX-R3: Integrate VisualResolver into EventRunner

## Goal
Use the new `VisualResolver` to determine which VFX to trigger for gameplay events, replacing hard-coded effect look-ups in `EventRunner`.

## Tasks
1. **Modify `EventRunner.lua`:**
   * `require("systems.VisualResolver")` at the top.
   * In the `EFFECT` handler within `EventRunner.EVENT_HANDLERS`:
     * Remove old logic that directly looked at `event.effectType` / `vfxParams`.
     * Call `local baseEffectName, vfxOpts = VisualResolver.pick(event)`.
     * If `baseEffectName` is falsy, log and return (skip VFX).
     * Determine coordinates (srcX, srcY, tgtX, tgtY) based on `event.source`, `event.target`, `caster`, `target` (reuse existing helper or logic).
     * Call `VFX.createEffect(baseEffectName, srcX, srcY, tgtX, tgtY, vfxOpts)`.

2. **Review Other Event Handlers:**
   * Identify handlers that currently call `safeCreateVFX` or `VFX.createEffect` directly (e.g., `SET_ELEVATION`, shield-related logic).
   * For each, choose either:
     * (Preferred) Generate an `EFFECT` event and let the main handler process it.
     * (Interim) Call `VisualResolver.pick` directly to obtain parameters, then create the effect.
   * Document decisions in comments.

## Acceptance Criteria
* The `EFFECT` handler in `EventRunner` now exclusively relies on `VisualResolver.pick` to decide visuals.
* Visual effects for core gameplay events (damage, status, conjure, etc.) still trigger correctly in-game.
* Legacy direct VFX calls in other handlers are removed or routed through the resolver.

## Design Notes / Pitfalls
* Coordinate resolution is non-trivial; ensure consistency with previous visuals.
* Consider staging changes—first update `EFFECT` handler, then gradually refactor other direct calls. 

## Tickets/S7_RulesDrivenVfx/VFX-R4-Adapt_VFX_Module_for_Resolver_Output_and_Motion.md
# Ticket #VFX-R4: Adapt VFX Module for Resolver Output & Motion Styles

## Goal
Update the `vfx.lua` system to consume the generic templates and option table produced by `VisualResolver`, while introducing motion styles and improved scaling/trajectory logic.

## Tasks
1. **Define Motion Styles (`core/Constants.lua`):**
   * Add `Constants.MotionStyle` enum with `RADIAL`, `SWIRL`, `HEX`, `SPIRAL`, `TWINKLE`.

2. **Create Base Templates (`vfx.lua`):**
   * Ensure `VFX.effects` includes `proj_base`, `beam_base`, `impact_base`, `aura_base`, and `shield_hit_base` with minimal defaults.

3. **Modify `VFX.createEffect` (`vfx.lua`):**
   * Accept `opts` table as the last parameter.
   * Apply `opts.color` as tint; `opts.scale` to particle counts, sizes, radii; store `opts.motion`, `opts.rangeBand`, `opts.elevation` on the effect instance.
   * If `opts.addons` exists, iterate and (initially) `print("TODO addon", addon)` – full addon support comes later.

4. **Implement Motion Styles:**
   * In `VFX.initializeParticles`, store `effect.motion` onto each particle (`p.motion`).
   * Extend `VFX.updateParticle` (or create if absent) with branching logic for each motion style:
     * `RADIAL`: linear outward velocity.
     * `SWIRL`: tangential swirl using sine/cosine.
     * `HEX`: hex-grid jitter (approx via snapped angles).
     * `SPIRAL`: particles accelerate outward in a spiral.
     * `TWINKLE`: oscillating alpha/scale.

5. **Refine Basic Trajectory:**
   * In `VFX.updateProjectile`, adjust start/end Y positions based on `effect.rangeBand` (`NEAR`, `FAR`) and `effect.elevation` (`GROUNDED`, `AERIAL`). Simple offsets are fine.

## Acceptance Criteria
* `VFX.createEffect` consumes `opts` correctly.
* Particles move following the selected motion styles.
* Projectiles visually differentiate between range bands and elevations.
* Addon list is logged for future work.

## Design Notes / Pitfalls
* Math heavy work—validate with debug visuals.
* Keep default behaviors identical to previous visuals until options provided. 

## Tickets/S7_RulesDrivenVfx/VFX-R5-Deprecate_Manual_VFX_Specification.md
# Ticket #VFX-R5: Deprecate Manual VFX Specification

## Goal
Remove legacy spell-specific VFX declarations, relying primarily on the rule-driven `VisualResolver` with an override mechanic for special cases.

## Tasks
1. **Clean Up `spells.lua`:**
   * Remove most `vfx = { ... }` keyword entries and top-level `vfx = "effect"` properties.
   * Retain 1–2 showcase spells that intentionally set `effectOverride` (cinematic finishers).

2. **Adjust `Keywords.vfx` (`keywords.lua`):**
   * Change behavior: instead of creating an `EFFECT` event, simply set `results.effectOverride = params.effectOverride` (or `params.effect`) and return.

3. **Pass Override Through Compiler/Runner:**
   * Ensure `SpellCompiler.executeAll` or `EventRunner` copies `results.effectOverride` into the generated `EFFECT` event.
   * Alternatively, have `VisualResolver.pick` inspect `event.effectOverride` (preferred) – already planned in R2.

## Acceptance Criteria
* Majority of spells no longer specify VFX directly; visuals are resolved automatically.
* Override mechanism still works for designated spells.
* No runtime errors from missing VFX definitions.

## Design Notes / Pitfalls
* Double-check that removed manual VFX definitions are truly redundant.
* Keep at least one example spell using the override for regression testing. 

## Tickets/S7_RulesDrivenVfx/VFX-R6-Shield_Impacts_and_Trajectory_Visuals.md
# Ticket #VFX-R6: Handle Shield Impacts & Basic Trajectory Visuals

## Goal
Provide clear visual feedback when shields block attacks and fine-tune projectile trajectories based on range and elevation.

## Tasks
1. **Emit Shield Hit Event (`systems/ShieldSystem.lua`):**
   * In `ShieldSystem.handleShieldBlock` (or equivalent), create an `EFFECT` event instead of direct VFX:
     ```lua
     local shieldHitEvent = {
         type        = "EFFECT",
         source      = Constants.TargetType.TARGET,  -- defender is both source & target visually
         target      = Constants.TargetType.TARGET,
         effectType  = "shield_hit", -- logical tag for VisualResolver
         affinity    = target.affinity,
         tags        = { SHIELD_HIT = true },
         shieldType  = blockInfo.blockType,
         posX        = target.x,
         posY        = target.y,
     }
     EventRunner.processEvents({ shieldHitEvent }, target, caster, blockInfo.blockingSlot)
     ```

2. **Update `VisualResolver` (`systems/VisualResolver.lua`):**
   * Add handling for `event.effectType == "shield_hit"`.
   * Map to base template `shield_hit_base` and pick color via `event.shieldType` (use helper from ShieldSystem).

3. **Add Shield Hit Template (`vfx.lua`):**
   * Define `VFX.effects["shield_hit_base"]` – quick radial burst (reuse `impactRing` sprite).

4. **Refine Trajectory Logic (`vfx.lua`):**
   * Confirm `VFX.updateProjectile` offsets source/target based on `effect.rangeBand` and `effect.elevation`.
   * Tweak numbers so visual difference is noticeable but not exaggerated.

## Acceptance Criteria
* Blocking a spell produces a colored shield hit visual at the defender.
* Projectile trajectories respect range/elevation parameters set via `opts`.

## Design Notes / Pitfalls
* Ensure shield color derives from shield type, not affinity.
* Event-based triggering keeps visuals consistent with other systems. 

## Tickets/S7_RulesDrivenVfx/VFX-RulesBasedRefactor-GamePlan.md
Manastorm VFX Refactoring: Game Plan
Version: 1.0
Date: 2025-04-28
Context: This document provides a high-level overview for the VFX system refactoring outlined in tickets VFX-R1 through VFX-R6.
1. Purpose & Problem Statement
Goal: To refactor Manastorm's Visual Effects (VFX) system, making it more consistent, maintainable, and driven by the game's core rules rather than manual specification for every spell.
Current Problem: Our current system triggers VFX in several different places and often requires developers to manually specify both the gameplay effect (e.g., deal fire damage) and the visual effect (e.g., play the "firebolt" animation). This leads to:
Duplication: We often say the same thing twice (rule + visual).
Inconsistency: It's easy for visuals to drift out of sync with gameplay rules or element types.
Maintenance Overhead: Changing a spell's element might require hunting down and changing its VFX specification separately.
Scattered Logic: VFX triggers are spread across wizard.lua, manapool.lua, and the EventRunner, making it hard to track how visuals are initiated.
2. Target Architecture: Rule-Driven Visuals
We are moving to a rule-driven VFX system. The core idea is:
Gameplay Events should imply the necessary visuals.
Instead of manually telling the VFX system exactly which effect to play for most spells, we will:
Enrich Gameplay Events: Ensure events generated by keywords (like DAMAGE, APPLY_STATUS, CONJURE_TOKEN) contain key metadata about the action:
affinity (Fire, Moon, Salt, etc.)
attackType (Projectile, Remote, Zone, Utility)
manaCost (as a proxy for power/intensity)
tags (indicating specific mechanics like Burn, Shield, Conjure)
Positional context (rangeBand, elevation)
Introduce a VisualResolver: This new module will look at the metadata within an incoming event.
Derive Visuals: Based on the event's metadata, the VisualResolver will intelligently select:
A base VFX template (e.g., a generic projectile, beam, impact, or aura).
A color tint based on the affinity.
A scale/intensity modifier based on the manaCost.
A particle motion style based on the affinity (e.g., radial bursts for Fire, swirls for Water).
Potentially small additive overlay effects based on tags (e.g., embers for Burn, sparkles for Conjure).
Centralized Triggering: The EventRunner will be the primary system responsible for calling the VisualResolver and then triggering the VFX module with the derived template name and parameters. Manual specification of VFX (vfx = { effectOverride = ... }) becomes the exception for unique, cinematic moments, not the rule.
3. Key Benefits of This Approach
Single Source of Truth: Gameplay rules (keywords, spell definitions) define the effect; visuals follow automatically.
Consistency: All Fire projectiles will share visual characteristics, tinted correctly. All Water effects will have a distinct motion style.
Reduced Boilerplate: No need to add vfx = ... to most spell definitions.
Easier Design Iteration: Change a spell's affinity, and its visual color/motion updates automatically. Add a new element, and you primarily need to add its color/motion to the VisualResolver.
Improved Readability: Players can learn to visually associate colors, motions, and shapes with specific elements and attack types.
Maintainability: VFX logic is centralized in the VisualResolver and VFX module.
4. How the Tickets Fit Together (VFX-R1 to VFX-R6)
This refactor is broken down into manageable steps:
VFX-R1 (Enrich Events): Focuses on making sure the data needed by the resolver (affinity, attackType, cost, tags etc.) gets added to the events when keywords execute.
VFX-R2 (Implement Resolver): Creates the core VisualResolver module with the logic to map event data to visual parameters (template, color, scale, motion).
VFX-R3 (Integrate Resolver): Modifies the EventRunner to use the VisualResolver when it processes EFFECT events (and potentially other relevant events like SET_ELEVATION).
VFX-R4 (Adapt VFX Module): Updates the VFX module itself to understand the generic base templates, apply tints/scales/motion styles, and handle additive effects passed from the resolver.
VFX-R5 (Deprecate Manual VFX): Cleans up spells.lua by removing most of the now-redundant manual vfx specifications, relying on the resolver instead. It also refactors the vfx keyword to only handle explicit overrides.
VFX-R6 (Shield Impacts): Ensures shield blocking correctly triggers a distinct visual effect via the new event/resolver pipeline.
5. Example Flow (Post-Refactor)
Wizard casts "Tidal Force" (Water Affinity, Remote Attack, 2 Mana).
The damage keyword executes, generating a DAMAGE event.
The event includes: { type="DAMAGE", affinity="water", attackType="remote", manaCost=2, tags={DAMAGE=true}, rangeBand="NEAR", ... }.
EventRunner processes this event.
EventRunner calls VisualResolver.pick(event).
VisualResolver sees attackType="remote" -> chooses "beam_base". Sees affinity="water" -> chooses OCEAN color and SWIRL motion. Sees manaCost=2 -> calculates scale=1.1. Sees tags={DAMAGE=true} -> maybe adds no specific addon.
VisualResolver returns ("beam_base", {color=OCEAN, scale=1.1, motion=SWIRL, addons={}, ...}).
EventRunner calls VFX.createEffect("beam_base", srcX, srcY, tgtX, tgtY, {color=OCEAN, scale=1.1, motion=SWIRL, ...}).
The VFX module renders a generic beam, tinted blue, slightly larger than default, with particles that swirl.
6. Guidance for Implementation
Focus on Events: Think about what information an event needs to carry for the VisualResolver to work.
Use Constants: Rely heavily on core/Constants.lua for affinities, attack types, colors, and the new motion styles.
Understand the Resolver: The VisualResolver is the central mapping layer. Keep its logic clear and based on the event data.
Test Incrementally: After each ticket, test relevant spells to ensure visuals are still triggering and gradually adopting the new rule-driven appearance.
Keep it Simple Initially: The base templates and motion styles can start very basic. The goal is functional consistency first, polish later.
7. Conclusion
This refactor moves Manastorm towards a more elegant and maintainable VFX system where visuals are a direct reflection of the underlying gameplay rules. While it involves touching several core systems, the end result will be a cleaner codebase and a more consistent visual experience for players.

## Tickets/S8_AIOpponent/AI-1-Module_Setup_and_Integration.md
Ticket AI-1: AI Module Setup & Integration
Goal: Create the fundamental structure for the AI system and integrate it into the main game loop.
Tasks:
Create a new directory ai/.
Create ai/OpponentAI.lua.
Define the basic OpponentAI table structure with empty new, update, perceive, decide, and act functions.
In OpponentAI.new(wizard, gameState), store the wizard (AI's wizard object) and gameState references.
In main.lua (love.load), require ai/OpponentAI and create an instance, storing it in game.opponentAI (e.g., game.opponentAI = OpponentAI.new(game.wizards[2], game)).
In main.lua (love.update, within the "BATTLE" state), add a call to game.opponentAI:update(dt) if game.opponentAI exists.
Add a simple print("AI Update Tick") inside OpponentAI:update for initial verification.
Acceptance Criteria:
The game loads and runs without errors.
The "AI Update Tick" message appears periodically in the console during the BATTLE state.
game.opponentAI holds a valid instance of the AI controller.
Design Notes: Keep this purely structural. No decision logic yet.

## Tickets/S8_AIOpponent/AI-2-Implement_AI_Perception.md
Ticket AI-2: Perception Implementation
Goal: Enable the AI to gather necessary information about the current game state.
Tasks:
Implement the OpponentAI:perceive() function.
Inside perceive, access necessary data from self.wizard, self.gameState, and the opponent wizard (self.gameState.wizards[1] if AI is P2). Gather:
Own health, elevation, active spell slot details (which are active, progress, isShield).
Opponent health, elevation, active spell slot details.
gameState.rangeState.
Counts of key mana token types in self.wizard.manaPool (using ManaHelpers).
Return the gathered data in a structured table (e.g., perceptions = { selfHealth = ..., oppHealth = ..., range = ..., mana = {fire=..., moon=...} }).
Call self:perceive() within OpponentAI:update and store the result (initially just print it for debugging).
Acceptance Criteria:
perceive() function returns a table containing relevant, up-to-date game state information.
The perception data is logged or verifiable via debugger during gameplay.
Pitfalls: Avoid trying to perceive everything. Start with the most critical information (health, range, elevation, basic mana counts). Avoid deep copying large tables; extract only necessary values or use references carefully.

## Tickets/S8_AIOpponent/AI-3-Basic_FSM_and_Decision_Logic.md
Ticket AI-3: Basic FSM & Decision Logic
Goal: Implement a rudimentary Finite State Machine (FSM) with simple rules to determine the AI's general intent (e.g., attack, defend).
Tasks:
Define basic AI states as constants within OpponentAI (e.g., local STATE_IDLE = 1, local STATE_ATTACK = 2, local STATE_DEFEND = 3). Add self.currentState = STATE_IDLE in OpponentAI.new.
Implement the OpponentAI:decide(perceptions) function.
Inside decide, implement simple state transition logic based on perceptions:
Example: if perceptions.selfHealth < 40 then self.currentState = STATE_DEFEND
Example: elseif perceptions.oppHealth < 75 then self.currentState = STATE_ATTACK
Example: else self.currentState = STATE_IDLE
Based only on the self.currentState, choose a placeholder action type. Return a simple action description:
If DEFEND: return { type = "DEFEND_ACTION" }
If ATTACK: return { type = "ATTACK_ACTION" }
If IDLE: return { type = "IDLE_ACTION" } (or { type = "WAIT" })
Call self:decide(perceptions) within OpponentAI:update after perceiving. Print the returned action type.
Acceptance Criteria:
The AI transitions between basic states based on simple health thresholds (verified via print statements).
The decide function returns a basic action type corresponding to the current state.
Design Notes: This separates state determination from specific action selection, which comes next. Keep rules extremely simple for now.

## Tickets/S8_AIOpponent/AI-4-AI_Action_Execution.md
Ticket AI-4: Action Execution
Goal: Translate the AI's high-level action decision into specific calls to the Wizard API.
Tasks:
Implement the OpponentAI:act(action) function.
Add if/elseif conditions based on action.type returned from decide.
Crucially: For CAST actions (which will be defined in the next ticket), call self.wizard:queueSpell(action.spell). Do NOT simulate key presses.
Implement handlers for placeholder actions from AI-3 (initially, they might just print a message like "AI wants to attack").
Add basic action types like { type = "WAIT" } (does nothing) and { type = "FREE_ALL" } (calls self.wizard:freeAllSpells()).
Call self:act(action) within OpponentAI:update after deciding.
Acceptance Criteria:
The act function receives the action table from decide.
Appropriate wizard methods are called based on the action type (initially verified with prints, later by observing game behavior).
Pitfalls: Using queueSpell directly is essential. Avoid any logic related to keySpell or castKeyedSpell for the AI.

## Tickets/S8_AIOpponent/AI-5-AI_Spellbook_Knowledge_and_Strategy.md
Ticket AI-5: Spell Knowledge & Basic Strategy
Goal: Make the AI choose specific spells from its spellbook based on its state and check mana costs.
Tasks:
Refine OpponentAI:decide(perceptions):
Spell Selection: Instead of returning placeholder action types, select an actual spell from self.wizard.spellbook.
If DEFENDING, find a spell with a block keyword (e.g., iterate through self.wizard.spellbook, check if spell.keywords.block exists).
If ATTACKING, find a spell with a damage keyword. Start with the simplest available (e.g., the "1" key spell).
If MANA_GATHERING (add this state if desired), find a conjure spell.
Mana Check: Before returning a { type = "CAST", spell = chosenSpell } action, call self.wizard:canPayManaCost(chosenSpell.cost). If it returns nil (cannot afford), the AI should not choose that spell (it could WAIT or try a cheaper spell/conjure).
Update OpponentAI:act(action) to correctly handle the { type = "CAST", spell = ... } action by calling self.wizard:queueSpell(action.spell).
Acceptance Criteria:
AI attempts to cast spells appropriate to its current state (defensive, offensive).
AI only attempts to cast spells it has the mana for.
AI uses spells defined in its own spellbook.
The AI can be observed successfully casting different spells during gameplay.
Design Notes: Keep spell selection simple initially (e.g., "first available defensive spell"). Can add weights/priorities later. Introduce a simple MANA_GATHERING state if the AI often gets stuck unable to afford anything.

## Tickets/S8_AIOpponent/AI-Add_AI_Opponent_Gameplan.md
Manastorm AI Opponent - Phase 1: Local Demo Implementation
Version: 1.0
Date: 2025-04-29
1. Context & Goal
Context: Manastorm currently requires two human players. To facilitate local testing, demonstrations, and balancing of core mechanics without needing a second player, a basic AI opponent is required.
Primary Goal: Implement a functional, non-player opponent ("AI") capable of participating in a duel using the existing game mechanics. The AI should provide a minimal level of interaction and challenge, enabling single-player testing and demonstration of the core gameplay loop.
Non-Goals (for this phase): This is not intended to be a highly skilled, human-like, or strategically deep AI. Advanced features like prediction, complex counter-play, learning, or multiple difficulty levels are outside the scope of this initial implementation.
2. Scope
In Scope:
Creating a dedicated AI module (ai/OpponentAI.lua).
Integrating the AI update loop into the main game cycle (main.lua).
Implementing basic perception of critical game state (own/opponent health, range, elevation, basic mana availability).
Implementing a simple Finite State Machine (FSM) with core states (e.g., Idle, Attack, Defend).
Rule-based transitions between AI states based on perceived game state.
Ability for the AI to select spells from its pre-defined spellbook based on its current state.
Ability to check mana costs using the existing Wizard:canPayManaCost function.
Ability to execute actions by directly calling methods on its assigned Wizard object (specifically queueSpell, freeAllSpells).
Basic configuration points (like decision timer interval, health thresholds).
Out of Scope:
Simulating key presses or interacting with the Input module.
Predicting player actions or reacting to player spell casting progress.
Complex strategic planning or resource management beyond basic mana checks.
Learning or adaptive behavior.
Multiple distinct difficulty levels (beyond simple parameter tuning).
AI vs. AI simulations.
3. High-Level Approach: Rule-Based FSM
We will implement a simple Finite State Machine (FSM) combined with rule-based decision-making.
States: The AI will operate in a small number of distinct states (e.g., IDLE, ATTACKING, DEFENDING).
Perception: On a regular interval, the AI will perceive the game state.
Decision: Based on the perceived state and simple rules, the AI will transition between its internal states and select an appropriate action (e.g., "cast defensive spell", "cast offensive spell", "wait").
Action: The AI will execute the chosen action by calling the relevant methods on its Wizard instance.
Rationale: This approach is chosen for its relative simplicity, ease of initial implementation and debugging, clear alignment with the game's existing discrete states (range, elevation), and extensibility for future enhancements. It avoids the complexity of behavior trees or learning systems for this initial phase.
4. Integration Points
Initialization: An OpponentAI instance will be created in main.lua during love.load and associated with one of the Wizard instances (typically game.wizards[2]).
Update Loop: The OpponentAI:update(dt) method will be called from main.lua's love.update function during the BATTLE state.
State Reading: The AI will read data directly from its assigned Wizard object, the opponent Wizard object, and the shared gameState (including manaPool via ManaHelpers).
Action Execution: The AI will directly invoke methods on its Wizard object (queueSpell, freeAllSpells). It will NOT simulate keyboard input.
5. Success Metrics (for Phase 1)
The AI component runs without causing errors or stability issues.
The AI can perceive basic game state changes (health, range, etc.).
The AI transitions between its defined behavioral states based on simple rules.
The AI successfully queues spells from its spellbook when it has sufficient mana.
The AI provides some level of interaction, casting spells periodically and reacting minimally to significant health changes (e.g., attempting to defend when low).
A human player can complete a basic duel against the AI, allowing testing of the core game loop, spell effects, and win/loss conditions.
6. Future Considerations (Post-Phase 1)
More sophisticated decision-making (e.g., Behavior Trees).
Improved perception (tracking specific tokens, opponent cast progress).
Reactive behaviors (e.g., attempting to block projectiles, countering specific spell types).
Strategic mana management and combo spell usage.
Distinct difficulty levels.
7. Related Tickets
AI-1: AI Module Setup & Integration
AI-2: Perception Implementation
AI-3: Basic FSM & Decision Logic
AI-4: Action Execution
AI-5: Spell Knowledge & Basic Strategy

## Tickets/S9_VfxSystemRefactor/VFX-S2-Rule_Driven_System-Game_Plan.md
# Manastorm VFX Refactoring: Rule-Driven System - Game Plan
**Version:** 2.0  
**Date:** Thu May 1 13:36:18 CDT 2025  
**Context:** This document outlines the plan for Sprint 2 of the VFX refactoring, focusing on implementing a rule-driven visual system.

## 1. Purpose & Problem Statement

### Goal
To refactor Manastorm's Visual Effects (VFX) system so that visuals are primarily derived from gameplay rules and metadata (affinity, attack type, visual shape, cost, tags), rather than being manually specified for every spell. This aims to improve consistency, maintainability, and designer workflow.

### Current Problem
The existing system relies heavily on manual VFX specification (vfx property or keyword) for most spells. This couples visual decisions tightly to gameplay definitions, leading to:
- **Inconsistency:** Visuals can easily mismatch a spell's element or type.
- **Maintenance Burden:** Changing a spell's affinity requires manually updating its VFX.
- **Scalability Issues:** Adding new elements/shapes requires widespread manual updates.
- **Scattered Logic:** VFX triggers are distributed, making the flow hard to follow.

## 2. Target Architecture: Rule-Driven Visuals

We are moving to a system where gameplay events imply the necessary visuals.

### Core Components & Flow:

#### Enriched Events
Gameplay keywords (damage, conjure, etc.) generate events containing rich metadata:
- **affinity:** (Fire, Moon, etc.) -> Determines Color & Motion
- **attackType:** (Projectile, Zone, etc.) -> Determines Base Structure (if visualShape absent)
- **visualShape:** (Beam, Bolt, Blast, etc.) -> Overrides Base Structure
- **manaCost:** (Number) -> Determines Scale/Intensity
- **tags:** ({ BURN=true, SHIELD=true }) -> Determines Additive Overlays (Future)
- **Context:** (rangeBand, elevation) -> Influences Trajectory/Appearance

#### VisualResolver (systems/VisualResolver.lua)
- Acts as the central mapping service.
- Takes an enriched event as input.
- Uses internal mapping tables (TEMPLATE_BY_SHAPE, BASE_BY_ATTACK, COLOR_BY_AFF, AFFINITY_MOTION) and logic (scaling by manaCost) to determine visual parameters.
- Outputs: baseTemplateName (String), opts (Table: { color, scale, motion, addons, rangeBand, elevation, particleAsset, ... }).
- Handles effectOverride as the highest priority bypass.

#### EventRunner (systems/EventRunner.lua)
- Processes all game events, including EFFECT events.
- For EFFECT events, calls VisualResolver.pick(event) to get visual parameters.
- Calls VFX.createEffect(baseTemplateName, ..., opts) to trigger the visual.

#### VFX Module (vfx.lua)
- VFX.effects registry contains primarily base templates (proj_base, beam_base, impact_base, etc.) defining structure and default particle assets.
- VFX.createEffect consumes the baseTemplateName and the opts table.
- Initializes effect instances using parameters from opts (overriding template defaults for color, scale, motion, particle asset, etc.).
- update*/draw* functions render the effect based on the instance's parameters and motion style.

### Key Principle
Define the gameplay, get consistent visuals for free. Override only when necessary.

## 3. Sprint Ticket Breakdown (VFX-S2-T1 to VFX-S2-T6)

This sprint builds the rule-driven system step-by-step:
1. **T1 (Refine Resolver):** Implement visualShape mapping in VisualResolver and clarify priority (override > shape > attackType).
2. **T2 (Decouple Assets):** Make particle/asset choice in vfx.lua data-driven via templates and opts. Remove hardcoded asset names from draw*.
3. **T3 (Consume Params):** Ensure VFX.createEffect fully uses all parameters from opts (color, scale, motion, overrides) and passes them to the effect instance.
4. **T4 (Purge Registry):** Clean VFX.effects, leaving mostly base templates and a few truly unique named effects.
5. **T5 (Motion Styles):** Fully implement the particle movement logic for different motion styles in VFX.updateParticle.
6. **T6 (Deprecate Old Specs):** Remove legacy vfx properties from spells, ensuring reliance on the resolver.

## 4. Example Flow (Post-Refactor)

1. **Spell Def:** `MySpells.AquaBlast = { affinity=WATER, attackType=ZONE, visualShape="blast", keywords={damage={...}} }`
2. **Event:** DAMAGE event generated with `{ affinity=WATER, attackType=ZONE, visualShape="blast", manaCost=3, tags={DAMAGE=true} }`
3. **EventRunner:** Processes EFFECT event derived from DAMAGE.
4. **Resolver:** VisualResolver.pick(event):
   - Sees visualShape="blast", maps to baseTemplate="zone_base".
   - Sees affinity=WATER, maps to color=OCEAN, motion=SWIRL.
   - Sees manaCost=3, calculates scale=1.25.
   - Sees tags={DAMAGE=true}, adds addon=DAMAGE_OVERLAY.
   - Returns ("zone_base", {color=OCEAN, scale=1.25, motion=SWIRL, addons={...}, ...}).
5. **VFX:** VFX.createEffect("zone_base", ..., {color=OCEAN, ...}). Renders a zone effect, tinted blue, 25% larger, with swirling particles.

## 5. Guidance & Notes

- **Focus on Base Templates:** Make proj_base, beam_base, etc., robust and parameterizable.
- **Use Constants:** Heavily rely on core/Constants.lua.
- **Incremental Testing:** Test visuals after each ticket, ensuring the resolver and VFX module interact correctly.
- **Visual Language Doc:** Refer to docs/Visual_Language.md to guide parameter choices (default particle assets, motion styles per affinity).

## 6. Conclusion

This sprint fundamentally shifts how VFX are handled, moving from manual specification to a rule-driven, metadata-based system. This will improve consistency, reduce maintenance, and make adding visually appropriate effects for new spells significantly easier.

## Tickets/S9_VfxSystemRefactor/VFX-S2-T1-Refine_VisualResolver_for_visualShape_Mapping.md
# Ticket #VFX-S2-T1: Refine VisualResolver for visualShape Mapping

## Goal
Make the VisualResolver prioritize visualShape over attackType for selecting the base VFX template and centralize this mapping logic.

## Background
The VisualResolver currently relies primarily on attackType to determine the base VFX template. We want to shift toward using the visualShape property as the primary determinant, which will allow for more consistent and intuitive visual effects based on the spell's shape rather than its combat mechanics.

## Tasks

### Define Mapping Table (VisualResolver.lua)
- Create a private table `TEMPLATE_BY_SHAPE` mapping visualShape strings (e.g., "beam", "bolt", "blast") to Constants.VFXType base template names
- Include all shapes from docs/visualShape.md
- Example mapping:
  - "beam" -> Constants.VFXType.BEAM_BASE
  - "bolt" -> Constants.VFXType.PROJ_BASE
  - "blast" -> Constants.VFXType.IMPACT_BASE
  - etc.

### Modify VisualResolver.pick(event)
- Implement priority logic for determining baseTemplate:
  1. Check event.effectOverride first
  2. If no override, check event.visualShape and look it up in TEMPLATE_BY_SHAPE
  3. If no match or no visualShape, fall back to BASE_BY_ATTACK[event.attackType]
  4. If still no match, use DEFAULT_BASE
- Ensure the rest of the function (color, scale, motion, addons) uses the final resolved baseTemplate consistently
- Add debug prints to clearly show which logic path (override, shape, attackType, default) determined the baseTemplate

## Acceptance Criteria
- VisualResolver.pick correctly uses event.visualShape to determine the base template when present
- The fallback logic to attackType and default still works correctly
- Debug logs clearly indicate the selection path
- Spells defined with visualShape (e.g., Full Moon Beam) now use the corresponding base template according to the new mapping table

## Technical Notes
This change isolates the shape-to-template logic, making it easier to manage and extend visualShape support. The refactoring should maintain backward compatibility with spells that don't yet have visualShape defined.

## Dependencies
- Requires Constants.VFXType to be properly defined
- Should be implemented before other VFX system refactoring tickets

## Tickets/S9_VfxSystemRefactor/VFX-S2-T2-Decouple_Particle_Assets_in_VFX_Module.md
# Ticket #VFX-S2-T2: Decouple Particle Assets in VFX Module

## Goal
Remove hardcoded particle asset names from vfx.lua's draw* functions, making particle choice data-driven via templates and options.

## Background
Currently, the vfx.lua module has hardcoded asset names in its drawing functions, limiting flexibility and making it difficult to vary particle appearances based on spell properties. This refactoring will make the particle asset selection configurable through templates and options.

## Tasks

### Add Default Assets to Templates (vfx.lua)
- For each base template definition in VFX.effects (e.g., proj_base, impact_base), add a defaultParticleAsset field
- Example changes:
  ```lua
  VFX.effects = {
    proj_base = {
      -- existing properties
      defaultParticleAsset = "sparkle",
      defaultGlowAsset = "fireGlow",
    },
    impact_base = {
      -- existing properties
      defaultParticleAsset = "sparkle",
    },
    -- other templates
  }
  ```
- Consider adding fields for secondary assets if needed (e.g., defaultGlowAsset)

### Modify VFX.createEffect (vfx.lua)
- When processing the opts table, look for optional opts.particleAsset (and opts.glowAsset, etc.)
- Store the chosen asset key on the effect instance:
  ```lua
  effect.particleAssetKey = opts.particleAsset or template.defaultParticleAsset
  effect.glowAssetKey = opts.glowAsset or template.defaultGlowAsset
  ```

### Update draw* Functions (vfx.lua)
- Modify functions like drawProjectile, drawImpact, drawAura etc.
- Replace direct asset references:
  ```lua
  -- Before
  local particleImage = getAssetInternal("fireParticle")
  
  -- After
  local particleImage = getAssetInternal(effect.particleAssetKey)
  ```
- Handle cases where an asset might be missing gracefully
- Update logic for glow images and impact rings similarly

## Acceptance Criteria
- Base templates in vfx.lua define default particle/glow asset keys
- VFX.createEffect stores the correct asset key based on options or template defaults
- draw* functions dynamically load assets using the stored key via getAssetInternal
- Visual effects render using the particle assets defined by their templates (no visual change expected yet, just refactoring)

## Technical Notes
- Ensure getAssetInternal handles nil paths gracefully
- Consistent naming of asset keys is important
- This change will enable future improvements where particle appearance can be determined by spell properties

## Dependencies
- This change should be implemented after VFX-S2-T1 since it builds on the template selection logic

## Tickets/S9_VfxSystemRefactor/VFX-S2-T3-Full_Parameter_Consumption_in_VFX_Module.md
# Ticket #VFX-S2-T3: Full Parameter Consumption in VFX Module

## Goal
Ensure VFX.createEffect and the corresponding update*/draw* functions fully utilize the parameters provided in the opts table from the VisualResolver.

## Background
Currently, the VFX module only partially consumes parameters from the opts table produced by the VisualResolver. This ticket aims to enhance parameter utilization to allow for more nuanced control over visual effects based on spell properties.

## Tasks

### Enhance VFX.createEffect (vfx.lua)
- Explicitly read and store all relevant parameters from the opts table:
  ```lua
  -- Read and store all parameters from opts
  effect.color = opts.color or template.defaultColor
  effect.scale = opts.scale or 1.0
  effect.motion = opts.motion or template.defaultMotion or Constants.MotionStyle.DEFAULT
  effect.duration = opts.duration or template.duration
  effect.particleCount = opts.particleCount or template.particleCount
  effect.rangeBand = opts.rangeBand -- for trajectory calculation
  effect.elevation = opts.elevation -- for trajectory calculation
  effect.addons = opts.addons or {} -- for future extensions
  ```
- Apply opts.scale more comprehensively:
  - Define scaling rules for different properties (radius, beamWidth, height, impactSize)
  - Example: 
    ```lua
    effect.radius = template.radius * effect.scale
    effect.beamWidth = template.beamWidth * effect.scale
    effect.particleSize = template.particleSize * math.sqrt(effect.scale) -- Non-linear scaling option
    ```

### Adapt update*/draw* Functions (vfx.lua)
- Ensure all update* and draw* functions read parameters from the effect instance rather than using template values directly
- Update position/trajectory logic to account for rangeBand and elevation:
  ```lua
  -- In updateProjectile for example:
  local distance = effect.rangeBand and (effect.rangeBand * Constants.RANGE_BAND_PIXELS) or defaultDistance
  local height = effect.elevation and (effect.elevation * Constants.ELEVATION_PIXELS) or 0
  ```
- Ensure color tinting is properly applied in all drawing functions

## Acceptance Criteria
- VFX.createEffect correctly initializes effect instances based on the full opts table
- Color tints are applied correctly based on opts.color
- Visual scale (size, count, radius) reflects opts.scale
- Particle motion reflects opts.motion (basic integration with VFX-S2-T5)
- Trajectory reflects opts.rangeBand and opts.elevation
- All parameters from the VisualResolver are meaningfully utilized

## Technical Notes
- Define clear rules for how opts.scale affects different geometric properties
- Consider documenting the scaling behavior for future reference
- This change is foundational for rule-driven visual effects

## Dependencies
- This ticket builds upon VFX-S2-T2
- Should be implemented before VFX-S2-T5 (Full Motion Style Integration)

## Tickets/S9_VfxSystemRefactor/VFX-S2-T4-Purge_Specific_Effects_from_VFX_Registry.md
# Ticket #VFX-S2-T4: Purge Specific Effects from VFX Registry

## Goal
Clean up the VFX.effects registry in vfx.lua, removing specific named effects and leaving only parameterized base templates.

## Background
The VFX.effects registry currently contains many specific named effect definitions (firebolt, meteor, emberlift, etc.) alongside base templates. This approach has led to code duplication and made it difficult to maintain consistency. With the VisualResolver now handling template selection and parameter generation, we can simplify by focusing on base templates.

## Tasks

### Identify Base Templates (vfx.lua)
- Clearly mark the essential base templates that should be kept:
  - proj_base
  - beam_base
  - impact_base
  - aura_base
  - util_base
  - shield_hit_base
  - vertical_base
  - conjure_base
  - Any other truly essential base templates

### Remove Specific Definitions (vfx.lua)
- Delete specific named effect entries from VFX.effects, such as:
  - firebolt
  - meteor
  - emberlift
  - conjurefire
  - tidal_force
  - shield
  - Any other effect that can be represented as a base template + parameters

### Review Constants.VFXType (core/Constants.lua)
- Review Constants.VFXType to ensure consistency with the new approach:
  - Keep constants for base templates
  - Keep constants for any truly unique effects that are maintained as overrides
  - Ensure constants are used consistently throughout the codebase

### Update Override Examples
- Identify any remaining spells using overrides
- Ensure they reference a valid Constants.VFXType value
- Document the override approach for the few cases where it's still needed

## Acceptance Criteria
- VFX.effects registry primarily contains base template definitions
- The game runs without errors related to missing effect definitions
- Spells previously using removed named effects correctly resolve to a base template via VisualResolver
- Explicit override spells (if any were kept) still function correctly

## Technical Notes
- This is a significant removal step that should be done carefully
- Thorough testing is needed to catch spells whose visuals might break
- Consider backup/documentation of removed templates before deletion
- This change simplifies the VFX system but requires all visual effects to be properly parameterized through the VisualResolver

## Dependencies
- This ticket should be implemented after VFX-S2-T1, VFX-S2-T2, and VFX-S2-T3
- Should be completed before VFX-S2-T6 (final cleanup)

## Tickets/S9_VfxSystemRefactor/VFX-S2-T5-Full_Motion_Style_Integration.md
# Ticket #VFX-S2-T5: Full Motion Style Integration

## Goal
Fully integrate the defined motion styles into the particle update logic, ensuring particles behave correctly according to the style determined by the VisualResolver.

## Background
The VisualResolver determines motion styles based on spell properties, but the VFX module needs to be enhanced to fully implement these styles. This ticket focuses on refactoring the particle update logic to support different motion behaviors based on the assigned style.

## Tasks

### Refactor update* Functions (vfx.lua)
- Review VFX.updateProjectile, VFX.updateImpact, VFX.updateAura, etc.
- Ensure particle movement logic is delegated to a common helper function:
  ```lua
  -- In update functions, focus on effect-level progression
  for i, particle in ipairs(effect.particles) do
    if particle.active then
      local particleProgress = (effect.elapsedTime - particle.startTime) / particle.lifespan
      VFX.updateParticle(particle, effect, dt, particleProgress)
    end
  end
  ```
- The main update* functions should focus on:
  - Overall effect progression (beam extension, projectile trajectory)
  - Particle lifecycle management (activation, deactivation)

### Enhance VFX.updateParticle (vfx.lua)
- Implement or refine logic for each Constants.MotionStyle:
  ```lua
  function VFX.updateParticle(particle, effect, dt, progress)
    -- Base updates common to all styles
    particle.alpha = VFX.calculateAlpha(progress, effect.fadeIn, effect.fadeOut)
    
    -- Apply motion style-specific updates
    if effect.motion == Constants.MotionStyle.RISE then
      -- Particles gradually rise upward
      particle.y = particle.y - (particle.speed * dt)
      particle.rotation = particle.rotation + (dt * 0.5)
    elseif effect.motion == Constants.MotionStyle.SWIRL then
      -- Particles move in a circular pattern
      local radius = particle.distance * (1 - 0.5 * progress) -- Decreasing radius
      local angle = particle.angle + (dt * particle.speed)
      particle.angle = angle
      particle.x = effect.x + math.cos(angle) * radius
      particle.y = effect.y + math.sin(angle) * radius
    elseif effect.motion == Constants.MotionStyle.PULSE then
      -- Particles expand and contract
      local scale = 1 + 0.5 * math.sin(progress * math.pi * 2)
      particle.scale = particle.baseScale * scale
    elseif effect.motion == Constants.MotionStyle.DIRECTIONAL then
      -- Particles move in their assigned direction
      particle.x = particle.x + math.cos(particle.angle) * particle.speed * dt
      particle.y = particle.y + math.sin(particle.angle) * particle.speed * dt
    else -- DEFAULT motion
      -- Simple motion outward from center
      particle.x = particle.x + particle.dx * dt
      particle.y = particle.y + particle.dy * dt
    end
  end
  ```

## Acceptance Criteria
- Particles in different effects clearly exhibit the motion behavior associated with their spell's affinity
- Motion styles are applied correctly regardless of the base effect type
- update* functions are cleaner, primarily managing effect state and calling updateParticle
- Different spells with the same base template but different affinities show visually distinct particle behaviors

## Technical Notes
- This refactoring separates effect-level progression from particle-level movement
- Consider adding comments explaining each motion style's visual intention
- The implementation should be efficient and avoid unnecessary calculations

## Dependencies
- This ticket builds upon VFX-S2-T3
- Should be implemented before VFX-S2-T6 (final cleanup)

## Tickets/S9_VfxSystemRefactor/VFX-S2-T6-Deprecate_Old_VFX_Specifications_Final_Cleanup.md
# Ticket #VFX-S2-T6: Deprecate Old VFX Specifications & Final Cleanup

## Goal
Remove remaining legacy ways of specifying VFX in spell definitions and ensure the codebase relies solely on the VisualResolver (plus explicit overrides via vfx keyword where necessary).

## Background
Currently, spells can specify visual effects in multiple ways, including a top-level vfx property and through the vfx keyword. This ticket aims to standardize on using the rule-driven VisualResolver, with overrides only as exceptions.

## Tasks

### Remove Top-Level vfx Properties
- Search all spell definition files (spells/*.lua) for top-level vfx = "effect_name" properties
- Remove these properties, instead relying on:
  - affinity (for color)
  - attackType (as fallback)
  - visualShape (as primary determinant)
- Example:
  ```lua
  -- Before
  {
    name = "Fire Bolt",
    affinity = "fire",
    attackType = Constants.AttackType.PROJECTILE,
    vfx = "firebolt", -- Remove this line
    -- Add this if not already present
    visualShape = "bolt",
    -- other properties
  }
  ```

### Review vfx Keyword Usage
- Examine all uses of the vfx keyword in spell definitions
- Remove most instances, relying on the resolver instead
- Keep only those intended as explicit overrides for unique spells:
  ```lua
  -- Example of a valid override that should be kept
  keywords = {
    vfx = { effectOverride = Constants.VFXType.METEOR } -- Intentional override for unique appearance
  }
  ```

### Code Search & Cleanup
- Search the codebase for any remaining logic that might read spell.vfx directly
- Look for instances in EventRunner, keywords.lua, and wizard.lua
- Remove or refactor these instances to use the VisualResolver

### Documentation Update
- Update docs/spellcasting.md to reflect that VFX are now primarily rule-driven
- Add or update documentation about visualShape's role in determining VFX
- Example addition:
  ```markdown
  ## Visual Effects
  
  Spell visual effects are now primarily determined through rule-based resolution using:
  
  1. **visualShape**: The primary determinant of effect type (beam, bolt, blast, etc.)
  2. **affinity**: Determines color and particle motion style
  3. **attackType**: Used as fallback when visualShape is not specified
  
  Manual specification via the `vfx` keyword should only be used for exceptional cases where 
  a completely unique visual effect is required.
  ```

## Acceptance Criteria
- No spells use the top-level vfx property
- The vfx keyword is used sparingly, only for intentional overrides
- The game relies on the VisualResolver for the vast majority of spell VFX
- Codebase is cleaner, with fewer ways to specify or trigger VFX
- Documentation accurately reflects the new standard

## Technical Notes
- This is the final cleanup step in the VFX refactoring process
- After this ticket, the visual effects system should be fully rule-driven
- Consider running tests with various spells to ensure visuals still appear correctly

## Dependencies
- This ticket should be implemented last, after all other VFX system refactoring tickets

