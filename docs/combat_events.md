# Manastorm Combat Event System

This document defines the event schema for the Manastorm combat system. Events are generated by the spell compiler and processed by the EventRunner to apply state changes to the game.

## Event Structure

All events follow a common structure:

```lua
{
  type = "EVENT_TYPE",  -- Required: string identifying the event type
  source = "caster",    -- Required: entity that generated the event ("caster" or "target")
  target = "enemy",     -- Required: entity that receives the effect ("self", "enemy", "both", or specific slot)
  
  -- Additional fields specific to the event type
  ...
}
```

## Core Event Types

### Damage Events

```lua
{
  type = "DAMAGE",
  source = "caster",
  target = "enemy",
  amount = 10,
  damageType = "fire"  -- Optional: type of damage (fire, ice, force, etc.)
}
```

### Status Effect Events

```lua
{
  type = "APPLY_STATUS",
  source = "caster",
  target = "enemy",
  statusType = "burn",
  duration = 3.0,
  tickDamage = 2,      -- For DoT effects
  tickInterval = 1.0,  -- For DoT effects
  -- Additional status-specific parameters
}
```

### Elevation Events

```lua
{
  type = "SET_ELEVATION",
  source = "caster",
  target = "self",    -- or "enemy" for forced elevation changes
  elevation = "AERIAL",
  duration = 5.0      -- Optional: duration of the effect (nil = permanent)
}
```

### Range Events

```lua
{
  type = "SET_RANGE",
  source = "caster",
  target = "both",    -- Range changes always affect both wizards
  position = "NEAR"
}
```

### Force Position Events

```lua
{
  type = "FORCE_POSITION",
  source = "caster",
  target = "enemy",   -- Force enemy to move to caster's range
}
```

## Resource and Token Events

### Conjure Token Events

```lua
{
  type = "CONJURE_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "fire", -- Type of token to create
  amount = 1          -- Number of tokens to create
}
```

### Dissipate Token Events

```lua
{
  type = "DISSIPATE_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "any",  -- Type of token to remove, "any" for any type
  amount = 1          -- Number of tokens to remove
}
```

### Token Shift Events

```lua
{
  type = "SHIFT_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  tokenType = "fire", -- Type to transform tokens into
  amount = 1          -- Number of tokens to transform
}
```

### Lock Token Events

```lua
{
  type = "LOCK_TOKEN",
  source = "caster",
  target = "pool",    -- Target is always the shared pool
  duration = 5.0,     -- Duration of the lock
  amount = 1,         -- Number of tokens to lock
  tokenType = "any"   -- Optional: specific type to lock
}
```

## Spell Timing Events

### Delay Events

```lua
{
  type = "DELAY_SPELL",
  source = "caster",
  target = "enemy_slot", -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,         -- Specific slot to target (nil = random active slot)
  amount = 1.0           -- Amount to delay by in seconds
}
```

### Accelerate Events

```lua
{
  type = "ACCELERATE_SPELL",
  source = "caster",
  target = "self_slot",   -- Can specify exact slot number (1-3) or "current"
  slotIndex = 2,          -- Specific slot to target (nil = current slot)
  amount = 1.0            -- Amount to accelerate by in seconds
}
```

### Cancel Spell Events

```lua
{
  type = "CANCEL_SPELL",
  source = "caster",
  target = "enemy_slot",  -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,          -- Specific slot to target (nil = random active slot)
  returnMana = true       -- Whether to return mana to the pool (true = dispel, false = disjoint)
}
```

### Freeze Spell Events

```lua
{
  type = "FREEZE_SPELL",
  source = "caster",
  target = "enemy_slot",  -- Can specify exact slot number (1-3) or "random"
  slotIndex = 2,          -- Specific slot to target (nil = random active slot)
  duration = 2.0          -- Duration of the freeze effect
}
```

## Defense Events

### Create Shield Events

```lua
{
  type = "CREATE_SHIELD",
  source = "caster",
  target = "self_slot",   -- Always targets a slot of the caster
  slotIndex = 1,          -- Slot where the shield is created
  defenseType = "barrier", -- Type of shield
  blocksAttackTypes = {"projectile", "zone"}, -- Attack types this shield blocks
  reflect = false         -- Whether the shield reflects damage
}
```

### Reflect Events

```lua
{
  type = "REFLECT",
  source = "caster",
  target = "self",
  duration = 3.0          -- Duration of the reflect effect
}
```

## Special Events

### Echo Events

```lua
{
  type = "ECHO",
  source = "caster",
  target = "self_slot",   -- Always targets a slot of the caster
  slotIndex = 1,          -- Slot to echo
  delay = 2.0             -- Delay before echo triggers
}
```

### Zone Anchor Events

```lua
{
  type = "ZONE_ANCHOR",
  source = "caster",
  target = "self",
  anchorRange = "NEAR",    -- Range state to anchor to (or "ANY")
  anchorElevation = "AERIAL", -- Elevation to anchor to (or "ANY")
  requireAll = true       -- Whether all conditions must be met
}
```

### Zone Multi Events

```lua
{
  type = "ZONE_MULTI",
  source = "caster",
  target = "self"
}
```

## Event Processing Order

Events are processed in the following order to ensure consistent game state:

1. **State Setting Events**: Elevation, Range, Zone anchors
2. **Resource Events**: Conjure, Dissipate, Shift, Lock 
3. **Spell Timeline Events**: Delay, Accelerate, Cancel, Freeze
4. **Defense Events**: Create Shield, Reflect
5. **Status Effect Events**: Apply DoTs and other effects
6. **Damage Events**: Direct damage
7. **Special Effect Events**: Echo, Zone Multi

## Integration with Existing Systems

The EventRunner module is responsible for processing events and applying their effects to the game state. It will:

1. Receive events from the spell compiler
2. Sort them according to the processing order
3. Apply each event to the game state
4. Handle any visual effects triggered by events
5. Return a summary of applied effects for UI updates

## Design Principles

1. **Separation of Concerns**: Events describe what happens, the runner decides how it happens
2. **Deterministic Execution**: The same events always produce the same game state changes
3. **Testability**: Events can be serialized and replayed for testing
4. **Extensibility**: New event types can be added without changing the core system
5. **Backward Compatibility**: The event system supports all existing keyword behaviors

## Examples

### Example: Fireball Spell Events

```lua
-- Events generated by a Fireball spell
{
  {
    type = "DAMAGE",
    source = "caster",
    target = "enemy",
    amount = 10,
    damageType = "fire"
  },
  {
    type = "APPLY_STATUS",
    source = "caster",
    target = "enemy",
    statusType = "burn",
    duration = 3.0,
    tickDamage = 2,
    tickInterval = 1.0
  }
}
```

### Example: Shield Spell Events

```lua
-- Events generated by a Barrier Shield spell
{
  {
    type = "CREATE_SHIELD",
    source = "caster",
    target = "self_slot",
    slotIndex = 1,
    defenseType = "barrier",
    blocksAttackTypes = {"projectile", "zone"},
    reflect = false
  }
}
```

## Future Extensions

Possible future extensions to the event system:

1. **Event Logging**: Recording all events for replay and analysis
2. **Deterministic Replay**: Replaying a sequence of events to recreate a game state
3. **Network Synchronization**: Using events for multiplayer synchronization
4. **AI Decision-Making**: AI can analyze possible events to make decisions
5. **Event Modifications**: Allowing special effects to modify events before processing